---
title: 接口鉴权失效到底该返回 401 还是 200？——大厂实践与最佳方案
date: 2025-09-08 09:59:24
tags:
---

---

title: 接口鉴权失效到底该返回 401 还是 200？——大厂实践与最佳方案
date: 2025-09-08
tags:

- API 设计
- 鉴权
- Axios
- 最佳实践

---

## 一句话结论

**用标准 HTTP 状态码。**
**令牌过期/无效 → `401 Unauthorized`（必须带 `WWW-Authenticate`）**；
**令牌有效但权限/范围不足 → `403 Forbidden`**。
可以在响应体里再补充业务错误码（如 `code: TOKEN_EXPIRED`），但**状态码绝不能用 `200`**。

- 标准依据：HTTP 语义规范对 401 的定义与 `WWW-Authenticate` 要求。([rfc-editor.org][1], [IETF Datatracker][2])
- OAuth2 Bearer 令牌规范：过期令牌**应返回 401**，并在 `WWW-Authenticate` 中标明 `error="invalid_token"`。([IETF Datatracker][3])
- 安全与业界建议：**“总是使用语义正确的状态码”**。([cheatsheetseries.owasp.org][4])
- 大厂/主流 API：GitHub、Stripe、Microsoft Graph、Google Cloud 都用 `401/403`，不走 `200` 包错误。([GitHub Docs][5], [docs.stripe.com][6], [Microsoft Learn][7], [Google Cloud][8])

---

## 为什么不是 200 包业务码？

**坏处：**

1. 违背 HTTP 语义，监控/网关/APM 误判为成功，请求质量统计失真。([IETF Datatracker][2])
2. 中间件（反向代理、缓存、重试器）、浏览器与 SDK（如 axios）对 4xx 有内置处理，改成 200 等于放弃这些“免费能力”。
3. 安全基线与业界资料都明确建议按语义返回 4xx。([cheatsheetseries.owasp.org][4])

**什么时候有人用 200？**
多见于早期内部系统或前后端强耦合的历史包袱；从“是否规范/大厂是否采用”的角度看，不推荐继续沿用。

---

## 规范与大厂做法（证据）

- **RFC 9110（HTTP 语义）**：`401` 表示缺少或无效凭据；响应**必须**带 `WWW-Authenticate`。([rfc-editor.org][1])
- **RFC 6750（Bearer Token）**：

  - 过期/无效令牌 → `401`，并在 `WWW-Authenticate` 里加 `error="invalid_token"`，可附 `error_description`。
  - 权限不足 → `403`，可标注所需 `scope`。([IETF Datatracker][3])

- **Microsoft Graph**：无效令牌报 `401`，权限不够报 `403`。([Microsoft Learn][7])
- **GitHub REST**：无效凭据先 `401`，权限不足 `403`/`404`。([GitHub Docs][5])
- **Stripe**：无效 API Key → `401`；Key 权限不足 → `403`。([docs.stripe.com][6])
- **Google Cloud Storage**：文档按标准列出 `401/403/404/409` 等。([Google Cloud][8])

---

## 服务端最佳返回示例

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="api",
                  error="invalid_token",
                  error_description="The access token expired"
Content-Type: application/json

{
  "code": "TOKEN_EXPIRED",
  "message": "Access token expired"
}
```

> 权限不足时改用：
>
> ```http
> HTTP/1.1 403 Forbidden
> WWW-Authenticate: Bearer realm="api", error="insufficient_scope", scope="orders:read"
> ```

（依据 RFC 6750 §3/§3.1 与 RFC 9110 对 `WWW-Authenticate` 的要求。([IETF Datatracker][3], [rfc-editor.org][1])）

---

## Axios 端处理建议（最小改动片段）

> 你没有给已有代码，这里只给**需要添加/调整的最小片段**；复杂逻辑均在上一行加注释，便于直接搬到你的拦截器里。

```ts
// 在响应拦截器里统一处理 401，读取 WWW-Authenticate 判断是否 invalid_token，然后走刷新流程
axiosInstance.interceptors.response.use(
  (r) => r,
  async (error) => {
    const status = error?.response?.status;
    if (status === 401) {
      // 解析 WWW-Authenticate: Bearer ... error="invalid_token"
      const wa: string | undefined =
        error.response.headers?.["www-authenticate"];
      const invalidToken = wa?.includes('error="invalid_token"');
      if (invalidToken) {
        // 触发你现有的刷新令牌逻辑（避免并发刷新：排队/锁）
        // await refreshAccessTokenOnce()
        // 刷新成功后重放原请求
        // return axiosInstance(error.config)
      }
      // 刷新失败或非 invalid_token → 登出并跳登录页/提示
      // handleLogoutAndRedirect()
    }
    return Promise.reject(error);
  }
);
```

> 如果你当前是 **200 + 业务码**，只需把后端改为上述 `401/403`，前端这段将更简单（少一层业务码判断），且能复用更多生态能力。

---

## 落地检查清单（给后端与网关）

1. 令牌过期/无效返回 `401`，附 `WWW-Authenticate: Bearer error="invalid_token"`；权限不足返回 `403`，可附 `scope`。([IETF Datatracker][3])
2. 仍可在 JSON 体内放业务码（便于前端文案与埋点），但**状态码必须准确**。([cheatsheetseries.owasp.org][4])
3. API 文档与错误模型对齐（示例响应、错误枚举、重试/刷新流程）。
4. 网关/监控基于状态码告警（401 暴增提示鉴权系统异常，403 暴增提示权限策略变更）。
5. 禁止将鉴权失败重定向到登录页（浏览器友好但**API 不友好**）。
6. 前端统一在拦截器里处理 `401` 刷新与重放，**加并发防抖**（只刷新一次，队列等待）。

---

## 结论

- **规范与大厂一致选择：`401/403`。**
- **推荐做法：** 后端按 RFC 9110 与 RFC 6750 返回 `401`/`403` 并设置 `WWW-Authenticate`；前端（axios）仅根据状态码与可选头信息处理刷新或提示。
- **不要** 用 `200` 包业务 401，这既不规范，也会损失网关/监控/SDK 的生态红利。([rfc-editor.org][1], [IETF Datatracker][3], [cheatsheetseries.owasp.org][4], [GitHub Docs][5], [docs.stripe.com][6])

如果你贴出现在的 axios 拦截器或后端异常处理中间件，我按你的\*\*“只给需要改的片段+行上注释”\*\*偏好，直接标注出具体改动位。

[1]: https://www.rfc-editor.org/rfc/rfc9110.html?utm_source=chatgpt.com "RFC 9110: HTTP Semantics"
[2]: https://datatracker.ietf.org/doc/html/rfc9110?utm_source=chatgpt.com "RFC 9110 - HTTP Semantics"
[3]: https://datatracker.ietf.org/doc/html/rfc6750 "
            
                RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage
            
        "
[4]: https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html?utm_source=chatgpt.com "REST Security Cheat Sheet"
[5]: https://docs.github.com/rest/authentication/authenticating-to-the-rest-api?utm_source=chatgpt.com "Authenticating to the REST API"
[6]: https://docs.stripe.com/api/errors?utm_source=chatgpt.com "Errors | Stripe API Reference"
[7]: https://learn.microsoft.com/en-us/graph/resolve-auth-errors?utm_source=chatgpt.com "Resolve Microsoft Graph authorization errors"
[8]: https://cloud.google.com/storage/docs/json_api/v1/status-codes?utm_source=chatgpt.com "HTTP status and error codes for JSON | Cloud Storage"
