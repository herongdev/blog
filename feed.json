{
    "version": "https://jsonfeed.org/version/1",
    "title": "我的博客",
    "home_page_url": "https://herongdev.github.io/blog",
    "feed_url": "https://herongdev.github.io/blog/feed.json",
    "description": "个人博客 RSS",
    "items": [
        {
            "id": "https://herongdev.github.io/blog/posts/requirement-realization-1",
            "content_html": "\n---\n\ntitle: 已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）\ndate: 2025-09-05\ntags:\n\n- Passkeys\n- WebAuthn\n- 账号绑定\n- 设备唯一\n\n---\n\n## 摘要\n\n当**用户已经登录（本地有 JWT/token）**时，常见需求是“**再绑定一把通行密钥**”（或在新设备上补绑）。本文给出一个**稳妥的一次点击方案**：\n\n- 前端：带上 **Authorization: Bearer \\<token>** 与 **X-Device-Id（设备唯一码）** 请求 `/passkeys/register/options`。\n- 浏览器完成 `navigator.credentials.create(...)` 后，将结果 + `deviceIdentifier` 回传 `/passkeys/register/verify`。\n- 后端：从 **token 解析 userId**，生成/校验 challenge、**入库凭证**，并执行**设备唯一绑定**（`deviceId -> userId`）。\n\n> 关键点：**不要尝试枚举本地是否已有凭证**；隐私模型不允许。登录态下的“绑定”其实就是“已知用户的注册流程”。\n\n---\n\n## 设计要点\n\n- **用户唯一标识**：后端**不靠前端传 userId**，而是从 **JWT** 中解析（`sub`）→ 更安全。\n- **设备唯一**：前端生成/缓存 `deviceId`，通过 `X-Device-Id` 头传给后端；后端使用 `dvc:owner:${deviceId}` 在 Redis 做“一致性绑定”。\n- **防重复注册**：注册 options 中使用 `excludeCredentials`（由后端查询该用户已绑定的 credentialId）。\n- **风控与速率限制**：对 `deviceId` 做限流（如 1h/3 次），并在 verify 阶段二次校验。\n- **协议对齐**：保持与登录/JIT 注册完全相同的编码规范（字节字段统一 **base64url**）。\n\n---\n\n## 前端实现（Web）\n\n> 仅新增**一个按钮事件**用于“绑定通行密钥”。代码自包含；把 `BASE_URL` 改成你的后端地址即可。\n> 复杂逻辑均在上一行写注释。\n\n```html\n<!-- 你的页面按钮 -->\n<button id=\"btn-bind-passkey\">绑定通行密钥</button>\n<pre\n  id=\"log\"\n  style=\"background:#111;color:#9f9;padding:12px;white-space:pre-wrap\"\n></pre>\n\n<script type=\"module\">\n  // ========= 工具：设备ID与 base64url 转换 =========\n  function getDeviceId() {\n    let id = localStorage.getItem(\"device_id\");\n    if (!id) {\n      id =\n        crypto?.randomUUID?.() ||\n        \"dev-\" + Date.now() + \"-\" + Math.random().toString(16).slice(2);\n      localStorage.setItem(\"device_id\", id);\n    }\n    return id;\n  }\n  function b64urlToBuf(b64url) {\n    const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4);\n    const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const bin = atob(b64);\n    const buf = new ArrayBuffer(bin.length);\n    const view = new Uint8Array(buf);\n    for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);\n    return buf;\n  }\n  function bufToB64url(buf) {\n    const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;\n    let s = \"\";\n    for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);\n    return btoa(s).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n  }\n  // 复杂：把 CreationOptions 中的 base64url → ArrayBuffer\n  function toCreationOptions(serverOpts) {\n    const opts = structuredClone(serverOpts);\n    if (typeof opts.challenge === \"string\")\n      opts.challenge = b64urlToBuf(opts.challenge);\n    if (opts.user && typeof opts.user.id === \"string\")\n      opts.user.id = b64urlToBuf(opts.user.id);\n    if (Array.isArray(opts.excludeCredentials)) {\n      opts.excludeCredentials = opts.excludeCredentials.map((c) => ({\n        ...c,\n        id: b64urlToBuf(c.id),\n      }));\n    }\n    return opts;\n  }\n  // 复杂：将 create() 结果打包为后端可校验的 JSON（统一 base64url）\n  function packAttestation(cred) {\n    return {\n      id: cred.id,\n      rawId: bufToB64url(cred.rawId),\n      type: cred.type,\n      response: {\n        clientDataJSON: bufToB64url(cred.response.clientDataJSON),\n        attestationObject: bufToB64url(cred.response.attestationObject),\n      },\n      clientExtensionResults: cred.getClientExtensionResults?.() || {},\n    };\n  }\n  // 复杂：通用 POST，附带 token 与设备ID\n  async function postJSON(url, body, token) {\n    const res = await fetch(url, {\n      method: \"POST\",\n      credentials: \"include\",\n      headers: {\n        \"content-type\": \"application/json\",\n        \"X-Device-Id\": getDeviceId(), // 设备唯一\n        ...(token ? { Authorization: `Bearer ${token}` } : {}), // 已登录用户必带\n      },\n      body: JSON.stringify(body || {}),\n    });\n    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);\n    return res.json();\n  }\n\n  // ========= 绑定入口：用户已登录（本地有 token） =========\n  const BASE_URL = \"\"; // 同源可留空；跨域改成你的后端地址\n  function getToken() {\n    // 复杂：示例从 localStorage 取；实际按你的项目来源（Cookie/JWT 管理方案）\n    return localStorage.getItem(\"token\");\n  }\n  async function bindPasskey() {\n    const log = (m) =>\n      (document.getElementById(\n        \"log\"\n      ).textContent += `[${new Date().toLocaleTimeString()}] ${m}\\n`);\n    const token = getToken();\n    if (!token) {\n      log(\"未登录：请先登录再绑定\");\n      return;\n    }\n\n    try {\n      // 复杂：步骤1——向后端请求“注册（绑定）options”，后端将从 JWT 解析 userId\n      log(\"请求 /passkeys/register/options ...\");\n      const data = await postJSON(\n        `${BASE_URL}/passkeys/register/options`,\n        {},\n        token\n      );\n      const serverOptions = data.options || data; // 兼容返回形态\n      const publicKey = toCreationOptions(serverOptions);\n\n      // 复杂：步骤2——发起浏览器创建凭据\n      log(\"调用 navigator.credentials.create ...\");\n      const att = await navigator.credentials.create({ publicKey });\n\n      // 复杂：步骤3——打包 + 回传 verify，并带上 deviceIdentifier 以完成设备唯一绑定\n      log(\"提交 /passkeys/register/verify ...\");\n      const verifyBody = {\n        ...packAttestation(att),\n        deviceIdentifier: getDeviceId(),\n      };\n      const verifyResp = await postJSON(\n        `${BASE_URL}/passkeys/register/verify`,\n        verifyBody,\n        token\n      );\n\n      log(\"绑定完成 ✅ \" + JSON.stringify(verifyResp));\n      alert(\"通行密钥绑定成功\");\n    } catch (e) {\n      console.error(e);\n      alert(\"绑定失败：\" + (e?.message || e));\n    }\n  }\n\n  // 绑定按钮点击\n  document\n    .getElementById(\"btn-bind-passkey\")\n    ?.addEventListener(\"click\", bindPasskey);\n</script>\n```\n\n> 若你在 **uni-app**（H5）里使用，也可沿用同样逻辑；在 **App（UTS 插件）** 上只需把 `navigator.credentials.create` 替换为你的 `passkeys.createPasskey(optionsJson)` 即可，其余协议不变。\n\n---\n\n## 后端实现（NestJS，仅给“增量/改动片段”）\n\n> 你的工程里已有 JIT 与登录接口。这里**新增/完善**“**已登录的注册（绑定）**”两个端点，并对 Service 增强**按 token 解析 user** 与**设备唯一**。\n\n### 1）Controller 片段\n\n```ts\n// 复杂：新增“已登录绑定”端点；依赖 JWT 守卫把 user 注入 request.user\nimport { Controller, Post, Req, UseGuards, Body } from \"@nestjs/common\";\nimport { AuthGuard } from \"@nestjs/passport\";\nimport { PasskeysService } from \"../../services/passkeys.service\";\n\n@Controller(\"passkeys\")\nexport class PasskeysController {\n  constructor(private readonly passkeysService: PasskeysService) {}\n\n  // 复杂：注册（绑定）options——登录态\n  @UseGuards(AuthGuard(\"jwt\"))\n  @Post(\"register/options\")\n  getBindOptions(@Req() req: any) {\n    // 复杂：设备ID从 Header/Cookie/IP 提取，用于风控与后续绑定一致性\n    const deviceIdentifier =\n      req.headers[\"x-device-id\"] || req.cookies?.dvc || `ip:${req.ip}`;\n    const userId = req.user?.sub; // 复杂：从 JWT 解析出的 userId\n    return this.passkeysService.issueRegistrationOptionsForUser(\n      userId,\n      deviceIdentifier\n    );\n  }\n\n  // 复杂：注册（绑定）verify——登录态\n  @UseGuards(AuthGuard(\"jwt\"))\n  @Post(\"register/verify\")\n  verifyBind(@Req() req: any, @Body() body: any) {\n    const deviceIdentifier =\n      req.headers[\"x-device-id\"] ||\n      body.deviceIdentifier ||\n      req.cookies?.dvc ||\n      `ip:${req.ip}`;\n    const userId = req.user?.sub;\n    return this.passkeysService.verifyRegistrationForUser(\n      userId,\n      body,\n      deviceIdentifier\n    );\n  }\n}\n```\n\n### 2）Service 片段\n\n```ts\n// 复杂：为“已登录绑定”增加两个方法\n@Injectable()\nexport class PasskeysService {\n  // ... 省略已有依赖与构造\n\n  // 复杂：签发已登录用户的注册 options（含 excludeCredentials 与限流）\n  async issueRegistrationOptionsForUser(\n    userId: string,\n    deviceIdentifier?: string\n  ) {\n    if (!userId) throw new UnauthorizedException(\"未登录\");\n\n    // 复杂：限流（1h/3次）\n    if (deviceIdentifier) {\n      const rlKey = `rl:bind:${deviceIdentifier}`;\n      const n = await this.redisService.incrementKey(rlKey);\n      if (n === 1) await this.redisService.expireKey(rlKey, 3600);\n      if (n > 3) throw new BadRequestException(\"操作过于频繁，请稍后再试\");\n    }\n\n    const rpId = this.configService.get<string>(\"RP_ID\");\n\n    // 复杂：查询该用户已有凭证，构造 excludeCredentials 防重复注册\n    const existing = await this.staffService.findManyCredentialsByUserId(\n      userId\n    ); // 需要你实现查询\n    const exclude = (existing || []).map((c: any) => ({\n      id: Buffer.from(c.credentialId, \"base64url\"),\n      type: \"public-key\" as const,\n    }));\n\n    const options = await generateRegistrationOptions({\n      rpName: \"Your App\",\n      rpID: rpId,\n      // 复杂：v11+ 要求 userID 为字节；这里直接用 UTF-8 Buffer\n      userID: Buffer.from(String(userId), \"utf8\"),\n      userName: String(userId),\n      attestationType: \"none\",\n      // 复杂：兼容性更好（ES256 + RS256）\n      supportedAlgorithmIDs: [-7, -257],\n      authenticatorSelection: {\n        residentKey: \"required\", // 复杂：要求可发现凭证，便于后续一键直登\n        userVerification: \"preferred\",\n      },\n      excludeCredentials: exclude,\n      extensions: { credProps: true },\n    });\n\n    // 复杂：将 challenge(base64url) 与 user 绑定，TTL 5 分钟\n    const ch =\n      typeof options.challenge === \"string\"\n        ? options.challenge\n        : Buffer.from(options.challenge).toString(\"base64url\");\n    await this.redisService.setWithTimeToLive(\n      `webauthn:register:${userId}`,\n      ch,\n      300\n    );\n\n    return { options };\n  }\n\n  // 复杂：校验 attestation + 入库 + 设备唯一绑定（不重新发 token，也可选择刷新）\n  async verifyRegistrationForUser(\n    userId: string,\n    requestBody: any,\n    deviceIdentifier?: string\n  ) {\n    if (!userId) throw new UnauthorizedException(\"未登录\");\n\n    const rpId = this.configService.get<string>(\"RP_ID\");\n    const origin = this.configService.get<string>(\"ORIGIN\");\n    const cachedChallenge = await this.redisService.getValue(\n      `webauthn:register:${userId}`\n    );\n    if (!cachedChallenge)\n      throw new BadRequestException(\"注册挑战不存在或已过期\");\n\n    const verification = await verifyRegistrationResponse({\n      response: requestBody,\n      expectedRPID: rpId,\n      expectedOrigin: origin,\n      expectedChallenge: cachedChallenge,\n      requireUserVerification: true, // 复杂：绑定建议要求 UV\n    });\n    if (!verification.verified || !verification.registrationInfo) {\n      throw new UnauthorizedException(\"注册校验失败\");\n    }\n\n    const { credential } = verification.registrationInfo;\n    const credentialIdB64url = Buffer.from(credential.id).toString(\"base64url\");\n    const publicKey = Buffer.from(credential.publicKey); // 存二进制或 base64 皆可\n    const counter = credential.counter ?? 0;\n\n    // 复杂：入库（若同 credentialId 已存在且属同人，可忽略/幂等）\n    await this.staffService.upsertCredential({\n      userId,\n      credentialId: credentialIdB64url,\n      publicKey,\n      counter,\n      transports: credential.transports\n        ? JSON.stringify(credential.transports)\n        : null,\n    });\n\n    // 复杂：设备唯一绑定（若存在 deviceId 且已被他人占用，则拒绝）\n    if (deviceIdentifier) {\n      const key = `dvc:owner:${deviceIdentifier}`;\n      const existed = await this.redisService.getValue(key);\n      if (existed && existed !== String(userId)) {\n        throw new ForbiddenException(\"此设备已绑定其他账号\");\n      }\n      // 绑定一年（或不设 TTL）\n      await this.redisService.setWithTimeToLive(key, String(userId), 31536000);\n    }\n\n    await this.redisService.deleteKey(`webauthn:register:${userId}`);\n    // 已登录状态下可不必重签 token；如需刷新可在此签新 JWT\n    return { verified: true, userId, credentialId: credentialIdB64url };\n  }\n}\n```\n\n> 你只需要实现（或补齐）`staffService.findManyCredentialsByUserId` 与 `upsertCredential` 两个数据存取方法；字段即你现有的 `credentialId/publicKey/counter/transports/userId`。\n\n---\n\n## 时序对照（已登录绑定）\n\n1. 前端带 **Authorization** 与 **X-Device-Id** → `POST /passkeys/register/options`\n2. 后端从 **JWT** 取 `userId`，构造 **excludeCredentials**，保存 **challenge**\n3. 前端调用 **`navigator.credentials.create({ publicKey })`**\n4. 前端回传 **attestation + deviceIdentifier** → `/passkeys/register/verify`\n5. 后端 **verify + 入库 + 设备唯一绑定** → 返回 `{ verified: true, userId }`\n\n---\n\n## 常见问题\n\n- **为什么不让前端直接传 userId？**\n  防止伪造。登录态下应以 **Authorization** 为准，由后端解析身份。\n\n- **若用户已绑定过此设备，再次点击绑定会怎样？**\n  由于 `excludeCredentials` 与 `dvc:owner:*` 绑定同时生效，**不会重复写入**；可返回幂等成功或提示“已绑定”。\n\n- **如何与一键直登/JIT 流程共存？**\n\n  - **未登录**：走 `/login/options` → 失败回退 `/register-or-login/*`。\n  - **已登录**：走本文 `/register/*`（绑定专用）。两套互不冲突。\n\n---\n\n## 小结\n\n- **唯一标识传递**：已登录场景下，把 **用户身份交给 JWT**，把 **设备唯一交给 `X-Device-Id`**。\n- **绑定即注册**：本质是“已知用户”的注册流程；用 `excludeCredentials` 防重复，用 Redis 绑定 `deviceId -> userId`。\n- **最少交互**：一次点击完成整个绑定，协议与登录/JIT 完全一致，维护成本低。\n",
            "url": "https://herongdev.github.io/blog/posts/requirement-realization-1",
            "title": "已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）",
            "date_modified": "2025-09-05T00:54:31.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/requirement-realization-2",
            "content_html": "\n## 目标\n\n把我们讨论的“**先尝试通行密钥登录 → 失败自动回退到 JIT 注册并登录**”接到你这份 **uvue（uni-app x）页面** 上，**保留原有微信登录按钮**，新增一个“通行密钥登录”按钮。\n支持：\n\n- **App 端（Android/iOS）**：走你自定义的 **UTS 插件** `@/uni_modules/pass-keys`（`getPasskey`/`createPasskey`）。\n- **H5 端**：走浏览器 WebAuthn（`navigator.credentials.get/create`）。\n- **设备唯一**：用 `deviceIdentifier`（App 用 `plus.device.uuid`，H5 用本地生成）传后端，便于 `deviceId -> userId` 绑定。\n\n> 复杂逻辑均在代码**上一行加中文注释**。下面给出**整文件覆盖式代码**（符合你“Passkeys 项目优先给完整文件”的约定）。\n\n---\n\n## 完整代码（直接替换你当前页面）\n\n```vue\n<template>\n  <view class=\"container\">\n    <view class=\"header\">\n      <text class=\"title\">欢迎使用商户平台</text>\n    </view>\n\n    <view v-if=\"!baseUrl\" class=\"tip\">\n      <text class=\"tip-text\">未配置后端地址，请先配置</text>\n      <button size=\"mini\" @tap=\"openConfig\">去配置</button>\n    </view>\n\n    <view class=\"actions\">\n      <button\n        type=\"primary\"\n        :disabled=\"!baseUrl || loading\"\n        @tap=\"onWeChatLogin\"\n      >\n        {{\n          baseUrl\n            ? isWeChatInstalled\n              ? \"微信登录\"\n              : \"登录\"\n            : \"请先配置后端地址\"\n        }}\n      </button>\n\n      <!-- 新增：通行密钥一键登录（失败自动回退注册并登录） -->\n      <button\n        style=\"margin-top:12rpx\"\n        :disabled=\"!baseUrl || loading\"\n        @tap=\"onPasskeyLogin\"\n      >\n        {{ loading ? \"处理中...\" : \"通行密钥登录\" }}\n      </button>\n    </view>\n\n    <view v-if=\"loading\" class=\"loading-mask\">\n      <view class=\"loading-box\"><text>处理中...</text></view>\n    </view>\n\n    <view v-if=\"showConfig\" class=\"modal-mask\" @tap=\"closeConfig\">\n      <view class=\"modal\" @tap.stop>\n        <text class=\"modal-title\">配置后端地址</text>\n        <input\n          class=\"modal-input\"\n          type=\"text\"\n          v-model=\"configInput\"\n          placeholder=\"例如：https://api.example.com\"\n        />\n        <view class=\"modal-actions\">\n          <button size=\"mini\" @tap=\"closeConfig\">取消</button>\n          <button type=\"primary\" size=\"mini\" @tap=\"saveConfig\">保存</button>\n        </view>\n      </view>\n    </view>\n  </view>\n</template>\n\n<script>\n// #ifdef APP-PLUS\n// 复杂逻辑：App 端引入你的 UTS 插件（Android/iOS 调平台原生 Credential/AuthenticationServices）\nimport * as passkeys from \"@/uni_modules/pass-keys\";\n// #endif\n\nexport default {\n  data() {\n    return {\n      baseUrl: \"\",\n      loading: false,\n      isWeChatInstalled: true,\n      showConfig: false,\n      configInput: \"\",\n      // 复杂逻辑：设备唯一标识；App=plus.device.uuid；H5=本地生成并持久化\n      deviceId: \"\",\n    };\n  },\n  onLoad() {\n    this.baseUrl = uni.getStorageSync(\"BASE_URL\") || \"\";\n    // 复杂逻辑：初始化设备ID（用于 deviceId -> userId 绑定与风控）\n    // #ifdef APP-PLUS\n    this.deviceId =\n      plus && plus.device && plus.device.uuid\n        ? plus.device.uuid\n        : \"app-\" + Date.now();\n    // #endif\n    // #ifdef H5\n    const key = \"DEVICE_ID\";\n    this.deviceId = localStorage.getItem(key);\n    if (!this.deviceId) {\n      this.deviceId =\n        crypto?.randomUUID?.() ||\n        \"web-\" + Date.now() + \"-\" + Math.random().toString(16).slice(2);\n      localStorage.setItem(key, this.deviceId);\n    }\n    // #endif\n  },\n  methods: {\n    openConfig() {\n      this.configInput = this.baseUrl;\n      this.showConfig = true;\n    },\n    closeConfig() {\n      this.showConfig = false;\n    },\n    saveConfig() {\n      this.baseUrl = (this.configInput || \"\").trim();\n      uni.setStorageSync(\"BASE_URL\", this.baseUrl);\n      this.showConfig = false;\n      uni.showToast({ title: \"已保存\", icon: \"success\" });\n    },\n\n    // 复杂逻辑：统一 POST 封装；把 deviceIdentifier 一并传给后端（也可由 Header 传）\n    async post(path, body) {\n      return await new Promise((resolve, reject) => {\n        uni.request({\n          url: `${this.baseUrl}${path}`,\n          method: \"POST\",\n          data: { deviceIdentifier: this.deviceId, ...(body || {}) },\n          dataType: \"json\",\n          header: { \"content-type\": \"application/json\" },\n          success: (res) => resolve(res.data),\n          fail: reject,\n        });\n      });\n    },\n\n    // 保留原有：微信登录\n    async onWeChatLogin() {\n      if (!this.baseUrl) return;\n      this.loading = true;\n      try {\n        let code = \"\";\n        // 小程序端获取 code\n        // #ifdef MP-WEIXIN\n        const res = await new Promise((resolve, reject) => {\n          uni.login({ provider: \"weixin\", success: resolve, fail: reject });\n        });\n        code = res.code || \"\";\n        // #endif\n\n        // 其他端未集成微信登录，给出提示\n        // #ifndef MP-WEIXIN\n        throw new Error(\"当前平台未集成微信登录\");\n        // #endif\n\n        if (!code) throw new Error(\"获取登录凭证失败\");\n        const data = await this.post(\"/admin/wechat/login\", { code });\n        if (\n          data &&\n          data.success === true &&\n          data.userInfo &&\n          data.userInfo.approved === true &&\n          data.userInfo.token\n        ) {\n          uni.setStorageSync(\"TOKEN\", data.userInfo.token);\n          uni.showToast({ title: \"登录成功\", icon: \"success\" });\n          setTimeout(() => {\n            uni.reLaunch({ url: \"/pages/index/index\" });\n          }, 600);\n        } else {\n          throw new Error(data?.message || \"登录失败\");\n        }\n      } catch (e) {\n        uni.showToast({ title: e?.message || String(e), icon: \"none\" });\n      } finally {\n        this.loading = false;\n      }\n    },\n\n    // ================== 通行密钥一键登录入口（失败回退注册） ==================\n    async onPasskeyLogin() {\n      if (!this.baseUrl) return;\n      this.loading = true;\n      try {\n        // 复杂逻辑：步骤A——请求登录 options（无用户名直登；后端可按设备ID定向返回 allowCredentials）\n        const resp = await this.post(\"/passkeys/login/options\", {});\n        const options = resp.options || resp;\n\n        // #ifdef APP-PLUS\n        // 复杂逻辑：App 端调用 UTS 插件进行“使用通行密钥”\n        const requestOptionsJson = JSON.stringify(options);\n        const authRespJson = await passkeys.getPasskey(requestOptionsJson, {\n          conditional: true,\n        });\n        const verifyBody = JSON.parse(authRespJson);\n        // #endif\n\n        // #ifdef H5\n        // 复杂逻辑：H5 端使用 WebAuthn —— 将 base64url 字段转 ArrayBuffer\n        const publicKey = this.toWebAuthnRequestOptions(options);\n        // 复杂逻辑：若支持条件UI，mediation='conditional'，否则 'required'（需用户手势）\n        const mediation = (await this.isConditionalUI())\n          ? \"conditional\"\n          : \"required\";\n        const assertion = await navigator.credentials.get({\n          publicKey,\n          mediation,\n        });\n        const verifyBody = this.packAssertion(assertion);\n        // #endif\n\n        // 复杂逻辑：步骤B——提交登录 verify\n        const verify = await this.post(\"/passkeys/login/verify\", verifyBody);\n        this.onLoginSucceed(verify);\n      } catch (e) {\n        // 复杂逻辑：登录失败（无凭据/取消/过期）→ 步骤C——回退到 JIT 注册\n        try {\n          const jit = await this.post(\n            \"/passkeys/register-or-login/options\",\n            {}\n          );\n          const userId = jit.userId || jit?.user?.id;\n          const creationOptions = jit.options || jit;\n\n          // #ifdef APP-PLUS\n          // 复杂逻辑：App 端调用 UTS 插件“创建通行密钥”\n          const creationOptionsJson = JSON.stringify(creationOptions);\n          const regRespJson = await passkeys.createPasskey(creationOptionsJson);\n          const verifyRegBody = {\n            ...JSON.parse(regRespJson),\n            userId,\n            deviceIdentifier: this.deviceId,\n          };\n          // #endif\n\n          // #ifdef H5\n          // 复杂逻辑：H5 端 WebAuthn —— 转换 base64url → ArrayBuffer，发起 create\n          const publicKey = this.toWebAuthnCreationOptions(creationOptions);\n          const attestation = await navigator.credentials.create({ publicKey });\n          const verifyRegBody = {\n            ...this.packAttestation(attestation),\n            userId,\n            deviceIdentifier: this.deviceId,\n          };\n          // #endif\n\n          // 复杂逻辑：步骤D——提交注册 verify（完成入库+设备唯一绑定+签发会话）\n          const verify = await this.post(\n            \"/passkeys/register-or-login/verify\",\n            verifyRegBody\n          );\n          this.onLoginSucceed(verify, true);\n        } catch (e2) {\n          uni.showToast({ title: e2?.message || String(e2), icon: \"none\" });\n        }\n      } finally {\n        this.loading = false;\n      }\n    },\n\n    // 复杂逻辑：登录/注册成功后的统一处理（落 token + 跳转）\n    onLoginSucceed(verify, isRegister = false) {\n      if (verify?.verified) {\n        if (verify.token) {\n          uni.setStorageSync(\"TOKEN\", verify.token);\n        }\n        uni.showToast({\n          title: isRegister ? \"已注册并登录\" : \"登录成功\",\n          icon: \"success\",\n        });\n        setTimeout(() => {\n          uni.reLaunch({ url: \"/pages/index/index\" });\n        }, 600);\n      } else {\n        throw new Error(\"校验失败\");\n      }\n    },\n\n    // ================== H5 专用辅助：WebAuthn 转换与打包 ==================\n    // #ifdef H5\n    // 复杂逻辑：检测是否支持条件UI\n    async isConditionalUI() {\n      try {\n        return !!(await PublicKeyCredential.isConditionalMediationAvailable?.());\n      } catch {\n        return false;\n      }\n    },\n    // 复杂逻辑：base64url → ArrayBuffer\n    b64urlToBuf(b64url) {\n      const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4);\n      const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\");\n      const bin = atob(b64);\n      const buf = new ArrayBuffer(bin.length);\n      const view = new Uint8Array(buf);\n      for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);\n      return buf;\n    },\n    // 复杂逻辑：ArrayBuffer/Uint8Array → base64url\n    bufToB64url(buf) {\n      const b = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;\n      let s = \"\";\n      for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);\n      return btoa(s)\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=+$/g, \"\");\n    },\n    // 复杂逻辑：将登录 options（服务端 base64url）转为 WebAuthn 可用结构\n    toWebAuthnRequestOptions(serverOpts) {\n      const opts = JSON.parse(JSON.stringify(serverOpts));\n      if (typeof opts.challenge === \"string\")\n        opts.challenge = this.b64urlToBuf(opts.challenge);\n      if (Array.isArray(opts.allowCredentials)) {\n        opts.allowCredentials = opts.allowCredentials.map((c) => ({\n          ...c,\n          id: typeof c.id === \"string\" ? this.b64urlToBuf(c.id) : c.id,\n        }));\n      }\n      return opts;\n    },\n    // 复杂逻辑：将注册 options 转为 WebAuthn 可用结构\n    toWebAuthnCreationOptions(serverOpts) {\n      const opts = JSON.parse(JSON.stringify(serverOpts));\n      if (typeof opts.challenge === \"string\")\n        opts.challenge = this.b64urlToBuf(opts.challenge);\n      if (opts.user && typeof opts.user.id === \"string\")\n        opts.user.id = this.b64urlToBuf(opts.user.id);\n      if (Array.isArray(opts.excludeCredentials)) {\n        opts.excludeCredentials = opts.excludeCredentials.map((c) => ({\n          ...c,\n          id: typeof c.id === \"string\" ? this.b64urlToBuf(c.id) : c.id,\n        }));\n      }\n      return opts;\n    },\n    // 复杂逻辑：将 get() 结果打包为后端可校验的 JSON（统一 base64url）\n    packAssertion(cred) {\n      const resp = cred.response;\n      return {\n        id: cred.id,\n        rawId: this.bufToB64url(cred.rawId),\n        type: cred.type,\n        response: {\n          clientDataJSON: this.bufToB64url(resp.clientDataJSON),\n          authenticatorData: this.bufToB64url(resp.authenticatorData),\n          signature: this.bufToB64url(resp.signature),\n          userHandle: resp.userHandle\n            ? this.bufToB64url(resp.userHandle)\n            : null,\n        },\n        clientExtensionResults: cred.getClientExtensionResults?.() || {},\n      };\n    },\n    // 复杂逻辑：将 create() 结果打包为后端可校验的 JSON（统一 base64url）\n    packAttestation(cred) {\n      const resp = cred.response;\n      return {\n        id: cred.id,\n        rawId: this.bufToB64url(cred.rawId),\n        type: cred.type,\n        response: {\n          clientDataJSON: this.bufToB64url(resp.clientDataJSON),\n          attestationObject: this.bufToB64url(resp.attestationObject),\n        },\n        clientExtensionResults: cred.getClientExtensionResults?.() || {},\n      };\n    },\n    // #endif\n  },\n};\n</script>\n\n<style>\n.container {\n  padding: 24rpx;\n}\n.header {\n  margin-top: 40rpx;\n  margin-bottom: 24rpx;\n}\n.title {\n  font-size: 36rpx;\n  font-weight: 600;\n  text-align: center;\n}\n.tip {\n  display: flex;\n  align-items: center;\n  gap: 16rpx;\n  padding: 16rpx;\n  margin: 12rpx 0;\n  border: 1px solid #ffc107;\n  background: #fff8e1;\n  border-radius: 12rpx;\n}\n.tip-text {\n  color: #8d6e63;\n  font-size: 26rpx;\n}\n.actions {\n  margin-top: 24rpx;\n  display: flex;\n  flex-direction: column;\n}\n.loading-mask {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.2);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.loading-box {\n  padding: 20rpx;\n  background: #fff;\n  border-radius: 12rpx;\n}\n.modal-mask {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.4);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.modal {\n  width: 80%;\n  background: #fff;\n  border-radius: 16rpx;\n  padding: 24rpx;\n}\n.modal-title {\n  font-size: 30rpx;\n  font-weight: 600;\n}\n.modal-input {\n  border: 1px solid #eee;\n  margin: 16rpx 0;\n  padding: 12rpx;\n  border-radius: 8rpx;\n}\n.modal-actions {\n  display: flex;\n  justify-content: flex-end;\n  gap: 12rpx;\n}\n</style>\n```\n\n---\n\n## 说明与对接要点\n\n- **后端路由**保持为：\n\n  - `/passkeys/login/options` → 返回 `PublicKeyCredentialRequestOptions`（`challenge`/`allowCredentials[].id` 为 **base64url**）。\n  - `/passkeys/login/verify` → 接收 `packAssertion` 结果。\n  - `/passkeys/register-or-login/options` → 返回 `{ userId, options }`（注册用，`challenge`/`user.id` 为 **base64url**）。\n  - `/passkeys/register-or-login/verify` → 接收 `packAttestation` + `{ userId, deviceIdentifier }`。\n\n- **设备唯一**：页面已在所有请求体中带上 `deviceIdentifier`（`this.deviceId`），你的服务端即可写入/校验 `dvc:owner:*`。\n- **H5 前置条件**：需 HTTPS 或 `localhost`；Safari/移动端有平台限制。\n- **App 端**：确保 `@/uni_modules/pass-keys` 已实现 `getPasskey`/`createPasskey` 且返回 **JSON 字符串**（与我们前面约定一致）。\n\n需要我把 **“已登录场景的绑定按钮”** 也加到这个页面吗（即 `/passkeys/register/options|verify`，走绑定而非 JIT）？如果要，加哪个位置，我按你“只给改动段”的规范再补。\n",
            "url": "https://herongdev.github.io/blog/posts/requirement-realization-2",
            "title": "在你现有 uvue 登录页集成“一键通行密钥登录”（含回退注册），完整代码可直接替换",
            "date_modified": "2025-09-05T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/requirement-realization",
            "content_html": "\n---\n\ntitle: Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现\ndate: 2025-09-05\ntags:\n\n- Passkeys\n- WebAuthn\n- 前端实战\n- 一键直登\n\n---\n\n## 摘要\n\n本文给出 **Web 端** 的最小可用实现：**点击一个按钮 → 优先尝试登录（可发现凭证）→ 若无可用凭证或用户取消，则自动走 JIT 注册并直接登录**。\n重点说明：“**不能事先枚举本地是否存在凭据**”（浏览器出于隐私不允许），正确姿势是**拿到服务端的 options 再调用 WebAuthn**，并对失败分支做平滑回退。\n\n---\n\n## 背景与原则\n\n- 浏览器不会暴露“本地是否已有你家 RP 的通行密钥”的枚举 API（防侧信道追踪）。\n- 正确流程永远是：**后端发 options（含 challenge）→ 前端发起 `get()`/`create()` → 前端把回包交给后端 `verify`**。\n- 若想“先感知再决定”，只能做**能力探测**（如 `isConditionalMediationAvailable()`、`isUserVerifyingPlatformAuthenticatorAvailable()`），但这**不等于**“确有凭据”。\n- 因此，本实现直接：**先请求登录 options** → `navigator.credentials.get` → 失败则 **请求注册 options** → `navigator.credentials.create` → 验证成功后**注册即登录**。\n\n---\n\n## 交互时序（简述）\n\n1. 用户点击「一键登录」按钮\n2. 前端 `POST /passkeys/login/options`（携带 `X-Device-Id`）\n3. 浏览器 `navigator.credentials.get({ publicKey, mediation })`\n4. 成功 → 回传 `/passkeys/login/verify` → **登录完成**\n5. 失败（无匹配凭据/取消等）→ `POST /passkeys/register-or-login/options`\n6. `navigator.credentials.create({ publicKey })`\n7. 回传 `/passkeys/register-or-login/verify` → **注册并登录完成**\n\n---\n\n## 完整代码\n\n> 下面给出**可直接粘贴落地**的最小实现（HTML + JS）。\n> 复杂逻辑的上一行均有中文注释。\n> 假设你的后端路由与本文一致：\n>\n> - `/passkeys/login/options`、`/passkeys/login/verify`\n> - `/passkeys/register-or-login/options`、`/passkeys/register-or-login/verify`\n\n### 1）页面与按钮\n\n```html\n<!-- index.html 片段：按钮与日志面板 -->\n<button id=\"btn-passkey\">一键通行密钥</button>\n\n<pre\n  id=\"log\"\n  style=\"background:#111;color:#9f9;padding:12px;white-space:pre-wrap\"\n></pre>\n\n<script type=\"module\" src=\"./passkeys-web.js\"></script>\n```\n\n### 2）前端模块：`passkeys-web.js`\n\n```js\n// ======================= 基础工具 =======================\n\n// 复杂：生成稳定的设备ID（首访生成并持久化，用于设备→账号绑定与风控）\nfunction getDeviceId() {\n  const key = \"device_id\";\n  let id = localStorage.getItem(key);\n  if (!id) {\n    id =\n      crypto?.randomUUID?.() ||\n      \"dev-\" + Date.now() + \"-\" + Math.random().toString(16).slice(2);\n    localStorage.setItem(key, id);\n  }\n  return id;\n}\n\n// 复杂：base64url ↔ ArrayBuffer 转换，确保与后端统一\nfunction b64urlToBuf(b64url) {\n  const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4);\n  const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const str = atob(b64);\n  const buf = new ArrayBuffer(str.length);\n  const view = new Uint8Array(buf);\n  for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n  return buf;\n}\nfunction bufToB64url(buf) {\n  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;\n  let str = \"\";\n  for (let i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);\n  return btoa(str).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\n\n// 复杂：把 AuthenticationOptions 中的 base64url 字段转 ArrayBuffer\nfunction toWebAuthnRequestOptions(serverOpts) {\n  const opts = structuredClone(serverOpts);\n  // challenge 需要转 ArrayBuffer\n  if (typeof opts.challenge === \"string\")\n    opts.challenge = b64urlToBuf(opts.challenge);\n  // allowCredentials 中的 id 也需要转 ArrayBuffer\n  if (Array.isArray(opts.allowCredentials)) {\n    opts.allowCredentials = opts.allowCredentials.map((c) => ({\n      ...c,\n      id: typeof c.id === \"string\" ? b64urlToBuf(c.id) : c.id,\n    }));\n  }\n  return opts;\n}\n\n// 复杂：把 RegistrationOptions 中的 base64url 字段转 ArrayBuffer/Uint8Array\nfunction toWebAuthnCreationOptions(serverOpts) {\n  const opts = structuredClone(serverOpts);\n  if (typeof opts.challenge === \"string\")\n    opts.challenge = b64urlToBuf(opts.challenge);\n  if (opts.user && typeof opts.user.id === \"string\")\n    opts.user.id = b64urlToBuf(opts.user.id);\n  if (Array.isArray(opts.excludeCredentials)) {\n    opts.excludeCredentials = opts.excludeCredentials.map((c) => ({\n      ...c,\n      id: typeof c.id === \"string\" ? b64urlToBuf(c.id) : c.id,\n    }));\n  }\n  return opts;\n}\n\n// 复杂：把 get() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）\nfunction packAssertion(cred) {\n  const resp = cred.response;\n  return {\n    id: cred.id,\n    rawId: bufToB64url(cred.rawId),\n    type: cred.type,\n    response: {\n      clientDataJSON: bufToB64url(resp.clientDataJSON),\n      authenticatorData: bufToB64url(resp.authenticatorData),\n      signature: bufToB64url(resp.signature),\n      userHandle: resp.userHandle ? bufToB64url(resp.userHandle) : null,\n    },\n    clientExtensionResults: cred.getClientExtensionResults?.() || {},\n  };\n}\n\n// 复杂：把 create() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）\nfunction packAttestation(cred) {\n  const resp = cred.response;\n  return {\n    id: cred.id,\n    rawId: bufToB64url(cred.rawId),\n    type: cred.type,\n    response: {\n      clientDataJSON: bufToB64url(resp.clientDataJSON),\n      attestationObject: bufToB64url(resp.attestationObject),\n    },\n    clientExtensionResults: cred.getClientExtensionResults?.() || {},\n  };\n}\n\n// 复杂：通用 POST 封装，自动带上设备ID\nasync function postJSON(url, body) {\n  const res = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/json\",\n      // 设备ID写入 Header，便于后端风控/设备绑定。后端也可从 body 读取。\n      \"X-Device-Id\": getDeviceId(),\n    },\n    body: JSON.stringify(body || {}),\n    credentials: \"include\",\n  });\n  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);\n  return res.json();\n}\n\n// 复杂：检测“条件UI”与平台验证器可用性（仅做能力判断，不代表一定有凭据）\nasync function detectSupport() {\n  const hasWebAuthn = \"PublicKeyCredential\" in window;\n  let conditional = false,\n    uvpa = false;\n  try {\n    conditional =\n      !!(await PublicKeyCredential.isConditionalMediationAvailable?.());\n  } catch {}\n  try {\n    uvpa =\n      !!(await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable?.());\n  } catch {}\n  return { hasWebAuthn, conditional, uvpa };\n}\n\n// ======================= 业务主流程 =======================\n\n// 复杂：优先尝试登录（可发现凭证/或定向 allowCredentials）；失败则自动转注册并登录\nexport async function oneTapPasskey(baseUrl = \"\") {\n  const log = (msg) => {\n    const pre = document.getElementById(\"log\");\n    if (pre) pre.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\\n`;\n    console.log(msg);\n  };\n\n  const deviceId = getDeviceId();\n  const { hasWebAuthn, conditional, uvpa } = await detectSupport();\n  if (!hasWebAuthn) throw new Error(\"当前环境不支持 WebAuthn\");\n\n  log(`检测：conditional=${conditional}, uvpa=${uvpa}`);\n\n  try {\n    // ========== 步骤A：请求“登录 options” ==========\n    log(\"请求登录 options...\");\n    const loginOptsResp = await postJSON(`${baseUrl}/passkeys/login/options`, {\n      deviceIdentifier: deviceId,\n    });\n    const requestOptions = loginOptsResp.options || loginOptsResp; // 兼容你的返回结构\n    const publicKey = toWebAuthnRequestOptions(requestOptions);\n\n    // 复杂：若支持条件UI，则 mediation 设为 'conditional'；否则 'required'（需用户手势）\n    const mediation = conditional ? \"conditional\" : \"required\";\n\n    // ========== 步骤B：发起 credentials.get ==========\n    log(`调用 navigator.credentials.get (mediation=${mediation})...`);\n    const assertion = await navigator.credentials.get({ publicKey, mediation });\n\n    // ========== 步骤C：打包并回传后端校验 ==========\n    log(\"提交登录 verify...\");\n    const verifyBody = packAssertion(assertion);\n    const verifyResp = await postJSON(\n      `${baseUrl}/passkeys/login/verify`,\n      verifyBody\n    );\n\n    log(\"登录成功 ✅ \" + JSON.stringify(verifyResp));\n    return { mode: \"login\", result: verifyResp };\n  } catch (err) {\n    // 复杂：常见失败 1）用户取消 2）设备没有匹配凭据 3）options 过期\n    console.warn(\"登录失败，准备转注册：\", err);\n    // ========== 步骤D：请求“一键注册 options” ==========\n    const regOptsResp = await postJSON(\n      `${baseUrl}/passkeys/register-or-login/options`,\n      {\n        deviceIdentifier: deviceId,\n      }\n    );\n    const { userId, options: creationOptionsServer } = regOptsResp.userId\n      ? regOptsResp\n      : { userId: regOptsResp.userId, options: regOptsResp.options };\n\n    const publicKey = toWebAuthnCreationOptions(creationOptionsServer);\n\n    // ========== 步骤E：发起 credentials.create（注册） ==========\n    log(\"调用 navigator.credentials.create ...\");\n    const attestation = await navigator.credentials.create({ publicKey });\n\n    // ========== 步骤F：打包并回传后端，完成绑定+激活+登录 ==========\n    log(\"提交注册 verify...\");\n    const verifyBody = {\n      ...packAttestation(attestation),\n      userId, // 复杂：JIT 返回的临时/访客 userId\n      deviceIdentifier: deviceId, // 复杂：用于设备→账号唯一绑定\n    };\n    const verifyResp = await postJSON(\n      `${baseUrl}/passkeys/register-or-login/verify`,\n      verifyBody\n    );\n\n    log(\"注册并登录成功 ✅ \" + JSON.stringify(verifyResp));\n    return { mode: \"register-then-login\", result: verifyResp };\n  }\n}\n\n// ======================= 页面挂载：按钮点击即触发 =======================\ndocument.getElementById(\"btn-passkey\")?.addEventListener(\"click\", () => {\n  // 复杂：这里的 baseUrl 请改为你的后端地址；同源部署可留空\n  oneTapPasskey(\"\").catch((e) => {\n    const pre = document.getElementById(\"log\");\n    if (pre) pre.textContent += `❌ ${e?.message || e}\\n`;\n    console.error(e);\n  });\n});\n```\n\n---\n\n## 与后端契约（对齐要点）\n\n- `/passkeys/login/options`\n\n  - **入参**：`{ deviceIdentifier?: string }`（Header 也可）\n  - **返回**：`{ options: PublicKeyCredentialRequestOptions }`（`challenge`、`allowCredentials[].id` 为 **base64url** 字符串）\n\n- `/passkeys/login/verify`\n\n  - **入参**：上文 `packAssertion()` 的结果（所有字节字段 **base64url**）\n  - **返回**：`{ verified: true, token, userId }`\n\n- `/passkeys/register-or-login/options`\n\n  - **入参**：`{ deviceIdentifier?: string }`\n  - **返回**：`{ userId: string, options: PublicKeyCredentialCreationOptions }`（`challenge`、`user.id`、`excludeCredentials[].id` 为 **base64url**）\n\n- `/passkeys/register-or-login/verify`\n\n  - **入参**：`packAttestation()` + `{ userId, deviceIdentifier }`\n  - **返回**：`{ verified: true, token, userId }`\n\n> 以上与您现有的 `PasskeysService` 设计完全兼容。你也可以在“已绑定设备”场景下返回 `allowCredentials`，以提升命中率（文中已说明）。\n\n---\n\n## 常见问题（FAQ）\n\n- **能不能“先看一下本地有没有凭据”，有就登录、没有就不调后端？**\n  不能。浏览器不允许枚举凭据。你能做的只是能力探测与**尝试调用** `credentials.get`。而调用 `get/create` 都必须先有**服务端下发的 options（含 challenge）**。\n\n- **什么时候用条件 UI（conditional mediation）？**\n  页面加载即拿到 `login options` 后即可“无提示等候”；但为简化，这里在**按钮点击**后再调，用 `mediation='conditional'`（若可用）+ `required` 作为兜底。\n\n- **后端 challenge 过期怎么办？**\n  统一设置较短 TTL（如 300s），一旦 `get/create` 抛出 `InvalidStateError/NotAllowedError`，前端直接重拉 options 再试。\n\n---\n\n## 测试步骤\n\n1. **HTTPS 环境**部署（本地可用 `localhost`）\n2. **确保后端 RP_ID/ORIGIN 正确**、Redis 正常、四个路由可达\n3. 首次访问：点击按钮 → 预期走注册 → 后端 verify 成功后返回 token\n4. 再次访问：点击按钮 → 直接 `get()` 登录成功\n5. Android/Chrome 测试条件 UI：地址栏出现通行密钥提示；Safari 需同源 HTTPS\n\n---\n\n## 小结\n\n- “先判断本地是否有凭据”在浏览器上**不可行**；\n- **正确做法**是**每次先拿登录 options**，用 `credentials.get` 尝试登录；\n- **失败则无缝切到注册**（JIT 建号 + 可发现凭证 + 注册即登录）。\n- 上文代码开箱即用，你只需要把 `baseUrl` 指向你的后端即可。\n",
            "url": "https://herongdev.github.io/blog/posts/requirement-realization",
            "title": "Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现",
            "date_modified": "2025-09-05T00:21:16.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/显式覆盖",
            "content_html": "\n## 结论（一句话）\n\n**不要维护 `noAuthPaths` 白名单数组。**\n大厂常用是**约定式路径前缀**（如 `/api/pub/**` 全部公开，其余默认鉴权）+ **显式 `auth:false` 覆盖**个别特殊接口（如登录/注册）。必要时再做**双实例**（`authHttp`/`pubHttp`）隔离。\n\n## 你只需做的最小改动（片段）\n\n### 1) 用“前缀约定”替换白名单数组\n\n> 复杂逻辑：将“是否需要鉴权”收敛为**实例级默认值** + **URL 前缀** + **每次请求的显式覆盖**。\n\n**删除：**\n\n```ts\n// 删除这行\nconst noAuthPaths = [\n  \"/login\",\n  \"/register\",\n  \"/public-endpoint\",\n  \"/api/pub/get_feednews\",\n];\n```\n\n**在 `createAxiosHttp` 定义处新增第二个参数（不改已有调用方也能有默认值）：**\n\n```ts\n// 复杂逻辑：通过 opts 控制默认鉴权与公开前缀\nfunction createAxiosHttp(\n  config: AxiosRequestConfig,\n  opts: { authDefault?: boolean; publicPrefixes?: string[] } = {},\n) {\n  const authDefault = opts.authDefault ?? true\n  const publicPrefixes = opts.publicPrefixes ?? ['/api/pub']  // 仅维护“前缀”，而非逐个接口\n  // ...\n```\n\n**在请求拦截器里替换 needAuth 判定：**\n\n```ts\n_axios.interceptors.request.use((req) => {\n  // ...（保留你已有的 AbortController 代码）\n\n  // 复杂逻辑：先按前缀判定是否公开，再由显式 req.auth 覆盖\n  const url = req.url || \"\";\n  const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));\n\n  // 复杂逻辑：优先使用 req.auth（true/false），否则用实例默认值 + 前缀约定\n  const needAuth = (req as any).auth ?? (authDefault && !isPublicByPrefix);\n\n  const accToken = storage.get(ACCESS_TOKEN);\n  const tokenType = storage.get(TOKEN_TYPE) || \"Bearer\";\n  if (needAuth && !accToken) {\n    ((req as any).__abortController as AbortController | undefined)?.abort();\n    return Promise.reject(new Error(\"UNAUTHENTICATED\"));\n  }\n  if (needAuth && accToken) {\n    req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };\n  }\n  return req;\n});\n```\n\n**创建实例时传入前缀约定（一次配置，全局生效）：**\n\n```ts\n// 复杂逻辑：默认需要鉴权，唯独 /api/pub/** 前缀走公开\nconst http = createAxiosHttp(\n  {\n    timeout: 10000,\n    baseURL: API_BASE,\n    withCredentials: true,\n    xsrfCookieName: \"Authorization\",\n    xsrfHeaderName: \"Authorization\",\n  },\n  { authDefault: true, publicPrefixes: [\"/api/pub\"] }\n);\n```\n\n### 2) 显式覆盖个别公开接口（例如登录/注册）\n\n> 复杂逻辑：无需继续维护数组；在调用时给 `{ auth:false }`。\n\n```ts\n// 复杂逻辑：显式声明无需鉴权\nhttp.request(\"/auth/login\", \"POST\", body, { auth: false });\nhttp.request(\"/auth/register\", \"POST\", body, { auth: false });\n```\n\n### 3) 小修 bug：统一释放键，避免内存泄露\n\n> 你在请求里写的是 `__abortController`，但错误拦截里读取的是 `__ac`。统一成同一个键。\n\n**在错误拦截器里替换：**\n\n```ts\n// 复杂逻辑：统一用 __abortController\nconst abortController = (err?.config as any)?.__abortController as\n  | AbortController\n  | undefined;\nif (abortController) abortPool.delete(abortController);\n```\n\n---\n\n## 为什么这是“更像大厂”的做法\n\n- **约定 > 配置**：接口分层（`/api/pub/**` 公开，其他默认鉴权）是**稳定、低维护**的组织方式；新增公开接口只需放在该前缀下。\n- **按需覆盖**：极少数“路径不在公开前缀但仍需公开”的接口，用 `auth:false` **显式声明**，可读性强。\n- **可扩展**：未来要拆网关/多后端时，可用**双实例**进一步隔离（见下方“进阶”）。\n- **类型友好**：`AxiosRequestConfig` 扩展 `auth?: boolean`，IDE 自动提示，避免遗漏。\n\n---\n\n## 进阶可选（按需采纳）\n\n### 方案 B：双实例隔离（最常见于中大型前端）\n\n> 公有与鉴权接口**不同实例**，互不影响，拦截器更简单。\n\n```ts\n// 复杂逻辑：一个实例默认鉴权，一个实例默认公开\nexport const authHttp = createAxiosHttp(config, {\n  authDefault: true,\n  publicPrefixes: [],\n});\nexport const pubHttp = createAxiosHttp(config, {\n  authDefault: false,\n  publicPrefixes: [\"/api/pub\"],\n});\n\n// 使用时不再传 auth:false\npubHttp.request(\"/api/pub/get_feednews\", \"GET\");\nauthHttp.request(\"/api/secure/profile\", \"GET\");\n```\n\n### 方案 C：API 分层封装（类型安全）\n\n> 给每个后端接口包一层函数：在函数里固定 `auth:true/false`，业务层不再关心 `auth`。\n\n```ts\n// 复杂逻辑：在 API 层固定鉴权语义\nexport const Api = {\n  getFeedNews: () =>\n    http.request<Feed[]>(\"/api/pub/get_feednews\", \"GET\", undefined, {\n      auth: false,\n    }),\n  getProfile: () => http.request<Profile>(\"/api/secure/profile\", \"GET\"), // 默认为鉴权\n};\n```\n\n---\n\n## 小结\n\n- **最佳实践**：**前缀约定 + 显式覆盖**，别再维护接口白名单数组。\n- 这样新增公开接口只要放到 `/api/pub/**`，其余默认鉴权；个别例外 `auth:false` 即可。\n- 若项目更复杂，进一步采用**双实例**或**API 分层**，把鉴权语义固化到“调用入口”，彻底杜绝分散判断。\n",
            "url": "https://herongdev.github.io/blog/posts/显式覆盖",
            "title": "鉴权判定“最佳实践”：别维护白名单数组，用“前缀约定 + 显式覆盖”",
            "date_modified": "2025-09-05T21:13:27.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界",
            "content_html": "\n## 为什么要谈“边界”\n\nAI 擅长“已知知识的重组与加速”，但在“问题定义、系统性权衡、非完备信息推理、组织沟通与落地”上存在天然短板。明确人机边界，能让 AI 负责“快且广”，工程师负责“准与稳”。\n\n## 人类工程师显著更强的领域\n\n### 1）需求澄清与问题定义\n\n- 把模糊诉求变成可验证的目标/约束/验收标准\n- 在成本/性能/上市时间等冲突目标之间做取舍并对齐干系人\n\n### 2）系统设计与演进路线\n\n- 跨模块/跨团队的架构升级、灰度与回滚策略\n- 面向未来不确定性的扩展点，平衡复杂度与收益\n\n### 3）真实生产问题定位（非完备信息）\n\n- 偶发、不可复现故障的“信号拼图”与因果链验证\n- 跨层关联日志/指标/链路，形成可复现实验和结论\n\n### 4）领域知识与隐性约定\n\n- 行业合规/风控/结算/对账等隐性“黑话”与规则\n- 团队历史技术债与未显式表达的不变量\n\n### 5）安全、隐私与合规（PIPL/GDPR/许可证）\n\n- 供应链安全、最小权限、日志脱敏、审计与存证\n- 在业务价值与合规要求之间做可落地的折中\n\n### 6）分布式与性能工程\n\n- 幂等/重试/限流/熔断等系统级设计与验证\n- 基准测试设计，硬件/内核/网络抖动下的性能归因\n\n### 7）复杂交互与可用性\n\n- 真用户的边界输入、可访问性与可用性权衡\n- 多端/多浏览器/容器内嵌环境的微妙差异处理\n\n### 8）数据与正确性\n\n- 事务边界、最终一致、补偿/重放的业务落地\n- 数据质量/血缘/稽核与“可追责”的数据治理\n\n### 9）产品感觉与工程品味\n\n- API 的语义一致性与长期可维护性\n- 何时“少做/不做”，把复杂度留在正确层次\n\n### 10）组织沟通与推动落地\n\n- 与上下游谈判、拆分排期与风险缓解、跨团队协作\n- 方案说服与共识形成，真正“从纸面到生产”\n\n### 11）实验设计与度量\n\n- 指标选择、A/B 边界、因果与相关的区分\n- 防“纸面最优”，用业务闭环指标检验技术方案\n\n### 12）零先例创新与复盘文化\n\n- 无公开资料时的原型验证、快速试错与知识沉淀\n- 事后复盘（Postmortem）与最小可复现仓库建设\n\n## 可落地的人机协作流程（模板化执行）\n\n### A. 文档先行（AI 起草，人类定锚）\n\n- 产出《问题定义/约束/验收标准》与《设计评审提纲》\n- 用清单化模板：输入、假设、边界、风险、观测项\n\n### B. 强化“验证链路”\n\n- 最小可复现（MRE）、自动化测试、基准测试与可观测性基线\n- 对高风险改动设护栏：灰度/回滚/特性开关/错误预算\n\n### C. 产物分级与质量关卡\n\n- AI 产物只进“开发态/草稿态”，上线前必须经 CR 与度量验证\n- 引入“拒收条件”：不满足验收标准/观测项即退回补强\n\n### D. 知识显性化与复用\n\n- 维护《事故复盘》《设计评审》《发布流程》三套 Checklist\n- 以专题/系列沉淀：生产复盘、系统权衡、行业隐性规则\n\n## 建议的长期专题（可做成系列与课程）\n\n- 生产问题复盘：从信号采集到因果验证的全链路\n- 系统权衡与演进：灰度、回滚、演进路线与“变更即文档”\n- 性能与分布式：限流/熔断/幂等等“系统级能力”的可验证实践\n- 数据治理：质量/血缘/稽核与数据可追责体系\n- 安全与合规：供应链安全、最小权限、合规落地与审计\n- 工程化流程：评审/发布/观测/复盘的标准化与自动化\n\n## 结语\n\nAI 让“生成更快”，工程师让“正确落地”。边界越清晰，协作越高效。把“不可替代”的能力沉淀为流程、清单与课程，才是个人品牌与团队战斗力的复利来源。\n\n## 延伸阅读\n\n- 请求层与鉴权：\n  - [/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线](/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线)\n  - [/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）](/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）)\n- Vue 性能与交互：\n  - [/posts/前端/Vue/Vue 项目请求处理优化](/posts/前端/Vue/Vue项目请求处理优化)\n  - [/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）](/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）)\n- 实时通信与网络：\n  - [/posts/前端/实时通信/web 应用开发-前端-Web-应用如何做到实时消息通知](/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知)\n- 下载与文件：\n  - [/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）](/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）)\n- Web 推送与标识：\n  - [/posts/Web-API-与推送/Web-Push/Web-Push-推送简介](/posts/Web-API-与推送/Web-Push/Web-Push-推送简介)\n  - [/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取](/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取)\n",
            "url": "https://herongdev.github.io/blog/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界",
            "title": "AI 时代：工程师不可替代的价值与协作边界",
            "summary": "这些是 AI 相对更弱、人类工程师显著更强的领域，以及落地的人机协作做法与质量保障。",
            "date_modified": "2025-09-09T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/_templates/article",
            "content_html": "\n## 背景与目标\n\n- 业务/技术背景\n- 这篇文章要解决什么问题？如何验证？\n\n## 问题分析（可复现）\n\n- 最小复现或真实案例\n- 误区与常见失败路径\n\n## 解决方案（可验证）\n\n- 方案对比与取舍\n- 步骤/代码/配置\n- 验证与指标\n\n## 探索与延伸\n\n- 边界条件、兼容性、性能与安全\n- 与相关专题的链接\n\n## 结论与行动项\n\n- 关键结论\n- 下一步可执行清单\n",
            "url": "https://herongdev.github.io/blog/posts/_templates/article",
            "title": "<替换为标题>",
            "summary": "<一句话摘要，便于 SEO>",
            "date_modified": "2025-01-01T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/_templates/series-intro",
            "content_html": "\n## 系列对象与前置\n\n- 适合谁？需要什么前置知识？\n\n## 目录与进度\n\n- [第 1 篇：主题 A](/posts/...) —— 进度：✅/进行中\n- [第 2 篇：主题 B](/posts/...)\n\n## 学习方式\n\n- 推荐阅读顺序\n- 配套 Demo/最小复现仓库\n\n## 常见问题\n\n- FAQ 1\n- FAQ 2\n",
            "url": "https://herongdev.github.io/blog/posts/_templates/series-intro",
            "title": "<专题导言：描述系列价值与对象>",
            "summary": "<系列摘要与读者收益>",
            "date_modified": "2025-01-01T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/Web-API-与推送/Web-Push/Web-Push-推送简介",
            "content_html": "\n---\n\ntitle: Web Push 推送简介\ndate: 2025-09-05\ncategories: \\[Web 实时通讯, 浏览器推送]\ntags: \\[Web Push, Service Worker, PWA, VAPID, 离线通知, 实时消息]\ndescription: 全面介绍 Web Push 技术的原理、特点、实现步骤和典型应用场景，帮助前端/全栈开发者理解并快速落地。\n\n---\n\n# 什么是 Web Push？\n\n**Web Push** 是浏览器层面的 **推送通知机制**。与 WebSocket 或 SSE 不同，它不依赖页面是否处于前台，甚至用户没有打开网页也能收到通知。核心依赖：\n\n- **Service Worker**：浏览器的后台脚本，常驻运行。\n- **Push API**：浏览器与推送服务（FCM、APNs 等）之间的推送通道。\n- **Notification API**：展示系统级通知。\n\n特点：\n\n- **跨平台**：Chrome、Firefox、Edge、Safari（部分版本）均支持。\n- **后台可达**：即使网页未激活或浏览器最小化也能收到。\n- **需用户授权**：必须 HTTPS，且用户点击“允许通知”。\n- **带有身份机制**：通过 VAPID（Voluntary Application Server Identification for Web Push）实现应用级认证。\n\n---\n\n# 工作流程\n\n```mermaid\nsequenceDiagram\n  participant User as 用户浏览器\n  participant SW as Service Worker\n  participant PushSrv as 浏览器厂商推送服务(FCM等)\n  participant Server as 应用服务端\n\n  User->>Server: 注册并获取 VAPID 公钥\n  User->>SW: 注册 Service Worker\n  User->>PushSrv: 订阅推送 (PushSubscription)\n  User->>Server: 上报订阅信息 (endpoint+keys)\n\n  Server->>PushSrv: 使用 VAPID 私钥加密并发送消息\n  PushSrv->>SW: 转发推送\n  SW->>User: Notification API 展示通知\n```\n\n---\n\n# 核心实现步骤\n\n## 1. 生成 VAPID 密钥对\n\n```bash\nnpx web-push generate-vapid-keys\n```\n\n会得到 **公钥 / 私钥**，公钥发给前端，私钥保存在服务端。\n\n---\n\n## 2. 前端注册 Service Worker\n\n```js\nconst reg = await navigator.serviceWorker.register(\"/sw.js\");\n\n// 申请通知权限\nconst permission = await Notification.requestPermission();\nif (permission === \"granted\") {\n  // 订阅推送\n  const sub = await reg.pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: \"<VAPID_PUBLIC_KEY_BASE64URL>\",\n  });\n  // 上报给服务端保存\n  await fetch(\"/push/subscribe\", { method: \"POST\", body: JSON.stringify(sub) });\n}\n```\n\n---\n\n## 3. Service Worker 处理推送\n\n```js\n// sw.js\nself.addEventListener(\"push\", (event) => {\n  const data = event.data?.json() ?? {};\n  event.waitUntil(\n    self.registration.showNotification(data.title || \"通知\", {\n      body: data.body,\n      icon: \"/icon.png\",\n    })\n  );\n});\n```\n\n---\n\n## 4. 服务端发送推送\n\n以 Node.js 为例：\n\n```js\nimport webpush from \"web-push\";\n\n// 设置 VAPID\nwebpush.setVapidDetails(\n  \"mailto:admin@example.com\",\n  process.env.VAPID_PUBLIC,\n  process.env.VAPID_PRIVATE\n);\n\n// subs 存储用户的 PushSubscription\nexport async function sendPush(sub, payload) {\n  await webpush.sendNotification(sub, JSON.stringify(payload));\n}\n```\n\n---\n\n# 典型应用场景\n\n- **消息提醒**：聊天应用收到新消息。\n- **电商营销**：用户未登录页面也能收到促销信息。\n- **系统告警**：后台监控推送紧急故障。\n- **PWA（渐进式 Web 应用）**：接近原生 App 的体验。\n\n---\n\n# 优缺点对比\n\n✅ 优点：\n\n- 浏览器级支持，后台可达。\n- 无需页面常驻，适合通知类消息。\n- 跨浏览器标准（W3C Push API）。\n\n⚠️ 缺点：\n\n- 依赖用户同意，存在拒绝率。\n- Safari 支持有限制（macOS 较晚才全面支持）。\n- 消息大小有限制（通常 4KB）。\n- 不适合大流量/高频推送（需 WebSocket/SSE）。\n\n---\n\n# 小结\n\n**Web Push** = **Service Worker + Push API + Notification API**\n适合“提醒/通知”类场景，不适合实时高频通信。生产实践里常和 **WebSocket/SSE** 组合：\n\n- **WebSocket**：前台实时互动。\n- **Web Push**：后台/离线通知兜底。\n\n---\n\n要不要我帮你写一个 **完整的最小 Web Push DEMO 项目（前端+后端）**，可以直接跑通并测试浏览器推送？\n",
            "url": "https://herongdev.github.io/blog/posts/Web-API-与推送/Web-Push/Web-Push-推送简介",
            "title": "Web Push 推送简介",
            "date_modified": "2025-09-05T14:10:59.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取",
            "content_html": "\n# 一、国内主流 OAID 获取的两条路线\n\n1. **MSA 官方 SDK（闭源）**\n\n- 由“移动安全联盟/CAICT”提供。接入要放 `oaid_sdk_x.x.x.aar`（或早期 `miit_mdid_x.x.x.aar`）、`supplierconfig.json`、证书（`xxx.cert.pem`），并**先加载安全库**再 `MdidSdkHelper.InitSdk(...)` 获取 OAID。常见混淆与加载问题官方 FAQ 也有说明。([百度移动统计][1], [网站名称][2])\n\n2. **开源聚合库（Android_CN_OAID）**\n\n- 由 gzu-liyujiang 提供，统一封装**各厂商 OAID + 海外 AAID + 多种替代 ID**（AndroidID/WidevineID/GUID 等），API 友好。常用入口：`DeviceIdentifier.register(app)` 预取，或者 `DeviceID.getOAID(context, IGetter)` 异步获取。([李宇江的个人网站][3])\n\n> 额外：**华为设备**可直接通过 **HMS Ads Identifier** 获取 OAID（`AdvertisingIdClient.getAdvertisingIdInfo(context).getId()`），不依赖 MSA（很多三方 SDK 文档也这样说明）。([华为开发者][4], [Adjust][5])\n\n---\n\n# 二、你的两个 UTS 插件实际做法（我已解包查看）\n\n- **`android-deviceid`**（UTS for Android）\n\n  - 直接 `import com.github.gzuliyujiang.oaid.*`，调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!)` 进行预取；随后通过接口把结果回调出去。\n  - 插件内还自带 **华为 HMS ads-identifier AAR**（`ads-identifier-*.aar`），作为获取 OAID 的华为路径支撑。\n  - 这是一个\\*\\*标准的“开源聚合库 + （可选）HMS”\\*\\*实现范式。\n\n  片段（来自 `utssdk/app-android/index.uts`）：\n\n  ```ts\n  import DeviceIdentifier from \"com.github.gzuliyujiang.oaid.DeviceIdentifier\";\n  export const register = function () {\n    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);\n  };\n  ```\n\n  （随后通过自定义 `MyListener implements IDManger.OnIOAIDListener` 回传 JSON 结果）\n\n- **`zws-uniqueid`**\n\n  - 不取 OAID，仅根据 `android.os.Build` 若干字段计算 `MD5` 作为**伪标识**（PseudoID），没有广告/合规可重置特性，仅能用于弱追踪/灰度分配等**非广告**用途。\n\n---\n\n# 三、初始化 & 获取：可直接抄的代码片段库\n\n## 方案 A：开源 Android_CN_OAID（推荐起步用）\n\n**初始化（建议在用户同意隐私后再调用）**\n\n```kotlin\n// Application.onCreate 或隐私同意后\nDeviceIdentifier.register(application)  // 预取 clientId/OAID\n```\n\n**获取 OAID（两种）**\n\n- 同步拿预取结果（需先 register）：\n\n  ```kotlin\n  val oaid = DeviceID.getOAID()  // 若未预取会为空\n  ```\n\n- 异步获取（不需要 register）：\n\n  ```kotlin\n  DeviceID.getOAID(context, object : IGetter {\n      override fun onOAIDGetComplete(result: String) { /* result 即 OAID */ }\n      override fun onOAIDGetError(error: Exception) { /* 失败或不支持 */ }\n  })\n  ```\n\n这些方法签名、时机说明都在官方 javadoc 文档中有清晰描述：`register(...)` 预取、`getOAID(...)` 异步、`supportedOAID(context)` 判断支持性、以及 `getGUID`、`getAndroidID` 等替代项。([李宇江的个人网站][6])\n\n> **优点**：开源、快速落地；**缺点**：在个别厂商/系统组合上获取率可能不如官方 MSA；不过开源库会优先尝试 HMS、厂商通道，整体覆盖度已较好。([李宇江的个人网站][3])\n\n## 方案 B：MSA 官方 SDK（企业/上量后建议切换或并行）\n\n**准备**\n\n- `oaid_sdk_x.x.x.aar` 放 `libs/`\n- `supplierconfig.json`、`<package>.cert.pem` 放 `assets/`\n- Proguard：`-keep class com.bun.miitmdid.core.** { *; }`\n- **在 Init 前加载安全库**（不同版本库名可能不同，如 `msaoaidsec` 或文档示例里的 nllvm 加固库名），否则会出现 `No implementation found for ... InitCert` 之类错误。([百度移动统计][1], [网站名称][2])\n\n**初始化 & 获取**\n\n```java\n// 1) （可选但推荐）在 Application.onCreate 尝试加载安全库\ntry { System.loadLibrary(\"msaoaidsec\"); } catch(Throwable ignore) {}\n\n// 2) 在合适时机发起初始化与获取（不要在主线程里做耗时 I/O）\nMdidSdkHelper.InitSdk(\n  context.getApplicationContext(),\n  /* isCert = */ true,\n  new IIdentifierListener() {\n    @Override public void onSupport(IdSupplier supplier) {\n      if (supplier != null) {\n        String oaid = supplier.getOAID();\n        // supplier.isSupported() / isLimited() 等也可读\n      }\n    }\n  }\n);\n```\n\n上面这段 init 与回调写法，在各家第三方接入文档里都是类似范式（百度统计、Adjust、AppsFlyer 等均说明“MSA 或 HMS”两路径），并给出了混淆、AAR、`supplierconfig.json` 的标准放置方法。([百度移动统计][1], [Adjust][5], [AppsFlyer 支持中心][7])\n\n## 方案 C：华为设备走 HMS（若接入了 HMS Core）\n\n```java\n// 不依赖 MSA，在华为设备上直接拿 OAID\nAdvertisingIdClient.Info info =\n    com.huawei.hms.ads.identifier.AdvertisingIdClient.getAdvertisingIdInfo(context);\nString oaid = info.getId();\n// info.isLimitAdTrackingEnabled() 可读 “限制个性化广告” 状态\n```\n\nHMS 文档对 OAID / Identifier Service 的 API 有明确说明。([华为开发者][4])\n\n---\n\n# 四、UTS（uni-app x）里的**最佳实践**总方案\n\n> 目标：**一个 API 跨 H5 / Android**，Android 侧**优先 MSA/HMS**，没有则回退到 **Android_CN_OAID**，最后再降级 **AndroidID / GUID**；且**必须在取得隐私同意后**再初始化与获取。\n\n### 1) API 设计（简洁且可扩展）\n\n```ts\n// /uni_modules/uaid-kit/utssdk/index.uts\nexport type UaidInfo = {\n  oaid: string | null;\n  source: \"MSA\" | \"HMS\" | \"GZU\" | \"NONE\";\n  limitAdTracking?: boolean | null;\n  aaid?: string | null; // 海外广告标识，未来可补\n  androidId?: string | null; // 回退项\n  guid?: string | null; // 本地持久 GUID（Web/低版本回退）\n};\n\nexport function initAfterConsent(): void;\nexport function getUaid(callback: (info: UaidInfo) => void): void;\n```\n\n### 2) UTS 源码（**可直接用**；Android + Web 双端）\n\n> 说明：\n>\n> - **MSA** 部分需要你把 `oaid_sdk_x.x.x.aar` 放到 `utssdk/app-android/libs/`，并在 `manifest.json` 勾选 UTS 插件；否则请把 `// MSA 可选块` 注释掉再编译。\n> - **HMS** 部分需要 `ads-identifier` 依赖；没有就留开源库/回退路径。\n> - Web 端只能**生成/持久化 GUID**，OAID 是 Android 概念。\n\n```ts\n// /uni_modules/uaid-kit/utssdk/app-android/index.uts\n// #ifdef APP-ANDROID\nimport Context from \"android.content.Context\";\nimport Application from \"android.app.Application\";\nimport System from \"java.lang.System\";\n\n// 开源库（gzu-liyujiang）\nimport DeviceIdentifier from \"com.github.gzuliyujiang.oaid.DeviceIdentifier\";\nimport DeviceID from \"com.github.gzuliyujiang.oaid.DeviceID\";\nimport IGetter from \"com.github.gzuliyujiang.oaid.IGetter\";\n\n// HMS（若集成）\nimport AdvertisingIdClient from \"com.huawei.hms.ads.identifier.AdvertisingIdClient\";\n\n// MSA（若集成了 AAR，否则请注释下一行两行以及使用处）\nimport MdidSdkHelper from \"com.bun.miitmdid.core.MdidSdkHelper\";\nimport IIdentifierListener from \"com.bun.miitmdid.interfaces.IIdentifierListener\";\nimport IdSupplier from \"com.bun.miitmdid.interfaces.IdSupplier\";\n// #endif\n\n// #ifdef H5\nimport { ref } from \"vue\";\n// #endif\n\nexport type UaidInfo = {\n  oaid: string | null;\n  source: \"MSA\" | \"HMS\" | \"GZU\" | \"NONE\";\n  limitAdTracking?: boolean | null;\n  aaid?: string | null;\n  androidId?: string | null;\n  guid?: string | null;\n};\n\nexport function initAfterConsent(): void {\n  // #ifdef APP-ANDROID\n  try {\n    // 优先预取开源库的 clientId/OAID\n    DeviceIdentifier.register(\n      UTSAndroid.getUniActivity()!!.getApplication()!! as Application\n    );\n  } catch (e) {}\n\n  // （可选）若你计划走 MSA，尽早加载安全库，避免 InitCert 报错\n  try {\n    System.loadLibrary(\"msaoaidsec\");\n  } catch (e) {}\n  // #endif\n  // #ifdef H5\n  // nothing\n  // #endif\n}\n\nfunction buildGuid(): string {\n  // 128bit GUID，H5/Android 均可用，H5 存 localStorage 即可\n  const s = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\";\n  return s.replace(/[xy]/g, (c) => {\n    const r = (Math.floor(Math.random() * 16) as number) & 0xf;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport function getUaid(cb: (info: UaidInfo) => void): void {\n  // #ifdef APP-ANDROID\n  const ctx = UTSAndroid.getUniActivity()!! as Context;\n\n  // 1) 尝试 HMS（若集成）\n  try {\n    const info = AdvertisingIdClient.getAdvertisingIdInfo(ctx);\n    const id = info.getId();\n    if (id) {\n      cb({\n        oaid: id,\n        source: \"HMS\",\n        limitAdTracking: info.isLimitAdTrackingEnabled(),\n      });\n      return;\n    }\n  } catch (e) {\n    /* ignore */\n  }\n\n  // 2) 尝试 MSA 官方（若集成了 AAR）\n  try {\n    MdidSdkHelper.InitSdk(\n      ctx,\n      true,\n      new (class implements IIdentifierListener {\n        override onSupport(supplier: IdSupplier | null) {\n          if (supplier != null && supplier.getOAID() != null) {\n            cb({ oaid: supplier.getOAID(), source: \"MSA\" });\n          } else {\n            // 3) 回退：开源库异步\n            DeviceID.getOAID(\n              ctx,\n              new (class implements IGetter {\n                override onOAIDGetComplete(result: string) {\n                  cb({ oaid: result, source: \"GZU\" });\n                }\n                override onOAIDGetError(err: any) {\n                  const androidId = DeviceID.getAndroidID(ctx);\n                  cb({ oaid: null, source: \"NONE\", androidId });\n                }\n              })()\n            );\n          }\n        }\n      })()\n    );\n    return;\n  } catch (e) {\n    // 没集成 MSA 或运行异常，继续走开源库回退\n  }\n\n  // 3) 开源库异步（无预取也能用）\n  DeviceID.getOAID(\n    ctx,\n    new (class implements IGetter {\n      override onOAIDGetComplete(result: string) {\n        cb({ oaid: result, source: \"GZU\" });\n      }\n      override onOAIDGetError(err: any) {\n        const androidId = DeviceID.getAndroidID(ctx);\n        cb({ oaid: null, source: \"NONE\", androidId });\n      }\n    })()\n  );\n  // #endif\n\n  // #ifdef H5\n  try {\n    let guid = uni.getStorageSync(\"UAID_GUID\") as string;\n    if (!guid) {\n      guid = buildGuid();\n      uni.setStorageSync(\"UAID_GUID\", guid);\n    }\n    cb({ oaid: null, source: \"NONE\", guid });\n  } catch (e) {\n    cb({ oaid: null, source: \"NONE\", guid: buildGuid() });\n  }\n  // #endif\n}\n```\n\n**混淆/配置建议（Android）**\n\n- 若启用 **MSA**：\n\n  ```\n  -keep class com.bun.miitmdid.core.** { *; }\n  ```\n\n  同时把 `oaid_sdk_x.x.x.aar`、`supplierconfig.json`、`<pkg>.cert.pem` 放到对应目录（AAR: `libs/`，其余在 `assets/`）。初始化前加载安全库，避免 `InitCert` 报错。([百度移动统计][1], [网站名称][2])\n\n- 若启用 **HMS**：确保引入 `com.huawei.hms:ads-identifier`（你现有 `android-deviceid` 插件已内置两个 ads-identifier AAR）。华为 OAID API 文档参考。([华为开发者][4])\n- 若只用**开源库**：不需要证书，按上面 `DeviceID` / `DeviceIdentifier` 的调用即可（方法签名见官方 javadoc）。([李宇江的个人网站][6])\n\n**隐私合规关键点**\n\n- **必须在用户同意隐私政策后**再 `initAfterConsent()`；开源库文档也特别提示 register/获取前需获同意。([李宇江的个人网站][6])\n\n---\n\n# 五、再回答你“原来的插件中如何实现”的要点\n\n- 你的 **`android-deviceid`** 正是采用**开源库（Android_CN_OAID）+（可选）HMS**的组合：\n\n  - 预取：`DeviceIdentifier.register(...)`\n  - 异步获取：`DeviceID.getOAID(context, IGetter)`\n  - 附带 ad-identifier AAR，完善华为路径\n\n  > 这与文档推荐用法一致（register 预取、或异步获取；支持 `supportedOAID` 检查）。([李宇江的个人网站][6])\n\n- 你的 **`zws-uniqueid`** 只是**伪 ID**（基于 `Build.*` 拼接+MD5），**不属于 OAID**，适合作兜底标识，不可用于广告归因。\n\n---\n\n# 六、为什么推荐“先开源库 → 再视需要加 MSA/HMS”\n\n- **落地速度**：开源库无证书/厂商注册门槛，上线快；API 稳定，文档完整（还有 `GUID/AndroidID` 兜底）。([李宇江的个人网站][3])\n- **兼容与获取率**：有华为设备时可直接走 **HMS OAID**；大盘上量/商业化合规要求更高时，再**并行接入 MSA** 提升部分机型覆盖率。([华为开发者][4], [Adjust][5])\n- **合规**：始终把 OAID 获取放在**隐私同意之后**。([李宇江的个人网站][6])\n\n---\n\n## 附：权威/一手资料（便于你对照）\n\n- Android_CN_OAID 文档（`DeviceID.register/getOAID/supportedOAID/...` 方法签名）([李宇江的个人网站][6])\n- Android_CN_OAID 项目主页/文档导航（含包结构/实现原理）([李宇江的个人网站][3])\n- MSA 官方接入说明（AAR、`supplierconfig.json`、混淆、加载安全库/InitCert 问题）([百度移动统计][1], [网站名称][2])\n- Adjust / AppsFlyer 对 OAID 的总述与“MSA 或 HMS”两条路径的明确表述（帮助理解生态）([Adjust][5], [AppsFlyer 支持中心][7])\n- 华为 HMS Ads Identifier OAID 能力文档（API 参考）([华为开发者][4])\n\n---\n\n如果你同意这套方案，我可以把上面的 **UTS 插件源码**按你项目结构打包成 `uni_modules/uaid-kit`（含 `package.json`、`utssdk/app-android/config.json`、`README.md`、示例页），并给出在 **uni-app x** 项目里如何调用的示例页（含隐私弹窗 → 同意后初始化 → 展示结果）的完整代码。\n\n[1]: https://mtj.baidu.com/static/userguide/book/android/oaid.html?utm_source=chatgpt.com \"Android OAID 接入\"\n[2]: https://16054554.s21i.faiusr.com/61/ABUIABA9GAAgx5iGjgYo2_j-1AE.pdf?utm_source=chatgpt.com \"常见问题问答F&Q - 信息资源系统\"\n[3]: https://gzu-liyujiang.github.io/Android_CN_OAID/?utm_source=chatgpt.com \":library\"\n[4]: https://developer.huawei.com/consumer/en/doc/hmscore-references/overview-0000001050066887?utm_source=chatgpt.com \"Overview-com.huawei.hms.ads.identifier-Android-Java- ...\"\n[5]: https://dev.adjust.com/zh/sdk/android/plugins/oaid-plugin/?utm_source=chatgpt.com \"OAID\"\n[6]: https://gzu-liyujiang.github.io/Android_CN_OAID/com/github/gzuliyujiang/oaid/DeviceID.html \"DeviceID \"\n[7]: https://support.appsflyer.com/hc/en-us/articles/360006278797-Android-OAID-implementation-in-the-SDK?utm_source=chatgpt.com \"Android OAID implementation in the SDK\"\n",
            "url": "https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取",
            "title": "OAID 库的初始化与获取",
            "date_modified": "2025-09-07T15:44:21.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit",
            "content_html": "\n棒～这个方向很实用。按你的节奏来：**先取名 → 再讲实现思路 → 之后我们再一步步落地**。\n\n---\n\n## 先取个名字（我给你几个风格不同的备选）\n\n**强推：`UniIdKit`（中文：一体设备 ID 工具包）**\n\n- 简洁、易记、和 uni-app 生态贴合（Uni 前缀）。\n- “Kit” 体现工具集合的定位（OAID/AAID/AndroidID/GUID…聚合）。\n\n其它好选项（任选其一也行）：\n\n- `UniDeviceID`（直白、上手即懂）\n- `IdFusion` / 中文：ID 融合（强调多源融合）\n- `OmniIdKit` / 中文：全域 ID 工具包（强调覆盖广泛）\n- `SignalID` / 中文：设备信标（更“概念化”，偏品牌感）\n\n> 没有特别诉求的话，我后续以 **`UniIdKit`** 为默认名继续讲实现与代码。\n\n---\n\n## 实现思路（先把“大图”画清楚）\n\n### 1) 目标与边界\n\n- **平台覆盖**：Android（App-Plus 原生）、iOS（可选：IDFV）、H5（本地持久 GUID）。\n- **能力聚合**：OAID、AAID、AndroidID、（可选）IMEI/MEID、WidevineID、PseudoID、GUID。\n- **合规优先**：\n\n  - 默认**不采集强隐私**（如 IMEI），需**显式同意**与**动态权限**才允许。\n  - 提供**哈希化输出**（SHA-256）选项，避免直传原始标识。\n  - 尊重系统/用户“广告追踪限制”（AAID/OAID 可能返回空或受限标志）。\n\n### 2) 能力分层（便于维护与扩展）\n\n```\nUniIdKit（JS/TS 封装与 API ）\n ├─ ConsentManager（隐私同意、选项管理、状态缓存）\n ├─ CacheLayer（本地缓存：uni.storage / iOS Keychain / Android MMKV）\n ├─ Aggregator（聚合各 Adapter 的结果、去重、优先级策略、哈希化）\n └─ Adapters\n     ├─ Android:\n     │   ├─ OAIDAdapter（MSA SDK）\n     │   ├─ AAIDAdapter（Google Play 服务）\n     │   ├─ AndroidIdAdapter（SSAID）\n     │   ├─ WidevineIdAdapter（DRM ID，有些机型/ROM可能不可用）\n     │   ├─ PseudoIdAdapter（Build 信息拼接的伪 ID，稳定性一般）\n     │   └─ IMEI/MEIDAdapter（需权限；默认关闭）\n     ├─ iOS:\n     │   └─ IDFVAdapter（IdentifierForVendor）\n     └─ H5:\n         └─ GuidAdapter（首访生成 UUID，localStorage/IndexedDB/Cookie 持久化）\n```\n\n### 3) API 设计（兼容回调，也提供 Promise 风格）\n\n与 Ba-IdCode 的 API 兼容，但**统一返回结构**、并补充 Promise 版本：\n\n- `register(options?)`：完成 SDK 初始化/权限请求/合规弹窗接入（**只有用户同意后才能继续**）。\n- `getIdCodes(options?)`：一次性返回所有可用标识（含哈希/明文二选一），并标出可用性/限制信息。\n- `getOAID()` / `getAAID()` / `getAndroidId()` / `getGuid()`：单项拉取。\n- `getBestId(options?)`：按优先级策略返回“一个最合适的设备标识”（例如：`OAID > AAID > AndroidID > IDFV > GUID`）。\n- `setSalt(salt: string)`：设置服务端协商的哈希盐（建议）；前端仅输出 hash 以降低风险。\n\n**统一返回结构（示例）**：\n\n```ts\ntype IdValue = {\n  value?: string; // 原始值（默认可关闭）\n  hash?: string; // SHA-256(value + salt) 的十六进制\n  available: boolean; // 是否成功获取\n  limited?: boolean; // 是否受限制（如关闭广告标识、受 ROM 策略限制）\n  source?: string; // 具体来源：oaid/aaid/androidId/idfv/guid/...\n  message?: string; // 失败/限制说明\n};\n\ntype IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue; // iOS\n  widevineId?: IdValue;\n  pseudoId?: IdValue;\n  imei?: IdValue; // 默认不返回，需开启 & 权限通过\n  guid?: IdValue; // H5/兜底\n  ts: number; // 时间戳\n  consent: boolean; // 是否已取得用户隐私同意\n};\n```\n\n**调用风格**：\n\n```ts\n// 回调\nidKit.getIdCodes((res) => {\n  /* ... */\n});\n\n// Promise（推荐）\nconst res = await UniIdKit.getIdCodes({\n  hashOnly: true,\n  include: [\"oaid\", \"aaid\", \"androidId\", \"guid\"],\n});\n```\n\n### 4) 平台实现要点\n\n- **Android**：\n\n  - OAID：集成 **MSA (移动安全联盟) SDK** 或厂商合规通道（插件市场常用做法）。\n  - AAID：Google Play 服务 `AdvertisingIdClient`（需处理“限制广告跟踪”返回）。\n  - AndroidID：`Settings.Secure.ANDROID_ID`。\n  - IMEI/MEID：`READ_PHONE_STATE` 动态权限 + Play 政策；**默认关闭**、强提醒不建议依赖。\n  - 缓存：优先使用 MMKV/SharedPreferences，配合有效期（如 24 小时）避免频繁拉取。\n\n- **iOS**：\n\n  - IDFV：`UIDevice.current.identifierForVendor`；卸载所有同一 Vendor 应用后可能变。\n  - 不建议用 IDFA（需要 ATT 授权且涉广告用途，与你目标不匹配）。\n\n- **H5**：\n\n  - 生成 `uuid`，持久化在 `localStorage` + `cookie` 双存；被清理会变，属于“弱设备 ID”。\n  - 返回 `guid` 字段；可选加“服务端长 Cookie dvc=xxx”作为辅助。\n\n### 5) 合规与配置\n\n- 插件默认只返回 **hash**；要返回原值需显式 `exposeRaw: true`。\n- 提供 `register()` 用于展示你的隐私弹窗（或与现有弹窗 SDK 对接），**未同意**则所有采集接口返回 `available=false`。\n- 允许配置 `include/exclude` 字段（避免不必要的请求/权限）。\n- 提供 `fallback: 'guid' | 'none'` 选项控制 H5 的兜底行为。\n\n---\n\n## 3) 先给你一份可直接用的 JS 封装（跨端 & 可渐进增强）\n\n> 先从 JS 层开始（不依赖原生插件也可工作），App 端等你绑定好原生插件后，再把 `native` 分支接上即可。\n\n```ts\n// src/utils/uni-id-kit.ts  —— 先做纯JS壳子，后续接原生\nfunction uuid4() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function sha256Hex(msg: string): Promise<string> {\n  if (typeof window !== \"undefined\" && window.crypto?.subtle) {\n    const enc = new TextEncoder().encode(msg);\n    const buf = await window.crypto.subtle.digest(\"SHA-256\", enc);\n    return Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n  // 非 H5（App 小程序）用简易实现或交给原生\n  // 这里先用最简单的占位：直接返回 msg（上线前请接真 SHA-256，如 plus.crypto / 原生）\n  return msg;\n}\n\ntype GetIdOptions = {\n  include?: Array<\n    | \"oaid\"\n    | \"aaid\"\n    | \"androidId\"\n    | \"idfv\"\n    | \"widevineId\"\n    | \"pseudoId\"\n    | \"imei\"\n    | \"guid\"\n  >;\n  exposeRaw?: boolean; // 默认 false，默认仅返回 hash\n  salt?: string; // 建议传服务端下发的盐\n  fallback?: \"guid\" | \"none\";\n  ttlMs?: number; // 缓存有效期，默认 1 天\n};\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: any } | null = null;\n\nexport const UniIdKit = {\n  setSalt(salt: string) {\n    _salt = salt || \"\";\n  },\n\n  async register(): Promise<{ consent: boolean }> {\n    // TODO: 这里接你的隐私弹窗或第三方隐私 SDK\n    _consent = true; // 演示先直接同意\n    return { consent: _consent };\n  },\n\n  async getIdCodes(opts: GetIdOptions = {}) {\n    const include = opts.include || [\n      \"oaid\",\n      \"aaid\",\n      \"androidId\",\n      \"idfv\",\n      \"guid\",\n    ]; // 先常用\n    const ttl = opts.ttlMs ?? 24 * 3600 * 1000;\n\n    // 简单缓存\n    if (_cache && Date.now() - _cache.ts < ttl) {\n      return _cache.data;\n    }\n\n    const data: any = { ts: Date.now(), consent: _consent };\n\n    // App 原生插件（占位），后续把 requireNativePlugin 接上\n    let native: any = null;\n    try {\n      // @ts-ignore\n      native = uni.requireNativePlugin && uni.requireNativePlugin(\"Uni-IdKit\");\n    } catch {}\n\n    // 工具：组装返回（含 hash）\n    const build = async (\n      source: string,\n      value?: string,\n      limited?: boolean,\n      msg?: string\n    ) => {\n      const available = !!value;\n      const raw = opts.exposeRaw ? value : undefined;\n      const hash = value ? await sha256Hex(value + (_salt || \"\")) : undefined;\n      return { value: raw, hash, available, limited, source, message: msg };\n    };\n\n    // Android / iOS / H5 分支（先写 H5 + 纯 JS 兜底，原生等你接上）\n    const isH5 =\n      typeof window !== \"undefined\" && typeof document !== \"undefined\";\n\n    // OAID / AAID / AndroidID / IDFV —— 占位：若未接原生，返回不可用\n    if (include.includes(\"oaid\"))\n      data.oaid = await build(\n        \"oaid\",\n        native?.getOAID ? await native.getOAID() : undefined\n      );\n    if (include.includes(\"aaid\"))\n      data.aaid = await build(\n        \"aaid\",\n        native?.getAAID ? await native.getAAID() : undefined\n      );\n    if (include.includes(\"androidId\"))\n      data.androidId = await build(\n        \"androidId\",\n        native?.getAndroidID ? await native.getAndroidID() : undefined\n      );\n    if (include.includes(\"idfv\"))\n      data.idfv = await build(\n        \"idfv\",\n        native?.getIDFV ? await native.getIDFV() : undefined\n      );\n    if (include.includes(\"widevineId\"))\n      data.widevineId = await build(\n        \"widevineId\",\n        native?.getWidevineID ? await native.getWidevineID() : undefined\n      );\n    if (include.includes(\"pseudoId\"))\n      data.pseudoId = await build(\n        \"pseudoId\",\n        native?.getPseudoID ? await native.getPseudoID() : undefined\n      );\n    if (include.includes(\"imei\"))\n      data.imei = await build(\n        \"imei\",\n        native?.getIMEI ? await native.getIMEI() : undefined\n      );\n\n    // H5 / 兜底 GUID\n    if (include.includes(\"guid\")) {\n      let guid = uni.getStorageSync(\"UNI_ID_KIT_GUID\");\n      if (!guid) {\n        guid = `web:${uuid4()}`;\n        uni.setStorageSync(\"UNI_ID_KIT_GUID\", guid);\n      }\n      data.guid = await build(\"guid\", guid);\n    }\n\n    // 如果要求有“最佳 ID”\n    data.best = (() => {\n      const order = [\"oaid\", \"aaid\", \"androidId\", \"idfv\", \"guid\"];\n      for (const k of order) {\n        if (data[k]?.available) return k;\n      }\n      return null;\n    })();\n\n    _cache = { ts: Date.now(), data };\n    return data;\n  },\n\n  async getBestId(opts: GetIdOptions = {}) {\n    const res = await this.getIdCodes(opts);\n    const key = res.best;\n    return key ? res[key] : { available: false, source: \"none\" };\n  },\n};\n```\n\n> 这份 JS 壳子**现在就能在 H5 返回一个稳定的 GUID**；等你把 Android/iOS 原生侧接上 `Uni-IdKit` 插件，就能自动获得 OAID/AAID/AndroidID/IDFV 等真实值，API 不变。\n\n---\n\n## 下一步怎么干？\n\n1. **确定名字**（默认我用 `UniIdKit` 继续）。\n2. 我给你 **Android 原生插件最小实现骨架（Kotlin）**：\n\n   - 暴露 `getOAID/getAAID/getAndroidID/...` 方法；\n   - 可先不接 MSA/AAID，返回占位，跑通桥接；\n   - 再逐个接入 MSA SDK、Google Play Advertising ID。\n\n3. 同步给 **iOS 原生插件（Swift）** 获取 IDFV；\n4. 最后在你的登录流程里，把 `const dvc = await UniIdKit.getBestId({ hashOnly: true })` 接上，作为 `x-device-id` 传后端。\n\n要不要我直接开始贴 **Android 插件骨架（可云打包）**？你点个头我就开写。\n\n太好了，我们就按 **UTS 插件**来落地。下面我先给出**项目结构 & API 设计（最佳实践版）**，然后直接给你**可运行的首版代码骨架**（先支持 Web；Android 提供可运行的基础实现 + OAID/AAID 预留点），后续你把 MSA/GP 的 SDK 接上即可。\n\n---\n\n# 一、插件命名 & 目录结构\n\n**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）\n\n- 英文：**UniIdKit**\n- 中文：**一体设备 ID 工具包**\n\n**目录（uni_modules 标准）**：\n\n```\nuni_modules/\n  uni-id-kit/\n    package.json\n    module.json\n    utssdk/\n      index.uts              # 聚合导出（按平台分发）\n      common/\n        types.uts            # 类型与常量定义（复用）\n        hash.uts             # SHA-256 工具（Web/Android 均可）\n        storage.uts          # 本地缓存工具（uni.storage封装）\n      web/\n        index.uts            # Web 实现（GUID、hash、缓存）\n      app-android/\n        index.uts            # Android 实现（AndroidID，OAID/AAID占位）\n        adapters/\n          android_id.uts     # ANDROID_ID\n          aaid.uts           # Google AAID（待接SDK）\n          oaid.uts           # MSA OAID  （待接SDK）\n          pseudo_id.uts      # 伪ID（可选）\n```\n\n> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。\n> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。\n\n---\n\n# 二、API 设计（Promise + 回调兼容）\n\n> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。\n\n## 公开方法\n\n```ts\n// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）\nexport function register(options?: {\n  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗\n}): Promise<{ consent: boolean }>;\n\n// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash\nexport function setSalt(salt: string): void;\n\n// 3) 一次性获取所有可用的 ID（聚合）\nexport function getIdCodes(options?: {\n  include?: Array<\n    | \"oaid\"\n    | \"aaid\"\n    | \"androidId\"\n    | \"idfv\"\n    | \"widevineId\"\n    | \"pseudoId\"\n    | \"imei\"\n    | \"guid\"\n  >;\n  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value\n  ttlMs?: number; // 缓存有效期，默认 24h\n}): Promise<IdCodesResult>;\n\n// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）\nexport function getBestId(options?: {\n  prefer?: Array<\"oaid\" | \"aaid\" | \"androidId\" | \"idfv\" | \"guid\">; // 可自定义优先级\n  exposeRaw?: boolean;\n  ttlMs?: number;\n}): Promise<IdValue>;\n\n// 5) 单项拉取（必要时）\nexport function getOAID(): Promise<IdValue>;\nexport function getAAID(): Promise<IdValue>;\nexport function getAndroidId(): Promise<IdValue>;\nexport function getGuid(): Promise<IdValue>;\n```\n\n## 返回类型（最佳实践）\n\n```ts\n// utssdk/common/types.uts\nexport type IdValue = {\n  value?: string; // 原始值（exposeRaw=true 才返回）\n  hash?: string; // SHA-256(value + salt) 十六进制\n  available: boolean; // 是否获取成功\n  limited?: boolean; // 是否受限（系统关闭广告跟踪等）\n  source: string; // oaid/aaid/androidId/idfv/guid/...\n  message?: string; // 失败或说明\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue; // 预留给 iOS\n  widevineId?: IdValue; // 可选\n  pseudoId?: IdValue; // 可选\n  imei?: IdValue; // 不建议默认启用\n  guid?: IdValue; // H5/兜底\n  best?: string | null; // 最佳项的 key\n  consent: boolean;\n  ts: number; // 生成时间戳\n};\n```\n\n---\n\n# 三、首版代码（可直接放进项目）\n\n> **说明**：以下代码为 **可运行骨架**。\n>\n> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。\n> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。\n> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。\n\n## 1）`uni_modules/uni-id-kit/module.json`\n\n```json\n{\n  \"id\": \"uni-id-kit\",\n  \"displayName\": \"UniIdKit - 一体设备ID工具包\",\n  \"version\": \"0.1.0\",\n  \"description\": \"聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出\",\n  \"keywords\": [\"deviceid\", \"oaid\", \"aaid\", \"androidid\", \"guid\", \"uts\"],\n  \"repository\": \"\",\n  \"engines\": {\n    \"HBuilderX\": \"^3.8.0\"\n  },\n  \"uni_modules\": {\n    \"platforms\": {\n      \"app-android\": {\n        \"utssdk\": {\n          \"kotlin\": \">=1.7.0\"\n        }\n      },\n      \"web\": {\n        \"utssdk\": {}\n      }\n    }\n  }\n}\n```\n\n## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`\n\n```ts\nexport type IdValue = {\n  value?: string;\n  hash?: string;\n  available: boolean;\n  limited?: boolean;\n  source: string;\n  message?: string;\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue;\n  widevineId?: IdValue;\n  pseudoId?: IdValue;\n  imei?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`\n\n```ts\n// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）\nexport async function sha256Hex(input: string): Promise<string> {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const enc = new TextEncoder().encode(input);\n    const buf = await g.crypto.subtle.digest(\"SHA-256\", enc);\n    const arr = Array.from(new Uint8Array(buf));\n    return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现\n  return input;\n}\n```\n\n## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`\n\n```ts\nexport function get(key: string): string | null {\n  try {\n    // @ts-ignore\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\n\nexport function set(key: string, val: string) {\n  try {\n    // @ts-ignore\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getAndroidId(): Promise<IdValue> {\n  // Web 没有 AndroidID\n  return await build(\n    \"androidId\",\n    undefined,\n    false,\n    false,\n    \"Not supported on Web\"\n  );\n}\n\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"androidId\") >= 0) res.androidId = await getAndroidId();\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n\n  // 国内默认优先级\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`\n\n```ts\n// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）\nexport function getAndroidIdRaw(): string | null {\n  try {\n    // @ts-ignore\n    const ctx = plus.android.runtimeMainActivity();\n    // @ts-ignore\n    const SettingsSecure = plus.android.importClass(\n      \"android.provider.Settings$Secure\"\n    );\n    // @ts-ignore\n    const contentResolver = ctx.getContentResolver();\n    // @ts-ignore\n    const id = SettingsSecure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch (e) {\n    return null;\n  }\n}\n```\n\n## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\n// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：\n// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现\nasync function sha256Hex(input: string): Promise<string> {\n  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256\n}\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 这里接入你的合规弹窗/SDK；同意前建议不采集\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  const v = getAndroidIdRaw();\n  return await build(\"androidId\", v || undefined, exposeRaw);\n}\n\n// 预留：接入 Google Advertising ID（AAID）\nexport async function getAAID(): Promise<IdValue> {\n  // TODO：集成 com.google.android.gms:play-services-ads-identifier\n  return await build(\"aaid\", undefined, false, true, \"AAID not integrated\");\n}\n\n// 预留：接入 MSA OAID（国内主流）\nexport async function getOAID(): Promise<IdValue> {\n  // TODO：接入 MSA/OAID SDK\n  return await build(\"oaid\", undefined, false, true, \"OAID not integrated\");\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  // 国内优先级：oaid > androidId > guid\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）\n\n```ts\n// 平台分发：同名导出，业务方 import 一处即可\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n```\n\n---\n\n# 四、在页面中使用（uni-app x）\n\n```ts\n// pages/login/index.uvue (示例)\nimport {\n  register,\n  setSalt,\n  getBestId,\n  getIdCodes,\n} from \"@/uni_modules/uni-id-kit/utssdk/index.uts\";\n\nonMounted(async () => {\n  await register(); // 视需求弹你的隐私协议\n  setSalt(\"server-salt-xxx\"); // 建议从服务端下发\n\n  const best = await getBestId({ exposeRaw: false });\n  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）\n  const dvc = best.hash || best.value || \"unknown\";\n\n  await uni.request({\n    url: `${baseUrl}/passkeys/login/options`,\n    method: \"POST\",\n    header: { \"x-device-id\": dvc },\n    data: {},\n  });\n});\n```\n\n---\n\n# 五、后续接入指引（Android OAID/AAID）\n\n- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。\n- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。\n- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。\n- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。\n- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。\n\n---\n\n如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。\n",
            "url": "https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit",
            "title": "id-kit",
            "date_modified": "2025-09-07T12:35:03.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit开发",
            "content_html": "\n# 一、插件命名 & 目录结构\n\n**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）\n\n- 英文：**UniIdKit**\n- 中文：**一体设备 ID 工具包**\n\n**目录（uni_modules 标准）**：\n\n```\nuni_modules/\n  uni-id-kit/\n    package.json\n    module.json\n    utssdk/\n      index.uts              # 聚合导出（按平台分发）\n      common/\n        types.uts            # 类型与常量定义（复用）\n        hash.uts             # SHA-256 工具（Web/Android 均可）\n        storage.uts          # 本地缓存工具（uni.storage封装）\n      web/\n        index.uts            # Web 实现（GUID、hash、缓存）\n      app-android/\n        index.uts            # Android 实现（AndroidID，OAID/AAID占位）\n        adapters/\n          android_id.uts     # ANDROID_ID\n          aaid.uts           # Google AAID（待接SDK）\n          oaid.uts           # MSA OAID  （待接SDK）\n          pseudo_id.uts      # 伪ID（可选）\n```\n\n> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。\n> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。\n\n---\n\n# 二、API 设计（Promise + 回调兼容）\n\n> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。\n\n## 公开方法\n\n```ts\n// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）\nexport function register(options?: {\n  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗\n}): Promise<{ consent: boolean }>;\n\n// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash\nexport function setSalt(salt: string): void;\n\n// 3) 一次性获取所有可用的 ID（聚合）\nexport function getIdCodes(options?: {\n  include?: Array<\n    | \"oaid\"\n    | \"aaid\"\n    | \"androidId\"\n    | \"idfv\"\n    | \"widevineId\"\n    | \"pseudoId\"\n    | \"imei\"\n    | \"guid\"\n  >;\n  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value\n  ttlMs?: number; // 缓存有效期，默认 24h\n}): Promise<IdCodesResult>;\n\n// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）\nexport function getBestId(options?: {\n  prefer?: Array<\"oaid\" | \"aaid\" | \"androidId\" | \"idfv\" | \"guid\">; // 可自定义优先级\n  exposeRaw?: boolean;\n  ttlMs?: number;\n}): Promise<IdValue>;\n\n// 5) 单项拉取（必要时）\nexport function getOAID(): Promise<IdValue>;\nexport function getAAID(): Promise<IdValue>;\nexport function getAndroidId(): Promise<IdValue>;\nexport function getGuid(): Promise<IdValue>;\n```\n\n## 返回类型（最佳实践）\n\n```ts\n// utssdk/common/types.uts\nexport type IdValue = {\n  value?: string; // 原始值（exposeRaw=true 才返回）\n  hash?: string; // SHA-256(value + salt) 十六进制\n  available: boolean; // 是否获取成功\n  limited?: boolean; // 是否受限（系统关闭广告跟踪等）\n  source: string; // oaid/aaid/androidId/idfv/guid/...\n  message?: string; // 失败或说明\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue; // 预留给 iOS\n  widevineId?: IdValue; // 可选\n  pseudoId?: IdValue; // 可选\n  imei?: IdValue; // 不建议默认启用\n  guid?: IdValue; // H5/兜底\n  best?: string | null; // 最佳项的 key\n  consent: boolean;\n  ts: number; // 生成时间戳\n};\n```\n\n---\n\n# 三、首版代码（可直接放进项目）\n\n> **说明**：以下代码为 **可运行骨架**。\n>\n> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。\n> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。\n> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。\n\n## 1）`uni_modules/uni-id-kit/module.json`\n\n```json\n{\n  \"id\": \"uni-id-kit\",\n  \"displayName\": \"UniIdKit - 一体设备ID工具包\",\n  \"version\": \"0.1.0\",\n  \"description\": \"聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出\",\n  \"keywords\": [\"deviceid\", \"oaid\", \"aaid\", \"androidid\", \"guid\", \"uts\"],\n  \"repository\": \"\",\n  \"engines\": {\n    \"HBuilderX\": \"^3.8.0\"\n  },\n  \"uni_modules\": {\n    \"platforms\": {\n      \"app-android\": {\n        \"utssdk\": {\n          \"kotlin\": \">=1.7.0\"\n        }\n      },\n      \"web\": {\n        \"utssdk\": {}\n      }\n    }\n  }\n}\n```\n\n## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`\n\n```ts\nexport type IdValue = {\n  value?: string;\n  hash?: string;\n  available: boolean;\n  limited?: boolean;\n  source: string;\n  message?: string;\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue;\n  widevineId?: IdValue;\n  pseudoId?: IdValue;\n  imei?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`\n\n```ts\n// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）\nexport async function sha256Hex(input: string): Promise<string> {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const enc = new TextEncoder().encode(input);\n    const buf = await g.crypto.subtle.digest(\"SHA-256\", enc);\n    const arr = Array.from(new Uint8Array(buf));\n    return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现\n  return input;\n}\n```\n\n## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`\n\n```ts\nexport function get(key: string): string | null {\n  try {\n    // @ts-ignore\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\n\nexport function set(key: string, val: string) {\n  try {\n    // @ts-ignore\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getAndroidId(): Promise<IdValue> {\n  // Web 没有 AndroidID\n  return await build(\n    \"androidId\",\n    undefined,\n    false,\n    false,\n    \"Not supported on Web\"\n  );\n}\n\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"androidId\") >= 0) res.androidId = await getAndroidId();\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n\n  // 国内默认优先级\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`\n\n```ts\n// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）\nexport function getAndroidIdRaw(): string | null {\n  try {\n    // @ts-ignore\n    const ctx = plus.android.runtimeMainActivity();\n    // @ts-ignore\n    const SettingsSecure = plus.android.importClass(\n      \"android.provider.Settings$Secure\"\n    );\n    // @ts-ignore\n    const contentResolver = ctx.getContentResolver();\n    // @ts-ignore\n    const id = SettingsSecure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch (e) {\n    return null;\n  }\n}\n```\n\n## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\n// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：\n// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现\nasync function sha256Hex(input: string): Promise<string> {\n  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256\n}\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 这里接入你的合规弹窗/SDK；同意前建议不采集\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  const v = getAndroidIdRaw();\n  return await build(\"androidId\", v || undefined, exposeRaw);\n}\n\n// 预留：接入 Google Advertising ID（AAID）\nexport async function getAAID(): Promise<IdValue> {\n  // TODO：集成 com.google.android.gms:play-services-ads-identifier\n  return await build(\"aaid\", undefined, false, true, \"AAID not integrated\");\n}\n\n// 预留：接入 MSA OAID（国内主流）\nexport async function getOAID(): Promise<IdValue> {\n  // TODO：接入 MSA/OAID SDK\n  return await build(\"oaid\", undefined, false, true, \"OAID not integrated\");\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  // 国内优先级：oaid > androidId > guid\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）\n\n```ts\n// 平台分发：同名导出，业务方 import 一处即可\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n```\n\n---\n\n# 四、在页面中使用（uni-app x）\n\n```ts\n// pages/login/index.uvue (示例)\nimport {\n  register,\n  setSalt,\n  getBestId,\n  getIdCodes,\n} from \"@/uni_modules/uni-id-kit/utssdk/index.uts\";\n\nonMounted(async () => {\n  await register(); // 视需求弹你的隐私协议\n  setSalt(\"server-salt-xxx\"); // 建议从服务端下发\n\n  const best = await getBestId({ exposeRaw: false });\n  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）\n  const dvc = best.hash || best.value || \"unknown\";\n\n  await uni.request({\n    url: `${baseUrl}/passkeys/login/options`,\n    method: \"POST\",\n    header: { \"x-device-id\": dvc },\n    data: {},\n  });\n});\n```\n\n---\n\n# 五、后续接入指引（Android OAID/AAID）\n\n- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。\n- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。\n- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。\n- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。\n- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。\n\n---\n\n如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。\n\n# 参考实现\n\n太好了，我把你这两个现成插件解包看过了，简单总结下各自实现，然后给一套“最佳实践”的统一 API 和落地改造方案（含可以直接替换的 UTS 代码片段）。\n\n---\n\n## 现有两个插件的实现差异（速览）\n\n### 1) `android-deviceid`（UTS，App-Android）\n\n- **用到的库**：`com.github.gzuliyujiang.oaid`（常用 OAID SDK 聚合库），还打包了 3 个 AAR（`ads-identifier-*.aar`、`IDlibrary-release.aar`）。\n- **关键点**：\n\n  - 在 `register()` 里调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity().getApplication())` 完成 **OAID 初始化**。\n  - 暴露了一个 **监听器**（`IDManger.OnIOAIDListener`），把厂商返回的 JSON 结果转成你定义的 `Device` 对象回调出去。\n\n- **优点**：能拿到 **OAID**，并且是较为标准的做法；兼容多厂商。\n- **需要补强**：\n\n  - **统一 Promise API**（目前是回调），方便在页面里用 `await`。\n  - **AAID（Google 广告 ID）**、**AndroidID** 的兜底与优先级策略。\n  - **隐私合规**（register 同意前不采集）、**hash-only** 输出（默认只回传哈希，原值可开关）。\n  - **缓存**（ttl），防止频繁拉取。\n  - 错误/受限标记（例如用户关闭了广告跟踪）。\n\n### 2) `zws-uniqueid`（UTS，App-Android）\n\n- **实现**：拼接 `Build.*` 信息做一段文本，MD5 后作为“唯一 ID”。\n- **优点**：无需权限/SDK，易用。\n- **问题**：这是典型 **PseudoID**，**同型号/同批次设备可能相同**，也可能因 ROM/版本变更；不适合用来做**设备唯一绑定**或风控。\n- **建议**：可以作为 `pseudoId` 字段的**最末位兜底**，不要当主标识。\n\n---\n\n## 建议的统一方案（名字可用你之前认可的：**`uni-id-kit`**）\n\n**目标**：同一份 UTS 插件，覆盖 Web/H5 与 App-Android；API 一致、返回结构一致、默认合规（hash-only），国内优先级 `OAID > AndroidID > GUID > PseudoID`，海外可加 `AAID`。\n\n### 统一 API（Promise 风格）\n\n```ts\n// 注册/合规：未同意前一律 available=false\nexport function register(options?: {\n  showPrivacyDialog?: boolean;\n}): Promise<{ consent: boolean }>;\n\n// 配置哈希盐（建议服务端下发）\nexport function setSalt(salt: string): void;\n\n// 一次性获取所有（含可用性、受限说明、hash）\nexport function getIdCodes(options?: {\n  include?: Array<\"oaid\" | \"aaid\" | \"androidId\" | \"pseudoId\" | \"guid\">;\n  exposeRaw?: boolean; // 默认 false\n  ttlMs?: number; // 默认 24h\n}): Promise<IdCodesResult>;\n\n// 返回“最合适”的一个（按优先级，可定制）\nexport function getBestId(options?: {\n  prefer?: Array<\"oaid\" | \"androidId\" | \"guid\" | \"pseudoId\" | \"aaid\">;\n  exposeRaw?: boolean;\n  ttlMs?: number;\n}): Promise<IdValue>;\n\n// 单项\nexport function getOAID(): Promise<IdValue>;\nexport function getAAID(): Promise<IdValue>;\nexport function getAndroidId(): Promise<IdValue>;\nexport function getGuid(): Promise<IdValue>;\n```\n\n**统一返回结构**\n\n```ts\ntype IdValue = {\n  value?: string; // exposeRaw=true 才返回\n  hash?: string; // SHA-256(value + salt)\n  available: boolean;\n  limited?: boolean; // 例如系统关闭广告跟踪\n  source: string; // oaid/aaid/androidId/pseudoId/guid\n  message?: string;\n};\n\ntype IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  pseudoId?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n---\n\n## 如何改造你现有的两个插件\n\n> 下面给的都是 **直接能塞进工程** 的 UTS 代码。你可以新建一个 `uni_modules/uni-id-kit`，把这两个插件的“能力”合在一起；或者在你现有 `android-deviceid` 里重构导出，效果一致。\n\n### 1) 公共类型与工具（`common/types.uts`、`common/storage.uts`、`common/hash.uts`）\n\n```ts\n// common/types.uts\nexport type IdValue = {\n  value?: string;\n  hash?: string;\n  available: boolean;\n  limited?: boolean;\n  source: string;\n  message?: string;\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  pseudoId?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n```ts\n// common/storage.uts\nexport function get(key: string): string | null {\n  try {\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\nexport function set(key: string, val: string) {\n  try {\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n```ts\n// common/hash.uts（Web 有 crypto.subtle；Android 建议换成 MessageDigest）\nexport async function sha256Hex(input: string): Promise<string> {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const enc = new TextEncoder().encode(input);\n    const buf = await g.crypto.subtle.digest(\"SHA-256\", enc);\n    return Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n  return input; // Android 再换成原生 MessageDigest（见下）\n}\n```\n\n### 2) Web 实现（先把 H5 跑起来：GUID + hash + 缓存）\n\n```ts\n// web/index.uts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  _consent = true; // 你可在这里弹你的隐私协议\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getAndroidId(): Promise<IdValue> {\n  return await build(\n    \"androidId\",\n    undefined,\n    false,\n    false,\n    \"Not supported on Web\"\n  );\n}\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Not supported on Web\");\n}\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  res.best = res.guid?.available ? \"guid\" : null;\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const r = await getIdCodes(options);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n### 3) Android 实现（融合你两个插件思路，Promise 化 + 兜底 + 可拓展）\n\n- **AndroidID**：直接取 `Settings.Secure.ANDROID_ID`（不需要权限）。\n- **OAID**：沿用你 `android-deviceid` 的库，包装为 Promise；初始化要在 `register()` 里做。\n- **AAID**：先留占位，后续加 `play-services-ads-identifier`。\n- **PseudoID**：把 `zws-uniqueid` 的思路做成可选兜底，不当主标识。\n- **SHA-256**：建议在 Android 侧用 `java.security.MessageDigest`，比 web 占位靠谱。\n\n```ts\n// app-android/adapters/android_id.uts\nexport function getAndroidIdRaw(): string | null {\n  try {\n    // @ts-ignore\n    const ctx = plus.android.runtimeMainActivity();\n    // @ts-ignore\n    const SettingsSecure = plus.android.importClass(\n      \"android.provider.Settings$Secure\"\n    );\n    // @ts-ignore\n    const contentResolver = ctx.getContentResolver();\n    // @ts-ignore\n    const id = SettingsSecure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch (e) {\n    return null;\n  }\n}\n```\n\n```ts\n// app-android/adapters/pseudo_id.uts（把 zws 的实现收编为兜底项）\nimport Build from \"android.os.Build\";\nimport MessageDigest from \"java.security.MessageDigest\";\nimport BigInteger from \"java.math.BigInteger\";\n\nexport function getPseudoIdRaw(): string | null {\n  try {\n    const text =\n      Build.BOARD +\n      Build.BRAND +\n      Build.DEVICE +\n      Build.DISPLAY +\n      Build.FINGERPRINT +\n      \"uni-id-kit\";\n    const md5s = MessageDigest.getInstance(\"MD5\").digest(\n      (text as any).toString().toByteArray()\n    );\n    return new BigInteger(1, md5s).toString(16);\n  } catch {\n    return null;\n  }\n}\n```\n\n```ts\n// app-android/index.uts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\nimport { getPseudoIdRaw } from \"./adapters/pseudo_id.uts\";\n\n// ==== 引入你 android-deviceid 插件用到的 OAID 库 ====\nimport DeviceIdentifier from \"com.github.gzuliyujiang.oaid.DeviceIdentifier\";\n// 你现有的监听器写法是 IDManger.OnIOAIDListener + JSON 回调，这里改 Promise 风格：\n// 如果库支持 IGetter 回调也可以（取决于版本），我这里按你包内的风格保留 register 初始化。\n\nlet _consent = false;\nlet _salt = \"\";\n\n// 使用 Android 的 MessageDigest 实现 SHA-256（优于 web 占位）\nfunction sha256HexSync(input: string): string {\n  try {\n    // @ts-ignore\n    const MessageDigest = plus.android.importClass(\n      \"java.security.MessageDigest\"\n    );\n    // @ts-ignore\n    const md = MessageDigest.getInstance(\"SHA-256\");\n    // @ts-ignore\n    const bytes = (input as any).toString().getBytes();\n    const out = md.digest(bytes);\n    let hex = \"\";\n    for (let i = 0; i < out.length; i++) {\n      const b = (out[i] as number) & 0xff;\n      hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n    }\n    return hex;\n  } catch {\n    return input;\n  }\n}\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nfunction buildSync(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): IdValue {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? sha256HexSync(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  try {\n    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);\n  } catch {}\n  _consent = true; // 这里接你的隐私弹窗\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  const v = getAndroidIdRaw();\n  return buildSync(\"androidId\", v || undefined, exposeRaw);\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return buildSync(\"guid\", guid as string, exposeRaw);\n}\n\n// OAID：基于你现有库封装为 Promise（示例：如果库是同步 API 换成同步返回即可）\nexport async function getOAID(): Promise<IdValue> {\n  try {\n    // 你包里是通过监听器把结果 JSON 回调出来的；\n    // 这里建议写一个同步/异步包装（示意）：\n    // 假设库提供 DeviceIdentifier.getOAID(ctx) 或者 DeviceID.getOAID(...)\n    // 如果仅有回调形式，就 new Promise 包一下。\n    // 先占位为“未集成”，避免误用：\n    return buildSync(\n      \"oaid\",\n      undefined,\n      false,\n      true,\n      \"OAID not integrated to Promise wrapper\"\n    );\n  } catch (e) {\n    return buildSync(\"oaid\", undefined, false, false, (e as any).toString());\n  }\n}\n\n// AAID：等你接 play-services-ads-identifier，这里先占位\nexport async function getAAID(): Promise<IdValue> {\n  return buildSync(\"aaid\", undefined, false, true, \"AAID not integrated\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"pseudoId\") >= 0)\n    res.pseudoId = buildSync(\n      \"pseudoId\",\n      getPseudoIdRaw() || undefined,\n      exposeRaw\n    );\n\n  // 国内默认优先级：oaid > androidId > guid > pseudoId\n  const order = [\"oaid\", \"androidId\", \"guid\", \"pseudoId\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const prefer = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n### 4) 平台聚合导出（`utssdk/index.uts`）\n\n```ts\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n```\n\n---\n\n## 要不要“调整现在的代码”？\n\n**要的**，但改动并不大，主要集中在 4 点：\n\n1. **Promise 化**：把回调/监听器的导出改为 Promise，页面里可以 `await`。\n2. **统一返回结构**：所有方法都返回 `IdValue/IdCodesResult`，好串联与埋点。\n3. **合规默认 & hash-only**：提供 `register()` 和 `setSalt()`，未同意前不采集；默认只回 `hash`。\n4. **兜底与优先级**：在拿不到 OAID 时，**自动回退**到 `AndroidID`、`GUID`、`pseudoId`，并清晰标出 `limited`/`message`。\n\n> 你的 `android-deviceid` 插件可以直接把库继续用；我在上面的安卓实现里已经把“桥接位”留好了。\n> `zws-uniqueid` 的算法我收编到 `pseudoId`，作为兜底，不再当主标识使用。\n\n---\n\n## 下一步\n\n- 你确认用 **`uni-id-kit`** 的方案我就把 **OAID Promise 包装**（基于你现有 `DeviceIdentifier` 监听回调）也给你写上，并且给出 **AAID 接入**（`play-services-ads-identifier`）的 `gradle` 依赖与 UTS 调用示例。\n- 如果需要，我也可以给 **iOS（IDFV）** 的 UTS 版本，一起并到这个套件里。\n\n没问题。我把你给的两个 UTS 插件（`android-deviceid` / `zws-uniqueid`）的可取之处吸收，做成一套\\*\\*“最佳实践版”统一插件\\*\\*：**`uni-id-kit`**。它满足：\n\n- 跨端（H5 / App-Android / App-iOS），统一 Promise API；\n- 默认合规：需先 `register()` 才采集；默认只回 **hash**（可开 `exposeRaw` 返回原值）；\n- 国内优先级（可自定义）：**OAID > AndroidID > GUID > PseudoID**，海外可加 **AAID**；\n- 安全版 UUID：多端用系统级安全随机（`crypto.getRandomValues` / `SecureRandom` / `SecRandomCopyBytes`），兜底 `Math.random`；\n- 缓存、错误与受限标记（如“限制广告跟踪”）；\n- 兼容你现有后端（请求头携带 `x-device-id` 即可）。\n\n> 下方给出**可直接落地**的文件结构与代码（可直接新建 `uni_modules/uni-id-kit`），Android 的 OAID/AAID 留好“可用的占位与接入点”；如果你确认要接哪套 SDK（MSA 官方/聚合库），我再把桥接也补全为可跑版本。\n\n---\n\n# 目录结构（放到项目的 `uni_modules/uni-id-kit`）\n\n```\nuni_modules/\n  uni-id-kit/\n    module.json\n    package.json\n    utssdk/\n      index.uts\n      common/\n        types.uts\n        uuid.uts\n        hash.uts\n        storage.uts\n      web/\n        index.uts\n      app-android/\n        index.uts\n        adapters/\n          android_id.uts\n          oaid.uts\n          aaid.uts\n          pseudo_id.uts\n      app-ios/\n        index.uts\n```\n\n---\n\n# 1) module.json\n\n```json\n{\n  \"id\": \"uni-id-kit\",\n  \"displayName\": \"UniIdKit - 一体设备ID工具包\",\n  \"version\": \"0.2.0\",\n  \"description\": \"聚合 OAID/AAID/AndroidID/GUID/IDFV 等设备标识，合规 & 哈希化输出，UTS 插件\",\n  \"keywords\": [\"deviceid\", \"oaid\", \"aaid\", \"androidid\", \"idfv\", \"guid\", \"uts\"],\n  \"engines\": { \"HBuilderX\": \">=3.8.0\" },\n  \"uni_modules\": {\n    \"platforms\": {\n      \"web\": { \"utssdk\": {} },\n      \"app-android\": { \"utssdk\": { \"kotlin\": \">=1.7.0\" } },\n      \"app-ios\": { \"utssdk\": {} }\n    }\n  }\n}\n```\n\n---\n\n# 2) 公共类型/工具\n\n## `utssdk/common/types.uts`\n\n```ts\nexport type IdValue = {\n  value?: string; // exposeRaw=true 才返回\n  hash?: string; // SHA-256(value + salt)\n  available: boolean; // 是否成功获取\n  limited?: boolean; // 广告跟踪受限/ROM限制\n  source: string; // oaid/aaid/androidId/idfv/guid/pseudoId\n  message?: string; // 说明/错误\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue;\n  guid?: IdValue;\n  pseudoId?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n## `utssdk/common/hash.uts`\n\n```ts\n// Web 有 crypto.subtle；原生侧建议用平台 API（Android 代码里换成 MessageDigest；iOS 侧可换 CommonCrypto）\nexport async function sha256Hex(input: string): Promise<string> {\n  // #ifdef H5\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const buf = await g.crypto.subtle.digest(\n      \"SHA-256\",\n      new TextEncoder().encode(input)\n    );\n    return Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n  // #endif\n  return input; // 非H5先返回原文；Android/iOS在各自实现中用系统哈希\n}\n```\n\n## `utssdk/common/storage.uts`\n\n```ts\nexport function get(key: string): string | null {\n  try {\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\nexport function set(key: string, val: string) {\n  try {\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n## `utssdk/common/uuid.uts`（跨端安全 UUIDv4）\n\n```ts\nfunction toHex(): string[] {\n  const h: string[] = [];\n  for (let i = 0; i < 256; i++) h[i] = (i + 0x100).toString(16).substring(1);\n  return h;\n}\nfunction formatUuid(b: Uint8Array): string {\n  b[6] = (b[6] & 0x0f) | 0x40; // version=4\n  b[8] = (b[8] & 0x3f) | 0x80; // variant=10\n  const H = toHex();\n  return (\n    H[b[0]] +\n    H[b[1]] +\n    H[b[2]] +\n    H[b[3]] +\n    \"-\" +\n    H[b[4]] +\n    H[b[5]] +\n    \"-\" +\n    H[b[6]] +\n    H[b[7]] +\n    \"-\" +\n    H[b[8]] +\n    H[b[9]] +\n    \"-\" +\n    H[b[10]] +\n    H[b[11]] +\n    H[b[12]] +\n    H[b[13]] +\n    H[b[14]] +\n    H[b[15]]\n  );\n}\n\n// #ifdef H5\nfunction getRandom16(): Uint8Array {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.getRandomValues)\n    return g.crypto.getRandomValues(new Uint8Array(16));\n  const a = new Uint8Array(16);\n  for (let i = 0; i < 16; i++) a[i] = Math.floor(Math.random() * 256);\n  return a;\n}\n// #endif\n\n// #ifdef APP-ANDROID\nfunction getRandom16(): Uint8Array {\n  const sr = new java.security.SecureRandom(); // UTS 原生：直接 Java 类\n  const arr: number[] = new Array<number>(16);\n  for (let i = 0; i < 16; i++) arr[i] = sr.nextInt(256);\n  return new Uint8Array(arr);\n}\n// #endif\n\n// #ifdef APP-IOS\n// 使用 Security 的 SecRandomCopyBytes（UTS 映射到 Swift）\nfunction getRandom16(): Uint8Array {\n  const bytes = new Uint8Array(16);\n  // @ts-ignore\n  const ok = SecRandomCopyBytes(kSecRandomDefault, 16, bytes);\n  if (ok === 0) return bytes;\n  // 兜底 arc4random_buf\n  // @ts-ignore\n  arc4random_buf(bytes, 16);\n  return bytes;\n}\n// #endif\n\nexport function uuid4(): string {\n  return formatUuid(getRandom16());\n}\n```\n\n---\n\n# 3) H5 实现\n\n## `utssdk/web/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { uuid4 } from \"../common/uuid.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: IdCodesResult } | null = null;\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 这里接你的隐私弹窗；Demo 直接视为同意\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\nexport async function getAndroidId(): Promise<IdValue> {\n  return await build(\"androidId\", undefined, false, false, \"Web unsupported\");\n}\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Web unsupported\");\n}\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Web unsupported\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const ttl = (options?.getNumber(\"ttlMs\") || 24 * 3600 * 1000) as number;\n\n  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  res.best = res.guid?.available ? \"guid\" : null;\n  _cache = { ts: Date.now(), data: res };\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const r = await getIdCodes(options);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n---\n\n# 4) Android 实现（融合两插件思路）\n\n- **参考自** `android-deviceid`：OAID 初始化/拉取（此处给出 Promise 版接口占位，方便你把已购库接上）；\n- **参考自** `zws-uniqueid`：PseudoID 作为**兜底**而非主标识；\n- **AndroidID**：不需权限，稳定性较好；\n- **AAID**：留占位（接入 `play-services-ads-identifier` 后即可实现）；\n- **哈希**：用 `java.security.MessageDigest`（强于 H5 占位）。\n\n## `utssdk/app-android/adapters/android_id.uts`\n\n```ts\nexport function getAndroidIdRaw(): string | null {\n  try {\n    const contentResolver = uni.getContext().getContentResolver();\n    const id = android.provider.Settings$Secure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch {\n    return null;\n  }\n}\n```\n\n## `utssdk/app-android/adapters/pseudo_id.uts`\n\n```ts\nexport function getPseudoIdRaw(): string | null {\n  try {\n    const text =\n      android.os.Build.BOARD +\n      android.os.Build.BRAND +\n      android.os.Build.DEVICE +\n      android.os.Build.DISPLAY +\n      android.os.Build.FINGERPRINT +\n      \"uni-id-kit\";\n    const md = java.security.MessageDigest.getInstance(\"MD5\");\n    md.update((text as any).toString().getBytes(\"UTF-8\"));\n    const out = md.digest();\n    let hex = \"\";\n    for (let i = 0; i < out.length; i++) {\n      const b = (out[i] as number) & 0xff;\n      hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n    }\n    return hex;\n  } catch {\n    return null;\n  }\n}\n```\n\n## `utssdk/app-android/adapters/oaid.uts`（接入点）\n\n```ts\n// 这里封装你现有的 OAID 库调用（例如使用 com.github.gzuliyujiang.oaid）\n// 由于每家库的接口不完全一致，这里给 Promise 化占位；你把实际调用贴进来即可。\nexport async function getOAIDRaw(): Promise<{\n  value?: string;\n  limited?: boolean;\n  message?: string;\n}> {\n  try {\n    // TODO: 用你的库实际实现（初始化 register 在 index.uts 的 register() 里做）\n    // 例如：DeviceIdentifier.getOAID(context, callback) -> 在 callback 里 resolve\n    return {\n      value: undefined,\n      limited: true,\n      message: \"OAID not integrated yet\",\n    };\n  } catch (e) {\n    return { value: undefined, limited: false, message: (e as any).toString() };\n  }\n}\n```\n\n## `utssdk/app-android/adapters/aaid.uts`（接入点）\n\n```ts\nexport async function getAAIDRaw(): Promise<{\n  value?: string;\n  limited?: boolean;\n  message?: string;\n}> {\n  try {\n    // TODO: 接入 play-services-ads-identifier：\n    // AdvertisingIdClient.getAdvertisingIdInfo(context).getId()\n    return {\n      value: undefined,\n      limited: true,\n      message: \"AAID not integrated yet\",\n    };\n  } catch (e) {\n    return { value: undefined, limited: false, message: (e as any).toString() };\n  }\n}\n```\n\n## `utssdk/app-android/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { uuid4 } from \"../common/uuid.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\nimport { getOAIDRaw } from \"./adapters/oaid.uts\";\nimport { getAAIDRaw } from \"./adapters/aaid.uts\";\nimport { getPseudoIdRaw } from \"./adapters/pseudo_id.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: IdCodesResult } | null = null;\n\nfunction sha256HexSync(input: string): string {\n  try {\n    const md = java.security.MessageDigest.getInstance(\"SHA-256\");\n    md.update((input as any).toString().getBytes(\"UTF-8\"));\n    const out = md.digest();\n    let hex = \"\";\n    for (let i = 0; i < out.length; i++) {\n      const b = (out[i] as number) & 0xff;\n      hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n    }\n    return hex;\n  } catch {\n    return input;\n  }\n}\n\nfunction buildSync(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): IdValue {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? sha256HexSync(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 1) OAID 库初始化（把你 android-deviceid 的 register 放到这里）\n  //    例：DeviceIdentifier.register(uni.getContext().getApplicationContext())\n  try {\n    // TODO: 调你的 OAID 库 register\n  } catch {}\n\n  // 2) 你的隐私弹窗/合规流程\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  return buildSync(\"androidId\", getAndroidIdRaw() || undefined, exposeRaw);\n}\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return buildSync(\"guid\", guid as string, exposeRaw);\n}\nexport async function getOAID(): Promise<IdValue> {\n  const r = await getOAIDRaw();\n  return buildSync(\"oaid\", r.value, false, r.limited, r.message);\n}\nexport async function getAAID(): Promise<IdValue> {\n  const r = await getAAIDRaw();\n  return buildSync(\"aaid\", r.value, false, r.limited, r.message);\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n    \"aaid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const ttl = (options?.getNumber(\"ttlMs\") || 24 * 3600 * 1000) as number;\n\n  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"pseudoId\") >= 0)\n    res.pseudoId = buildSync(\n      \"pseudoId\",\n      getPseudoIdRaw() || undefined,\n      exposeRaw\n    );\n\n  // 国内默认优先级（可通过 getBestId 覆盖）\n  const order = [\"oaid\", \"androidId\", \"guid\", \"pseudoId\", \"aaid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  _cache = { ts: Date.now(), data: res };\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const prefer = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n    \"aaid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n---\n\n# 5) iOS 实现（IDFV）\n\n> 你说先国内为主；这里把 **IDFV** 实现好，方便未来开 iOS 端复用。\n\n## `utssdk/app-ios/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { uuid4 } from \"../common/uuid.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: IdCodesResult } | null = null;\n\nfunction sha256HexSync(input: string): string {\n  // TODO: 可换成 CommonCrypto(CC_SHA256)；演示先返回原文\n  return input;\n}\nfunction buildSync(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): IdValue {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? sha256HexSync(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nfunction getIDFVRaw(): string | null {\n  try {\n    const idfv = UIDevice.currentDevice.identifierForVendor?.UUIDString;\n    return idfv ? `idfv:${idfv}` : null;\n  } catch {\n    return null;\n  }\n}\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `ios:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return buildSync(\"guid\", guid as string, exposeRaw);\n}\nexport async function getAndroidId(): Promise<IdValue> {\n  return buildSync(\"androidId\", undefined, false, false, \"iOS unsupported\");\n}\nexport async function getOAID(): Promise<IdValue> {\n  return buildSync(\"oaid\", undefined, false, false, \"iOS unsupported\");\n}\nexport async function getAAID(): Promise<IdValue> {\n  return buildSync(\"aaid\", undefined, false, false, \"iOS unsupported\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"idfv\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const ttl = (options?.getNumber(\"ttlMs\") || 24 * 3600 * 1000) as number;\n\n  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"idfv\") >= 0)\n    res.idfv = buildSync(\"idfv\", getIDFVRaw() || undefined, exposeRaw);\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  const order = [\"idfv\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  _cache = { ts: Date.now(), data: res };\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const prefer = (options?.getArray<string>(\"prefer\") || [\n    \"idfv\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n---\n\n# 6) 平台聚合导出\n\n## `utssdk/index.uts`\n\n```ts\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef APP-IOS\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-ios/index.uts\";\n// #endif\n```\n\n---\n\n# 7) 使用示例（在你的登录页中）\n\n```ts\nimport {\n  register,\n  setSalt,\n  getBestId,\n} from \"@/uni_modules/uni-id-kit/utssdk/index.uts\";\n\nonMounted(async () => {\n  await register({}); // 你的隐私弹窗/合规逻辑\n  setSalt(\"server-salt-xyz\"); // 建议服务端下发；默认只回 hash\n\n  const best = await getBestId({\n    prefer: [\"oaid\", \"androidId\", \"guid\"],\n    exposeRaw: false,\n  });\n  const dvc = best.hash || best.value || \"unknown\";\n\n  await uni.request({\n    url: `${baseUrl}/passkeys/login/options`,\n    method: \"POST\",\n    header: { \"x-device-id\": dvc },\n    data: {},\n  });\n});\n```\n\n---\n\n# 8) 和你两个插件的关系（怎么“融合/替换”）\n\n- `android-deviceid`：\n\n  - **保留其 OAID 能力**，把初始化 `register()` 与获取流程**Promise 化**放到 `adapters/oaid.uts`；\n  - 如果你用的是 **gzu 的聚合库**（`com.github.gzuliyujiang.oaid`），我可按它的 IGetter/Client 回调写成可跑代码；你只需告诉我当前项目里的依赖坐标/使用方式即可（或把现有 `register/getOAID` 调用片段贴我）。\n\n- `zws-uniqueid`：\n\n  - 仅作为 **PseudoID 兜底**（`adapters/pseudo_id.uts` 已收编）；\n  - 不再把它当“设备唯一标识”，它稳定性不够（但当兜底是有意义的）。\n\n---\n\n# 9) 你可能需要的依赖与打包说明（Android）\n\n**OAID**\n\n- 如果用 **MSA 官方 SDK**：按其文档接入（添加 AAR、初始化、回调）。\n- 如果用 **gzu 聚合库**：在 `module.json` 的 `app-android -> utssdk` 里加配置，或在 HBuilderX 的原生配置里勾选对应依赖；随后把 `adapters/oaid.uts` 里按该库接口实现 `getOAIDRaw()` 即可。\n\n**AAID**（Google 广告 ID）\n\n- `com.google.android.gms:play-services-ads-identifier`（需要科学上网/可用镜像）；\n- 通过 `AdvertisingIdClient.getAdvertisingIdInfo(context).id` 获取；若用户限制广告跟踪，返回 limited=true。\n\n> 我可以根据你环境（国内私服/镜像）给出具体 Gradle 依赖配置方式。\n\n---\n\n## 总结\n\n- 这套 **`uni-id-kit`** 是把你两个 UTS 插件做了**统一封装、Promise 化、合规默认与安全加强（哈希/安全随机）**，并提供**清晰可扩展**的适配层。\n- 你现在就可以把上述文件落地，H5 和 Android 的 **AndroidID/GUID/PseudoID** 已可用；**OAID/AAID** 只需在 `adapters/*.uts` 里按你现有库补上调用即可（导出接口已经定好）。\n- 一旦接上 OAID，你就能在国内端得到优先使用的稳定设备标识；其余平台自动回退到 AndroidID/IDFV/GUID。\n\n需要的话，你把你现在 OAID 库的 **初始化 & 获取代码片段**贴我，我直接把 `adapters/oaid.uts` 写成可用实现版（不再占位）。\n",
            "url": "https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit开发",
            "title": "id-kit开发",
            "date_modified": "2025-09-07T12:57:14.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案",
            "content_html": "\n结论先说：**可以把“登录+注册”做成一体化体验**。\n\n主流做法是 **“先尝试登录（可发现凭证）→ 如果用户或设备上没有可用通行密钥，再走 JIT 注册并在验证成功后直接登录”**。\n\n原因是 WebAuthn 天生是“**两步握手**”：\n**options**（服务端签发挑战）→ **客户端做凭证仪式** → **verify**（服务端校验）。\n所以无论登录还是注册，都至少要走这一来一回；想“完全无交互”是不可能的。但你可以把 **登录与注册的分支逻辑** 封装好，让前端只调用 1\\~2 次 API 就完成。\n\n你的代码里已经有这个形态了：\n\n- `/passkeys/login/options|verify`：**无用户名直登**（allowCredentials 留空 → 可发现凭证）\n- `/passkeys/register-or-login/options|verify`：**JIT 建号 + 设备唯一 + 注册即登录**\n\n这就是一体化的正确方向。下面给你**微调点**，让体验更顺滑，并回答“是否必须先绑定”的顾虑。\n\n## 推荐落地流程（与大厂一致的用户体验）\n\n1. **进入应用 → 前端先调用** `/passkeys/login/options`（不传 allowCredentials）。\n\n   - Android/iOS 原生会列出与 **RP ID** 匹配的“可发现凭证”(resident key)。\n   - 若用户设备上已有你的 RP 的通行密钥 → 用户点一下即返回 **assertion** → 你后端 `verifyAuthentication` → **直接登录**。\n\n2. **若返回“没有可用凭证/用户取消/NotFound”**：前端**立即**调用 `/passkeys/register-or-login/options`（带上 `deviceIdentifier`）。\n\n   - 后端 **JIT 建号**（或使用你已有的访客/待激活账号策略），签发 **registration options**（residentKey=required）。\n   - 前端发起注册仪式 → 拿到 **attestation** 回 `/register-or-login/verify`。\n   - 服务端 **校验 + 入库 + 绑定设备(可选) + 激活账号 + 签发 JWT** → **注册即登录**。\n\n> 是否必须先“绑定再登录”？\n> **不必须。**对已存在通行密钥的用户，第一步就能登录；对新设备/新用户，第二步完成**注册+登录**。\n> “设备唯一绑定”是**风控策略**（特别适合你的“仅内部员工”场景），不是通行密钥的强制要求。\n\n## 只给需要修改/新增的代码（复杂逻辑上一行有注释）\n\n### A) `PasskeysService.issueAuthenticationOptions`：若发现设备已绑定账号，则**定向登录**（加速成功率）\n\n```ts\n// 复杂逻辑：若 deviceIdentifier 已绑定 userId，则定向下发 allowCredentials（命中率更高，更快）\nasync issueAuthenticationOptions({ deviceIdentifier }: { deviceIdentifier?: string }) {\n  const relyingPartyId = this.configService.get<string>('RP_ID');\n\n  // 可选的速率限制（60s/5次）\n  if (deviceIdentifier) {\n    const rlKey = `rl:authpub:${deviceIdentifier}`;\n    const c = await this.redisService.incrementKey(rlKey);\n    if (c === 1) await this.redisService.expireKey(rlKey, 60);\n    if (c > 5) throw new BadRequestException('请求过于频繁，请稍后重试');\n  }\n\n  let allowCredentials: { id: Buffer; type: 'public-key' }[] | undefined;\n  let preferUserId: string | null = null;\n\n  if (deviceIdentifier) {\n    // 复杂逻辑：如果该设备已绑定过账号，优先走“定向登录”\n    preferUserId = await this.redisService.getValue(`dvc:owner:${deviceIdentifier}`);\n    if (preferUserId) {\n      // 复杂逻辑：查询该用户的所有凭证，拼出 allowCredentials（按你的持久层接口调整）\n      const creds = await this.staffService.findManyCredentialsByUserId(preferUserId);\n      allowCredentials = (creds || []).map((c: any) => ({\n        id: Buffer.from(c.credentialId, 'base64url'),\n        type: 'public-key' as const,\n      }));\n    }\n  }\n\n  const opts = await generateAuthenticationOptions({\n    rpID: relyingPartyId,\n    userVerification: 'preferred',\n    // 复杂逻辑：存在 allowCredentials → 定向登录；否则留空 = 可发现凭证\n    allowCredentials,\n  });\n\n  // 复杂逻辑：挑战转为 base64url，分别按“userId”或“challenge”做校验键\n  const ch = typeof opts.challenge === 'string'\n    ? opts.challenge\n    : Buffer.from(opts.challenge).toString('base64url');\n\n  if (preferUserId) {\n    // 定向登录：按 userId 存\n    await this.redisService.setWithTimeToLive(`webauthn:auth:${preferUserId}`, ch, 300);\n  } else {\n    // 无用户名直登：按 challenge 存\n    await this.redisService.setWithTimeToLive(`webauthn:auth:ch:${ch}`, '1', 300);\n  }\n\n  // 兼容前端：无需改协议，仍返回纯 AuthenticationOptions\n  return { options: opts };\n}\n```\n\n> 说明：\n>\n> - 这段逻辑**不改变你的路由与前端协议**，仅在“已绑定设备”的情况下给出 `allowCredentials`，成功率会更高，且仍保留“可发现凭证”的默认路径。\n> - `findManyCredentialsByUserId` 请在你的 `AdminStaffService` 或凭据仓库里补一个简单查询（只要返回 `credentialId` 列表即可）。\n\n---\n\n### B) 前端（你刚写的 `<script setup>` 页面）**登录按钮**增加“失败回退到注册”的兜底（只给改动段）\n\n```ts\n// 复杂逻辑：登录失败时自动回退到 JIT 注册（注册成功即登录）\nasync function onLogin() {\n  try {\n    appendLog(\"请求登录 options...\");\n    const { options } = await post(\"/passkeys/login/options\", {\n      deviceIdentifier: deviceId.value,\n    });\n    const requestOptionsJson = JSON.stringify(options);\n\n    // 复杂逻辑：先尝试登录（Android 支持 conditional UI；iOS 忽略该参数）\n    const authRespJson = await passkeys.getPasskey(requestOptionsJson, {\n      conditional: true,\n    });\n\n    appendLog(\"登录响应返回，提交后端 verify...\");\n    const verify = await post(\n      \"/passkeys/login/verify\",\n      JSON.parse(authRespJson)\n    );\n    appendLog(\"登录完成：\" + JSON.stringify(verify));\n    uni.showToast({ title: \"登录成功\", icon: \"success\" });\n  } catch (e: any) {\n    appendLog(\"未找到可用通行密钥或用户取消，转入一键注册...\");\n    // ===== 回退到 JIT 注册 =====\n    const { userId, options } = await post(\n      \"/passkeys/register-or-login/options\",\n      deviceId.value ? { deviceIdentifier: deviceId.value } : {}\n    );\n    const creationOptionsJson = JSON.stringify(options);\n    const regRespJson = await passkeys.createPasskey(creationOptionsJson);\n\n    appendLog(\"注册响应返回，提交后端 verify...\");\n    const verify = await post(\"/passkeys/register-or-login/verify\", {\n      ...JSON.parse(regRespJson),\n      userId,\n      deviceIdentifier: deviceId.value,\n    });\n    appendLog(\"注册并登录完成：\" + JSON.stringify(verify));\n    uni.showToast({ title: \"已注册并登录\", icon: \"success\" });\n  }\n}\n```\n\n---\n\n### C) 小修小补（可选但建议）\n\n```ts\n// ✅ 注册 options：建议同时允许 ES256 与 RS256，兼容性更好\nsupportedAlgorithmIDs: [-7, -257],  // ES256 + RS256\n\n// ✅ 注册时强制 residentKey=required 已很好；登录时建议 UV 至少 preferred（你已这么做）\n// 可对内网/高敏环境将 requireUserVerification 提升为 true\nrequireUserVerification: true, // 在 verify* 中按需要切换\n```\n\n---\n\n## 关键答疑\n\n- **“能不能只请求一次后端就完成登录？”**\n  不行。WebAuthn 必须由服务器先发“带签名挑战”的 **options**，客户端拿到后**本地安全硬件**完成签名/生成数据，再发给服务器 **verify**。这是设计使然，无法省略。\n\n- **“新用户是否必须先走‘绑定’页面？”**\n  不必须。你现在的 JIT 路线就是“**注册即登录**”。首次访问：登录失败 → 自动发起注册 → 验证成功后立刻签发会话即可。后续访问就直接“可发现凭证”一键登录了。\n\n- **“设备唯一绑定是必须的吗？”**\n  不是 WebAuthn 的硬性要求，但对**内部员工场景非常有用**（合规+风控）。你已经在 JIT 验证里写了 `dvc:owner:*` 的校验与写入，这就够了。\n\n---\n\n如果你愿意，我可以**补一个 `findManyCredentialsByUserId` 的最小实现**（Prisma/TypeORM 任一版）或把你的 `PasskeysController` 的“登录按钮”分支写成更干净的状态机。你说一声，我按你的“只给改动段”规范继续补。\n",
            "url": "https://herongdev.github.io/blog/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案",
            "title": "passkeys 通行密钥 登录+注册一体化方案",
            "date_modified": "2025-09-04T23:29:49.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/Next.js/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）",
            "content_html": "\n---\n\ntitle: 最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）\ndate: 2025-09-06\ntags:\n\n- TanStack Query\n- React Query\n- Next.js 14\n- TypeScript\n\n---\n\n## 目标\n\n在**不改动你现有 http 封装**（`http.call` + `api/modules/price.ts`）前提下，最小成本接入 TanStack Query，用于价格趋势这类“读多写少”的数据获取与缓存。\n\n---\n\n## 步骤总览\n\n1. 安装依赖\n2. 新增 `QueryProvider` 并在 `app/layout.tsx` 注入\n3. 写一个最小的 `usePriceTrend` 查询 Hook\n4. 在一个客户端组件里调用展示\n\n> 说明：只给**新增/变更**的文件内容；复杂逻辑在上一行加注释。\n\n---\n\n## 1) 安装\n\n```bash\npnpm add @tanstack/react-query\n# 可选：开发工具\npnpm add -D @tanstack/react-query-devtools\n```\n\n---\n\n## 2) Provider：在全局注入 QueryClient\n\n**新增：`src/lib/query/QueryProvider.tsx`**\n\n```tsx\n\"use client\";\n\nimport { PropsWithChildren, useState } from \"react\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\n// 可选：开发时打开\n// import { ReactQueryDevtools } from '@tanstack/react-query-devtools'\n\nexport default function QueryProvider({ children }: PropsWithChildren) {\n  // 复杂逻辑上一行注释：用 useState 确保在客户端持久化一个 QueryClient 单例\n  const [client] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // 复杂逻辑上一行注释：避免频繁重复请求，数据 5 分钟内视为新鲜\n            staleTime: 5 * 60 * 1000,\n            // 复杂逻辑上一行注释：失败最多重试 2 次，指数退避\n            retry: 2,\n            refetchOnWindowFocus: false,\n          },\n        },\n      })\n  );\n\n  return (\n    <QueryClientProvider client={client}>\n      {children}\n      {/* <ReactQueryDevtools initialIsOpen={false} /> */}\n    </QueryClientProvider>\n  );\n}\n```\n\n**修改：`src/app/layout.tsx`（只贴需要插入的代码）**\n\n```tsx\n// ➊ 新增这一行\nimport QueryProvider from \"@/lib/query/QueryProvider\";\n\n// ... 省略你的现有代码\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"zh-CN\">\n      <body>\n        {/* ➋ 用 Provider 包裹全局 */}\n        <QueryProvider>{children}</QueryProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n---\n\n## 3) 查询 Hook：封装价格趋势获取\n\n**新增：`src/features/price-trend/queries.ts`**\n\n```ts\n\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { priceApi } from \"@/api/modules/price\";\n\n// 复杂逻辑上一行注释：以业务语义定义查询 Hook，统一 queryKey 与调用的 API 函数\nexport function usePriceTrend(gameId: string, stores: string[]) {\n  return useQuery({\n    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参\n    queryKey: [\"priceTrend\", gameId, stores],\n    // 复杂逻辑上一行注释：交给领域 API，返回 Promise<any>\n    queryFn: () => priceApi.getTrend({ gameId, stores }),\n    // 复杂逻辑上一行注释：没有必要参数时不发起请求\n    enabled: Boolean(gameId) && stores.length > 0,\n    // 可选：覆盖全局默认值\n    staleTime: 5 * 60 * 1000,\n    gcTime: 60 * 60 * 1000,\n  });\n}\n```\n\n> 你之前已经有 `priceApi.getTrend`，这里直接复用即可。\n\n---\n\n## 4) 页面示例：客户端组件中使用\n\n**新增：`src/app/price-trend-demo/page.tsx`（最小可跑 Demo 页）**\n\n```tsx\n\"use client\";\n\nimport { useState } from \"react\";\nimport { usePriceTrend } from \"@/features/price-trend/queries\";\n\nexport default function PriceTrendDemoPage() {\n  const [gameId, setGameId] = useState(\"wukong\");\n  const [stores, setStores] = useState<string[]>([\"Steam\", \"Epic\"]);\n\n  const { data, isLoading, error, refetch } = usePriceTrend(gameId, stores);\n\n  return (\n    <div className=\"p-4 space-y-3\">\n      <div className=\"flex gap-2 items-center\">\n        <input\n          value={gameId}\n          onChange={(e) => setGameId(e.target.value)}\n          placeholder=\"gameId\"\n          className=\"border px-2 py-1 rounded\"\n        />\n        <button\n          // 复杂逻辑上一行注释：演示手动刷新（一般可不需要，TanStack 会按策略自动刷新）\n          onClick={() => refetch()}\n          className=\"px-3 py-1 rounded border\"\n        >\n          Refresh\n        </button>\n      </div>\n\n      {isLoading && <div>加载中...</div>}\n      {error && (\n        <div className=\"text-red-600\">出错了：{(error as any)?.message}</div>\n      )}\n\n      <pre className=\"bg-gray-100 p-3 rounded text-sm overflow-auto\">\n        {JSON.stringify(data, null, 2)}\n      </pre>\n    </div>\n  );\n}\n```\n\n> 想接上图表时，把 `data` 交给你的图表组件即可；后续可以把 `stores` 做成可搜索多选，与你主页筛选一致。\n\n---\n\n## 可选：SSR 预取（以后再加）\n\n最小集成里我们**不做 SSR**，直接用客户端渲染即可；若将来需要 SSR/Hydration，可用 `@tanstack/react-query` 的 `dehydrate/hydrate` 在 Server Component 里预取数据、在 Client 端复水。等你需要时我再给“最小 SSR 版本”的差异补丁即可。\n\n下面给你**Vue 3 最小可用示例**（基于 `@tanstack/vue-query`，不改你的 http 封装与 `priceApi`）。只包含**必要的新文件/改动**；复杂逻辑已在上一行加注释。\n\n---\n\n### 1) 安装\n\n```bash\npnpm add @tanstack/vue-query\n# 可选：开发工具\npnpm add -D @tanstack/vue-query-devtools\n```\n\n---\n\n### 2) 全局注册 Vue Query 插件\n\n**新增：`src/plugins/vue-query.ts`**\n\n```ts\n// 复杂逻辑上一行注释：创建全局 QueryClient，设定默认缓存/重试策略\nimport {\n  QueryClient,\n  VueQueryPlugin,\n  type VueQueryPluginOptions,\n} from \"@tanstack/vue-query\";\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // 复杂逻辑上一行注释：5 分钟内视为新鲜，避免频繁请求\n      staleTime: 5 * 60 * 1000,\n      // 复杂逻辑上一行注释：失败自动重试 2 次，指数退避\n      retry: 2,\n      // 聚焦窗口时不强制刷新（按需可改为 true）\n      refetchOnWindowFocus: false,\n    },\n  },\n});\n\nexport function installVueQuery(app: import(\"vue\").App) {\n  const options: VueQueryPluginOptions = { queryClient };\n  app.use(VueQueryPlugin, options);\n  // 可选：开发工具\n  // if (import.meta.env.DEV) {\n  //   const { VueQueryDevtools } = await import('@tanstack/vue-query-devtools')\n  //   app.use(VueQueryDevtools, { initialIsOpen: false })\n  // }\n}\n```\n\n**修改：`src/main.ts`（只贴需要新增的行）**\n\n```ts\nimport { createApp } from \"vue\";\nimport App from \"./App.vue\";\n\n// + 新增：注册 Vue Query 插件\nimport { installVueQuery } from \"@/plugins/vue-query\";\n\nconst app = createApp(App);\ninstallVueQuery(app);\napp.mount(\"#app\");\n```\n\n---\n\n### 3) 查询 Hook（Composable）\n\n**新增：`src/features/price-trend/usePriceTrend.ts`**\n\n```ts\n// 复杂逻辑上一行注释：以业务语义封装 useQuery，统一 queryKey 与调用的 API\nimport { useQuery } from \"@tanstack/vue-query\";\nimport { priceApi } from \"@/api/modules/price\";\n\nexport function usePriceTrend(gameId: string, stores: string[]) {\n  return useQuery({\n    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参\n    queryKey: [\"priceTrend\", gameId, stores],\n    // 复杂逻辑上一行注释：交给领域 API，返回 Promise\n    queryFn: () => priceApi.getTrend({ gameId, stores }),\n    // 复杂逻辑上一行注释：参数不全时不发起请求\n    enabled: Boolean(gameId) && stores.length > 0,\n    // 可选：覆盖默认策略\n    staleTime: 5 * 60 * 1000,\n    gcTime: 60 * 60 * 1000,\n  });\n}\n```\n\n> 这里直接复用你已有的 `priceApi.getTrend`（基于 `http.call`）。\n\n---\n\n### 4) 最小页面示例（组件中使用）\n\n**新增：`src/views/PriceTrendDemo.vue`**\n\n```vue\n<script setup lang=\"ts\">\nimport { ref } from \"vue\";\nimport { usePriceTrend } from \"@/features/price-trend/usePriceTrend\";\n\nconst gameId = ref(\"wukong\");\nconst stores = ref<string[]>([\"Steam\", \"Epic\"]);\n\nconst { data, isLoading, error, refetch } = usePriceTrend(\n  gameId.value,\n  stores.value\n);\n</script>\n\n<template>\n  <div class=\"p-4 space-y-3\">\n    <div class=\"flex gap-2 items-center\">\n      <input\n        v-model=\"gameId\"\n        placeholder=\"gameId\"\n        class=\"border px-2 py-1 rounded\"\n      />\n      <button class=\"px-3 py-1 rounded border\" @click=\"refetch()\">\n        Refresh\n      </button>\n    </div>\n\n    <div v-if=\"isLoading\">加载中...</div>\n    <div v-else-if=\"error\" class=\"text-red-600\">\n      出错了：{{ (error as any)?.message }}\n    </div>\n\n    <pre class=\"bg-gray-100 p-3 rounded text-sm overflow-auto\"\n      >{{ JSON.stringify(data ?? null, null, 2) }}\n    </pre>\n  </div>\n</template>\n```\n\n> 路由按你的项目来：例如在 `vue-router` 里把该组件挂到 `/price-trend-demo`。\n\n---\n\n#### 可选：当 `gameId/stores` 在页面中会变更时\n\n把 `usePriceTrend(gameId.value, stores.value)` 改成**侦听式**：\n\n```ts\nconst { data, isLoading, error, refetch } = usePriceTrend(\n  // 复杂逻辑上一行注释：传入原始值即可；依赖变化时 useQuery 会按 key 缓存/重取\n  gameId.value,\n  stores.value\n);\n```\n\n若你希望**自动**随着 `gameId/stores` 的变更而刷新，可在外层 `watch([gameId, stores], refetch)`；不过通常让 `queryKey` 变化即可自动生效（会根据 key 命中缓存或重新请求）。\n\n---\n\n### 5) 与你现有封装的关系\n\n- **无需修改** `http.call` / `client.ts` / `cancel.ts`；Vue Query 只是把“请求何时发起、如何缓存/重试/并发合并”的**状态机**托管出去。\n- 其他简单页面仍可直接用 `http.get/post` 或 `http.call`。把 **“读多写少、复用度高”的接口**（比如价格趋势、列表）逐步迁到 Vue Query 即可，**按需引入**、零破坏。\n\n如果你需要 **SSR（Nuxt 3）** 的最小示例或 **分页/无限滚动** 的 Query 示例，我也可以在此基础上给出只含必要代码的增量补丁。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/Next.js/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）",
            "title": "最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）",
            "date_modified": "2025-09-06T14:41:39.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/Vue/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）",
            "content_html": "\n---\n\ntitle: GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）\ndate: 2025-09-05\ntags: \\[Vue3, Ant Design Vue, 组件封装, v-model]\n\n---\n\n## 思路概述\n\n- 用 `defineModel` 直接驱动 `a-checkbox-group` / `a-radio-group`，去掉中间层 `innerValue` 与 `watch`，减少响应式开销与同步复杂度。\n- 加上 `defineOptions({ inheritAttrs: false })`，避免 attrs 同时落在根节点与 `a-*group` 上导致副作用。\n- `Checkbox` 明确 `value` 为 **数组**，默认 `[]`；`Radio` 的 `value` 为任意，默认 `null`。\n\n---\n\n## 最简实现步骤\n\n1. 删除 `innerValue` 与所有 `watch`。\n2. 用 `const value = defineModel<...>('value', { default: ... })`，模板直接 `v-model:value=\"value\"`。\n3. 设置 `inheritAttrs: false`，并将 `attrs` 仅透传给 `a-*group`。\n\n---\n\n## 完整代码（Checkbox）\n\n```vue\n<template>\n  <div\n    class=\"gtc-checkbox\"\n    :class=\"[`gtc-checkbox-${size}`, disabled ? 'is-disabled' : '']\"\n  >\n    <a-checkbox-group v-model:value=\"value\" :disabled=\"disabled\" v-bind=\"attrs\">\n      <slot />\n    </a-checkbox-group>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useAttrs } from \"vue\";\n\n// 复杂：避免 attrs 同时落到根节点与 a-checkbox-group\ndefineOptions({ inheritAttrs: false });\n\nconst attrs = useAttrs();\n\nconst props = defineProps({\n  size: { type: String, default: \"md\" },\n  disabled: { type: Boolean, default: false },\n});\n\n// 复杂：CheckboxGroup 期望数组；默认应为 []\nconst value = defineModel<any[]>(\"value\", { default: [] });\n</script>\n\n<style lang=\"less\" scoped>\n.gtc-checkbox {\n  .ant-checkbox-wrapper {\n    color: var(--ink-950);\n  }\n  .ant-checkbox {\n    &-inner {\n      border-color: var(--rim-300);\n      background: none;\n      box-shadow: none;\n    }\n    &-checked .ant-checkbox-inner {\n      background-color: var(--blue-primary);\n      border-color: var(--blue-primary);\n    }\n    &:hover .ant-checkbox-inner {\n      border-color: var(--ink-400);\n    }\n  }\n}\n\n.gtc-checkbox-sm .ant-checkbox-inner {\n  width: 14px;\n  height: 14px;\n}\n.gtc-checkbox-md .ant-checkbox-inner {\n  width: 16px;\n  height: 16px;\n}\n.gtc-checkbox-lg .ant-checkbox-inner {\n  width: 18px;\n  height: 18px;\n}\n\n.is-disabled {\n  .ant-checkbox-inner {\n    background: var(--ground-50);\n    border-color: var(--rim-300);\n  }\n}\n</style>\n```\n\n---\n\n## 完整代码（Radio）\n\n```vue\n<template>\n  <div\n    class=\"gtc-radio\"\n    :class=\"[`gtc-radio-${size}`, disabled ? 'is-disabled' : '']\"\n  >\n    <a-radio-group v-model:value=\"value\" :disabled=\"disabled\" v-bind=\"attrs\">\n      <slot />\n    </a-radio-group>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useAttrs } from \"vue\";\n\n// 复杂：避免 attrs 同时落到根节点与 a-radio-group\ndefineOptions({ inheritAttrs: false });\n\nconst attrs = useAttrs();\n\nconst props = defineProps({\n  size: { type: String, default: \"md\" },\n  disabled: { type: Boolean, default: false },\n});\n\n// 复杂：RadioGroup 接收单值；默认 null\nconst value = defineModel<any>(\"value\", { default: null });\n</script>\n\n<style lang=\"less\" scoped>\n.gtc-radio {\n  .ant-radio-wrapper {\n    color: var(--ink-950);\n  }\n  .ant-radio-inner {\n    border-color: var(--rim-300);\n    background: none;\n    box-shadow: none;\n  }\n  .ant-radio-checked .ant-radio-inner {\n    border-color: var(--blue-primary);\n  }\n  .ant-radio-checked .ant-radio-inner::after {\n    background-color: var(--blue-primary);\n  }\n  .ant-radio:hover .ant-radio-inner {\n    border-color: var(--ink-400);\n  }\n}\n\n.gtc-radio-sm .ant-radio-inner {\n  width: 14px;\n  height: 14px;\n}\n.gtc-radio-md .ant-radio-inner {\n  width: 16px;\n  height: 16px;\n}\n.gtc-radio-lg .ant-radio-inner {\n  width: 18px;\n  height: 18px;\n}\n\n.is-disabled {\n  .ant-radio-inner {\n    background: var(--ground-50);\n    border-color: var(--rim-300);\n  }\n}\n</style>\n```\n\n---\n\n## 备注\n\n- 现在两个组件都是\\*\\*“零 watch、零中间层”\\*\\*：父表单直接通过 `v-model:value` 与 antd 组件对齐；\n- 与你表单规则的“复选框至少选一项”自定义校验配合使用即可（在 `getValidationRules` 里对 `checkbox` 做长度判断）。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/Vue/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）",
            "title": "GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）",
            "date_modified": "2025-09-05T16:25:03.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）",
            "content_html": "\n---\n\ntitle: Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）\ndate: 2025-09-06\ntags:\n\n- Vue3\n- TanStack Vue Query\n- 分页\n- 无限滚动\n\n---\n\n## 前提\n\n已安装并在 `main.ts` 里注册了 `@tanstack/vue-query`（你之前那步已经完成）。下面示例直接复用你的 `http.call` 封装。\n\n---\n\n## 一、页码分页（page/pageSize）\n\n### 1) 组合式函数：`usePagedItems.ts`\n\n```ts\n// src/features/demo/usePagedItems.ts\n\"use client\";\n\nimport { ref } from \"vue\";\nimport { useQuery } from \"@tanstack/vue-query\";\nimport { http } from \"@/lib/http\";\n\n// 复杂逻辑上一行注释：后端返回 PageResp 结构（list/total/page/pageSize）\ntype Item = { id: string; title: string };\ntype PageResp<T> = { list: T[]; total: number; page: number; pageSize: number };\n\n// 复杂逻辑上一行注释：拉取某页数据的纯函数，便于测试与复用\nasync function fetchPage(\n  page: number,\n  pageSize: number\n): Promise<PageResp<Item>> {\n  return http.call<PageResp<Item>>({\n    url: \"/api/items\",\n    method: \"GET\",\n    params: { page, pageSize },\n  });\n}\n\nexport function usePagedItems(initialPageSize = 20) {\n  const page = ref(1);\n  const pageSize = ref(initialPageSize);\n\n  const query = useQuery({\n    // 复杂逻辑上一行注释：将页码作为 queryKey 的一部分，命中不同页的缓存\n    queryKey: () => [\"items\", page.value, pageSize.value],\n    // 复杂逻辑上一行注释：当 page 或 pageSize 改变时，自动按新 key 请求/复用缓存\n    queryFn: () => fetchPage(page.value, pageSize.value),\n    staleTime: 60_000,\n    keepPreviousData: true, // 复杂逻辑上一行注释：翻页时保留上一页数据，避免闪烁\n  });\n\n  // 复杂逻辑上一行注释：对外暴露翻页方法\n  const next = () => {\n    page.value += 1;\n  };\n  const prev = () => {\n    page.value = Math.max(1, page.value - 1);\n  };\n  const setPage = (p: number) => {\n    page.value = Math.max(1, p);\n  };\n\n  return { page, pageSize, ...query, next, prev, setPage };\n}\n```\n\n### 2) 组件示例：`PagedList.vue`\n\n```vue\n<!-- src/views/PagedList.vue -->\n<script setup lang=\"ts\">\nimport { usePagedItems } from \"@/features/demo/usePagedItems\";\n\nconst { data, isFetching, error, page, next, prev } = usePagedItems(10);\n</script>\n\n<template>\n  <div class=\"p-4 space-y-3\">\n    <div class=\"flex items-center gap-2\">\n      <button class=\"border px-3 py-1 rounded\" @click=\"prev\">上一页</button>\n      <span>第 {{ page }} 页</span>\n      <button class=\"border px-3 py-1 rounded\" @click=\"next\">下一页</button>\n    </div>\n\n    <div v-if=\"isFetching\">加载中...</div>\n    <div v-else-if=\"error\" class=\"text-red-600\">\n      出错：{{ (error as any)?.message }}\n    </div>\n\n    <ul v-else class=\"list-disc pl-5\">\n      <li v-for=\"it in data?.list ?? []\" :key=\"it.id\">{{ it.title }}</li>\n    </ul>\n  </div>\n</template>\n```\n\n---\n\n## 二、无限滚动（cursor/nextCursor）\n\n### 1) 组合式函数：`useInfiniteItems.ts`\n\n```ts\n// src/features/demo/useInfiniteItems.ts\n\"use client\";\n\nimport { computed } from \"vue\";\nimport { useInfiniteQuery } from \"@tanstack/vue-query\";\nimport { http } from \"@/lib/http\";\n\ntype Item = { id: string; title: string };\n// 复杂逻辑上一行注释：后端返回游标结构（items + nextCursor），没有更多时 nextCursor 为空/undefined\ntype CursorResp<T> = { items: T[]; nextCursor?: string | null };\n\nasync function fetchByCursor(\n  cursor: string | null,\n  limit: number\n): Promise<CursorResp<Item>> {\n  // 复杂逻辑上一行注释：第一页用 null/空串，后续带上 nextCursor\n  return http.call<CursorResp<Item>>({\n    url: \"/api/items/cursor\",\n    method: \"GET\",\n    params: { cursor, limit },\n  });\n}\n\nexport function useInfiniteItems(limit = 20) {\n  const q = useInfiniteQuery({\n    queryKey: [\"items-infinite\", limit],\n    // 复杂逻辑上一行注释：pageParam 是上一次 getNextPageParam 返回的值；第一页由 initialPageParam 提供\n    queryFn: ({ pageParam }) => fetchByCursor(pageParam ?? null, limit),\n    initialPageParam: null as string | null,\n    // 复杂逻辑上一行注释：从返回值中取下一页的游标；无则表示到底\n    getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,\n    staleTime: 60_000,\n  });\n\n  // 复杂逻辑上一行注释：将多页的 items 扁平合并，便于组件直接渲染\n  const flatItems = computed(\n    () => q.data.value?.pages.flatMap((p) => p.items) ?? []\n  );\n\n  return { ...q, flatItems };\n}\n```\n\n### 2) 组件示例（IntersectionObserver 自动触底加载）：`InfiniteList.vue`\n\n```vue\n<!-- src/views/InfiniteList.vue -->\n<script setup lang=\"ts\">\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\nimport { useInfiniteItems } from \"@/features/demo/useInfiniteItems\";\n\nconst { flatItems, isFetchingNextPage, hasNextPage, fetchNextPage, error } =\n  useInfiniteItems(15);\n\nconst sentinel = ref<HTMLDivElement | null>(null);\nlet observer: IntersectionObserver | null = null;\n\nonMounted(() => {\n  // 复杂逻辑上一行注释：使用 IntersectionObserver 观察“页尾哨兵”，进入视口即加载下一页\n  observer = new IntersectionObserver(\n    (entries) => {\n      const e = entries[0];\n      if (e.isIntersecting && hasNextPage.value && !isFetchingNextPage.value) {\n        fetchNextPage();\n      }\n    },\n    { root: null, rootMargin: \"0px\", threshold: 0.1 }\n  );\n\n  if (sentinel.value) observer.observe(sentinel.value);\n});\n\nonBeforeUnmount(() => {\n  if (observer && sentinel.value) observer.unobserve(sentinel.value);\n  observer = null;\n});\n</script>\n\n<template>\n  <div class=\"p-4 space-y-3\">\n    <div v-if=\"error\" class=\"text-red-600\">\n      出错：{{ (error as any)?.message }}\n    </div>\n\n    <ul class=\"space-y-2\">\n      <li v-for=\"it in flatItems\" :key=\"it.id\" class=\"border rounded p-2\">\n        {{ it.title }}\n      </li>\n    </ul>\n\n    <!-- 复杂逻辑上一行注释：页尾“哨兵”元素，用于触发下一页加载 -->\n    <div\n      ref=\"sentinel\"\n      class=\"h-8 flex items-center justify-center text-gray-500\"\n    >\n      <span v-if=\"isFetchingNextPage\">加载更多...</span>\n      <span v-else-if=\"!hasNextPage\">没有更多了</span>\n      <span v-else>下拉加载</span>\n    </div>\n\n    <!-- 兜底：手动加载更多按钮（可选） -->\n    <div class=\"text-center\">\n      <button\n        class=\"mt-2 border px-3 py-1 rounded\"\n        :disabled=\"!hasNextPage || isFetchingNextPage\"\n        @click=\"fetchNextPage()\"\n      >\n        {{\n          isFetchingNextPage\n            ? \"加载中…\"\n            : hasNextPage\n            ? \"加载更多\"\n            : \"没有更多了\"\n        }}\n      </button>\n    </div>\n  </div>\n</template>\n```\n\n---\n\n## 关键点与小贴士\n\n- **keepPreviousData**：页码分页时避免闪屏；无限滚动用 `useInfiniteQuery` 不需要它。\n- **queryKey 设计**：把影响结果的入参（如 `page/pageSize`、`limit/filters`）放进 key，缓存才可命中。\n- **getNextPageParam**：返回 `undefined` 代表“没有下一页”；返回游标字符串（或对象）将作为下一次 `pageParam` 传入。\n- **触底加载**：`IntersectionObserver` 比 `scroll` 事件更稳、成本更低；确保有合理的 `rootMargin/threshold`。\n- **错误重试**：默认会自动重试 2 次（取决于你的全局设置）。对幂等读接口通常是安全的。\n\n需要我把这两个 Demo 接到你现有的某个真实接口（比如你“价格趋势”或“攻略列表”）上，我可以直接给**最小改动的代码片段**。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）",
            "title": "Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）",
            "date_modified": "2025-09-06T14:49:38.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/Vue/Vue项目请求处理优化",
            "content_html": "\n现在的我的 vue+vite+pinia 项目有个问题，我的有些请求，我在 store 中就直接调用，但 store 的执行时机很早，这时用户可能没有登录，发出这些需要 token 的请求是不合适的，但如果我们把请求放到具体页面中，那每个页面都要请求，违背了我们放入 store 中的初衷，如何处理？\n\n**核心结论**：\n\n> **把“请求放在 Store”与“何时触发请求”解耦**。\n> 数据仍由 Pinia Store 管，但所有“首次加载/刷新”的触发统一由**受保护布局(ProtectedLayout)**或**集中启动钩子**在“已登录且当前路由需要鉴权”时一次性触发。\n> 请求层（Axios 封装）负责：自动带 Token、401 统一刷新/重试、（可选）对标记 `auth` 的请求在无 Token 时直接拒绝。\n\n## 路由：只给受保护页面打上 `requiresAuth`\n\n**修改位置：`src/router/index.ts`**\n\n```ts\n// 在需要登录的路由上增加 meta.requiresAuth\n{\n  path: '/dashboard',\n  name: 'dashboard',\n  component: () => import('@/pages/dashboard/index.vue'),\n  meta: { requiresAuth: true }\n}\n```\n\n## 受保护布局：只在“已登录 && 受保护路由”时触发各 Store 的初始化\n\n**新增文件：`src/composables/useAppBootstrap.ts`**\n\n```ts\nimport { watch } from \"vue\";\nimport { useRouter } from \"vue-router\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport { useUserStore } from \"@/stores/user\";\nimport { useXStore } from \"@/stores/x\"; // 你的其他数据模块按需引入\n\nexport function useAppBootstrap() {\n  const router = useRouter();\n  const auth = useAuthStore();\n  const user = useUserStore();\n  const x = useXStore();\n\n  // 复杂逻辑：仅在“已登录 && 当前路由需要鉴权”时做一次性初始化（可幂等）\n  watch(\n    [\n      () => auth.isAuthenticated,\n      () => router.currentRoute.value.meta.requiresAuth,\n    ],\n    async ([ok, need]) => {\n      if (ok && need) {\n        // 复杂逻辑：各 store 的 init() 必须“幂等”，重复调用不重复发请求\n        await Promise.all([user.init(), x.init()]);\n      }\n    },\n    { immediate: true }\n  );\n}\n```\n\n**在你的受保护布局/根布局里调用（例如 `src/layouts/ProtectedLayout.vue`）**：\n\n```ts\n// <script setup>\n// 复杂逻辑：在受保护布局挂载时调用集中引导\nimport { useAppBootstrap } from \"@/composables/useAppBootstrap\";\nuseAppBootstrap();\n// </script>\n```\n\n> 如果你没有单独的布局文件，可以在 `App.vue` 里根据 `route.meta.requiresAuth` 切出一个“受保护区域”再调用 `useAppBootstrap()`。\n\n---\n\n## Store：移除“定义即请求”的副作用，提供幂等 `init()`\n\n**修改位置：`src/stores/user.ts`（示例）**\n\n```ts\n// 删除：顶层的立即请求（例如 defineStore 里一创建就 fetch 的代码）\n\n// 新增：幂等 init()\nlet _initPromise: Promise<void> | null = null;\n\nexport const useUserStore = defineStore(\"user\", () => {\n  const profile = ref<User | null>(null);\n\n  // 复杂逻辑：单例 Promise，保证多处调用只触发一次真实请求\n  async function init() {\n    if (_initPromise) return _initPromise;\n    _initPromise = (async () => {\n      if (profile.value) return;\n      const { data } = await http.get(\"/me\", { meta: { auth: true } });\n      profile.value = data;\n    })();\n    return _initPromise;\n  }\n\n  // 可选：在登出时清理，便于下次重新 init\n  function reset() {\n    profile.value = null;\n    _initPromise = null;\n  }\n\n  return { profile, init, reset };\n});\n```\n\n> 你的其他 Store（如 `x.ts`、`projects.ts` 等）都按这个\\*\\*“删除副作用 + 提供幂等 init()”\\*\\*的模式改一遍。\n\n---\n\n## 请求层：自动带 Token、401 统一刷新并队列重试、无 Token 阻断受保护请求\n\n**修改位置：`src/http/axios.ts`（或你的请求封装文件）**\n\n**（1）扩展 Axios 类型，支持 `meta.auth` 与 `_retry`**\n\n```ts\n// 复杂逻辑：为请求增加自定义元信息与重试标记\ndeclare module \"axios\" {\n  export interface AxiosRequestConfig {\n    meta?: { auth?: boolean };\n    _retry?: boolean;\n  }\n}\n```\n\n**（2）请求拦截：自动加 Authorization；无 Token 且需要鉴权时直接拒绝**\n\n```ts\nimport axios from \"axios\";\nimport { useAuthStore } from \"@/stores/auth\";\nimport router from \"@/router\";\n\nexport const http = axios.create({ baseURL: import.meta.env.VITE_API_BASE });\n\nhttp.interceptors.request.use((config) => {\n  const auth = useAuthStore();\n\n  // 复杂逻辑：仅对标记了 meta.auth 的请求自动带 token\n  if (config.meta?.auth) {\n    if (!auth.token) {\n      // 复杂逻辑：阻断未登录时的鉴权请求（避免在 /user/login 等页面误发）\n      return Promise.reject(new Error(\"AUTH_REQUIRED\"));\n    }\n    config.headers = {\n      ...config.headers,\n      Authorization: `Bearer ${auth.token}`,\n    };\n  }\n  return config;\n});\n```\n\n**（3）响应拦截：统一处理 401，带刷新队列（避免并发多次刷新）**\n\n```ts\nlet refreshing = false;\nlet waitQueue: Array<() => void> = [];\n\nhttp.interceptors.response.use(\n  (r) => r,\n  async (error) => {\n    const auth = useAuthStore();\n    const { response, config } = error || {};\n    if (response?.status === 401 && config && !config._retry) {\n      // 复杂逻辑：给当前请求打 _retry，防止递归\n      config._retry = true;\n\n      if (!refreshing) {\n        refreshing = true;\n        try {\n          await auth.refreshToken(); // 你在 auth store 中实现这个方法\n          refreshing = false;\n          // 复杂逻辑：刷新成功后，放行所有队列中的请求\n          waitQueue.splice(0).forEach((fn) => fn());\n          return http(config);\n        } catch (e) {\n          refreshing = false;\n          // 复杂逻辑：刷新失败，清空队列并跳转登录\n          waitQueue.splice(0).forEach((fn) => fn());\n          auth.logout();\n          router.replace({\n            name: \"login\",\n            query: { redirect: router.currentRoute.value.fullPath },\n          });\n          return Promise.reject(e);\n        }\n      }\n\n      // 复杂逻辑：如果正在刷新，把当前请求加入队列，等待刷新完成后重试\n      return new Promise((resolve, reject) => {\n        waitQueue.push(() => http(config).then(resolve).catch(reject));\n      });\n    }\n    return Promise.reject(error);\n  }\n);\n```\n\n---\n\n## Auth Store：提供 `isAuthenticated`、`refreshToken()`、`logout()`\n\n**修改位置：`src/stores/auth.ts`**\n\n```ts\nexport const useAuthStore = defineStore(\"auth\", () => {\n  const token = ref<string | null>(null);\n  const refresh = ref<string | null>(null);\n\n  // 复杂逻辑：派生登录态，集中判断是否有有效 token\n  const isAuthenticated = computed(() => !!token.value);\n\n  async function setToken(t: string, r?: string) {\n    token.value = t;\n    if (r) refresh.value = r;\n  }\n\n  async function refreshToken() {\n    // 复杂逻辑：用 refresh_token 换新 token，失败则抛错\n    const { data } = await axios.post(\"/auth/refresh\", {\n      refresh_token: refresh.value,\n    });\n    token.value = data.access_token;\n    refresh.value = data.refresh_token ?? refresh.value;\n  }\n\n  function logout() {\n    token.value = null;\n    refresh.value = null;\n    // 复杂逻辑：通知其他 store 清空并重置 init()\n    useUserStore().reset();\n    // 其他 store 同理按需 reset()\n  }\n\n  return { token, isAuthenticated, setToken, refreshToken, logout };\n});\n```\n\n---\n\n## 登录成功后：只需设置 token 并跳转，初始化会自动发生\n\n**修改位置：`/user/login` 提交成功回调处**\n\n```ts\n// 复杂逻辑：写入 token 并跳到受保护路由；受保护布局会自动触发所有 store.init()\nawait authStore.setToken(res.access_token, res.refresh_token);\nrouter.replace((route.query.redirect as string) || \"/\");\n```\n\n---\n\n## 为什么这是“最佳做法”\n\n1. **单一职责清晰**：Store 只做“状态与方法”，不在定义期发请求；“什么时候发”交给受保护布局的引导钩子统一触发。\n2. **避免重复请求**：`init()` 使用**单例 Promise**，多次调用只会发一次请求。\n3. **页面无侵入**：页面无需关心是否登录、是否首发，页面只消费 Store 的 state。\n4. **错误集中处理**：401 统一刷新与队列重试，避免因并发导致多次刷新或脏状态。\n5. **登录页零干扰**：登录页不再误发需要 Token 的请求；即使误调，Axios 层也会拦截并拒绝。\n6. **易扩展**：新增数据域时，只需在受保护引导中 `store.init()` 一行接入。\n\n---\n\n如果你愿意，我可以基于你当前的目录结构，把上述“幂等 init + 受保护布局引导 + Axios 刷新队列”的改动**逐个落到你的具体文件**（只贴需要改的片段）。你把相关文件名和关键片段贴给我就行。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/Vue/Vue项目请求处理优化",
            "title": "Vue项目pinia中的Store中的请求时机管理",
            "date_modified": "2025-09-05T18:07:15.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/Vue/体积分布分析图",
            "content_html": "\n## 总览\n\n想在 **Vite + Vue3** 打包后看到类似 Webpack Bundle Analyzer 的交互式“依赖体积分布图”，最简单稳妥的方法是接入 `rollup-plugin-visualizer`。本文给出**最小改动**方案：按需启用分析模式、构建、自动打开 `stats.html`。\n\n---\n\n## 实现思路\n\n- 使用 Rollup 可视化插件（Vite 打包底层是 Rollup）。\n- 仅在“分析模式”挂载插件，避免影响日常构建速度。\n- 构建完成自动生成并打开 `stats.html`（Treemap/Sunburst 可选）。\n- 可选：开启 `sourcemap` 便于二次分析。\n\n---\n\n## 分步操作\n\n### 1）安装依赖\n\n```bash\n# 任选包管理器\npnpm add -D rollup-plugin-visualizer\n# 或\nnpm i -D rollup-plugin-visualizer\n# 或\nyarn add -D rollup-plugin-visualizer\n```\n\n### 2）修改 `vite.config.ts`（只给需要改的片段）\n\n> 说明：以下片段为**增量修改**，请在你的 `vite.config.ts` 里按位置插入即可。\n\n```ts\n// ① 顶部新增一行：导入可视化插件\nimport { visualizer } from \"rollup-plugin-visualizer\";\n```\n\n```ts\n// ② 在 defineConfig 回调里按需启用（若你当前不是回调形式，可改为回调：defineConfig(({ mode }) => ({ ... }))）\nconst enableAnalyze = process.env.ANALYZE === \"true\" || mode === \"analyze\";\n\n// 复杂逻辑：仅在分析模式下挂载插件，避免常规构建受影响\nenableAnalyze &&\n  plugins.push(\n    visualizer({\n      // 复杂逻辑：输出 treemap 到项目根目录，并在构建结束自动打开\n      filename: \"stats.html\",\n      template: \"treemap\", // 可选：'treemap' | 'sunburst' | 'network'\n      open: true,\n      gzipSize: true,\n      brotliSize: true,\n    })\n  );\n```\n\n```ts\n// ③（可选）为了配合二次分析或排查问题，开启源码映射\nbuild: {\n  // 复杂逻辑：仅在分析模式下开启 sourcemap（若你已有 build 配置，请合并到其中）\n  sourcemap: enableAnalyze;\n}\n```\n\n> 小贴士：若你的 `plugins` 是直接字面量数组，改成先声明 `const plugins = [vue(/*...*/)]` 再 `.push(...)`，最后 `return { plugins }`。不想改结构也行：`plugins: [vue(), enableAnalyze && visualizer({...})].filter(Boolean)`。\n\n### 3）新增构建脚本（二选一）\n\n**方案 A（推荐，跨平台零依赖）：用 `--mode analyze` 触发**\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"build:analyze\": \"vite build --mode analyze\"\n  }\n}\n```\n\n**方案 B：用环境变量触发（类 Unix 系统方便）**\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    // 复杂逻辑：通过环境变量开启分析模式；Windows 可用 cross-env 做兼容\n    \"build:analyze\": \"ANALYZE=true vite build\"\n  }\n}\n```\n\n---\n\n## 使用方法\n\n```bash\n# 触发分析构建（使用你选择的方案）\npnpm run build:analyze\n\n# 构建完成后会自动打开 stats.html\n# 若未自动打开，可手动在项目根目录双击/用浏览器打开 stats.html\n```\n\n---\n\n## 进阶玩法（可选）\n\n### A. 自定义输出位置/图表类型\n\n```ts\n// 复杂逻辑：将报告输出到 dist 目录下并改为 sunburst 风格\nvisualizer({\n  filename: \"dist/bundle-report.html\",\n  template: \"sunburst\",\n  open: true,\n});\n```\n\n### B. 快速“拆包”以便观察效果\n\n> 仅示例，按你实际依赖调整：\n\n```ts\n// 复杂逻辑：演示常见手动分包，便于在图里更清晰地区分\nbuild: {\n  rollupOptions: {\n    output: {\n      manualChunks: {\n        vue: ['vue', 'vue-router', 'pinia'],\n        // 如果你用到 Ant Design Vue / ECharts / AntV 等，可分别拆\n        // antdv: ['ant-design-vue'],\n        // echarts: ['echarts'],\n        // antv: ['@antv/g2', '@antv/g2plot'],\n      }\n    }\n  }\n}\n```\n\n### C. 二次分析（Source Map）\n\n```bash\n# 可选：安装 source-map-explorer 做“按文件”体积分析\npnpm add -D source-map-explorer\n# 构建（确保 sourcemap 已开启）\npnpm run build:analyze\n# 生成 HTML 报告（路径按你的 dist 实际文件调整）\nnpx source-map-explorer \"dist/assets/*.js\" --html dist/sme.html\n```\n\n---\n\n## 常见问题\n\n- **stats.html 是空白/打不开？**\n  多半是构建被缓存或浏览器拦截了本地文件。先清理 `dist` 再构建；或换个浏览器打开，必要时关闭浏览器的本地文件限制。\n\n- **报告没自动打开？**\n  CI/无头环境不会自动打开。把 `open: false`，直接到输出目录找报告 HTML 即可。\n\n- **Windows 下 `ANALYZE=true` 不生效？**\n  用方案 A（`--mode analyze`），或安装 `cross-env`：\n  `cross-env ANALYZE=true vite build`。\n\n- **体积异常大但定位不到模块？**\n  开启 `sourcemap` 后再看 `stats.html`；若仍不清晰，配合 `source-map-explorer` 交叉验证。\n\n---\n\n## 小结\n\n- 装一个 `rollup-plugin-visualizer`，按需启用分析模式，构建即得可交互分析图。\n- 报告默认 `stats.html`，Treemap/Sunburst 随选。\n- 需要更深入排查时，打开 `sourcemap` + `source-map-explorer` 双管齐下。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/Vue/体积分布分析图",
            "title": "Vite + Vue3 打包后如何查看“体积分布分析图”",
            "date_modified": "2025-09-06T16:59:20.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/Vue/动态表单「已勾选仍提示必填」的两处修复",
            "content_html": "\n---\n\ntitle: 动态表单「已勾选仍提示必填」的两处修复\ndate: 2025-09-05\ntags: \\[Vue3, Ant Design Vue, 表单校验, 组件封装]\n\n---\n\n## 问题概述\n\n复选框（`a-checkbox-group`）在 **必填** 时，即使勾选了第一项仍提示“请选择”。根因有两点：\n\n1. 你的 `Checkbox` 包装组件把 `v-model:value` **定义成了 boolean**（默认 `false`），而 `a-checkbox-group` 需要 **数组**；\n2. 通用的 `required: true` 规则对 **数组长度** 不做判断，需要为复选框补一条“至少选一项”的自定义校验。\n\n下面给出**最小修改**代码片段（仅展示需要调整的部分）。\n\n> 说明：按你的偏好，复杂逻辑的代码段我在**上一行加了注释**。\n\n---\n\n## 修改 1：`Checkbox` 组件把模型改为数组\n\n把 `defineModel<boolean>` 改为 **`defineModel<any[]>`**，默认值设为 `[]`，并确保内部状态是数组。\n\n```ts\n// 复杂：CheckboxGroup 期望数组类型；默认值必须为 []，否则 antd 校验无法判定“是否已选择”\nconst model = defineModel<any[]>(\"value\", { default: [] });\nconst innerValue = ref<any[]>(Array.isArray(model.value) ? model.value : []);\n\nwatch(model, (v) => (innerValue.value = Array.isArray(v) ? v : []));\nwatch(innerValue, (v) => (model.value = Array.isArray(v) ? v : []));\n```\n\n---\n\n## 修改 2：为复选框补充“至少选一项”的校验规则\n\n在 `getValidationRules` 中，为 `controlType === 'checkbox'` 增加自定义校验（**在你现有的特殊控件分支里添加一段即可**）。\n\n```ts\n// 复杂：CheckboxGroup 的必填校验——至少选择 1 项\n} else if (field.controlType === 'checkbox') {\n  rules.push({\n    validator: async (_: any, v: any[]) => {\n      const ok = Array.isArray(v) && v.length > 0\n      if (!ok && field.required)\n        return Promise.reject(t('files.form.rule.required', { label: field.label }))\n      return Promise.resolve()\n    },\n    trigger: ['change', 'blur'],\n  })\n```\n\n> 放置位置建议：就放在你现有的 `/* 特殊控件校验 */` 分支里，和 `stockholder / image / file` 同级。\n\n---\n\n## 可选增强：初始化把错误类型矫正为数组\n\n若后端历史数据里该字段可能是 `false/null/''/单值`，可以在你已有的 `watch(_fields, ...)` 预处理里顺手矫正为数组，避免初始值导致“已选中但校验失败”。\n\n```ts\n// 复杂：把历史/异常初始值统一矫正为 CheckboxGroup 需要的数组\n} else if (f.controlType === 'checkbox') {\n  const v = formData[f.name]\n  if (!Array.isArray(v)) formData[f.name] = v == null || v === false ? [] : [v]\n}\n```\n\n---\n\n## 结论\n\n- **关键修复**在于：复选框的 `v-model` 类型必须是 **数组**；\n- **规则层面**补充“至少一项”的自定义校验，避免通用 `required` 漏判。\n\n应用以上两处修改后，勾选第一项即可通过校验，不再提示“请选择”。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/Vue/动态表单「已勾选仍提示必填」的两处修复",
            "title": "动态表单「已勾选仍提示必填」的两处修复",
            "date_modified": "2025-09-05T16:22:47.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）",
            "content_html": "\n## 需求背景\n\n- 有的文件**公开直链**，直接点就能下；\n- 有的需要**携带 Cookie/Token、自定义 Header 或用 POST** 才能拿到二进制流；\n- 我们希望**一个函数**即可应对两类场景，并自动选择最优策略。\n\n## 设计要点\n\n- **优先直链（a.click）**：不加 header/body/credentials 时，直接跳转下载；\n- **按需请求（fetch→Blob）**：当需要鉴权/自定义 Header/POST，先拿 Blob，再用 Object URL 触发下载；\n- **文件名解析**：未显式传 `fileName` 时，尝试从 `Content-Disposition` 读取；\n- **内存友好**：使用 Object URL 并及时 `URL.revokeObjectURL`。\n\n## 代码\n\n```ts\nexport type DownloadOptions = Omit<RequestInit, \"signal\"> & {\n  fileName?: string;\n  forceRequest?: boolean;\n};\n\nfunction _pickNameFromContentDisposition(\n  cd: string | null\n): string | undefined {\n  if (!cd) return;\n  const star = cd.match(/filename\\*=(?:UTF-8'')?([^;]+)/i);\n  const norm = cd.match(/filename=([^;]+)/i);\n  const raw = (star?.[1] ?? norm?.[1])?.trim().replace(/^[\"']|[\"']$/g, \"\");\n  try {\n    return raw ? decodeURIComponent(raw) : undefined;\n  } catch {\n    return raw;\n  }\n}\n\nexport async function downloadFile(url: string, options: DownloadOptions = {}) {\n  const { fileName, forceRequest, ...req } = options;\n  const needRequest =\n    !!forceRequest ||\n    (req.method && req.method.toUpperCase() !== \"GET\") ||\n    !!req.headers ||\n    !!req.body ||\n    !!req.credentials;\n\n  if (!needRequest) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    if (fileName) a.download = fileName; // 跨域直链可能被忽略\n    a.style.display = \"none\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    return;\n  }\n\n  const res = await fetch(url, req);\n  if (!res.ok)\n    throw new Error(`Download failed: ${res.status} ${res.statusText}`);\n\n  let name =\n    fileName ??\n    _pickNameFromContentDisposition(res.headers.get(\"content-disposition\"));\n  const blob = await res.blob();\n  const href = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.style.display = \"none\";\n  a.href = href;\n  if (name) a.download = name;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(href);\n}\n```\n\n## 使用示例\n\n### 直链（公开资源）\n\n```ts\nawait downloadFile(\"https://cdn.example.com/file.pdf\", {\n  fileName: \"文档.pdf\",\n});\n```\n\n### 携带 Cookie/Token\n\n```ts\nawait downloadFile(\"/api/report/export\", {\n  credentials: \"include\",\n  headers: { Authorization: \"Bearer xxx\" },\n  fileName: \"报表.xlsx\",\n});\n```\n\n### POST 导出\n\n```ts\nawait downloadFile(\"/api/export\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\", Authorization: \"Bearer xxx\" },\n  body: JSON.stringify({ range: \"2025-01-01~2025-09-01\" }),\n  fileName: \"导出.csv\",\n});\n```\n\n## 注意事项\n\n- **跨域直链**时，浏览器可能**忽略 `download` 文件名**，以服务器或默认名为准；\n- 如需强制走请求分支，可传 `forceRequest: true`；\n- 服务器若返回 `Content-Disposition`，无需传 `fileName` 也能自动命名；\n- 大文件下载建议结合服务端分片/断点续传方案（本函数仅负责触发下载）。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）",
            "title": "一个 downloadFile 就够了：直链与鉴权下载自动切换（Vue/TS）",
            "date_modified": "2025-09-06T15:13:25.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知",
            "content_html": "\n---\n\ntitle: Web 应用如何做到“实时消息通知”\ndate: 2025-09-05\ncategories: \\[Web 实时通讯, 架构设计]\ntags: \\[WebSocket, SSE, Web Push, 长轮询, 消息队列, Redis, 可用性, 安全]\ndescription: 面向前端/全栈开发者，从选型到最小可行代码，教你在 Web 应用中实现稳定的实时消息通知。\n\n---\n\n# 总览\n\n**目标**：在浏览器里第一时间看到来自服务端的新消息（聊天、新订单、系统告警等）。\n**常见方案**：\n\n- **WebSocket**：全双工、低延迟、最通用。\n- **SSE（Server-Sent Events）**：服务端到客户端的单向推送，轻量、易用。\n- **长轮询（Long Polling）**：兼容性最佳的兜底方案。\n- **Web Push（Service Worker）**：浏览器级推送，页面不在前台也能收到（需用户同意）。\n\n**快速选型**（简表）：\n\n| 需求/约束                | 推荐                         |\n| ------------------------ | ---------------------------- |\n| 双向通信（聊天/协作）    | **WebSocket**                |\n| 只下行推送、需超轻量     | **SSE**                      |\n| 公司网络/代理限制 WS     | **SSE 或 长轮询**            |\n| 需离线/后台通知          | **Web Push**                 |\n| 海量连接、水平扩展       | **WS + Redis Pub/Sub 或 MQ** |\n| 服务端易实现、兼容老后端 | **长轮询**                   |\n\n---\n\n# 实现思路（一图流）\n\n1. **连接层**：浏览器（WS/SSE/HTTP） ↔ 反向代理（Nginx/Ingress） ↔ **推送网关服务**\n2. **消息路由层**：**Redis Pub/Sub / Kafka / RabbitMQ** 做 fan-out 与广播\n3. **业务层**：订单/聊天/告警服务把事件写入 **消息总线**\n4. **状态与可靠性**：在线用户表、订阅关系、**Ack/重试/幂等**、**断线重连**、**心跳**、**权限校验**\n\n---\n\n# 分步实践\n\n## 方案一：WebSocket（最通用）\n\n### 最小可行后端（Node.js + `ws`）\n\n```js\n// 复杂逻辑：保存连接、鉴权、心跳、按用户分组转发\nimport { WebSocketServer } from \"ws\";\nimport jwt from \"jsonwebtoken\";\n\nconst wss = new WebSocketServer({ port: 8080 });\nconst clients = new Map(); // userId -> Set<ws>\n\nwss.on(\"connection\", (ws, req) => {\n  // 复杂逻辑：从 ?token= 解析并校验用户身份\n  const token = new URL(req.url, \"http://x\").searchParams.get(\"token\");\n  let userId = null;\n  try {\n    userId = jwt.verify(token, process.env.JWT_SECRET).sub;\n  } catch {\n    ws.close();\n    return;\n  }\n\n  if (!clients.has(userId)) clients.set(userId, new Set());\n  clients.get(userId).add(ws);\n\n  // 复杂逻辑：心跳保活，清理僵尸连接\n  ws.isAlive = true;\n  ws.on(\"pong\", () => (ws.isAlive = true));\n\n  ws.on(\"message\", (buf) => {\n    // 这里可处理客户端上行，如已读回执/输入中状态\n  });\n\n  ws.on(\"close\", () => {\n    clients.get(userId).delete(ws);\n    if (clients.get(userId).size === 0) clients.delete(userId);\n  });\n});\n\n// 复杂逻辑：定时 ping\nsetInterval(() => {\n  wss.clients.forEach((ws) => {\n    if (!ws.isAlive) return ws.terminate();\n    ws.isAlive = false;\n    ws.ping();\n  });\n}, 30000);\n\n// 示例：向某用户推送\nexport function pushToUser(userId, payload) {\n  const set = clients.get(userId);\n  if (!set) return;\n  const msg = JSON.stringify(payload);\n  set.forEach((ws) => ws.readyState === ws.OPEN && ws.send(msg));\n}\n```\n\n### 前端最小连接封装（浏览器）\n\n```js\n// 复杂逻辑：自动重连、指数退避、前台/后台状态感知\nexport function createWsClient(urlWithToken, onMsg) {\n  let ws,\n    retry = 0,\n    timer;\n\n  const connect = () => {\n    ws = new WebSocket(urlWithToken);\n    ws.onopen = () => {\n      retry = 0;\n    };\n    ws.onmessage = (e) => onMsg(JSON.parse(e.data));\n    ws.onclose = () => scheduleReconnect();\n    ws.onerror = () => ws.close();\n  };\n\n  const scheduleReconnect = () => {\n    clearTimeout(timer);\n    const delay = Math.min(30000, 1000 * 2 ** retry++);\n    timer = setTimeout(connect, delay);\n  };\n\n  // 复杂逻辑：页面隐藏时减小重连频率\n  document.addEventListener(\"visibilitychange\", () => {\n    if (document.hidden && ws?.readyState !== WebSocket.OPEN) {\n      retry = Math.max(retry, 4); // 慢一些\n    }\n  });\n\n  connect();\n  return () => {\n    clearTimeout(timer);\n    ws?.close();\n  };\n}\n```\n\n### Nginx 反代（启用 WS 协议升级）\n\n```nginx\n# 复杂逻辑：确保 upgrade 头转发\nlocation /ws/ {\n  proxy_pass http://realtime:8080;\n  proxy_http_version 1.1;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_set_header Connection \"upgrade\";\n  proxy_read_timeout 60s;\n}\n```\n\n---\n\n## 方案二：SSE（Server-Sent Events，轻量下行推送）\n\n### 后端（Node.js + Express）\n\n```js\n// 复杂逻辑：SSE 连接池、心跳注释行、按用户推送\nimport express from \"express\";\nimport jwt from \"jsonwebtoken\";\n\nconst app = express();\nconst streams = new Map(); // userId -> res\n\napp.get(\"/sse\", (req, res) => {\n  const token = req.query.token;\n  let userId;\n  try {\n    userId = jwt.verify(token, process.env.JWT_SECRET).sub;\n  } catch {\n    return res.sendStatus(401);\n  }\n\n  res.set({\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache\",\n    Connection: \"keep-alive\",\n  });\n  res.flushHeaders();\n  streams.set(userId, res);\n\n  // 复杂逻辑：心跳，防止中间设备断开\n  const hb = setInterval(() => res.write(\":hb\\n\\n\"), 25000);\n\n  req.on(\"close\", () => {\n    clearInterval(hb);\n    streams.delete(userId);\n  });\n});\n\nexport function ssePush(userId, data) {\n  const res = streams.get(userId);\n  if (!res) return;\n  res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n}\n\napp.listen(8081);\n```\n\n### 前端\n\n```js\n// 复杂逻辑：SSE 自动重连由浏览器原生完成\nconst ev = new EventSource(`/sse?token=${encodeURIComponent(token)}`);\nev.onmessage = (e) => {\n  const payload = JSON.parse(e.data);\n  // 渲染消息\n};\n```\n\n**何时用 SSE**：仅需服务端 → 浏览器推送（如系统广播、价格/进度更新），无需上行交互；在某些企业代理/防火墙下比 WS 更稳定。\n\n---\n\n## 方案三：长轮询（兼容兜底）\n\n### 后端（Koa/Express 任意）\n\n```js\n// 复杂逻辑：如果没有新消息就挂起请求，直到有消息或超时\nconst waiters = new Map(); // userId -> res[]\n\napp.get(\"/poll\", (req, res) => {\n  const userId = auth(req); // 自行实现鉴权\n  (waiters.get(userId) ?? waiters.set(userId, []).get(userId)).push(res);\n  req.setTimeout(65000); // 与前端超时一致\n  req.on(\"close\", () => cleanup(userId, res));\n});\n\nfunction notify(userId, payload) {\n  const list = waiters.get(userId) || [];\n  for (const res of list) res.json(payload);\n  waiters.set(userId, []);\n}\n```\n\n### 前端\n\n```js\n// 复杂逻辑：递归调用保持“长连接”效果\nasync function longPoll() {\n  try {\n    const r = await fetch(\"/poll\", { credentials: \"include\" });\n    if (r.ok) {\n      const data = await r.json();\n      // 处理消息\n    }\n  } catch (_) {\n    /* 忽略网络错误 */\n  } finally {\n    setTimeout(longPoll, 100);\n  } // 轻微间隔\n}\nlongPoll();\n```\n\n---\n\n## 方案四：Web Push（离线/后台通知）\n\n> 适合 **提醒类** 场景：即便用户没打开页面、浏览器在后台，仍可收到通知（需 HTTPS 与用户授权）。\n\n### 前端注册 Service Worker\n\n```js\n// 复杂逻辑：注册 SW 并申请通知权限，然后向后端上报订阅\nconst reg = await navigator.serviceWorker.register(\"/sw.js\");\nconst permission = await Notification.requestPermission();\nif (permission === \"granted\") {\n  const sub = await reg.pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: \"<VAPID_PUBLIC_KEY_BASE64URL>\",\n  });\n  await fetch(\"/push/subscribe\", { method: \"POST\", body: JSON.stringify(sub) });\n}\n```\n\n### Service Worker 接收\n\n```js\n// 复杂逻辑：展示系统级通知\nself.addEventListener(\"push\", (e) => {\n  const data = e.data?.json() ?? {};\n  e.waitUntil(\n    self.registration.showNotification(data.title || \"通知\", {\n      body: data.body,\n    })\n  );\n});\n```\n\n### 后端发送（Node.js + web-push）\n\n```js\n// 复杂逻辑：使用 VAPID 签名向浏览器推送\nimport webpush from \"web-push\";\nwebpush.setVapidDetails(\n  \"mailto:admin@example.com\",\n  VAPID_PUBLIC,\n  VAPID_PRIVATE\n);\n\n// subs 为持久化的订阅列表\nexport async function sendPush(sub, payload) {\n  await webpush.sendNotification(sub, JSON.stringify(payload));\n}\n```\n\n---\n\n# 可扩展与高可用\n\n- **水平扩展**：WS/SSE 多实例时，用 **Redis Pub/Sub** 或 **消息队列（Kafka/RabbitMQ）** 做广播/定向投递。\n- **在线表/路由**：`userId -> connectionIds`（内存 + Redis）。\n- **可靠性**：业务消息落库 → 推送 → 客户端 **Ack** → 未 Ack 重试；**消息去重键** 防止重复渲染。\n- **断线重连**：客户端带 **上次 offset/lastId** 续传（SSE 原生有 `Last-Event-ID`）。\n- **背压控制**：批量合并（coalesce）、节流；超大消息用链接拉取。\n- **监控告警**：连接数、发送量、队列堆积、投递耗时、重试率、失败率。\n\n---\n\n# 安全与合规\n\n- **鉴权**：连接时附带 **短期 JWT**，服务端校验与续期；不同通道（WS/SSE/HTTP）统一鉴权层。\n- **权限**：服务端二次校验资源访问（不要把 topic 名称当权限）。\n- **限流**：IP / 用户 / 通道维度限速；异常断开与重连风暴保护。\n- **加密**：HTTPS/WSS；敏感字段服务端脱敏。\n- **审计**：关键通知落库，包含投递结果与阅读状态。\n\n---\n\n# 最简“端到端”范例清单\n\n> 你可以基于此快速拼装生产可用的实时通知：\n\n1. **连接层**：WebSocket（上面 Node + `ws` 代码）\n2. **消息总线**：Redis（`PUBLISH notifications:user:123 {...}`）\n3. **业务写入**：订单服务下单成功 → 发布事件\n4. **推送网关**：订阅 Redis 通道 → `pushToUser(userId, payload)`\n5. **前端**：`createWsClient` 接收 → 写入本地状态/弹出提醒\n6. **兜底**：前端检测 WS 不可用则回退 SSE/长轮询\n7. **离线补充**：允许用户开启 Web Push 作后台提醒\n\n---\n\n# 常见坑与排错\n\n- **公司代理挡 WS**：优先尝试 **SSE**；Nginx/Ingress 需正确配置 `Upgrade/Connection`。\n- **连接泄漏**：记得 **清理 close** 事件、设置 **心跳**。\n- **消息乱序/重复**：加入 **自增 offset / 事件时间戳 / 幂等键**。\n- **大房间广播**：用 **频道广播 + 客户端过滤** 或 **服务端分片广播**。\n- **移动网络切换**：重连后用 **lastId** 请求增量补齐。\n\n---\n\n# 结语\n\n- **单点小流量**：直接 **SSE 或 WS** 即可。\n- **中大型/海量**：**WS + Redis/MQ**，加上 **Ack/重试/幂等/监控**。\n- **提醒类**：配上 **Web Push**，覆盖离线/后台。\n\n需要我结合你现有技术栈（如 Next.js、Spring Boot、NestJS、Redis、Kafka）给出**最小改造的落地方案**和**只改动的代码片段**吗？我可以按你的项目结构直接贴可替换的文件/增量修改。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知",
            "title": "web应用开发/前端/Web 应用如何做到实时消息通知",
            "date_modified": "2025-09-05T14:10:20.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/路由/user-会不会匹配根路由-‘-’？",
            "content_html": "\n---\n\ntitle: “/user 会不会匹配根路由 ‘/’？”\ndate: 2025-09-05\ntags: \\[Vue Router 4, 路由匹配, 懒加载]\n\n---\n\n## 结论\n\n不会。`/user` **不会**匹配到你定义的根路由 `{ path: '/' }`。它只会匹配到**自己**这条顶层路由 `{ path: '/user' }`，因此也**不会**渲染 `@/views/(public)/layout.vue`。\n\n## 为什么\n\n- Vue Router 使用基于 `path-to-regexp` 的**精确匹配**。`'/'` 不是“前缀匹配一切”，只匹配根路径本身，或作为**父路由**被命中的**相对子路由**所包含。\n- 你现在把 `/user` 定义为**顶层**路由（不在 `children` 里），所以跳转到 `/user` 时，`to.matched` 里只有 `/user` 这一条记录，不会包含 `'/'` 那个布局。\n\n## 什么时候会经过 `'/'` 布局？\n\n只有当你把 **子路由写成相对路径** 时，例如：\n\n```ts\n// 复杂逻辑：相对子路由会被拼成 /user，且会渲染父布局\n{\n  path: '/',\n  component: () => import('@/views/(public)/layout.vue'),\n  children: [\n    { path: 'user', component: () => import('@/views/user/page.vue') } // 注意没有前导斜杠\n  ]\n}\n```\n\n上面这种写法才会让 `/user` 经过 `layout.vue`。而你当前是：\n\n```ts\n{ path: '/user', component: () => import('@/views/user/page.vue') } // 顶层、绝对路径\n```\n\n两者行为不同。\n\n## 快速自检（可在控制台验证）\n\n```ts\n// 复杂逻辑：查看匹配链，确认是否包含根布局\nconsole.log(router.resolve(\"/user\").matched.map((r) => r.path));\n// 期望：['/user']，而不是 ['/', '/user']\n```\n",
            "url": "https://herongdev.github.io/blog/posts/前端/路由/user-会不会匹配根路由-‘-’？",
            "title": "/user 会不会匹配根路由 ‘/’？",
            "date_modified": "2025-09-05T19:00:06.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/仍有请求与401统一处理）",
            "content_html": "\n> 只给**需要改的代码片段**；复杂逻辑我都在上一行加了**中文注释**。以下改动基于你贴的这份 `http` 封装。\n\n## 1) 请求可“集中取消”& 退出后不再飞行\n\n**位置：请求拦截器内（`_axios.interceptors.request.use`）头部插入**\n\n```ts\n// 复杂逻辑：为每个请求创建可集中取消的 AbortController，并桥接外部 signal\nconst ac = new AbortController();\nif (req.signal) {\n  const ext = req.signal as AbortSignal;\n  if (ext.aborted) ac.abort();\n  else ext.addEventListener?.(\"abort\", () => ac.abort());\n}\nreq.signal = ac.signal;\nabortPool.add(ac);\n// 复杂逻辑：把本次请求的 controller 暂存到 config 上，方便响应阶段释放\n(req as any).__ac = ac;\n```\n\n**位置：响应成功拦截器（`res` 分支）里，`return res` 之前插入**\n\n```ts\n// 复杂逻辑：请求完成后，从取消池中释放 controller\nconst ac = (res.config as any).__ac as AbortController | undefined;\nif (ac) abortPool.delete(ac);\n```\n\n**位置：响应失败拦截器（`err` 分支）里，`return Promise.reject(err)` 之前插入**\n\n```ts\n// 复杂逻辑：请求失败同样释放 controller，避免池子泄漏\nconst ac = (err?.config as any)?.__ac as AbortController | undefined;\nif (ac) abortPool.delete(ac);\n```\n\n> 这样就和你现有的 `cancelAll()` 打通了：登出时执行 `cancelAll()`，所有在途请求立刻中止。\n\n---\n\n## 2) “未登录硬拦”鉴权请求（默认需要鉴权）\n\n**位置：请求拦截器内，给你现有的加 Token 逻辑**改为如下\\*\\*\n\n```ts\n// 复杂逻辑：统一鉴权开关——默认需要鉴权，白名单或显式 { auth:false } 不需要\nconst needAuth =\n  (req as any).auth !== false && !noAuthPaths.includes(req.url || \"\");\n\n// 复杂逻辑：无 Token 且需要鉴权时，直接阻断请求，避免未登录拉数据\nconst at = storage.get(ACCESS_TOKEN);\nconst tt = storage.get(TOKEN_TYPE) || \"Bearer\";\nif (needAuth && !at) {\n  // 同时中止本次请求，确保不会真正发出\n  ((req as any).__ac as AbortController | undefined)?.abort();\n  return Promise.reject(new Error(\"UNAUTHENTICATED\"));\n}\n\n// 复杂逻辑：有 Token 再注入 Authorization 头\nif (needAuth && at) {\n  req.headers = { ...req.headers, Authorization: `${tt} ${at}` };\n}\n```\n\n> 使用方式：需要鉴权的 API **不用写任何额外配置**（默认会拦），公开 API（或登录/注册）**明确**加上 `{ auth: false }` 即可。\n\n---\n\n## 3) 统一 401 处理（去掉 `useRouter` 的非法使用）\n\n**位置：你的 `codeResponseParser` 内，将 401 分支替换为：**\n\n```ts\n// 复杂逻辑：统一未授权处理（不在解析器里用 useRouter）\nif (code === 401) {\n  storage.remove(ACCESS_TOKEN);\n  storage.remove(TOKEN_TYPE);\n  // 复杂逻辑：避免组合式 API 环境限制，使用硬跳转到登录页\n  if (window.location.pathname !== LOGIN_ROUTE.path) {\n    window.location.replace(LOGIN_ROUTE.path);\n  }\n  throw new Error(\"未授权，请重新登录\");\n}\n```\n\n**位置：响应失败拦截器（`err` 分支）里，加入 HTTP 401 fallback**\n\n```ts\n// 复杂逻辑：后端直接返回 HTTP 401 时的兜底处理\nif (err?.response?.status === 401) {\n  storage.remove(ACCESS_TOKEN);\n  storage.remove(TOKEN_TYPE);\n  if (window.location.pathname !== LOGIN_ROUTE.path) {\n    window.location.replace(LOGIN_ROUTE.path);\n  }\n}\n```\n\n> 说明：`useRouter()` 不能在解析器（组件外）调用，上面用 `window.location.replace` 做了上下文无关的重定向。\n\n---\n\n## 4) 实例方法：供登出调用（清鉴权头 & 集中取消）\n\n**位置：`createAxiosHttp` 末尾、`return _axios as unknown as AxiosInstance` 前插入**\n\n```ts\n// 复杂逻辑：向实例挂载工具方法，供外部优雅下线使用\n(_axios as any).cancelAll = cancelAll;\n(_axios as any).setAuthToken = (token?: string | null, type = \"Bearer\") => {\n  if (token) {\n    _axios.defaults.headers.common.Authorization = `${type} ${token}`;\n    storage.set(ACCESS_TOKEN, token);\n    storage.set(TOKEN_TYPE, type);\n  } else {\n    delete _axios.defaults.headers.common.Authorization;\n    storage.remove(ACCESS_TOKEN);\n    storage.remove(TOKEN_TYPE);\n  }\n};\n```\n\n> 这样在 `logout()` 里可以写：`http.cancelAll?.(); http.setAuthToken?.(null)`。\n\n---\n\n## 5) （可选）请求方法支持 `formdata` 与 `auth` 透传\n\n**位置：你重写的 `(_axios as any).request = async function ...` 的**函数签名**与**组装 `cfg`**部分替换为：**\n\n```ts\n// 复杂逻辑：扩展 contentType，支持 formdata；透传 { auth?: boolean, signal?: AbortSignal }\n(_axios as any).request = async function <T, P = RequestParams>(\n  url: string,\n  method: Method = \"GET\",\n  params?: P,\n  reqCfg?: AxiosRequestConfig & { auth?: boolean; signal?: AbortSignal },\n  contentType: \"json\" | \"urlencoded\" | \"formdata\" = \"json\"\n): Promise<T> {\n  const cfg: AxiosRequestConfig & { auth?: boolean } = {\n    url,\n    method,\n    ...reqCfg,\n    headers: { ...reqCfg?.headers },\n  };\n\n  if (method === \"GET\" || method === \"HEAD\") {\n    cfg.params = params;\n    cfg.paramsSerializer = (d) =>\n      qs.stringify(d, { indices: false, skipNulls: true });\n  } else {\n    // 复杂逻辑：根据 contentType 选择编码方式\n    if (contentType === \"formdata\") cfg.data = toFormData(params as any);\n    else if (contentType === \"urlencoded\")\n      cfg.data = toUrlencoded(params ?? ({} as any));\n    else cfg.data = params;\n\n    if (contentType === \"urlencoded\")\n      cfg.headers = {\n        ...cfg.headers,\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      };\n    if (contentType === \"json\")\n      cfg.headers = { ...cfg.headers, \"Content-Type\": \"application/json\" };\n    // formdata 让浏览器自动带 boundary，不手动设 Content-Type\n  }\n\n  return nativeRequest(cfg) as Promise<T>;\n};\n```\n\n> 有了 `{ auth?: boolean }`，你在公开接口（如 `/api/pub/get_feednews`）调用时可以：\n\n```ts\nhttp.request(\"/api/pub/get_feednews\", \"GET\", undefined, { auth: false });\n```\n\n---\n\n## 6) （配合改动）登出时的两行调用（在你的 `authStore.logout()` 里加）\n\n```ts\n// 复杂逻辑：登出时立即中止所有在途请求 + 清鉴权头\nhttp.cancelAll?.();\nhttp.setAuthToken?.(null);\n```\n\n---\n\n## 7) （可选）类型补充，便于在项目里显式写 `auth`\n\n**新建：`types/axios.d.ts`**\n\n```ts\n// 复杂逻辑：为 AxiosRequestConfig 增加自定义字段 auth\nimport \"axios\";\ndeclare module \"axios\" {\n  interface AxiosRequestConfig {\n    auth?: boolean;\n  }\n}\n```\n\n---\n\n### 验证 Checklist\n\n- 退出登录瞬间 Network 面板**无新的业务请求**（只有静态资源预取不算）。\n- 任何标记 `{ auth: true | 默认 }` 的请求在**无 Token**时不会发出。\n- 后端返回 **HTTP 401** 或 **业务码 401**，都能统一清理并跳到登录页。\n- `cancelAll()` 能把“已发起未完成”的请求**立即中断**。\n\n以上改完，你截图里“跳转后还发请求”的现象就会消失；即使有极短时序触发，也会被 **AbortController** 和 **未登录硬拦**兜住。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/仍有请求与401统一处理）",
            "title": "Axios 封装优化（登出后“仍有请求”与 401 统一处理）",
            "date_modified": "2025-09-05T20:15:05.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/登录后初始化的双阶段启动（增量修改）",
            "content_html": "\n## 思路\n\n- 把**不需要登录**的请求抽成“公共初始化（public bootstrap）”，在应用进入时就触发（只触发一次）。\n- 把**需要登录**且**命中鉴权路由**时才需要的数据，保留在你现有的 `watch` 分支里，但也确保只跑一次。\n- 用**模块级 once 标记**避免多组件重复调用；必要时可加 `online` 事件进行弱网重试（可选）。\n\n---\n\n## 需要调整的代码（仅片段）\n\n> 放在你这个 composable 文件里，**按位置插入**即可；复杂逻辑我已在上一行加中文注释。\n\n### 1）导入（在文件顶部补充）\n\n```ts\n// 复杂逻辑：公私两段初始化需要生命周期/事件\nimport { watch, onMounted } from \"vue\";\n```\n\n### 2）模块级 once 标记（在文件顶部、`export function useAppBootstrap` 外面）\n\n```ts\n// 复杂逻辑：模块级“只执行一次”标记，防止多组件重复初始化\nlet __BOOT_PUBLIC_ONCE__ = false;\nlet __BOOT_PRIVATE_ONCE__ = false;\n```\n\n### 3）在 `useAppBootstrap` 内部新增“公共初始化”方法与调用（建议贴在你定义完各个 store 之后）\n\n```ts\n// 复杂逻辑：公共初始化——无需登录的数据，进入站点即预取，且只执行一次\nconst bootstrapPublic = async () => {\n  if (__BOOT_PUBLIC_ONCE__) return;\n  __BOOT_PUBLIC_ONCE__ = true;\n\n  await Promise.all([\n    // ⬇️ 把“无需 token 的初始化”放这里；按你项目实际取舍\n    country.init().catch(() => {}),\n    exchange.init({ keyword: \"\" }).catch(() => {}),\n    marketCalendar.init().catch(() => {}),\n    // 如果 server.init() 不依赖用户态，也可放到公共初始化\n    server.init().catch(() => {}),\n    // …你还有其它完全公开的数据，也可加进来\n  ]);\n};\n```\n\n```ts\n// 复杂逻辑：进入应用即触发公共初始化（SSR/CSR 兼容性考虑，放到 onMounted 最稳妥）\nonMounted(() => {\n  bootstrapPublic();\n});\n```\n\n### 4）给你原来的 `watch` 回调加“私有初始化只跑一次”的保护\n\n```ts\n// 复杂逻辑：仅在“已登录 && 路由需要鉴权 && 未跑过私有初始化”时执行\nif (ok && need && !__BOOT_PRIVATE_ONCE__) {\n  __BOOT_PRIVATE_ONCE__ = true;\n  await Promise.all([\n    user.fetchUserInfo().catch(() => {}),\n    account.init({ withCategory: true, withExternal: true }).catch(() => {}),\n    leverage.init().catch(() => {}),\n    accountCurrency.init().catch(() => {}),\n    externalServer.init().catch(() => {}),\n    payChannel.init({ opt_type: \"deposit\" }).catch(() => {}),\n    verifyStore.initVerifyInfo().catch(() => {}),\n    inviteStore.getInviteGroupOptions().catch(() => {}),\n    // ⚠️ server.init()/country/exchange/marketCalendar 已在公共初始化里跑过的可移除，避免重复\n  ]);\n}\n```\n\n---\n\n## 可选增强\n\n### A. 弱网场景“上线即补跑”\n\n```ts\n// 复杂逻辑：若用户初次进入时离线，恢复网络后自动补跑公共初始化（最多触发一次）\nonMounted(() => {\n  const handler = () => {\n    bootstrapPublic();\n  };\n  window.addEventListener(\"online\", handler, { once: true });\n});\n```\n\n### B. Store 级幂等（示例片段，放到各自的 Pinia store 里）\n\n```ts\n// 复杂逻辑：在每个 init() 入口加幂等保护，彻底避免重复请求\nif ((this as any)._inited) return;\n(this as any)._inited = true;\n```\n\n---\n\n## 小结\n\n- 公共数据：`onMounted` 里 **立刻预取一次**，全站可复用。\n- 私有数据：沿用你的 `watch`，但加一次性保护，避免路由/状态抖动造成的重复请求。\n- 若存在弱网：监听 `online` 事件，**一次性**补跑公共初始化即可。\n\n---\n\ntitle: useAppBootstrap 放在哪？给你一份可直接复制的完整文件（含用法）\ndate: 2025-09-06\ntags:\n\n- Vue3\n- Vite\n- Pinia\n- composable\n  categories:\n- 前端工程化\n\n---\n\n## 位置推荐\n\n把文件放到：\n\n```\nsrc/composables/useAppBootstrap.ts\n```\n\n理由：可复用的启动逻辑属于“组合式函数（composable）”，与业务无关的初始化也方便在这里统一管理。\n\n---\n\n## 完整代码（可直接替换 `src/composables/useAppBootstrap.ts`）\n\n```ts\n// src/composables/useAppBootstrap.ts\nimport { onMounted, watch } from \"vue\";\nimport { useRouter } from \"vue-router\";\nimport {\n  useAuthStore,\n  useUserStore,\n  useAccountStore,\n  useServerStore,\n  useLeverageStore,\n  useAccountCurrencyStore,\n  useCountryStore,\n  useExchangeStore,\n  useExternalServerStore,\n  useMarketCalendarStore,\n  usePayChannelStore,\n} from \"@/store\";\nimport { useVerifyStore } from \"@/store/verify\";\nimport { useInviteStore } from \"@/store/invite\";\n\n// 复杂逻辑：模块级“只执行一次”标记，避免多组件/多次进入页面重复请求\nlet __BOOT_PUBLIC_ONCE__ = false;\nlet __BOOT_PRIVATE_ONCE__ = false;\n\nexport function useAppBootstrap() {\n  const router = useRouter();\n  const auth = useAuthStore();\n  const user = useUserStore();\n  const account = useAccountStore();\n  const server = useServerStore();\n  const leverage = useLeverageStore();\n  const accountCurrency = useAccountCurrencyStore();\n  const country = useCountryStore();\n  const exchange = useExchangeStore();\n  const externalServer = useExternalServerStore();\n  const marketCalendar = useMarketCalendarStore();\n  const payChannel = usePayChannelStore();\n  const verifyStore = useVerifyStore();\n  const inviteStore = useInviteStore();\n\n  // 复杂逻辑：公共初始化——无需登录可获取的数据，进入站点即预取，且只执行一次\n  const bootstrapPublic = async () => {\n    if (__BOOT_PUBLIC_ONCE__) return;\n    __BOOT_PUBLIC_ONCE__ = true;\n\n    await Promise.all([\n      // ⬇️ 放“无需 token”的初始化\n      country.init().catch(() => {}),\n      exchange.init({ keyword: \"\" }).catch(() => {}),\n      marketCalendar.init().catch(() => {}),\n      server.init().catch(() => {}),\n      // 如有其它公开数据，也可加在这里\n    ]);\n  };\n\n  // 复杂逻辑：进入应用即触发公共初始化；若首次访问时离线，恢复网络后补跑一次（仅一次）\n  onMounted(() => {\n    bootstrapPublic();\n    const handler = () => {\n      bootstrapPublic();\n    };\n    window.addEventListener(\"online\", handler, { once: true });\n  });\n\n  // 复杂逻辑：仅在“已登录 && 目标路由需要鉴权 && 未跑过私有初始化”时执行一次性私有初始化\n  watch(\n    [\n      () => auth.isAuthenticated,\n      () => router.currentRoute.value.meta?.requiresAuth,\n    ],\n    async ([ok, need]) => {\n      if (ok && need && !__BOOT_PRIVATE_ONCE__) {\n        __BOOT_PRIVATE_ONCE__ = true;\n\n        await Promise.all([\n          user.fetchUserInfo().catch(() => {}),\n          account\n            .init({ withCategory: true, withExternal: true })\n            .catch(() => {}),\n          leverage.init().catch(() => {}),\n          accountCurrency.init().catch(() => {}),\n          externalServer.init().catch(() => {}),\n          payChannel.init({ opt_type: \"deposit\" }).catch(() => {}),\n          verifyStore.initVerifyInfo().catch(() => {}),\n          inviteStore.getInviteGroupOptions().catch(() => {}),\n          // ⚠️ 已在公共初始化中完成的 server/country/exchange/marketCalendar 无需重复\n        ]);\n      }\n    },\n    { immediate: true }\n  );\n}\n\n// （可选）测试/登出时重置标记\nexport function __resetBootstrapFlagsForTestOnly() {\n  __BOOT_PUBLIC_ONCE__ = false;\n  __BOOT_PRIVATE_ONCE__ = false;\n}\n```\n\n---\n\n## 如何使用（最小改动）\n\n> 你**不需要**在每个页面手动调用，只需在 **App.vue** 顶层调用一次即可。\n\n在 `src/App.vue` 的 `<script setup>` 里加入一行（**增量修改**）：\n\n```ts\n// 复杂逻辑：顶层调用一次，注册 watch + onMounted，即可全局生效\nimport { useAppBootstrap } from \"@/composables/useAppBootstrap\";\nuseAppBootstrap();\n```\n\n> 如果你的项目还没在 `main.ts` 里安装 Pinia/Router，请确认已安装（一般你已经有了）：\n\n```ts\n// 仅供核对：main.ts 应该已包含这些\n// import { createApp } from 'vue'\n// import { createPinia } from 'pinia'\n// import router from './router'\n// import App from './App.vue'\n// createApp(App).use(createPinia()).use(router).mount('#app')\n```\n\n---\n\n## 小结\n\n- 文件放在：`src/composables/useAppBootstrap.ts`。\n- 在 `App.vue` 顶层调用一次 `useAppBootstrap()` 即全局生效。\n- 公共初始化：站点进入即跑；私有初始化：登录且命中鉴权路由时只跑一次。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/登录后初始化的双阶段启动（增量修改）",
            "title": "在 composable 里“公共初始化 + 登录后初始化”的双阶段启动（增量修改）",
            "date_modified": "2025-09-06T18:30:01.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录后跳转与请求是否会发出",
            "content_html": "\n---\n\ntitle: 退出登录后跳转与请求是否会发出？（Vue Router 4 实战）\ndate: 2025-09-05\ntags: \\[Vue, Vue Router, Pinia, Axios, 登录, 退出]\n\n---\n\n## TL;DR（先给结论）\n\n- `router.push('/user')` **不会**去加载 `@/views/(public)/layout.vue`；`/user` 是独立的**公开路由**，全局前置守卫会**先**跑，再决定是否进入目标路由，受保护布局组件不会被解析/执行。\n- 真正会“误发请求”的常见来源是：① 旧页中**已发起但未取消**的请求；② `<keep-alive>` 相关的激活/停用副作用；③ 你在 HTTP 层没有对“无 Token 的鉴权请求”做**硬性拦截**。\n- 给你三道保险：**彻底清 Token + 取消未决请求 + 请求层强拦**（可选再加根路由 `beforeEnter`）。\n\n---\n\n## 最小修改（仅给需要改的代码片段）\n\n> 说明：按你的偏好，只给**需修改**片段；复杂逻辑在上一行加注释。\n\n### 1) `auth` Store：退出时同时清理本地存储 Token、取消所有请求、清默认头\n\n**文件：** `useAuthStore` 所在文件\n\n```ts\n// 新增导入\nimport storage from \"store\";\nimport { STORAGE_KEYS } from \"@/constants\";\nconst { ACCESS_TOKEN } = STORAGE_KEYS;\n```\n\n```ts\n// 新增：统一清空本地 Token（Pinia + 本地存储）\nfunction clearToken() {\n  // 复杂逻辑：双通道清理，避免路由守卫误判已登录\n  token.value = null;\n  refresh.value = null;\n  storage.remove(ACCESS_TOKEN);\n}\n```\n\n```ts\n// 调整 logout 函数（仅贴需要增加的片段）\nasync function logout() {\n  try {\n    await http.post(\"/api/pub/loginOut\").catch(() => {});\n    // 复杂逻辑：优雅下线——取消所有还在飞行中的请求，防止“未登录也发请求”\n    http.cancelAll?.();\n    // 复杂逻辑：清掉默认鉴权头，防止后续请求夹带旧 Token\n    http.setAuthToken?.(null);\n\n    clearToken();\n    resetAllStores();\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n```\n\n> 你现在的调用 `await authStore.logout(); router.push('/user')` 没问题；若不想留下历史记录，可换成：\n\n```ts\n// 可选：避免回退到已登录页\nawait router.replace({ name: \"user\" });\n```\n\n---\n\n### 2) `http` 工具：加“全局取消池 + 无 Token 时硬拦需要鉴权的请求”\n\n**文件：** 你的 `@/utils/http`（或创建一个轻量封装）\n\n```ts\n// 新增：全局取消池\nconst abortPool = new Set<AbortController>();\n\nexport function cancelAll() {\n  // 复杂逻辑：退出登录时集中取消所有未决请求\n  abortPool.forEach((c) => c.abort());\n  abortPool.clear();\n}\n\nexport function setAuthToken(token?: string | null) {\n  // 复杂逻辑：动态设置/清除默认鉴权头\n  if (token) {\n    axios.defaults.headers.common.Authorization = `Bearer ${token}`;\n  } else {\n    delete axios.defaults.headers.common.Authorization;\n  }\n}\n```\n\n```ts\n// 在请求拦截里增加以下片段（保留你已有逻辑）\nhttp.interceptors.request.use((config) => {\n  // 复杂逻辑：为每个请求绑定 AbortController，纳入全局取消池\n  const ac = new AbortController();\n  (config as any).signal = ac.signal;\n  abortPool.add(ac);\n\n  // 复杂逻辑：对标记了 { auth: true } 的请求做硬性校验，无 Token 直接终止\n  const needAuth = (config as any).auth === true;\n  const token = storage.get(ACCESS_TOKEN);\n  if (needAuth && !token) {\n    ac.abort();\n    // 用标准错误中断；也可自定义错误码\n    throw new axios.Cancel(\"UNAUTHENTICATED\");\n  }\n  return config;\n});\n```\n\n```ts\n// 在响应/错误拦截里释放对应的 controller（保持池干净）\nconst detach = (cfg?: any) => {\n  if (!cfg?.signal) return;\n  for (const ac of abortPool) {\n    if (cfg.signal === ac.signal) {\n      abortPool.delete(ac);\n      break;\n    }\n  }\n};\nhttp.interceptors.response.use(\n  (resp) => {\n    detach(resp.config);\n    return resp;\n  },\n  (err) => {\n    detach(err?.config);\n    return Promise.reject(err);\n  }\n);\n```\n\n> 使用方式：**凡是需要登录才能访问的接口**，在调用时带上 `{ auth: true }`：\n\n```ts\n// 复杂逻辑：打上鉴权标记，无 Token 时在请求层被硬拦\nhttp.get(\"/api/secure/profile\", { auth: true });\n```\n\n---\n\n### 3) 根布局路由（可选加固）：未登录禁止进入，阻止懒加载 `layout.vue`\n\n> 这是“冗余但稳”的**第四道锁**：即使有人误配了守卫，根布局也进不去。\n\n**文件：** 路由表所在文件\n\n```ts\n// 新增导入（如果本文件里还没有）\nimport storage from \"store\";\nimport { STORAGE_KEYS } from \"@/constants\";\nimport { LOGIN_ROUTE } from \"./constants\";\nconst { ACCESS_TOKEN } = STORAGE_KEYS;\n```\n\n```ts\n// 在 path: '/' 那个根路由对象上新增 beforeEnter（只贴新增的属性）\nbeforeEnter: (to, from, next) => {\n  // 复杂逻辑：未登录直接拒绝进入受保护根布局，避免解析/执行 layout.vue\n  const token = storage.get(ACCESS_TOKEN)\n  if (!token) return next({ name: LOGIN_ROUTE.name, replace: true })\n  next()\n},\n```\n\n---\n\n## 为什么你会怀疑 `layout.vue` 被加载？\n\n常见场景有三种（任选对号入座）：\n\n1. **旧页未决请求**：你还在“受保护页面”时就发出了请求，`push('/user')` 后这些请求仍会完成，除非你**主动取消**（上面第 2 步已解决）。\n2. **`<keep-alive>` 激活/停用副作用**：离开/进入时有数据拉取，需要在未登录时短路。\n3. **预加载 Chunk**：如果手动开启过 `webpackPrefetch` 等，会看到静态资源拉取，但这不等同于“业务请求”发出。\n\n---\n\n## 排查清单（按优先级）\n\n1. 退出后 `localStorage`/`store` 里是否还残留 `ACCESS_TOKEN`？（第 1 步已处理）\n2. 所有**需要登录**的接口是否统一加了 `{ auth: true }` 并被请求拦截器“硬拦”？（第 2 步）\n3. 页面里有没有在 `onMounted` **直接拉数据**但无 Token 校验的逻辑？（在组件中加早返回）\n4. 是否使用了 `<keep-alive>` 并在 `activated`/`deactivated` 发请求？（同样做登录短路）\n5. 仍担心懒加载？给根布局加 `beforeEnter`（第 3 步“加固锁”）。\n\n---\n\n## 你最关心的那句直白话\n\n- **不会**：`router.push('/user')` 不会去跑 `@/views/(public)/layout.vue` 里的业务请求。\n- **会**：如果**旧页**的请求已经发出且你没有取消，它们**会继续完成**。上面给的三段修改能把这类“该停的请求”全部截住。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录后跳转与请求是否会发出",
            "title": "退出登录后跳转与请求是否会发出",
            "date_modified": "2025-09-05T18:55:38.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录要不要-resetAllStores",
            "content_html": "\n## 结论\n\n- **应该保留 `resetAllStores()`**（避免残留用户数据/权限态），但**直接在登出时先重置**会触发一堆 `watchEffect` / `watch` 的依赖变化，从而在组件卸载前**又发出请求**。\n- 正确做法：**先撤鉴权与在途请求 → 跳公开页卸载组件 → 最后再 `resetAllStores()`**；同时在页面副作用里用 `isAuthenticated`/`isLoggingOut` 做**登录短路**。\n\n## 推荐顺序（一眼抄）\n\n1. **标记登出中**（`isLoggingOut = true`）\n2. **取消所有在途请求**（`http.cancelAll()`）\n3. **清鉴权**（`http.setAuthToken(null)` + 清本地 `ACCESS_TOKEN/TOKEN_TYPE` + 清内存 `token`）\n4. **跳到公开路由**（`router.replace('/user')`）\n5. **最后** `resetAllStores()`\n6. **清掉登出标记**（`isLoggingOut = false`）\n\n## 仅需修改的代码片段\n\n### A) `auth` Store：按顺序登出（在 store 内部做跳转，保证顺序）\n\n```ts\n// 新增\nimport { useRouter } from \"vue-router\";\n\n// 新增\nconst isLoggingOut = ref(false);\n```\n\n```ts\n// 调整 logout（顺序：撤鉴权→跳公开页→reset）\nasync function logout() {\n  const router = useRouter();\n  try {\n    isLoggingOut.value = true;\n    await http.post(\"/api/pub/loginOut\").catch(() => {});\n\n    // 复杂逻辑：统一掐断飞行中的请求，避免“卸载前再打一次”\n    http.cancelAll?.();\n\n    // 复杂逻辑：清鉴权（默认头 + 本地存储 + 内存）\n    http.setAuthToken?.(null);\n    storage.remove(ACCESS_TOKEN);\n    storage.remove(TOKEN_TYPE);\n    token.value = null;\n    refresh.value = null;\n\n    // 复杂逻辑：先跳到公开页，卸载受保护组件，阻断其副作用\n    await router.replace({ name: \"user\" });\n\n    // 复杂逻辑：组件已卸载，再重置所有 store，安全不抖动\n    resetAllStores();\n  } catch (error) {\n    console.error(error);\n    throw error;\n  } finally {\n    isLoggingOut.value = false;\n  }\n}\n```\n\n> 这样**无需**在组件里再 `router.push('/user')`；如果你保留组件层跳转，记得删除那一行以免重复。\n\n---\n\n### B) 页面副作用：加“登录短路”（防抖再保险）\n\n> 示例：你在 `public/dashboard` 页和分析卡片里原来用 `watchEffect` 拉数据。\n\n```ts\n// 复杂逻辑：登出过程/未登录时直接短路，不发请求\nimport { useAuthStore } from '@/plugins'\nimport { storeToRefs } from 'pinia'\nconst { isAuthenticated, isLoggingOut } = storeToRefs(useAuthStore())\n\nwatch(/* 精确依赖或 isAuthenticated */ , () => {\n  if (!isAuthenticated.value) return\n  if (isLoggingOut?.value) return\n  // 这里再发请求\n}, { immediate: true })\n```\n\n> 说明：**副作用短路 + A 部分的顺序**，两层兜底，基本杜绝“退出时还在请求”。\n\n---\n\n## 什么时候可以“不 resetAllStores”？\n\n- 仅在**演示/临时**场景；正式项目**不建议**。不重置会遗留：上一个用户的**列表数据、选择态、分页、缓存**等，存在隐私与越权风险。\n\n---\n\n## 小结\n\n- **不是不要 `resetAllStores()`，而是要把它放在最后**，并在副作用处加“登录短路”。\n- 真正能解决“跳转后还在请求”的，是**顺序**（撤鉴权 → 跳公开页 → 重置）+ **取消在途** + **副作用短路**。\n",
            "url": "https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录要不要-resetAllStores",
            "title": "退出登录要不要 resetAllStores",
            "date_modified": "2025-09-05T20:45:33.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/后端/NestJS/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）",
            "content_html": "\n---\n\ntitle: 在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）\ndate: 2025-09-07\ntags:\n\n- NestJS\n- Redis\n- ioredis\n- 教程\n  categories:\n- 后端\n  description: 手把手带你在 NestJS 中集成 Redis（基于 ioredis），涵盖安装、配置、Provider、全局模块封装、业务实践（限流/一次性令牌）、Docker、本地调试与常见报错排查。\n\n---\n\n# 目标与适用读者\n\n- 目标：在 **NestJS** 项目中稳定接入 **Redis**，通过 **ioredis** 驱动，提供可复用的 `RedisService`（封装 `set/get/del/incr/expire`、NX 写入等），并支持 **全局模块**、**环境配置**、**本地/生产** 两套部署。\n- 适用：会基本 NestJS 模块/依赖注入的同学；数据库用 TypeORM/Prisma 均可（与本教程无冲突）。\n\n---\n\n# 技术栈选型\n\n- Redis 客户端：**ioredis**（成熟、支持集群/哨兵、TypeScript 友好）。\n- Nest 集成方式：自定义 **Provider + 全局模块**，暴露 `REDIS_CLIENT` 与 `RedisService`。\n- 配置：`.env` 中支持 `REDIS_URL` 或 `REDIS_HOST/PORT/PASSWORD/DB`。\n\n---\n\n# 目录结构（建议）\n\n```\nsrc/\n  common/\n    redis/\n      redis.module.ts       # 全局模块（@Global）\n      redis.service.ts      # 业务友好封装（依赖 REDIS_CLIENT）\n  app.module.ts             # 或各业务模块，引入 RedisModule 一次即可\n```\n\n---\n\n# 第一步：安装依赖\n\n```bash\n# 使用 pnpm（推荐）\npnpm add ioredis\n# 或者 npm\n# npm i ioredis\n```\n\n---\n\n# 第二步：准备环境变量\n\n建议在 `.env`（或 `.env.dev`）中添加 **二选一**：\n\n```ini\n# 方式 A：URL 一行式（含密码与 DB 索引，推荐）\nREDIS_URL=redis://:password@localhost:6379/0\n\n# 方式 B：分散式\nREDIS_HOST=127.0.0.1\nREDIS_PORT=6379\nREDIS_PASSWORD=\nREDIS_DB=0\n```\n\n---\n\n# 第三步：编写 `RedisService`\n\n> 放在 `src/common/redis/redis.service.ts`\n> 命名**清晰可读**，复杂逻辑上方有中文注释。\n\n```ts\nimport { Injectable, Inject } from \"@nestjs/common\";\nimport type { Redis } from \"ioredis\";\n\n// 复杂：作为底层连接的注入令牌；项目全局唯一\nexport const REDIS_CLIENT = \"REDIS_CLIENT\";\n\n@Injectable()\nexport class RedisService {\n  constructor(@Inject(REDIS_CLIENT) private readonly redisClient: Redis) {}\n\n  // 复杂：统一封装写入并设置过期时间，便于存挑战/一次性令牌\n  async setWithTimeToLive(\n    key: string,\n    value: string,\n    timeToLiveSeconds = 300\n  ): Promise<void> {\n    await this.redisClient.set(key, value, \"EX\", timeToLiveSeconds);\n  }\n\n  async getValue(key: string): Promise<string | null> {\n    return this.redisClient.get(key);\n  }\n\n  async deleteKey(key: string): Promise<void> {\n    await this.redisClient.del(key);\n  }\n\n  // 复杂：自增计数用于限流（第一次返回 1）\n  async incrementKey(key: string): Promise<number> {\n    return this.redisClient.incr(key);\n  }\n\n  // 复杂：给键设置过期时间，配合 incrementKey 实现简单窗口限流\n  async expireKey(key: string, seconds: number): Promise<void> {\n    await this.redisClient.expire(key, seconds);\n  }\n\n  // 复杂：仅当键不存在时写入并设置 TTL（一次性令牌/幂等防重放）\n  async setIfAbsentWithTimeToLive(\n    key: string,\n    value: string,\n    timeToLiveSeconds: number\n  ): Promise<boolean> {\n    // 复杂：NX 确保不存在才写入；避免并发下的重复写入\n    const result = await this.redisClient.set(\n      key,\n      value,\n      \"NX\",\n      \"EX\",\n      timeToLiveSeconds\n    );\n    return result === \"OK\";\n  }\n}\n```\n\n---\n\n# 第四步：编写 `RedisModule`（全局模块，一次引入处处可用）\n\n> 放在 `src/common/redis/redis.module.ts`，标记 `@Global()`，自动对全局开放。\n\n```ts\nimport { Global, Module } from \"@nestjs/common\";\nimport * as IORedis from \"ioredis\";\nimport { RedisService, REDIS_CLIENT } from \"./redis.service\";\n\n@Global()\n@Module({\n  providers: [\n    {\n      provide: REDIS_CLIENT,\n      // 复杂：通过工厂读取 .env，创建 ioredis 客户端\n      useFactory: () => {\n        const url = process.env.REDIS_URL;\n        const host = process.env.REDIS_HOST ?? \"127.0.0.1\";\n        const port = parseInt(process.env.REDIS_PORT ?? \"6379\", 10);\n        const password = process.env.REDIS_PASSWORD || undefined;\n        const db = parseInt(process.env.REDIS_DB ?? \"0\", 10);\n\n        const client: IORedis.Redis = url\n          ? new (IORedis as any)(url)\n          : new (IORedis as any)({ host, port, password, db });\n\n        // 复杂：记录连接错误，便于排查\n        client.on(\"error\", (err: any) => {\n          // eslint-disable-next-line no-console\n          console.error(\"[Redis] connection error:\", err?.message || err);\n        });\n\n        return client;\n      },\n    },\n    RedisService,\n  ],\n  exports: [REDIS_CLIENT, RedisService],\n})\nexport class RedisModule {}\n```\n\n---\n\n# 第五步：在应用中引入 `RedisModule`\n\n> 只需在**任意一个模块**引入一次（例如 `AppModule`），因为它是 `@Global()`。\n\n```ts\n// src/app.module.ts（或你任一根模块）\nimport { Module } from \"@nestjs/common\";\nimport { ConfigModule } from \"@nestjs/config\";\nimport { RedisModule } from \"./common/redis/redis.module\";\nimport { AppController } from \"./app.controller\";\nimport { AppService } from \"./app.service\";\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    RedisModule, // 复杂：全局模块，仅需引入一次\n    // ... 你的其它模块\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n---\n\n# 第六步：业务中使用示例\n\n### 6.1 限流（每分钟最多 10 次）\n\n```ts\nimport { Injectable, TooManyRequestsException } from \"@nestjs/common\";\nimport { RedisService } from \"src/common/redis/redis.service\";\n\n@Injectable()\nexport class LoginService {\n  constructor(private readonly redisService: RedisService) {}\n\n  // 复杂：按 IP 做 60 秒/10 次 限流\n  async limitByIp(ipAddress: string) {\n    const rateLimitKey = `rl:login:${ipAddress}`;\n    const currentCount = await this.redisService.incrementKey(rateLimitKey);\n    if (currentCount === 1) {\n      await this.redisService.expireKey(rateLimitKey, 60);\n    }\n    if (currentCount > 10) {\n      throw new TooManyRequestsException(\"请求过于频繁，请稍后再试\");\n    }\n  }\n}\n```\n\n### 6.2 一次性令牌（幂等/防重放）\n\n```ts\n// 复杂：仅当 key 不存在时写入，5 分钟有效\nconst ok = await this.redisService.setIfAbsentWithTimeToLive(\n  `once:${token}`,\n  \"1\",\n  300\n);\nif (!ok) {\n  throw new Error(\"令牌已使用或失效\");\n}\n```\n\n### 6.3 短期会话/挑战值（例如 WebAuthn）\n\n```ts\nawait this.redisService.setWithTimeToLive(\n  `webauthn:register:${userId}`,\n  challengeBase64Url,\n  300\n);\nconst cached = await this.redisService.getValue(`webauthn:register:${userId}`);\n// ... 验证后删除\nawait this.redisService.deleteKey(`webauthn:register:${userId}`);\n```\n\n---\n\n# 第七步：Docker Compose（本地起 Redis）\n\n> `docker-compose.yml`（项目根目录）\n\n```yaml\nversion: \"3.9\"\nservices:\n  redis:\n    image: redis:7-alpine\n    container_name: demo-redis\n    ports:\n      - \"6379:6379\"\n    command: [\"redis-server\", \"--appendonly\", \"yes\"]\n    volumes:\n      - redis-data:/data\nvolumes:\n  redis-data:\n```\n\n启动：\n\n```bash\ndocker compose up -d\n# .env 示例\n# REDIS_URL=redis://localhost:6379\n```\n\n---\n\n# 第八步：生产环境注意事项\n\n- **连接池与超时**：ioredis 默认复用单连接；高并发可根据需要创建多个客户端或使用 `cluster`/`sentinel`。\n- **密码与 ACL**：生产务必启用密码或 ACL；不要暴露无鉴权实例。\n- **键名规范**：`<领域>:<用途>:<实体>`（如 `webauthn:auth:ch:<challenge>`），可读性与清理都更好。\n- **TTL 策略**：短期挑战/令牌务必设置 TTL，并在验证后删除，避免重放。\n- **监控**：监控 `connected clients`、`keyspace hits/misses`、`latency`；必要时加慢日志。\n- **持久化**：默认 RDB；根据业务考虑 AOF（`appendonly yes`）与混合持久化。\n\n---\n\n# 第九步：常见报错与排查\n\n- **Nest can't resolve dependencies of the RedisService (REDIS_CLIENT)**\n  说明：未注册 `REDIS_CLIENT` Provider。\n  解决：确保 `RedisModule`（或 `AppModule` 的 `providers`）里 **provide: REDIS_CLIENT** 已配置，并且模块被应用引入。\n- **ECONNREFUSED / getaddrinfo ENOTFOUND**\n  说明：Redis 未启动或地址错误。\n  解决：检查 `REDIS_URL/REDIS_HOST/REDIS_PORT`，本地起容器或服务端口是否 6379。\n- **WRONGPASS invalid username-password pair**\n  说明：密码有误或未配置。\n  解决：核对 `REDIS_URL` 中 `:password@` 或 `REDIS_PASSWORD`。\n- **Ready check failed**\n  说明：网络/权限/ACL 问题或连接尚未可用。\n  解决：检查安全组/防火墙；对云服务需配置白名单。\n\n---\n\n# 第十步：单元测试（Mock Redis）\n\n> 不在测试中连真实 Redis，可用 `ioredis-mock` 或手写假对象。\n\n```ts\nimport { Test } from \"@nestjs/testing\";\nimport { RedisService, REDIS_CLIENT } from \"src/common/redis/redis.service\";\n\ndescribe(\"RedisService\", () => {\n  it(\"set/get works\", async () => {\n    // 复杂：用最小可用的假客户端满足接口\n    const fakeClient = {\n      storage: new Map<string, string>(),\n      set: function (k: string, v: string) {\n        this.storage.set(k, v);\n        return Promise.resolve(\"OK\");\n      },\n      get: function (k: string) {\n        return Promise.resolve(this.storage.get(k) ?? null);\n      },\n      del: function (k: string) {\n        this.storage.delete(k);\n        return Promise.resolve();\n      },\n      incr: function (k: string) {\n        const next = Number(this.storage.get(k) ?? \"0\") + 1;\n        this.storage.set(k, String(next));\n        return Promise.resolve(next);\n      },\n      expire: function () {\n        return Promise.resolve();\n      },\n    } as any;\n\n    const moduleRef = await Test.createTestingModule({\n      providers: [\n        { provide: REDIS_CLIENT, useValue: fakeClient },\n        RedisService,\n      ],\n    }).compile();\n\n    const redis = moduleRef.get(RedisService);\n    await redis.setWithTimeToLive(\"foo\", \"bar\", 60);\n    expect(await redis.getValue(\"foo\")).toBe(\"bar\");\n  });\n});\n```\n\n---\n\n# 结语\n\n至此，你已经完成了 **NestJS × Redis（ioredis）** 的完整接入：\n\n- 全局模块提供底层连接与服务封装；\n- 业务中可轻松完成 **限流**、**一次性令牌**、**短期会话/挑战** 等高频需求；\n- 本地用 Docker 起 Redis，生产注意密码、ACL、监控与 TTL 策略。\n\n需要我把你的现有项目改造为 **全局 `RedisModule` 方案** 或 **在 `AppModule` 直接注册 Provider** 的最小改动 **完整文件**，就把相关文件发我（或让我复用你上面的 `AppModule` 路径）。\n",
            "url": "https://herongdev.github.io/blog/posts/后端/NestJS/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）",
            "title": "在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）",
            "date_modified": "2025-09-07T20:40:23.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图",
            "content_html": "\n## 结论\n\n- “系统课程＋博客”在 AI 时代更有价值：AI 能补局部知识，但难给“由浅入深的体系、场景权衡、复盘与职业路径”。\n- 差异化关键：工程落地（SOP/Checklist/MRE/观测与度量）、权衡（Trade-off）、真实复盘与团队协作。\n- 难度与风险：持续产出、版权合规、转化与交付。以“可验证的工程实践”做护城河，值得做。\n\n## 为什么在 AI 时代更有价值\n\n- AI 的短板：上下文有限、缺乏全局体系与演进路线、对 Why/Trade-off 薄弱、难处理非完备信息。\n- 课程的角色：给“脉络与标准动作”；学员用 AI 追问局部细节，构成最优组合。\n\n## 传统培训的空白\n\n- 多停留“API/八股/题库”，少谈生产问题、平台化工程、合规/安全、观测与性能、协作与落地。\n- 实战同质化，缺真实业务约束与指标验证，缺事故复盘与上线闭环。\n\n## 差异化定位与设计\n\n- 工程落地：每模块配 SOP ＋ Checklist ＋最小可复现（MRE）＋观测/指标模板。\n- 权衡为骨架：何时做/不做，代价/收益，灰度/回滚方案，失败复盘。\n- 专题系列：生产问题定位、性能与分布式、数据治理与一致性、安全与合规、团队协作与流程。\n- 作品集导向：设计题 → 实现 → 观测/基准 → 复盘，形成可投递 Portfolio。\n\n## 课程结构（由浅入深）\n\n- Level 0：能力地图（路线图/评估表）\n- Level 1：基础与最佳实践（现代前端/工程化基础，快速过）\n- Level 2：体系工程（构建/测试/发布/观测/安全/合规）\n- Level 3：生产问题与权衡（性能、网络、数据一致性、幂等、限流、熔断、回滚）\n- Level 4：平台与协作（多仓/MonoRepo、规范化、流水线、指标治理）\n- Capstone：端到端项目（灰度、回滚、SLO、事故演练与复盘）\n\n## 与“国外系统课程＋ AI”的结合\n\n- 参考框架与案例，必须本地化：国内云/合规、常用栈、网络/CDN/容器差异。\n- AI 作“内容助理”而非“策展人”：生成素材/雏形/题库；你把关正确性、权衡、边界与度量。\n- 明确来源与改编，避免版权风险。\n\n## 难度与风险\n\n- 产出节奏：先做一个金刚区（如“生产问题复盘”）打爆款，再扩张。\n- 版权与合规：授权/引用规范；示例代码素材需可再发布。\n- 转化与交付：从免费内容 → 专题导读 → 训练营 → 口碑。\n- 期望管理：明确承诺边界，不做虚假“保就业”。\n\n## 商业模式\n\n- 免费区：系统博文、复盘、Checklist、Demo（SEO 与信任）\n- 付费区：训练营/系统课（作业批改、走查、复盘、1v1）\n- 长尾：模板包/脚手架/工作坊\n- 定价：首期开营“半价＋强交付”，用成功案例突破冷启动\n\n## 度量与证明\n\n- 前/后测、作业通过率、问题解决周期、事故率/SLO 改善、作品集与面试反馈、NPS 与转介绍\n\n## 最小可行路径（3 步）\n\n1. 选一个差异化专题（建议“生产问题复盘”），产出系列博文＋模板包＋公开课；\n2. 升级为 4 ～ 6 周试点班：每周作业＋代码走查＋复盘报告；\n3. 在案例基础上扩展到“性能与分布式”“数据治理”“安全与合规”等模块，形成矩阵。\n\n## 延伸阅读\n\n- 生产问题复盘：\n  - [/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）](/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）)\n- AI 协作与边界：\n  - [/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界](/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界)\n",
            "url": "https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图",
            "title": "AI 时代：系统课程的价值、定位与路线图",
            "summary": "AI 擅长局部解题，但系统性、权衡与落地需要课程提供“结构化路径”。本文给出价值判断、差异化定位、结构设计、风险与最小可行路线。",
            "date_modified": "2025-09-09T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/系统课程大纲与招生README（骨架）",
            "content_html": "\n# 课程介绍\n\n- 课程定位：工程落地为核心，强调 SOP/Checklist/MRE/观测与度量。\n- 适合对象：有 1 ～ 5 年经验，想从“能写页面”进阶到“能落地系统”的工程师。\n- 学习产出：可投递的作品集、问题复盘报告、基准与观测面板、团队落地 SOP。\n\n# 课程大纲（节选）\n\n- 模块 0：能力地图与路线\n- 模块 1：现代工程基础（构建/测试/发布基础）\n- 模块 2：工程体系（可观测/安全/合规/规范化）\n- 模块 3：生产问题与权衡（性能/网络/一致性/幂等/限流/熔断/回滚）\n- 模块 4：平台与协作（多仓/MonoRepo/流水线/指标治理）\n- Capstone：端到端项目（灰度、回滚、SLO、事故演练与复盘）\n\n# 日程与学习方式（示例：6 周）\n\n- 第 1 周：体系化工程启航 + 能力评估\n- 第 2 ～ 5 周：每周 2 次直播/录播 + 作业（代码走查/观测/复盘）\n- 第 6 周：Capstone 收官展示与简历/作品集打磨\n\n# 作业与考核\n\n- 强制作业：每周 1 次最小可复现 + 复盘报告（含观测截图/基准数据）\n- 评估维度：正确性/鲁棒性/性能/可观测/规范/表达\n- 通过门槛：达到基线 + 一处可验证优化\n\n# 度量指标（示例）\n\n- 前/后测提升、作业通过率、问题解决周期、SLO 改善、作品集质量、NPS、转介绍\n\n# 报名与名额\n\n- 报名链接：<填写>\n- 名额与价格：<填写>\n- 退课与售后：<填写>\n\n# FAQ（示例）\n\n- 我基础一般可以学吗？\n- 是否有助教/代码走查？\n- 是否提供发票/合同？\n\n# 延伸阅读\n\n- 课程价值与路线：\n  - [/posts/商业化与营收/课程与训练营/AI 时代：系统课程的价值、定位与路线图](/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图)\n- 试点班方案：\n  - [/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）](/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）)\n",
            "url": "https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/系统课程大纲与招生README（骨架）",
            "title": "系统课程大纲与招生 README（骨架）",
            "summary": "课程目标与对象、大纲结构、日程安排、作业与考核、报名方式与FAQ 的可复用骨架模板。",
            "date_modified": "2025-09-09T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/平台与博客/Hexo/hello-world",
            "content_html": "\n## 前置条件\n\n- Node.js 18+（推荐 20）\n- Git 与 GitHub 账号\n\n## 1）初始化项目\n\n```bash\nmkdir my-blog && cd my-blog\nnpm init -y\n```\n\n## 2）安装与创建 VitePress\n\n```bash\nnpm i -D vitepress\n\n# 快速启动开发（首次运行会创建 docs/.vitepress 基础结构）\nnpx vitepress init # 如未安装可用：npm create vitepress@latest\n```\n\n选择 “Blog” 模板或空模板均可。本仓库采用 `docs` 作为内容根目录。\n\n开发预览：\n\n```bash\nnpm run docs:dev\n```\n\n## 3）项目结构建议\n\n```txt\ndocs/\n  index.md                 # 首页（可用 hero 布局）\n  posts/                   # 博文目录\n    hello-world.md         # 你的第一篇文章（本页）\n  .vitepress/\n    config.ts              # 站点配置\n    dist/                  # 构建输出（自动生成）\n```\n\n## 4）基础配置（docs/.vitepress/config.ts）\n\n本仓库已内置一份可用于 GitHub Pages 的配置，关键点：\n\n```ts\n// 只展示关键片段\nconst BASE = process.env.BASE || \"/\";\nconst SITE_HOSTNAME = process.env.SITE_URL || \"https://example.com\";\n\nexport default {\n  lang: \"zh-CN\",\n  title: \"我的博客\",\n  description: \"记录、积累人气、可被搜索引擎良好收录的个人博客\",\n  base: BASE.endsWith(\"/\") ? BASE : `${BASE}/`,\n  sitemap: { hostname: SITE_HOSTNAME },\n  themeConfig: {\n    nav: [\n      { text: \"首页\", link: \"/\" },\n      { text: \"文章\", link: \"/posts/hello-world\" },\n    ],\n    search: { provider: \"local\" },\n    outline: { level: [2, 3] },\n  },\n  // 如需在 Markdown 中写原始 HTML，可将 markdown.html 设为 true\n  markdown: { html: false },\n};\n```\n\n> 提示：GitHub Pages 二级路径（`https://<owner>.github.io/<repo>`）要设置 `BASE=/<repo>/`。\n\n## 5）写第一篇文章（本页示例）\n\n在 `docs/posts/` 下新建 Markdown 文件，建议包含 Frontmatter：\n\n```md\n---\ntitle: 我的第一篇 VitePress 文章\ndescription: 这是一段用于 SEO 的摘要\ndate: 2025-01-01\ntags: [随笔]\n---\n\n这里是正文内容，可以使用 Markdown 语法、代码块等。\n```\n\n## 6）本地预览\n\n```bash\nnpm run docs:dev\n```\n\n打开终端输出的本地地址，检查首页与文章路由是否可用。\n\n## 7）生成静态站点\n\n```bash\nnpm run build\n```\n\n构建产物在 `docs/.vitepress/dist` 目录。你可以用：\n\n```bash\nnpm run docs:preview\n```\n\n进行本地预览。\n\n## 8）生成 RSS（可选）\n\n本仓库内置 `scripts/gen-rss.mjs`，`npm run build` 后会自动生成 RSS/Atom/JSON：\n\n- 产物：`docs/.vitepress/rss.xml`、`atom.xml`、`feed.json`\n- 设置站点地址：通过环境变量 `SITE_URL` 指定，例如：\n\n```bash\nSITE_URL=\"https://<owner>.github.io/<repo>\" npm run build\n```\n\n如需单独生成：\n\n```bash\nSITE_URL=\"https://<owner>.github.io/<repo>\" npm run rss\n```\n\n## 9）发布到 GitHub Pages（自动）\n\n本仓库已包含工作流：`.github/workflows/deploy.yml`。\n\n操作步骤：\n\n1. 将仓库推送到 GitHub，分支 `main` 或 `master`。\n2. 编辑工作流，将占位替换为你的信息：\n   - `SITE_URL: https://<owner>.github.io/<repo>`\n   - `BASE: /<repo>/`\n3. 在 GitHub → Settings → Pages：\n   - Build and deployment → Source 选择：GitHub Actions。\n\n工作流会：安装依赖 → 构建 → 上传 `docs/.vitepress/dist` → 部署到 Pages。\n\n## 10）常见问题\n\n- 构建时报 HTML 标签错误：本配置默认 `markdown.html=false`，避免原始 HTML 引起解析问题。确需使用时改为 `true`，并确保标签闭合正确。\n- 访问 404 或资源路径不对：多为 `base` 未设置为仓库名，如 `BASE=/your-repo/`。\n- 中文文件名：VitePress 支持中文路径，但在 Windows 下请确保 Git 编码与终端能正确显示。\n\n## 11）下一步\n\n- 自定义主题外观、接入统计脚本（在 `head` 中注入）\n- 组织文章分类/侧边栏\n- 接入站点地图（已开启）、结构化数据、以及搜索优化\n\n祝写作愉快！\n",
            "url": "https://herongdev.github.io/blog/posts/平台与博客/Hexo/hello-world",
            "title": "用 VitePress 从零搭建个人博客（含 GitHub Pages 发布）",
            "summary": "一步步完成初始化、写作、构建、RSS、以及 GitHub Pages 自动发布",
            "date_modified": "2025-09-08T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/平台与博客/Hexo/hexo博客分类分目录组织",
            "content_html": "\n> 目标：当文章**成千上万**时，既能在磁盘上**分目录管理**，又能在站点里以**目录树（分类层级）**浏览，并让 **URL 跟随分类层级**，同时保持 GitHub Project Pages 的子路径（`/blog/`）不乱。\n\n## 1 屏跑通\n\n1. **物理分目录**：`source/_posts/` 下建多级子目录；`hexo new post 路径/标题` 可直接写入对应子目录。\n2. **URL 跟随分类层级**：把 `permalink` 改成 `:categories/:title/`，并在每篇文章的 front-matter 写层级 `categories: [父, 子]`。\n3. **目录树页面**：确认有 `source/categories/index.md`（`type: categories`），NexT 会按层级展示。\n4. **脚手架（scaffolds）**：为高频目录建模板，一键新建时自动带好层级分类。\n5. **GitHub Pages 子路径**：你是项目页 → 继续保持 `url: https://<你>.github.io/<仓库名>` 与 `root: /<仓库名>/`。\n\n---\n\n## 一、物理分目录（递归扫描，直接可用）\n\nHexo 会**递归**读取 `source/_posts/` 的子目录，所以可以放心分层管理。\n\n```bash\n# 在 _posts 下建立层级目录\nmkdir -p source/_posts/GIS/GeoServer\nmkdir -p source/_posts/前端/NextJS\n\n# 新建文章时直接带路径（两种都行）\nhexo new post GIS/GeoServer/切片入门\nhexo new \"GIS/GeoServer/缓存与预热\"\n```\n\n```yaml\n# 复杂：建议开启“同名资源文件夹”，让每篇文章的图片等资产跟随文章文件夹\n# _config.yml（站点根配置）只需改这一行\npost_asset_folder: true\n```\n\n> 开启后，`hexo new post GIS/GeoServer/切片入门` 会生成\n> `source/_posts/GIS/GeoServer/切片入门.md` 与 `source/_posts/GIS/GeoServer/切片入门/`（放图）。\n\n## 二、URL & 页面跟“分类层级”走（而不是物理目录名）\n\n**关键点**：页面导航与 URL 建议依赖 **front-matter 的 categories**，而不是物理目录。\n这样**更可控**（物理目录可随时重构、不影响 URL）。\n\n```yaml\n# 复杂：让文章链接包含“分类层级”\n# _config.yml（站点根配置）\npermalink: :categories/:title/\n```\n\n> 你在 GitHub Project Pages（项目页），**继续保持子路径**（别动就对了）：\n\n```yaml\n# 复杂：站点部署在 /blog/ 子路径下\nurl: https://herongxhr-netizen.github.io/blog\nroot: /blog/\n```\n\n在每篇文章顶部写**层级分类**（数组顺序即层级）：\n\n```md\n---\ntitle: 切片入门\ndate: 2025-09-04\n# 复杂：层级分类会生成 /GIS/GeoServer/ 的目录层级与 URL\ncategories: [GIS, GeoServer]\ntags: [GeoServer, 切片, 缓存]\n# （可选）若想自定义更友好的英文链接\n# slug: geoserver-tiling-intro\n---\n```\n\n## 三、目录树页面与导航菜单\n\n确认你已有分类页与标签页（否则先创建）：\n\n```bash\nhexo new page categories\nhexo new page tags\n```\n\n编辑索引页 front-matter（**只需这几行**）：\n\n```md\n---\ntitle: 分类\ntype: categories\n---\n```\n\n```md\n---\ntitle: 标签\ntype: tags\n---\n```\n\n在 NexT 主题菜单里露出入口（`themes/next/_config.yml`）：\n\n```yaml\n# 复杂：在菜单里显示分类/标签\nmenu:\n  home: /\n  categories: /categories/\n  tags: /tags/\n```\n\n---\n\n## 四、批量高效新建：自定义脚手架（scaffolds）\n\n为高频目录做脚手架，自动带上层级分类与常用字段。\n\n**示例 1：GIS 系列脚手架**\n创建 `scaffolds/gis.md`：\n\n```md\n---\ntitle: { { title } }\ndate: { { date } }\n# 复杂：预置层级分类，后续文章自动套用\ncategories: [GIS, GeoServer]\ntags:\n---\n```\n\n使用（指定脚手架名）：\n\n```bash\n# 复杂：--s 指定使用自定义脚手架 \"gis\"\nhexo new --s gis \"瓦片缓存策略\"\n```\n\n**示例 2：NextJS 系列脚手架**\n`scaffolds/nextjs.md`：\n\n```md\n---\ntitle: { { title } }\ndate: { { date } }\ncategories: [前端, NextJS]\ntags:\n---\n```\n\n使用：\n\n```bash\nhexo new --s nextjs \"App Router 与 RBAC\"\n```\n\n> 贴士（可选）：在 `package.json` 里加脚本别名，敲更短：\n\n```json\n{\n  \"scripts\": {\n    \"new:gis\": \"hexo new --s gis\",\n    \"new:next\": \"hexo new --s nextjs\"\n  }\n}\n```\n\n使用：`npm run new:gis \"OpenLayers 点聚合最佳实践\"`\n\n---\n\n## 五、目录结构示例（仅供参考）\n\n```\nsource/_posts/\n├─ GIS/\n│  └─ GeoServer/\n│     ├─ 切片入门.md\n│     ├─ 切片入门/         # 文章同名资源文件夹（图片等）\n│     └─ 缓存与预热.md\n└─ 前端/\n   └─ NextJS/\n      └─ App Router 与 RBAC.md\n```\n\n> **注意**：物理目录**不会**自动变成 URL；URL 由 `permalink` + 文章的 `categories` 决定。\n\n---\n\n## 六、搜索与站点生成（与你现有配置兼容）\n\n你已使用 `hexo-generator-searchdb`（本地搜索），与分目录/层级分类**无冲突**，无需额外改动。\n每次发文后按旧流程即可：\n\n```bash\nhexo clean && hexo g && hexo s\n# 自动部署（GitHub Actions）仍是：git add . && git commit && git push\n```\n\n---\n\n## 七、常见坑位（快速定位）\n\n- **页面 404 / 样式丢失**：`_config.yml` 的 `url/root` 未按**项目页子路径**设置（应为 `/blog/`）。\n- **URL 没有层级**：缺少 `permalink: :categories/:title/` 或文章没写 `categories: [父, 子]`。\n- **分类页不展示树**：`source/categories/index.md` 的 `type` 不是 `categories`；或主题菜单未加入口。\n- **物理目录改变但 URL 想保持不变**：别动 front-matter 的 `categories`，URL 就不会变。\n- **想迁移到“用户页”（根路径）**：把仓库改名为 `<用户名>.github.io`，并把\n\n  ```yaml\n  # 复杂：用户页改为根路径部署\n  url: https://<用户名>.github.io\n  root: /\n  ```\n\n  重新部署即可。\n\n---\n\n## 复盘清单（照这个一项项核对）\n\n- [ ] `_config.yml` 已设置\n\n  ```yaml\n  permalink: :categories/:title/\n  url: https://herongxhr-netizen.github.io/blog\n  root: /blog/\n  post_asset_folder: true\n  ```\n\n- [ ] 文章 front-matter 用层级分类（`[父, 子]`）。\n- [ ] 有 `source/categories/index.md` 与 `type: categories`。\n- [ ] NexT 菜单里有 `/categories/` 与 `/tags/`。\n- [ ] 脚手架按需要创建（`scaffolds/*.md`），新建时用 `hexo new --s <脚手架> \"标题\"`。\n\n---\n\n### FAQ\n\n**Q：必须物理分目录吗？**\nA：不是必须，但**强烈建议**。这样 Git 与编辑器里都更可管理；而 URL/导航交给分类层级来控制，二者解耦。\n\n**Q：以后想批量重构目录怎么办？**\nA：直接移动文件夹即可；只要 front-matter 的 `categories` 不改，URL 不会变（避免 SEO 损失）。\n\n**Q：图片怎么引用？**\nA：启用 `post_asset_folder: true` 后，文章内用相对路径（如 `![](切片入门/示意图.png)`）即可。\n\n---\n",
            "url": "https://herongdev.github.io/blog/posts/平台与博客/Hexo/hexo博客分类分目录组织",
            "title": "Hexo 千篇文章的“分目录存储 + 目录树导航”实战（含 URL、分类、脚手架）",
            "date_modified": "2025-09-04T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/平台与博客/Hexo/使用-hexo-在-github-部署个人博客",
            "content_html": "\n# 整体实现思路\n\n- **写作方式**：本地写 Markdown（VSCode/Typora），利用 Hexo 生成静态文件。\n- **站点能力**：front-matter 实现**分类/标签**；装 `hexo-generator-searchdb` 提供**本地搜索**（纯静态，无后端）。\n- **部署方式**：用 **GitHub Actions** 在每次 `push main` 时自动构建，把 `public/` 发布到 **`gh-pages`** 分支；**Pages** 指向该分支即可上线。\n- **路径模式**：你当前是**项目页**（仓库名不是 `<用户名>.github.io`），所以站点路径是 `https://<用户名>.github.io/<仓库名>/`，Hexo 里必须设置 `url` 和 `root`。\n\n---\n\n# 分步实现过程\n\n## 1）环境与初始化（已有可跳过）\n\n```bash\nnpm i -g hexo-cli\nhexo init blog && cd blog\nnpm i\nhexo s   # 本地预览 http://localhost:4000\n```\n\n## 2）启用主题与“分类/标签/搜索”\n\n```bash\n# 安装 NexT（已安装可跳过）\nnpm i hexo-theme-next\n\n# 生成分类与标签页面\nhexo new page categories\nhexo new page tags\n```\n\n在两个索引页文件顶部加 front-matter（**只需新增这几行**）：\n\n```md\n---\ntitle: 分类\ntype: categories\n---\n```\n\n```md\n---\ntitle: 标签\ntype: tags\n---\n```\n\n安装本地搜索索引插件（**一次性**）：\n\n```bash\nnpm i hexo-generator-searchdb --save\n```\n\n**站点配置 `_config.yml` 里新增（或确认存在）**：\n\n```yaml\n# 复杂：生成 search.json，供主题读取（静态搜索，无后端）\nsearch:\n  path: search.json\n  field: post\n  content: true\n```\n\n**主题配置 `themes/next/_config.yml` 里开启**：\n\n```yaml\n# 复杂：在 NexT 主题中开启本地搜索\nlocal_search:\n  enable: true\n```\n\n## 3）Hexo 站点路径设置（项目页必改）\n\n打开根目录的 **`_config.yml`**，**只改这两行**：\n\n```yaml\n# 复杂：GitHub Project Pages 部署在 /blog/ 子路径（用你的用户名和仓库名）\nurl: https://<你的GitHub名>.github.io/<你的仓库名>\nroot: /<你的仓库名>/\n```\n\n> 你当前仓库是 `herongxhr-netizen/blog`，因此应为：\n> `url: https://herongxhr-netizen.github.io/blog` > `root: /blog/`\n\n## 4）把项目推到 GitHub（已有仓库可跳过初始化）\n\n```bash\ngit init\ngit add .\ngit commit -m \"init blog\"\ngit branch -M master\ngit remote add origin https://github.com/<你的GitHub名>/<你的仓库名>.git\ngit push -u origin master\n```\n\n## 5）创建自动部署（GitHub Actions）\n\n在仓库中新建文件 **`.github/workflows/deploy.yml`**，内容如下：\n\n```yaml\n# 复杂：构建 Hexo 并把生成的 public/ 发布到 gh-pages\nname: Deploy Hexo to GitHub Pages\non:\n  push:\n    # 注意检查这个分支是否存在，另外还要注意master|main 两种默认主分支\n    branches: [master]\npermissions:\n  contents: write\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - run: npm i\n      - run: npx hexo clean && npx hexo g\n      - uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n          publish_branch: gh-pages\n```\n\n> 作用：每次推送到 `master`，自动构建 Hexo 并把 `public/` 发布到 `gh-pages` 分支。\n\n## 6）打开 GitHub Pages（指向 `gh-pages`）\n\n仓库 → **Settings → Pages**：\n\n- **Source** 选 **Deploy from a branch**\n- **Branch** 选 **`gh-pages`**，**Folder** 选 **`/(root)`** → Save\n  访问：`https://<你的GitHub名>.github.io/<你的仓库名>/`\n\n## 7）写第一篇/后续文章（固定节奏）\n\n```bash\nhexo new post \"我的第一篇文章\"\n# 编辑 source/_posts/我的第一篇文章.md，增加分类/标签 front-matter\nhexo s                 # 本地预览确认\ngit add . && git commit -m \"post: 第一篇\" && git push\n# -> Actions 自动构建 -> Pages 自动更新\n```\n\n## 故障排查（按频率排序）\n\n1. **页面样式丢失或 404**\n\n   - 九成是 `_config.yml` 的 `url/root` 不匹配“项目页子路径”。\n   - 修复：按上面的两行改好 → `git push` 触发重建。\n\n2. **推送成功但没自动发布**\n\n   - 检查 **Actions** 是否执行、是否报“权限不足”。\n   - 修复：打开 **Read and write permissions** 或在 workflow 增加 `permissions: contents: write`。\n\n3. **Pages 仍显示旧内容**\n\n   - 浏览器缓存或 GitHub Pages 缓存未刷新。\n   - 修复：改动任意文件再推一次，或等几分钟刷新。\n\n4. **找不到搜索框/搜索无结果**\n\n   - 主题未开启 `local_search.enable` 或站点未生成 `search.json`。\n   - 修复：确认两处配置；本地 `hexo clean && hexo g` 看 `public/search.json` 是否存在。\n\n5. **想改成“用户页”根路径**\n\n   - 把仓库改名为 `<你的GitHub名>.github.io`；\n   - `_config.yml` 改为：\n\n     ```yaml\n     # 复杂：用户页部署在根路径\n     url: https://<你的GitHub名>.github.io\n     root: /\n     ```\n\n   - Pages 的 Source 仍选 `gh-pages`。\n\n---\n\n需要的话，把你当前 `themes/next/_config.yml` 里想开的功能（目录、代码复制、文章 TOC、暗色主题）告诉我；我会**只列需要修改的那几行**，并在复杂行上面加注释。\n",
            "url": "https://herongdev.github.io/blog/posts/平台与博客/Hexo/使用-hexo-在-github-部署个人博客",
            "title": "使用 hexo 在 github 部署个人博客",
            "date_modified": "2025-09-04T18:04:44.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/架构与请求/请求层/AbortController-Api的使用",
            "content_html": "\n### 什么是 `AbortController`？\n\n`AbortController` 是一个 Web API，允许开发者在 JavaScript 中主动取消某些异步操作，例如网络请求（`fetch`）、定时器或其他可取消的操作。它是现代 Web 开发中处理异步任务的重要工具，特别是在需要中断或取消正在进行的操作时。`AbortController` 提供了简单、标准化的方式来实现取消功能，广泛用于浏览器环境。\n\n`AbortController` 是在 WHATWG 的 DOM 规范中定义的，最初主要与 `fetch` API 配合使用，但现在也被其他 API（如 `ReadableStream`）支持。它的核心思想是提供一个信号（`AbortSignal`），通过这个信号可以通知相关操作停止执行。\n\n---\n\n### 核心概念\n\n1. **AbortController**:\n\n   - `AbortController` 是一个构造函数，用于创建控制器对象。\n   - 它有一个 `signal` 属性，返回一个 `AbortSignal` 对象，用于监听取消信号。\n   - 它还有一个 `abort()` 方法，调用后会触发取消信号。\n\n2. **AbortSignal**:\n\n   - `AbortSignal` 是 `AbortController` 的信号对象，传递给支持取消的 API（如 `fetch`）。\n   - 当 `AbortController` 的 `abort()` 方法被调用时，`AbortSignal` 会触发 `abort` 事件，通知相关操作取消。\n\n3. **用途**:\n   - 取消网络请求（例如用户切换页面时取消未完成的 `fetch` 请求）。\n   - 中止某些异步任务（如文件读取、流操作）。\n   - 提高性能，避免不必要的资源消耗。\n   - 实现用户交互中的取消功能（如取消上传或下载）。\n\n---\n\n### 工作原理\n\n`AbortController` 的工作流程可以简单总结为以下步骤：\n\n1. 创建一个 `AbortController` 实例。\n2. 将其 `signal` 属性传递给支持取消的 API（如 `fetch`）。\n3. 在需要取消操作时，调用 `AbortController` 的 `abort()` 方法。\n4. 相关的 API 会接收到取消信号并停止操作，同时抛出 `AbortError` 异常。\n\n---\n\n### 使用示例\n\n以下是一个使用 `AbortController` 取消 `fetch` 请求的详细代码示例：\n\n```javascript\n// 创建 AbortController 实例\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// 发起一个 fetch 请求，传入 signal\nfetch(\"https://api.example.com/data\", { signal })\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => {\n    if (error.name === \"AbortError\") {\n      console.log(\"请求被取消\");\n    } else {\n      console.error(\"请求失败:\", error);\n    }\n  });\n\n// 假设 2 秒后取消请求\nsetTimeout(() => {\n  controller.abort(); // 调用 abort() 方法取消请求\n}, 2000);\n```\n\n#### 代码解释：\n\n- `new AbortController()` 创建控制器。\n- `controller.signal` 获取信号对象，传递给 `fetch` 的 `signal` 选项。\n- `controller.abort()` 触发取消，`fetch` 请求会立即停止，并抛出 `AbortError`。\n- 使用 `catch` 捕获错误并判断是否为 `AbortError`。\n\n---\n\n### 实际应用场景\n\n1. **取消网络请求**:\n\n   - 用户在页面上点击“搜索”，但在结果返回前又切换到另一个页面，可以用 `AbortController` 取消未完成的请求，避免浪费带宽。\n   - 示例：用户在输入框快速输入时，取消之前的搜索请求，只处理最新的请求。\n\n2. **清理定时器或事件监听器**:\n\n   - 虽然 `AbortController` 本身不直接控制 `setTimeout` 或事件监听器，但可以通过监听 `AbortSignal` 的 `abort` 事件来实现类似功能。\n\n3. **流操作**:\n\n   - 在处理 `ReadableStream` 或 `WritableStream` 时，`AbortController` 可用于取消流传输。\n\n4. **用户交互**:\n   - 提供“取消”按钮，让用户手动中止上传、下载或其他耗时操作。\n\n---\n\n### 高级用法：监听 `AbortSignal` 事件\n\n`AbortSignal` 是一个 `EventTarget`，可以监听其 `abort` 事件，用于自定义取消逻辑。\n\n```javascript\nconst controller = new AbortController();\nconst signal = controller.signal;\n\n// 监听 abort 事件\nsignal.addEventListener(\"abort\", () => {\n  console.log(\"操作已被取消\");\n});\n\n// 模拟一个异步任务\nasync function doWork() {\n  try {\n    const response = await fetch(\"https://api.example.com/data\", { signal });\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      console.log(\"任务被取消\");\n    } else {\n      console.error(\"任务失败:\", error);\n    }\n  }\n}\n\ndoWork();\n\n// 3 秒后取消任务\nsetTimeout(() => {\n  controller.abort();\n}, 3000);\n```\n\n#### 说明：\n\n- `signal.addEventListener('abort', ...)` 监听取消事件。\n- 可以在取消时执行额外的清理逻辑，例如关闭资源或更新 UI。\n\n---\n\n### 注意事项\n\n1. **浏览器兼容性**:\n\n   - `AbortController` 在现代浏览器（如 Chrome、Firefox、Safari）中广泛支持，IE 不支持。\n   - 对于旧浏览器，可能需要使用 polyfill。\n\n2. **异常处理**:\n\n   - 调用 `abort()` 后，相关 API 会抛出 `AbortError`，需要在代码中捕获并处理。\n\n3. **不可恢复**:\n\n   - 一旦调用 `abort()`，`AbortController` 实例不可重用，必须创建新的实例。\n\n4. **支持的 API**:\n\n   - 目前主要与 `fetch` 和 `ReadableStream` 等 API 配合使用，其他场景需要开发者手动实现取消逻辑。\n\n5. **性能优化**:\n   - 使用 `AbortController` 可以减少不必要的资源消耗，尤其在高并发或频繁请求的场景下。\n\n---\n\n### 扩展：结合 React 示例\n\n在 React 中，`AbortController` 常用于组件卸载时取消请求，避免内存泄漏。\n\n```javascript\nimport { useEffect } from \"react\";\n\nfunction MyComponent() {\n  useEffect(() => {\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    async function fetchData() {\n      try {\n        const response = await fetch(\"https://api.example.com/data\", {\n          signal,\n        });\n        const data = await response.json();\n        console.log(data);\n      } catch (error) {\n        if (error.name === \"AbortError\") {\n          console.log(\"请求被取消\");\n        } else {\n          console.error(\"请求失败:\", error);\n        }\n      }\n    }\n\n    fetchData();\n\n    // 组件卸载时取消请求\n    return () => {\n      controller.abort();\n    };\n  }, []);\n\n  return <div>加载中...</div>;\n}\n```\n\n#### 说明：\n\n- 在 `useEffect` 中创建 `AbortController`。\n- 在组件卸载时（`return` 回调），调用 `abort()` 取消请求。\n- 防止因组件卸载而导致的内存泄漏或状态更新错误。\n\n---\n\n### 总结\n\n`AbortController` 是一个简单而强大的工具，用于在 Web 开发中取消异步操作。它通过 `AbortSignal` 提供了一种标准化的取消机制，广泛应用于 `fetch` 请求、流操作等场景。它的主要优点包括：\n\n- **简单易用**：只需要创建控制器并调用 `abort()` 即可。\n- **灵活性**：支持多种异步操作的取消。\n- **性能优化**：避免不必要的资源消耗。\n- **现代化**：符合现代 Web 开发的需求，特别是在用户交互和性能敏感的场景中。\n\n通过合理使用 `AbortController`，开发者可以更好地管理异步任务，提升 Web 应用的性能和用户体验。\n",
            "url": "https://herongdev.github.io/blog/posts/架构与请求/请求层/AbortController-Api的使用",
            "title": "什么是 `AbortController`？",
            "date_modified": "2025-09-06T11:18:10.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）",
            "content_html": "\n````yaml\ntitle: Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）\ndate: 2025-09-06\ntags:\n  - Axios\n  - Vue3\n  - TypeScript\n  - Interceptor\n  - Auth\n---\n\n## 目标\n- 保留按前缀（如 `/api/pub`）**自动放行**的白名单机制；\n- 支持**逐请求显式关闭鉴权**（即便该接口不在白名单里）；\n- 避免与 Axios 自带的 `config.auth`（Basic Auth）混淆；\n- 兼容历史 `(req as any).auth` 写法，**渐进迁移**到 `useAuth`。\n\n## 方案总览\n1. **类型扩展**：给 `AxiosRequestConfig` 增加 `useAuth?: boolean`。\n2. **对象式入口透传**：`http.call({... useAuth })` 直达拦截器。\n3. **拦截器优先级**：优先读 `useAuth` → 回退老的 `auth` → 再按前缀与实例默认值判定。\n4. **显式移除头**：当不需要鉴权时，从请求头里**删除** `Authorization`，避免误带默认 token。\n5. **调用方式**：`http.get/post(..., { useAuth:false })` 或 `http.call({ useAuth:false })`。\n\n---\n\n## 关键改动（最小补丁）\n\n### 1) 扩展 Axios 配置\n> 避免与 Basic Auth 的 `config.auth` 冲突，用单独的 `useAuth`。\n\n```ts\n// src/types/http/axios.d.ts\ndeclare module 'axios' {\n  export interface AxiosRequestConfig {\n    /** 覆盖实例默认鉴权：true=强制带token；false=强制不带token */\n    useAuth?: boolean\n  }\n}\n````\n\n### 2) 对象式入口支持 `useAuth`\n\n```ts\n// src/lib/http/types.ts（RequestOptions 中新增）\nuseAuth?: boolean\n```\n\n```ts\n// src/lib/http/call.ts（buildAxiosConfigFromOptions 末尾透传）\nif (typeof (options as any).useAuth === \"boolean\") {\n  (cfg as any).useAuth = (options as any).useAuth;\n}\n```\n\n### 3) 请求拦截器：判定与显式移除头\n\n```ts\n// src/lib/http/client.ts（拦截器内替换判定片段）\n\n// 1) 优先 useAuth，回退旧的 auth\nconst explicitAuth =\n  typeof (req as any).useAuth === \"boolean\"\n    ? (req as any).useAuth\n    : typeof (req as any).auth === \"boolean\"\n    ? (req as any).auth\n    : undefined;\n\nconst needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);\nconst accToken = storage.get(ACCESS_TOKEN);\nconst tokenType = storage.get(TOKEN_TYPE) || \"Bearer\";\n\n// 2) 不需要鉴权：显式移除 Authorization，避免误带默认头\nif (!needAuth) {\n  const h = (req.headers || {}) as Record<string, any>;\n  delete h.Authorization;\n  delete h.authorization;\n  req.headers = h;\n} else {\n  // 需要鉴权但无 token：中断\n  if (!accToken) {\n    abortController.abort();\n    return Promise.reject(new Error(\"UNAUTHENTICATED\"));\n  }\n  // 需要鉴权且有 token：注入\n  req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };\n}\n```\n\n---\n\n## 调用方式示例\n\n### A) 传统 axios 三参（推荐）\n\n```ts\n// 公开接口（不走 /api/pub，但也不需要 token）\nawait http.get(\"/api/third/get_login_credential_code\", { useAuth: false });\n\n// POST 且不带 token\nawait http.post(\"/api/third/login_by_credential\", payload, { useAuth: false });\n```\n\n### B) 对象式入口\n\n```ts\nawait http.call({\n  url: \"/api/third/get_login_credential_code\",\n  method: \"GET\",\n  useAuth: false,\n});\n\nawait http.call({\n  url: \"/api/third/login_by_credential\",\n  method: \"POST\",\n  data: payload,\n  useAuth: false,\n});\n```\n\n---\n\n## 兼容与迁移\n\n- 旧代码里的 `(req as any).auth = false` 仍可用（拦截器已回退支持），但**建议逐步统一到 `useAuth`**。\n- 仍保留 `publicPrefixes`（如 `/api/pub`）自动放行；`useAuth:false` 仅在**个别不走白名单的公开接口**上使用。\n\n---\n\n## 常见坑\n\n- **不要**再用 `config.auth = false`：那是 Basic Auth，类型不对、语义也不对。\n- 如果调用过 `http.setAuthToken` 写了默认头，**不显式移除**就会误带 token；本方案在拦截器中已处理。\n- 确保 `tsconfig.json` 的 `include` 覆盖到 `src/types`，让编辑器识别 `useAuth` 类型。\n\n---\n\n## 验收清单\n\n- [ ] `src/types/http/axios.d.ts` 已生效（编辑器能识别 `useAuth`）。\n- [ ] `http.call` 能接收 `useAuth` 并透传到拦截器。\n- [ ] 拦截器在 `useAuth:false` 时**不发送 Authorization**；在需要鉴权但无 token 时**立即中断**。\n- [ ] 现网公开接口（不在 `/api/pub`）能通过 `{ useAuth:false }` 正常调用。\n\n> 结论：这套改动**小而稳**，语义清晰、类型安全，满足“前缀白名单 + 逐请求显式关闭鉴权”的企业级最佳实践。\n\n```\n::contentReference[oaicite:0]{index=0}\n```\n",
            "url": "https://herongdev.github.io/blog/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）",
            "title": "Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）",
            "date_modified": "2025-09-06T16:20:26.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线",
            "content_html": "\n## 目标与判断\n\n你的现状：页面里混着 `api.d.ts / axios.d.ts / common.ts` 等类型与封装，随着“对象入参 + 零破坏兼容”推进，类型边界和目录粘在一起，开始“乱”。\n\n**结论（大厂常用做法）**：保持 `axios` 原语义不覆写，新增对象式入口（如 `http.call`）；**类型集中管理**、**代码生成** 与 **运行时校验** 组合；请求层**分三层**（core/http、api/generated、api/modules），再用**查询层**（TanStack Query/Vue Query）管理缓存与重试；本地与集成测试统一用 **MSW** 拦截网络层。这些都是一线公司里稳定落地的模式。([axios-http.com][1], [orval.dev][2], [GitHub][3], [tanstack.com][4], [mswjs.io][5])\n\n---\n\n## 推荐目录（企业级分层）\n\n```txt\nsrc/\n  lib/\n    http/                      # Core 请求层（只做“通用能力”）\n      client.ts                # axios 实例与拦截器（不覆写 axios.request）\n      call.ts                  # 新增对象式入口：http.call(options)\n      interceptors.ts          # 拦截器拆分：auth、retry、logging\n      cancel.ts                # 取消池/AbortController 管理\n      types.ts                 # RequestOptions、HttpError、CodeResponse 等\n      index.ts                 # 统一导出 http 实例与类型\n  api/\n    __generated__/             # OpenAPI 代码生成产物（只读）\n      client.ts\n      schemas.ts               # 可选：导出 Zod/类型\n      README.md\n    modules/                   # 领域 API（手写，薄封装）\n      user.ts\n      order.ts\n      price.ts\n  features/                    # 业务功能（视框架而定：React/Vue）\n    price-trend/\n      queries.ts               # TanStack Query/Vue Query 的 hooks\n      components/...\n  types/\n    http/                      # 类型声明集中地（仅 .d.ts）\n      axios.d.ts               # module augmentation：扩展 AxiosInstance（如 .call）\n      api.d.ts                 # 全局响应范式、工具类型\n    common.ts                  # 与请求无关的通用类型\ntests/\n  msw/\n    server.ts                  # MSW 服务端/浏览器初始化\n    handlers/                  # 接口级别的 mock 处理器\n```\n\n- `lib/http` 只做“通用能力”（超时、重试、鉴权、取消、日志、错误规约），**不写任何“业务 URL”**；这能保证“可替换/可迁移”。拦截器是 axios 官方推荐扩展点。([axios-http.com][1])\n- `api/__generated__` 用 OpenAPI/Swagger **生成**强类型客户端，避免手写 drift；常见工具：**orval**、**openapi-typescript-codegen**、OpenAPI Generator。([orval.dev][2], [GitHub][3], [openapi-generator.tech][6])\n- `api/modules` 是“轻薄门面层”：把生成代码或 `http.call` 包一层，落地**统一的错误/返回范式**，方便埋点与切面。\n- `features/*/queries.ts` 将请求函数交给 **TanStack Query/Vue Query** 管理缓存、并发、重试、失效、SSR 等。([tanstack.com][7])\n- `tests/msw` 用 **MSW** 在浏览器/Node 统一拦截 HTTP，保证本地/CI 可重复。([mswjs.io][5])\n\n---\n\n## 类型与声明管理：收口与增量\n\n### 1) `.d.ts` **只放声明，不放实现**\n\n- 将你现有的 `api.d.ts / axios.d.ts` **合并/去重**后放到 `src/types/http/` 下，职责清晰：\n\n  - `axios.d.ts`：**module augmentation**（扩展 `AxiosInstance`，如新增 `call<T>()` 签名，不改原生 `get/post`）。TypeScript 官方建议通过声明合并做到“对第三方库的扩展”。([typescriptlang.org][8], [Stack Overflow][9], [futurestud.io][10])\n  - `api.d.ts`：与后端约定的响应外层、错误码、工具类型（如 `CodeResponse<T>`、`PageResp<T>`）。\n\n- `common.ts` 只保留**与请求无关**的通用类型/常量，避免耦合。\n\n> **示例（module augmentation）**：将 `.call` 加入 `AxiosInstance`（放 `src/types/http/axios.d.ts`）\n\n```ts\n// 在同名模块作用域内“声明合并”，不会改动运行时代码\ndeclare module \"axios\" {\n  export interface AxiosInstance {\n    // 简化：对象式入口\n    call<T = any, P = Record<string, any>>(options: {\n      url: string;\n      method?: import(\"axios\").Method;\n      params?: P;\n      data?: unknown;\n      requestConfig?: import(\"axios\").AxiosRequestConfig;\n      contentType?: \"json\" | \"urlencoded\" | \"formdata\";\n    }): Promise<T>;\n  }\n}\n```\n\n### 2) **运行时校验（可选但推荐）**\n\n- 对关键接口采用 **Zod**/生成器产出的 schema，做“入站/出站”校验，尽早暴露协议漂移。([Zod][11])\n- 如果你用 **Zodios**，可直接以 Zod 定义端点 → 生成强类型 axios 客户端。([zodios.org][12], [npm][13])\n\n---\n\n## 代码生成：把“类型维护成本”降到最低\n\n- **orval**：从 OpenAPI 生成 TS 客户端，内置 React/Vue Query 集成、缓存与 MSW mock 模板，工程化最佳。([orval.dev][2], [GitHub][14], [npm][15])\n- **openapi-typescript-codegen**：轻量、纯客户端生成，适合你已有 Query 层。([GitHub][16])\n\n> 建议：把生成产物放进 `src/api/__generated__`，并**加入 lint/tsc**，但**排除 format**（防止误改）。CI 里加“变更即失败”的 diff 检查，确保版本与后端规范同步。\n\n---\n\n## Core HTTP 的“硬规范”\n\n1. **不覆写** `axios.request`，新增 `http.call(options)`，保持 `http.get/post/...` 零破坏兼容（你已走在正确路线上）。\n2. **拦截器**：鉴权（注入 `Authorization`）、401 统一处理、取消池、日志/链路 ID、错误归一化。([axios-http.com][1])\n3. **FormData 正确处理**：\n\n   - **不要手动设置** `Content-Type: multipart/form-data`，让浏览器带 boundary；否则容易 4xx/网络错误。([axios-http.com][17], [GitHub][18])\n\n4. **错误范式**：将 `AxiosError` → 统一 `HttpError`（含 `status`、`code`、`message`、`traceId`、`isNetworkError`）。\n5. **请求命名与埋点**：在 `requestConfig` 中允许 `opName`、`skipAuth`、`retry` 等自定义键，统一日志与灰度。\n\n---\n\n## 查询层（React/Vue）：“把副作用交给专业工具”\n\n- 用 **TanStack Query / Vue Query** 管理缓存、并发去重、后台刷新、窗口聚焦重刷、错误边界、SSR/Hydration、离线等硬问题；你的 `http.call` / 生成客户端只需提供 **纯函数** 即可。([tanstack.com][19])\n- 典型封装（以 React 为例）：\n\n```ts\n// features/price-trend/queries.ts\nimport { useQuery } from \"@tanstack/react-query\";\nimport { priceApi } from \"@/api/modules/price\";\n\nexport const useGamePriceTrend = (gameId: string, stores: string[]) =>\n  useQuery({\n    queryKey: [\"priceTrend\", gameId, stores],\n    // 复杂逻辑上一行注释：调用领域 API，返回 Promise，交由 Query 管理缓存与失败重试\n    queryFn: () => priceApi.getTrend({ gameId, stores }),\n    staleTime: 5 * 60 * 1000,\n    gcTime: 60 * 60 * 1000,\n    retry: 2,\n  });\n```\n\n> TanStack 官方定位就是“声明式异步/服务端状态管理”，在大厂广泛使用。([tanstack.com][7])\n\n---\n\n## Mock 与测试：MSW 打通本地与 CI\n\n- **MSW** 在浏览器/Node 拦截真实网络层，mock 定义可复用到 Storybook/E2E/单元测试，减少“环境不可用”的波动。([mswjs.io][5])\n- 放到 `tests/msw/handlers`，与 `api/modules` 一一对应；生成器也能产出 mock 模板（如 orval）。([GitHub][14])\n\n---\n\n## 迁移策略（零停机）\n\n1. **先落地 core/http 与 `http.call`**（不动 `get/post`）。\n2. **挑 1 ～ 2 个模块**迁移到 `api/modules`（使用 `http.call` 或 `__generated__` 客户端），沉淀错误与重试策略。\n3. **接入 TanStack/Vue Query** 的“易变接口”（价格趋势、榜单、列表）以验证缓存收益。\n4. 稳定后再逐步 **把老的页面直连 http 的代码迁到 modules**；期间保留 `api.d.ts` 的兼容类型，避免一次性爆炸式改动。\n5. 接入 **MSW** 保障端到端可测。\n\n---\n\n## 你现有文件的落位建议\n\n- `/mnt/data/api.d.ts` → `src/types/http/api.d.ts`（保留响应范式与工具类型，去掉与 axios 的交叉声明）\n- `/mnt/data/axios.d.ts` → `src/types/http/axios.d.ts`（**只做 module augmentation**：为 `AxiosInstance` 增加 `.call` 的签名，不定义实现）\n- `/mnt/data/common.ts` → `src/types/common.ts`（与请求无关的类型保留在此；若有请求相关的工具类型，迁到 `lib/http/types.ts`）\n\n---\n\n## 最小代码约定（只列关键片段）\n\n```ts\n// lib/http/call.ts\nimport type { AxiosRequestConfig, Method } from \"axios\";\nimport http from \"./client\";\nimport { toFormData, toUrlencoded } from \"./utils\";\n\nexport type RequestContentType = \"json\" | \"urlencoded\" | \"formdata\";\nexport interface RequestOptions<P = Record<string, any>> {\n  url: string;\n  method?: Method;\n  params?: P;\n  data?: unknown;\n  requestConfig?: AxiosRequestConfig;\n  contentType?: RequestContentType;\n}\n\nexport async function call<T, P = Record<string, any>>(\n  opt: RequestOptions<P>\n): Promise<T> {\n  const {\n    url,\n    method = \"GET\",\n    params,\n    data,\n    requestConfig,\n    contentType = \"json\",\n  } = opt;\n  if (!url) throw new Error(\"Missing url\");\n\n  const cfg: AxiosRequestConfig = { ...(requestConfig || {}), url, method };\n  if (method === \"GET\" || method === \"HEAD\") {\n    cfg.params = params ?? requestConfig?.params;\n  } else {\n    // 复杂逻辑上一行注释：统一 body 选择并按 contentType 组织\n    const body = data ?? params ?? requestConfig?.data;\n    if (contentType === \"formdata\")\n      cfg.data = body instanceof FormData ? body : toFormData(body as any);\n    else if (contentType === \"urlencoded\")\n      cfg.data =\n        body instanceof URLSearchParams\n          ? body\n          : toUrlencoded((body ?? {}) as any);\n    else cfg.data = body;\n  }\n  return http.request(cfg) as Promise<T>;\n}\n```\n\n> `client.ts` 里注册拦截器与取消池；`index.ts` 里 `export { http }` 与 `export { call }`；FormData 时**别手动设置** `Content-Type`，让浏览器带 boundary（官方文档有说明，也有 issue 讨论）。([axios-http.com][17], [GitHub][18])\n\n---\n\n## 校验清单（落地前检查）\n\n- [ ] **不覆写** `axios.request`；保留 `http.get/post/...`\n- [ ] `.d.ts` **只放声明**；`axios.d.ts` 仅做 module augmentation\n- [ ] `http.call` **对象式入口**可用；FormData 不手设 `Content-Type`\n- [ ] 统一 `HttpError`；401/取消池/日志在拦截器层\n- [ ] 关键接口用 **Zod** 校验或生成器 schema\n- [ ] 接入 **TanStack/Vue Query** 管理缓存与重试\n- [ ] **MSW** 拦截器与 handlers 就位；本地/CI 可跑通\n\n---\n\n## 参考与延伸\n\n- Axios 拦截器官方文档（拦截请求/响应的标准扩展点）。([axios-http.com][1])\n- Axios Multipart/FormData 说明（自动序列化；不要手动 `Content-Type`）。([axios-http.com][17])\n- 不要手动设置 FormData 的 `Content-Type`（社区/issue 共识）。([GitHub][18], [Stack Overflow][20])\n- TypeScript **声明合并 / 模块增强**（官方手册）。([typescriptlang.org][8])\n- Orval（OpenAPI → TS 客户端、Query、MSW mock 一体化）。([orval.dev][2], [GitHub][14])\n- openapi-typescript-codegen（轻量生成 TS 客户端）。([GitHub][16])\n- TanStack Query（React/Vue 的服务端状态/数据获取）。([tanstack.com][4])\n- MSW（浏览器/Node 的网络层 API Mock）。([mswjs.io][5])\n\n---\n\n如果你愿意，我可以把你现有的 `api.d.ts / axios.d.ts / common.ts` **逐条清点**并给出**迁移 diff**（仅贴需要修改的片段，复杂处在上一行加注释），直接落到上面的目录结构里。\n\n[1]: https://axios-http.com/docs/interceptors?utm_source=chatgpt.com \"Interceptors | Axios Docs\"\n[2]: https://orval.dev/?utm_source=chatgpt.com \"orval - Restful client generator\"\n[3]: https://github.com/ferdikoomen/openapi-typescript-codegen/wiki?utm_source=chatgpt.com \"Home · ferdikoomen/openapi-typescript-codegen Wiki\"\n[4]: https://tanstack.com/query/docs?utm_source=chatgpt.com \"TanStack Query\"\n[5]: https://mswjs.io/docs/?utm_source=chatgpt.com \"Introduction - Mock Service Worker\"\n[6]: https://openapi-generator.tech/docs/generators/typescript/?utm_source=chatgpt.com \"Documentation for the typescript Generator\"\n[7]: https://tanstack.com/query/latest/docs?utm_source=chatgpt.com \"Overview | TanStack Query React Docs\"\n[8]: https://www.typescriptlang.org/docs/handbook/declaration-merging.html?utm_source=chatgpt.com \"Documentation - Declaration Merging\"\n[9]: https://stackoverflow.com/questions/52637028/how-can-i-use-typescripts-declaration-merging-with-an-interface-imported-from-a?utm_source=chatgpt.com \"How can I use Typescript's declaration merging with an ...\"\n[10]: https://futurestud.io/tutorials/typescript-module-augmentation-overwrites-declarations-instead-of-merging-them?utm_source=chatgpt.com \"TypeScript — Module Augmentation Overwrites Declarations ...\"\n[11]: https://zod.dev/?utm_source=chatgpt.com \"Zod: Intro\"\n[12]: https://www.zodios.org/?utm_source=chatgpt.com \"Zodios | Zodios\"\n[13]: https://www.npmjs.com/package/%40zodios/axios?activeTab=readme&utm_source=chatgpt.com \"zodios/axios\"\n[14]: https://github.com/orval-labs/orval?utm_source=chatgpt.com \"orval-labs/orval\"\n[15]: https://www.npmjs.com/package/orval?utm_source=chatgpt.com \"orval\"\n[16]: https://github.com/ferdikoomen/openapi-typescript-codegen?utm_source=chatgpt.com \"ferdikoomen/openapi-typescript-codegen\"\n[17]: https://axios-http.com/docs/multipart?utm_source=chatgpt.com \"Multipart Bodies | Axios Docs\"\n[18]: https://github.com/axios/axios/issues/5067?utm_source=chatgpt.com \"Content type changed from multipart/form-data to ...\"\n[19]: https://tanstack.com/query/v5/docs/react/guides/queries?utm_source=chatgpt.com \"TanStack Query React Docs\"\n[20]: https://stackoverflow.com/questions/75742226/cant-set-content-type-header-for-axios-with-formdata?utm_source=chatgpt.com \"Can't set Content-Type header for axios with FormData\"\n\n下面给你一套**可直接落地**的企业级请求层目录与**所有涉及文件的完整代码**（不使用 Hexo）。\n特点：不覆盖 `axios.request`、保留 `http.get/post/...` 零破坏；新增对象式入口 `http.call(options)`；类型集中在 `.d.ts` 与 `types.ts`；复杂逻辑行已在上一行加中文注释。\n\n---\n\n## 目录结构\n\n```\nsrc/\n  lib/\n    http/\n      client.ts\n      call.ts\n      types.ts\n      utils.ts\n      index.ts\n  api/\n    modules/\n      user.ts\n      price.ts\n  types/\n    http/\n      axios.d.ts\n      api.d.ts\n    common.ts\n  tests/\n    msw/\n      server.ts\n      handlers/\n        price.ts\n```\n\n> 说明：`api/__generated__`（OpenAPI 代码生成）在此略去，你可以后续接入 orval/openapi-typescript-codegen；当前示例定位为手写模块层。\n\n---\n\n## src/lib/http/types.ts\n\n```ts\nimport type {\n  AxiosInstance,\n  AxiosRequestConfig,\n  Method,\n  AxiosResponse,\n} from \"axios\";\n\n/** 请求体类型枚举 */\nexport type RequestContentType = \"json\" | \"urlencoded\" | \"formdata\";\n\n/** 对象式入参：与 axios 原生保持解耦 */\nexport interface RequestOptions<P = Record<string, any>> {\n  url: string;\n  method?: Method;\n  /** GET/HEAD 下作为查询串；非 GET/HEAD 下作为 body 的回退来源 */\n  params?: P;\n  /** 非 GET/HEAD 的首选请求体 */\n  data?: unknown;\n  /** 附加的 axios 配置（headers/timeout/signal 等） */\n  requestConfig?: AxiosRequestConfig;\n  contentType?: RequestContentType;\n}\n\n/** 统一的错误对象，可在拦截器里规约 */\nexport interface HttpError extends Error {\n  status?: number;\n  code?: number | string;\n  data?: unknown;\n  traceId?: string;\n  isNetworkError?: boolean;\n}\n\n/** 统一的响应解析器签名：返回 undefined 表示“跳过，让后续解析器或原始响应继续处理” */\nexport type ResponseParser<T = any, R = AxiosResponse<any>> = (\n  resp: R\n) => T | undefined;\n\n/** 为 http 实例扩展的方法（实现见 client.ts / call.ts） */\nexport interface HttpInstance extends AxiosInstance {\n  call<T = any, P = Record<string, any>>(\n    options: RequestOptions<P>\n  ): Promise<T>;\n  cancelAll(): void;\n  setAuthToken(token?: string | null, type?: string): void;\n  setGlobalParser(parsers: ResponseParser<any, any>[]): void;\n  setAuthorization(token: string, expires: number | Date, name?: string): void;\n  removeAuthorization(name?: string): void;\n  checkAuthorization(name?: string): boolean;\n}\n```\n\n---\n\n## src/lib/http/utils.ts\n\n```ts\n/** 将对象转为 FormData；数组按 key[] 追加；对象值 JSON.stringify */\nexport function toFormData(params?: Record<string | number, unknown>) {\n  const formData = new FormData();\n  if (!params) return formData;\n  Object.entries(params).forEach(([k, v]) => {\n    if (Array.isArray(v)) {\n      v.forEach((val) =>\n        formData.append(\n          `${k}[]`,\n          typeof val === \"object\" ? JSON.stringify(val) : String(val)\n        )\n      );\n    } else if (typeof v === \"object\" && v !== null) {\n      formData.append(k, JSON.stringify(v));\n    } else if (v !== null && v !== undefined) {\n      formData.append(k, String(v));\n    }\n  });\n  return formData;\n}\n\n/** 将对象转为 application/x-www-form-urlencoded（支持嵌套/数组） */\nexport function toUrlencoded(params: Record<string | number, unknown>) {\n  const urlencoded = new URLSearchParams();\n  function walk(obj: Record<string | number, unknown>, parent = \"\") {\n    for (const [k, v] of Object.entries(obj)) {\n      const key = parent ? `${parent}[${k}]` : k;\n      if (v === null || v === undefined) continue;\n      if (Array.isArray(v)) {\n        v.forEach((item) =>\n          urlencoded.append(\n            `${key}[]`,\n            typeof item === \"object\" ? JSON.stringify(item) : String(item)\n          )\n        );\n      } else if (typeof v === \"object\") {\n        walk(v as Record<string | number, unknown>, key);\n      } else {\n        urlencoded.append(key, String(v));\n      }\n    }\n  }\n  walk(params);\n  return urlencoded;\n}\n```\n\n---\n\n## src/lib/http/call.ts\n\n```ts\nimport type { AxiosRequestConfig } from \"axios\";\nimport qs from \"qs\";\nimport type { RequestOptions } from \"./types\";\nimport { toFormData, toUrlencoded } from \"./utils\";\n\n/** 复杂逻辑上一行注释：根据 contentType 组织 body 并设置 headers/paramsSerializer */\nexport function buildAxiosConfigFromOptions(\n  options: RequestOptions\n): AxiosRequestConfig {\n  const {\n    url,\n    method = \"GET\",\n    params,\n    data,\n    requestConfig,\n    contentType = \"json\",\n  } = options;\n\n  if (!url) throw new Error(\"Missing url\");\n\n  const cfg: AxiosRequestConfig = {\n    ...(requestConfig || {}),\n    url,\n    method,\n    headers: {\n      // 默认 Content-Type，稍后允许外部覆盖；formdata 会主动删除以让浏览器自动带 boundary\n      \"Content-Type\":\n        contentType === \"urlencoded\"\n          ? \"application/x-www-form-urlencoded\"\n          : \"application/json\",\n      ...(requestConfig?.headers || {}),\n    },\n  };\n\n  if (method === \"GET\" || method === \"HEAD\") {\n    cfg.params = params ?? requestConfig?.params;\n    // 复杂逻辑上一行注释：数组无索引、跳过 null\n    cfg.paramsSerializer = (d) =>\n      qs.stringify(d, { indices: false, skipNulls: true });\n  } else {\n    // 复杂逻辑上一行注释：优先 data，回退 params（兼容旧思路）\n    const body = data ?? params ?? requestConfig?.data;\n    if (contentType === \"formdata\") {\n      // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type\n      if (cfg.headers) delete (cfg.headers as any)[\"Content-Type\"];\n      cfg.data = body instanceof FormData ? body : toFormData(body as any);\n    } else if (contentType === \"urlencoded\") {\n      cfg.data =\n        body instanceof URLSearchParams\n          ? body\n          : toUrlencoded((body ?? {}) as Record<string, any>);\n      cfg.headers = {\n        ...cfg.headers,\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      };\n    } else {\n      cfg.data = body;\n      cfg.headers = { ...cfg.headers, \"Content-Type\": \"application/json\" };\n    }\n  }\n  return cfg;\n}\n```\n\n---\n\n## src/lib/http/client.ts\n\n```ts\nimport axios from \"axios\";\nimport Cookie from \"js-cookie\";\nimport storage from \"store\";\nimport type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from \"axios\";\nimport type { HttpInstance, ResponseParser } from \"./types\";\nimport { buildAxiosConfigFromOptions } from \"./call\";\nimport { STORAGE_KEYS } from \"@/constants\";\nimport { LOGIN_ROUTE } from \"@/router/constants\";\n\nconst { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;\n\n/** —— 取消池：统一管理所有请求的 AbortController —— */\nconst abortPool = new Set<AbortController>();\n\n/** 对外暴露：集中取消所有未决请求（如退出登录时） */\nfunction cancelAll() {\n  abortPool.forEach((c) => c.abort());\n  abortPool.clear();\n}\n\n/** 创建 axios 实例并安装拦截器 */\nfunction createAxiosHttp(\n  config: AxiosRequestConfig,\n  opts: {\n    authDefault?: boolean;\n    publicPrefixes?: string[];\n  } = {}\n): HttpInstance {\n  const authDefault = opts.authDefault ?? true;\n  const publicPrefixes = opts.publicPrefixes ?? [\"/api/pub\"];\n\n  const _axios = axios.create(config) as AxiosInstance;\n\n  // —— 业务增强：全局解析器（按顺序尝试，返回 undefined 表示跳过） ——\n  (_axios as any).setGlobalParser = (parsers: ResponseParser<any, any>[]) => {\n    _axios.interceptors.response.use(\n      (resp: AxiosResponse) => {\n        for (const p of parsers) {\n          const r = p(resp);\n          if (r !== undefined) return r;\n        }\n        return resp;\n      },\n      (err) => {\n        if (err?.response) {\n          const e: any = new Error(err.response.statusText);\n          e.status = err.response.status;\n          e.code = err.response.data?.code;\n          e.data = err.response.data;\n          throw e;\n        }\n        // 网络层错误（超时/断网/跨域）\n        const e: any = new Error(err?.message || \"Network Error\");\n        e.isNetworkError = true;\n        throw e;\n      }\n    );\n  };\n\n  // —— cookie 鉴权工具方法（部分场景需要，同你原实现保持一致） ——\n  (_axios as any).setAuthorization = (\n    token: string,\n    expires: number | Date,\n    name?: string\n  ) => {\n    Cookie.set(name ?? _axios.defaults.xsrfCookieName!, token, { expires });\n  };\n  (_axios as any).removeAuthorization = (name?: string) => {\n    Cookie.remove(name ?? _axios.defaults.xsrfCookieName!);\n  };\n  (_axios as any).checkAuthorization = (name?: string) => {\n    return Boolean(Cookie.get(name ?? _axios.defaults.xsrfCookieName!));\n  };\n\n  // —— 请求拦截器：统一接入取消池/授权头/公开前缀 ——\n  _axios.interceptors.request.use((req) => {\n    // 复杂逻辑上一行注释：桥接外部 signal 与内部 AbortController，并加入取消池\n    const abortController = new AbortController();\n    if ((req as any).signal) {\n      const ext = (req as any).signal as AbortSignal;\n      if (ext.aborted) abortController.abort();\n      else ext.addEventListener?.(\"abort\", () => abortController.abort());\n    }\n    (req as any).signal = abortController.signal;\n    abortPool.add(abortController);\n    // 复杂逻辑上一行注释：把 controller 暂存在 config 上，响应阶段释放\n    (req as any).__abortController = abortController;\n\n    // 复杂逻辑上一行注释：根据前缀与开关决定是否附加 Authorization\n    const url = req.url || \"\";\n    const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));\n    // 优先使用 req.auth(boolean)；否则用实例默认值 + 前缀约定\n    const explicitAuth =\n      typeof (req as any).auth === \"boolean\" ? (req as any).auth : undefined;\n    const needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);\n    const accToken = storage.get(ACCESS_TOKEN);\n    const tokenType = storage.get(TOKEN_TYPE) || \"Bearer\";\n    if (needAuth && !accToken) {\n      ((req as any).__abortController as AbortController | undefined)?.abort();\n      return Promise.reject(new Error(\"UNAUTHENTICATED\"));\n    }\n    if (needAuth && accToken) {\n      req.headers = {\n        ...req.headers,\n        Authorization: `${tokenType} ${accToken}`,\n      };\n    }\n    return req;\n  });\n\n  // —— 响应拦截器：释放取消控制器；401 统一处理 ——\n  _axios.interceptors.response.use(\n    (res) => {\n      const abortController = (res.config as any).__abortController as\n        | AbortController\n        | undefined;\n      if (abortController) abortPool.delete(abortController);\n      return res;\n    },\n    (err) => {\n      if (err?.response?.status === 401) {\n        storage.remove(ACCESS_TOKEN);\n        storage.remove(TOKEN_TYPE);\n        if (window.location.pathname !== LOGIN_ROUTE.path) {\n          window.location.replace(LOGIN_ROUTE.path);\n        }\n      }\n      const abortController = (err?.config as any)?.__abortController as\n        | AbortController\n        | undefined;\n      if (abortController) abortPool.delete(abortController);\n      return Promise.reject(err);\n    }\n  );\n\n  // —— 实例级取消 ——\n  (_axios as any).cancelAll = cancelAll;\n\n  // —— 实例级鉴权头设置（与本地存储联动） ——\n  (_axios as any).setAuthToken = (token?: string | null, type = \"Bearer\") => {\n    if (token) {\n      _axios.defaults.headers.common.Authorization = `${type} ${token}`;\n      storage.set(ACCESS_TOKEN, token);\n      storage.set(TOKEN_TYPE, type);\n    } else {\n      delete _axios.defaults.headers.common.Authorization;\n      storage.remove(ACCESS_TOKEN);\n      storage.remove(TOKEN_TYPE);\n    }\n  };\n\n  // —— 新增对象式入口：http.call(options) ——\n  (_axios as any).call = async function <T = any>(\n    options: Parameters<typeof buildAxiosConfigFromOptions>[0]\n  ): Promise<T> {\n    const cfg = buildAxiosConfigFromOptions(options);\n    return _axios.request(cfg) as Promise<T>;\n  };\n\n  return _axios as unknown as HttpInstance;\n}\n\nconst http = createAxiosHttp(\n  {\n    timeout: 10000,\n    baseURL: import.meta.env.VITE_API_URL as string,\n    withCredentials: true,\n    xsrfCookieName: \"Authorization\",\n    xsrfHeaderName: \"Authorization\",\n  },\n  { authDefault: true, publicPrefixes: [\"/api/pub\"] }\n);\n\nexport default http;\nexport { cancelAll };\n```\n\n---\n\n## src/lib/http/index.ts\n\n```ts\nexport { default as http, cancelAll } from \"./client\";\nexport * from \"./types\";\nexport * from \"./utils\";\nexport * from \"./call\";\n```\n\n---\n\n## src/api/modules/user.ts\n\n```ts\nimport { http } from \"@/lib/http\";\nimport type { RequestOptions } from \"@/lib/http/types\";\n\n/** 复杂逻辑上一行注释：领域 API 薄封装，避免页面直接感知 URL/方法/解析细节 */\nexport const userApi = {\n  getProfile() {\n    return http.get<{ id: string; name: string; roles: string[] }>(\n      \"/api/user/profile\"\n    );\n  },\n\n  updateProfile(input: { name?: string }) {\n    return http.call<void>({\n      url: \"/api/user/profile\",\n      method: \"PUT\",\n      data: input,\n      contentType: \"json\",\n    });\n  },\n\n  /** 演示：URLSearchParams */\n  search(params: { keyword?: string; page?: number }) {\n    const options: RequestOptions<typeof params> = {\n      url: \"/api/user/search\",\n      method: \"GET\",\n      params,\n      requestConfig: { timeout: 8000 },\n    };\n    return http.call<{ list: any[]; total: number }>(options);\n  },\n};\n```\n\n---\n\n## src/api/modules/price.ts\n\n```ts\nimport { http } from \"@/lib/http\";\n\n/** 复杂逻辑上一行注释：后端采用 CodeResponse 外包裹，交由全局解析器转换 */\nexport const priceApi = {\n  getTrend(input: { gameId: string; stores: string[] }) {\n    return http.call<Array<{ store: string; date: string; price: number }>>({\n      url: \"/api/price/trend\",\n      method: \"POST\",\n      data: input,\n      contentType: \"json\",\n      requestConfig: { timeout: 15000 },\n    });\n  },\n};\n```\n\n---\n\n## src/types/http/axios.d.ts\n\n```ts\n// 声明合并：扩展 AxiosInstance，而不改动运行时代码\nimport type { AxiosRequestConfig } from \"axios\";\n\ndeclare module \"axios\" {\n  export interface AxiosInstance {\n    call<T = any, P = Record<string, any>>(options: {\n      url: string;\n      method?: Method;\n      params?: P;\n      data?: unknown;\n      requestConfig?: AxiosRequestConfig;\n      contentType?: \"json\" | \"urlencoded\" | \"formdata\";\n    }): Promise<T>;\n\n    cancelAll(): void;\n    setAuthToken(token?: string | null, type?: string): void;\n    setGlobalParser(parsers: Array<(resp: any) => any | undefined>): void;\n    setAuthorization(\n      token: string,\n      expires: number | Date,\n      name?: string\n    ): void;\n    removeAuthorization(name?: string): void;\n    checkAuthorization(name?: string): boolean;\n  }\n}\n```\n\n---\n\n## src/types/http/api.d.ts\n\n```ts\n// 与后端约定的通用响应外壳\nexport interface CodeResponse<T = any> {\n  code: number;\n  data: T;\n  message?: string;\n}\n\n// 常见分页返回\nexport interface PageResp<T> {\n  list: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\n// 解析器（如果你希望有全局类型）\nexport type ResponseParser<T = any, R = any> = (resp: R) => T | undefined;\n```\n\n---\n\n## src/types/common.ts\n\n```ts\n// 放与请求无关的通用类型\nexport type ID = string | number;\n\nexport interface Dict<T = any> {\n  [key: string]: T;\n}\n```\n\n---\n\n## （可选）全局解析器：将 CodeResponse<T> 解开\n\n> 你可以把它放到任意初始化位置（如 `src/app.ts` 或 `src/main.ts`）并在启动时挂载。\n\n```ts\n// src/app.setup-http.ts\nimport type { AxiosResponse } from \"axios\";\nimport { http } from \"@/lib/http\";\nimport { LOGIN_ROUTE } from \"@/router/constants\";\nimport storage from \"store\";\nimport { STORAGE_KEYS } from \"@/constants\";\nimport type { CodeResponse } from \"@/types/http/api\";\n\nconst { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;\n\n/** 复杂逻辑上一行注释：仅处理符合 CodeResponse 形状的响应，其他透传 */\nfunction isCodeResp<T>(d: unknown): d is CodeResponse<T> {\n  return (\n    !!d && typeof d === \"object\" && \"code\" in (d as any) && \"data\" in (d as any)\n  );\n}\n\nexport const codeResponseParser = <T, R = CodeResponse<T>>(\n  res: AxiosResponse<R>\n): T | undefined => {\n  const payload = res.data as any;\n  if (!isCodeResp<T>(payload)) return undefined;\n  const { code, data, message = \"\" } = payload;\n\n  if (code === 401) {\n    storage.remove(ACCESS_TOKEN);\n    storage.remove(TOKEN_TYPE);\n    if (window.location.pathname !== LOGIN_ROUTE.path) {\n      window.location.replace(LOGIN_ROUTE.path);\n    }\n    throw new Error(\"未授权，请重新登录\");\n  }\n  if (code === 200) return (data ?? null) as T;\n  throw new Error(message || \"后端错误\");\n};\n\n// 启动时挂载\nhttp.setGlobalParser([codeResponseParser]);\n```\n\n---\n\n## tests/msw/server.ts\n\n```ts\nimport { setupServer } from \"msw/node\";\nimport { handlers } from \"./handlers/price\";\n\nexport const server = setupServer(...handlers);\n\n// 在测试框架的 setup 中调用：\n// beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }))\n// afterEach(() => server.resetHandlers())\n// afterAll(() => server.close())\n```\n\n---\n\n## tests/msw/handlers/price.ts\n\n```ts\nimport { http, HttpResponse } from \"msw\";\n\n// 示例：与你的 priceApi.getTrend 匹配\nexport const handlers = [\n  http.post(\"/api/price/trend\", async ({ request }) => {\n    const body = (await request.json()) as any;\n    // 复杂逻辑上一行注释：模拟后端的 CodeResponse 外壳\n    return HttpResponse.json({\n      code: 200,\n      data: [\n        { store: \"Steam\", date: \"2025-09-01\", price: 199 },\n        { store: \"Epic\", date: \"2025-09-01\", price: 189 },\n      ],\n      message: \"ok\",\n    });\n  }),\n];\n```\n\n---\n\n# 使用要点\n\n- 老代码：`http.get/post/...` **完全不受影响**。\n- 新写法：`http.call({ url, method, data/params, contentType, requestConfig })` 更可读/可扩展。\n- `FormData` 场景不要手设 `Content-Type`，已在实现里处理。\n- 推荐在应用初始化处挂载 `codeResponseParser`，让模块层拿到的就是“已解壳”的数据。\n\n如果你要把你现有的 `api.d.ts / axios.d.ts / common.ts` 内容**原封不动**迁入以上文件名，也可以把原定义贴出来，我帮你对齐/去重并完善类型冲突的 diff。\n\n下面把你要的 **`cancel.ts` 完整代码**给出，并说明如何在 `client.ts` 接入；最后把 “FormData 自动带 boundary，需移除手动设置的 Content-Type” 的含义讲清楚。\n\n---\n\n## 1) `src/lib/http/cancel.ts`（完整代码）\n\n```ts\n// src/lib/http/cancel.ts\n\n/**\n * 维护一个全局取消池，用于集中取消所有尚未完成的请求。\n * 注意：只存放“活跃中的” AbortController；请求结束后要及时释放。\n */\nconst abortPool = new Set<AbortController>();\n\n/** 复杂逻辑上一行注释：把外部 signal（若有）与内部 controller 绑定，外部取消时联动内部取消 */\nfunction linkExternalSignal(\n  external?: AbortSignal,\n  controller?: AbortController\n) {\n  if (!external || !controller) return;\n  if (external.aborted) {\n    // 外部已取消则立即同步内部取消\n    controller.abort();\n    return;\n  }\n  // 外部后续取消时，触发内部取消\n  external.addEventListener(\"abort\", () => controller.abort());\n}\n\n/**\n * 创建一个“已纳入取消池管理”的 AbortController。\n * - 会自动与外部 signal（如果传入）联动；\n * - 会自动加入全局 abortPool，方便统一取消；\n * - 调用方需在请求完成/失败时调用 releaseController 释放。\n */\nexport function makeTrackedController(\n  externalSignal?: AbortSignal\n): AbortController {\n  const controller = new AbortController();\n  linkExternalSignal(externalSignal, controller);\n  abortPool.add(controller);\n  return controller;\n}\n\n/** 将 controller 从取消池释放（请求完成/失败时务必调用，避免内存泄漏） */\nexport function releaseController(controller?: AbortController) {\n  if (controller) abortPool.delete(controller);\n}\n\n/** 退出登录或全局重置时：集中取消所有未决请求 */\nexport function cancelAll() {\n  abortPool.forEach((c) => c.abort());\n  abortPool.clear();\n}\n```\n\n---\n\n## 2) 在 `client.ts` 中的**最小改动**\n\n> 按你的偏好，这里**只给需要改的片段**，并在复杂逻辑上一行加注释。\n\n**2.1 顶部引入：**\n\n```ts\n// + 新增\nimport { makeTrackedController, releaseController, cancelAll } from \"./cancel\";\n```\n\n**2.2 删除原本在 client.ts 里的这两段：**\n\n```ts\n// - 删除\nconst abortPool = new Set<AbortController>();\nfunction cancelAll() {\n  /* ...原实现... */\n}\n```\n\n**2.3 请求拦截器里替换创建/管理 controller 的逻辑：**\n\n```ts\n// —— 将外部 signal 与内部 AbortController 关联，并纳入统一取消池 ——\nconst abortController = makeTrackedController(\n  (req as any).signal as AbortSignal | undefined\n);\n(req as any).signal = abortController.signal;\n(req as any).__abortController = abortController;\n```\n\n**2.4 响应与异常分支里释放 controller：**\n\n```ts\n// —— 请求完成：释放与该请求关联的 AbortController ——\nreleaseController(\n  (res.config as any).__abortController as AbortController | undefined\n);\n\n// —— 异常完成：同样需要释放 AbortController ——\nreleaseController(\n  (err?.config as any)?.__abortController as AbortController | undefined\n);\n```\n\n**2.5 保持对外暴露实例方法：**\n\n```ts\n// 实例级的取消功能依然可用\n(_axios as any).cancelAll = cancelAll;\n```\n\n> 这样，取消逻辑就从 `client.ts` 拆分到了独立的 `cancel.ts`，便于复用与测试；`client.ts` 里只保留“如何在拦截器中使用”的胶水代码。\n\n---\n\n## 3) “FormData 自动带 boundary，需移除手动设置的 Content-Type” 是啥意思？\n\n- 当你在**浏览器环境**用 `FormData` 作为请求体时，真正发请求的是浏览器（或者 fetch/XHR），它会自动把请求头 `Content-Type` 设置成：\n\n  ```\n  Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXyz...\n  ```\n\n  这里的 `boundary` 是一段**分隔符**，用来把每个字段/文件的二进制块分割开。**这个 boundary 是浏览器动态生成的**。\n\n- **如果你手动把 `Content-Type` 固定写成 `multipart/form-data`**（没有 `boundary=...`），服务端收到的内容就**无法正确分段解析**，经常出现 400/422 或 “Unexpected end of form / Missing boundary” 之类错误。\n\n- 因此，在我们封装里（`contentType === 'formdata'` 分支）会：\n\n  ```ts\n  // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type\n  if (cfg.headers) delete (cfg.headers as any)[\"Content-Type\"];\n  cfg.data = body instanceof FormData ? body : toFormData(body as any);\n  ```\n\n  这么做是**故意**把 `Content-Type` 删除，让浏览器自己填上带 `boundary` 的正确值。\n\n> 小结：\n>\n> - **浏览器 + FormData**：不要手写 `Content-Type`，让它自动带 boundary（我们代码里已处理）。\n> - **Node.js 端（无浏览器）**：若用 `form-data`/`formdata-node` 等库，也应**让库自己设置**或通过库提供的方法拿到带 `boundary` 的 header，而不是手写。\n\n---\n\n需要我把 `client.ts` 根据上面的片段**整合成完整文件**再贴一次，也可以说一声；但如果你已经在用我之前给的版本，只要按上面的 4 处小改即可完成 `cancel.ts` 的接入。\n\n简短结论先给你：\n\n- **Axios 封装没有“唯一正确解”**，但大厂普遍遵循“**分层 + 零破坏 + 渐进演进**”三原则：\n  Core（http 客户端能力）→ Domain API（领域方法）→ View/State（查询层）。\n- **TanStack Query（React Query / Vue Query）不是必须**。当你的页面需要**缓存、并发去重、重试、后台刷新、预取、分页/无限滚动、乐观更新**中的多项时，它的价值非常高；否则可以先不用，等复杂度上来了再加。\n\n下面给你一套“可落地的选择题”，帮你快速拍板。\n\n---\n\n## 一、Axios 封装到底怎么选？\n\n### 方案 A：**极简封装（Core + 少量 Domain API）**\n\n适用：后端接口简单、页面少、交互不复杂，或以 **Server Actions/Route Handlers（Next.js 14）** 为主、客户端请求很少。\n要点：\n\n- Core 层：一个 `http` 实例（拦截器、取消池、统一错误、鉴权）、`http.call(options)` 对象式入口（你现在这版 ✅）。\n- Domain 层：在 `src/api/modules/*` 里写薄封装函数（避免在页面拼 URL/方法）。\n  优点：学习/维护成本最低；对现有代码**零破坏**。\n  缺点：项目一复杂，**缓存/并发/重试**容易重复造轮子。\n\n### 方案 B：**标准化封装（Core + Domain API + 代码生成）**\n\n适用：接口较多、多人协作、需要**强类型**对齐后端（避免“文档/实现漂移”）。\n要点：\n\n- 在 A 的基础上加 **OpenAPI 代码生成**（orval/openapi-typescript-codegen），产物放 `api/__generated__`，**只读、不手改**。\n- Domain 层再包一层“门面”，统一错误处理/埋点/灰度。\n  优点：类型和接口更新**自动跟进**；减少手抄 DTO。\n  缺点：引入生成链路，需要后端提供/维护 OpenAPI。\n\n### 方案 C：**企业级（Core + Domain + 代码生成 + 查询层 TanStack）**\n\n适用：**列表/详情很多**、需要**缓存/失效/后台刷新/并发去重/预取/SSR**等能力；或你已经遇到“重复请求、抖动、复杂 loading 状态”问题。\n要点：\n\n- 在 B 的基础上引入 **TanStack Query（React）/Vue Query（Vue3）** 做服务端状态管理。\n- 页面里不直接 `http.call`，而是用 `useQuery/useMutation` 调你封装好的 Domain API。\n  优点：把“**缓存/并发/重试/错误边界/重整化**”交给成熟库，页面只管渲染。\n  缺点：学习成本 ↑，需要 Provider 初始化与查询键设计。\n\n---\n\n## 二、到底要不要用 TanStack Query？（自测 8 题）\n\n请数一数你满足了多少条（≥3 条就**建议上**）：\n\n1. 同一数据被**多处页面/组件复用**，且你想要**共享缓存**。\n2. 同一接口在短时间内可能被**多次触发**（需要**请求去重**）。\n3. 希望**失败自动重试**、**退避**，或在**网络恢复**/**窗口聚焦**时自动**后台刷新**。\n4. 有**分页/无限滚动**，并且要处理**下一页预取**或**乐观更新**。\n5. 需要**预取数据**（用户悬停/路由即将跳转时先打请求）。\n6. 你在做 **Next.js 14** 前端页面，既有 **Server Components** 也有 **Client Components**，客户端数据要**SSR Hydration** 或 **延迟刷新**。\n7. 想**显式管理缓存过期（staleTime）** 与 **垃圾回收（gcTime）**，防止反复打接口。\n8. 现在已经在手写“请求缓存/合流/状态机”，感觉**心智负担**上来了。\n\n> 结合你的项目：有**价格趋势**、**多商店选择**、**首页与详情复用价格数据**、后续还要**图表/列表**，我建议：\n>\n> - 在**这些“读多写少”的模块**上用 TanStack Query；\n> - 其他简单页面（一次性拉取、无复杂刷新），继续用现在的 `http.call` 即可。\n>   这样“**按需引入**”，增量演进，不会一刀切。\n\n---\n\n## 三、你现在的最佳落地路线（最少折腾）\n\n1. **保留现有 http 层（你已完成）**\n\n   - `client.ts + cancel.ts + call.ts + types.ts + utils.ts`，不覆盖 `axios.request`，**零破坏**保留 `get/post`。\n\n2. **Domain API 薄封装**\n\n   - 在 `src/api/modules/*` 暴露语义化函数（`priceApi.getTrend`等），页面不拼 URL。\n\n3. **对“需要缓存/并发去重”的模块上 TanStack Query**\n\n   - 只在“价格趋势、榜单、列表”这些位置用 Query，其它模块不强求。\n\n4. **后续再接 OpenAPI 代码生成**（可选）\n\n   - 先让 Query 跑顺，再把类型维护成本转移给生成器，逐步替换手写 DTO。\n\n5. **MSW 做联调与测试**（可选）\n\n   - 本地/CI 统一拦截，减少后端不可用带来的卡点。\n\n---\n\n## 四、常见误区（避免踩坑）\n\n- **覆写 `axios.request`** → 破坏 `get/post` 的语义（你已经改成 `.call`，很对）。\n- **手写 `Content-Type: multipart/form-data`** → FormData 的 `boundary` 会丢（我们已在 `formdata` 分支删除该头，让浏览器自动带）。\n- **在组件里定义 DTO/类型** → 类型四散；建议集中到 `types/http/*` 与 `api/__generated__`。\n- **重复写缓存/重试/去重** → 已有成熟轮子（TanStack Query）；自己写容易遗漏边角。\n- **取消控制器不释放** → 造成内存泄漏；我们用 `releaseController` 在响应/异常两侧都释放。\n\n---\n\n## 五、如果暂时不用 TanStack Query，也能稳住吗？\n\n可以。你的 `http.call + modules` 架构，配合\\*\\*轻量的自定义缓存（Map + 过期时间）\\*\\*也能顶一阵子。但一旦出现“**相同查询在多处使用**”、“**滚动列表/分页**”、“**需要重试与后台刷新**”的需求，**切到 TanStack Query 成本更低**（只需把 Domain API 包进 `useQuery`），没必要造大轮子。\n\n---\n\n### 你现在可以怎么做（两步）：\n\n- **短期**：继续用现有封装；把价格趋势这块接入 Query（仅此一处），体会收益。\n- **中期**：如果感觉不错，再把“新闻列表/攻略列表”等也迁到 Query；并考虑引入 OpenAPI 代码生成，降低类型维护成本。\n\n需要的话，我可以基于你现有的模块，直接给出**一个最小的 TanStack Query 集成示例**（包含 Provider、`useQuery` 的示例调用、SSR Hydration 的注意点），只贴**必要的代码片段**，不改你现有文件结构。\n\n结论：**你的“核心响应拦截器”（释放 AbortController + 401 跳转）先执行，`setGlobalParser` 里注册的“全局解析器”后执行**。\n\n原因（Axios 规则）：\n\n- **response 拦截器是 FIFO**：谁**先注册**，谁**先执行**。\n- **request 拦截器是 LIFO**：谁**后注册**，谁**先执行**。（顺带一提）\n\n在你这份代码里：\n\n1. `createAxiosHttp` 里先注册了“核心响应拦截器”。\n2. 应用启动时再调用 `http.setGlobalParser([...])`，此时**追加**一个响应拦截器。\n   → 因为 response 是 FIFO，所以**核心拦截器先跑**，**全局解析器后跑**。\n\n执行顺序具体是：\n\n- **成功响应路径 (`fulfilled`)**\n  ① 核心响应拦截器：`releaseController(...)` → `return res`\n  ② 全局解析器：遍历 parsers，可能把 `AxiosResponse` 解包成你的业务数据（或继续返回原响应）\n\n- **失败响应路径 (`rejected`)**\n  ① 核心响应拦截器：遇到 `401` 清 token + 跳登录；不管什么错误都先 `releaseController(...)`；`return Promise.reject(err)`\n  ② 全局解析器：拿到上一步抛出的 `err`，再做标准化/改写错误对象（如果你这么实现）\n\n> 小提示：如果你**想让全局解析器先执行**，就必须**更早注册**它（例如把 `setGlobalParser` 的安装逻辑挪到 `createAxiosHttp` 里、并放在核心拦截器之前），或者在核心拦截器内部先调用解析器再做释放/跳转。但你当前这种“先释放/401，再解析”的顺序其实更稳：能确保无论成功还是失败，**先释放资源**再做业务级处理，避免泄漏。\n",
            "url": "https://herongdev.github.io/blog/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线",
            "title": "「请求层大重构」——从散乱到企业级：类型、目录与演进路线",
            "date_modified": "2025-09-06T11:58:07.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）",
            "content_html": "\n## 课程目标\n\n- 建立“从信号到因果”的定位方法论与可复现流程\n- 搭建最小可复现（MRE）、观测面板与基准测试\n- 交付可投递的复盘报告与改进方案\n\n## 课程大纲\n\n- Week 1：问题定义与信号采集（日志/指标/Trace 基线）\n- Week 2：复现场景与最小复现（MRE），错误预算与 SLO\n- Week 3：定位技术：长任务/网络抖动/资源争用/内存泄漏\n- Week 4：治理与回归：限流/熔断/幂等/回滚、回归基线\n- Week 5（可选）：端到端演练：灰度、回滚演练、事故演习\n- Week 6（可选）：Capstone 展示与简历/作品集打磨\n\n## 日程（示例 4 周）\n\n- 每周 2 次直播/录播 + 1 次作业走查 + 1 次办公小时\n- 每周固定提交：MRE 仓库、观测截图、复盘报告\n\n## 作业与考核\n\n- 作业 1：采集与基线（日志/指标/Trace 基线 + 一处异常信号）\n- 作业 2：最小可复现（MRE）与故障注入脚本\n- 作业 3：定位与因果链报告（含观测和对照）\n- 作业 4：治理与回归（限流/熔断/幂等/回滚）\n- 考核维度：正确性、鲁棒性、可观测、复盘完整性、表达与协作\n\n## 度量指标\n\n- 平均问题解决时长（前/后测）\n- 80 分位问题解决时长\n- 回滚率、事故率、SLO 改善\n- 作业通过率、复盘报告评分、作品集完成率\n\n## 落地素材清单（结合你现有文章）\n\n- 请求层与鉴权（目录：`架构与请求/请求层`）\n- Vue 性能与交互（目录：`前端/Vue`）\n- 实时通信与网络抖动（目录：`前端/实时通信`）\n- 登录与会话问题（目录：`前端/鉴权-登录`）\n- 下载/直链 vs 鉴权（目录：`前端/下载与文件`）\n- Web 推送与标识（目录：`Web-API-与推送`）\n\n> 每周选择 1 ～ 2 篇相关文章作为阅读材料与作业素材；\n> 每篇文章配套：MRE 仓库（或片段）、观测面板截图、复盘要点 Checklist。\n",
            "url": "https://herongdev.github.io/blog/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）",
            "title": "生产问题复盘：试点班（大纲/日程/作业/度量/素材）",
            "summary": "基于真实生产问题的 4～6 周训练营方案：大纲、日程、作业与考核、度量指标与落地素材清单。",
            "date_modified": "2025-09-09T00:00:00.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys：options",
            "content_html": "\n> 适用版本：**@simplewebauthn/server v11+**\n> 重点变化：`pubKeyCredParams` ➜ `supportedAlgorithmIDs`；注册验证结果中的 `credentialID/credentialPublicKey` ➜ 移到 `registrationInfo.credential`。\n\n# 一、两类 options 是什么？\n\n- **注册（Creation）**：发给前端 `navigator.credentials.create({ publicKey })` 的参数\n\n  - 服务器生成：`generateRegistrationOptions(opts)`\n  - 前端收到的是 **PublicKeyCredentialCreationOptions(JSON)**\n\n- **登录（Request/Assertion）**：发给前端 `navigator.credentials.get({ publicKey })` 的参数\n\n  - 服务器生成：`generateAuthenticationOptions(opts)`\n  - 前端收到的是 **PublicKeyCredentialRequestOptions(JSON)**\n\n> 前端 JSON 里的 `challenge` / `user.id` 等，通常是 **base64url** 字符串；服务端入参多数用 **Buffer/Uint8Array**。\n\n# 二、注册：服务端入参 & 前端 options 全量长相\n\n## 2.1 服务端入参（`generateRegistrationOptions(opts)`）\n\n```ts\nconst options = await generateRegistrationOptions({\n  // —— RP（你的站点） ——\n  rpName: \"Shop Thrive\", // 展示名（弹窗可见）\n  rpID: \"example.com\", // RP ID（域名，需与前端同源后缀匹配）\n\n  // —— 用户信息（必须） ——\n  // 注意：userID 必须是字节数组（Uint8Array/Buffer），不是 string\n  userID: Buffer.from(\"user-123\", \"utf8\"),\n  userName: \"user-123\", // 可读名（设备 UI 展示）\n  userDisplayName: \"Alice Zhang\", // 可选；不传时库会处理\n\n  // —— 安全策略 ——\n  // v11+：用 supportedAlgorithmIDs 指定算法（替代 pubKeyCredParams）\n  // 常用：-7=ES256；如需兼容更广，可加 -257=RS256/-8=EdDSA 等\n  supportedAlgorithmIDs: [-7, -257],\n\n  // 要求/偏好做本地用户验证（UV：指纹/人脸/PIN）\n  // 'required' | 'preferred' | 'discouraged'\n  userVerification: \"required\",\n\n  // 选择哪类认证器与凭证形态\n  authenticatorSelection: {\n    // 'platform'（本机/系统）| 'cross-platform'（外接/钥匙）| 不填（都可）\n    authenticatorAttachment: \"platform\",\n    // 要不要可发现凭证（resident key），用于“无用户名一键登录”\n    // 'required' | 'preferred' | 'discouraged'\n    residentKey: \"required\",\n    // 旧字段（某些库还在）：requireResidentKey: true,\n  },\n\n  // 证明链/隐私：'none' | 'indirect' | 'direct' | 'enterprise'\n  attestationType: \"none\",\n\n  // —— 体验/兼容 ——\n  timeout: 60_000, // 毫秒\n  excludeCredentials: [\n    // 防重复注册（可选）\n    {\n      id: Buffer.from(\"...\", \"base64url\"),\n      type: \"public-key\",\n      transports: [\"internal\", \"usb\"],\n    },\n  ],\n\n  // —— 扩展（按需） ——\n  extensions: {\n    credProps: true, // 要求返回“是否可发现凭证”等属性\n    // largeBlob: { support: 'required' | 'preferred' },\n    // hmacCreateSecret: true,\n    // // 老 FIDO 兼容场景：\n    // appidExclude: 'https://example.com'\n  },\n});\n```\n\n### COSE 算法常用映射\n\n| ID              | 名称                  | 说明                                        |\n| --------------- | --------------------- | ------------------------------------------- |\n| **-7**          | ES256                 | ECDSA w/ SHA-256（最常用，passkey 默认）    |\n| **-257**        | RS256                 | RSA w/ SHA-256（更广兼容）                  |\n| **-8**          | EdDSA                 | 常见为 Ed25519（浏览器/平台支持度差异较大） |\n| -35 / -36       | ES384 / ES512         | 更高位椭圆曲线                              |\n| -38 / -39 / -40 | PS256 / PS384 / PS512 | RSA-PSS 系列                                |\n\n> 生产一般 `[-7]` 足够；如有老设备需求，可加 `-257`。\n\n---\n\n## 2.2 前端收到的 **注册 options（完整 JSON 示例）**\n\n```json\n{\n  \"rp\": { \"name\": \"Shop Thrive\", \"id\": \"example.com\" },\n  \"user\": {\n    \"id\": \"dXNlci0xMjM\", // base64url（服务端 userID 的 JSON 形式）\n    \"name\": \"user-123\",\n    \"displayName\": \"Alice Zhang\"\n  },\n  \"challenge\": \"9P0mB1o0f1...Q\",\n  \"pubKeyCredParams\": [\n    // 注意：这是浏览器原生结构；simplewebauthn 已根据 supportedAlgorithmIDs 生成\n    { \"type\": \"public-key\", \"alg\": -7 },\n    { \"type\": \"public-key\", \"alg\": -257 }\n  ],\n  \"timeout\": 60000,\n  \"attestation\": \"none\",\n  \"authenticatorSelection\": {\n    \"authenticatorAttachment\": \"platform\",\n    \"residentKey\": \"required\",\n    \"userVerification\": \"required\"\n  },\n  \"excludeCredentials\": [\n    { \"type\": \"public-key\", \"id\": \"...\", \"transports\": [\"internal\", \"usb\"] }\n  ],\n  \"extensions\": {\n    \"credProps\": true\n  }\n}\n```\n\n> 实际上浏览器可能省略部分可选字段；**你看到的字段少，不代表“没生效”**，很多值有默认行为。\n\n# 三、登录：服务端入参 & 前端 options 全量长相\n\n## 3.1 服务端入参（`generateAuthenticationOptions(opts)`）\n\n```ts\nconst options = await generateAuthenticationOptions({\n  // —— 基本项 ——\n  rpID: \"example.com\",\n  timeout: 60_000,\n\n  // —— UV 要求 ——\n  // 'required' | 'preferred' | 'discouraged'\n  userVerification: \"preferred\",\n\n  // —— 可选：指定可用凭证（有用户名场景）\n  // 省略则启用“可发现凭证”（一键直登：浏览器列出该站点可用 passkey）\n  allowCredentials: [\n    {\n      id: Buffer.from(\"credential-id-base64url\", \"base64url\"),\n      type: \"public-key\",\n      transports: [\"internal\", \"usb\", \"nfc\", \"ble\", \"hybrid\"], // 按需\n    },\n  ],\n\n  // —— 扩展（按需） ——\n  extensions: {\n    // uvm: true,                    // 请求返回用户验证方式矩阵（支持时）\n    // appid: 'https://example.com' // 老 FIDO 兼容\n  },\n});\n```\n\n### `transports` 可能值\n\n- `usb` / `nfc` / `ble`：外接钥匙传输方式\n- `internal`：平台认证器（如 iOS/Android/Windows 内置）\n- `cable` / `hybrid`：跨设备传输（手机帮电脑解锁的流程）\n\n---\n\n## 3.2 前端收到的 **登录 options（完整 JSON 示例）**\n\n```json\n{\n  \"rpId\": \"example.com\",\n  \"challenge\": \"jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg\",\n  \"timeout\": 60000,\n  \"userVerification\": \"preferred\",\n  \"allowCredentials\": [\n    { \"type\": \"public-key\", \"id\": \"...\", \"transports\": [\"internal\", \"hybrid\"] }\n  ],\n  \"extensions\": {\n    \"uvm\": true\n  }\n}\n```\n\n> **条件式 UI（passkeys 一键直登）**：这是 `navigator.credentials.get()` 的**第二个参数**里的 `mediation: 'conditional'`，**不在** `publicKey` 这个 JSON 里。\n> 形如：\n>\n> ```ts\n> navigator.credentials.get({ publicKey: options, mediation: \"conditional\" });\n> ```\n\n---\n\n# 四、关键字段取值解释（速查表）\n\n## 4.1 `userVerification`\n\n| 值            | 含义                                                              | 推荐                   |\n| ------------- | ----------------------------------------------------------------- | ---------------------- |\n| `required`    | 必须进行本地用户验证（指纹/人脸/PIN）；不支持 UV 的认证器会被排除 | **后台/金融** 强烈推荐 |\n| `preferred`   | 优先进行 UV；不支持也可继续                                       | **通用登录** 默认      |\n| `discouraged` | 不鼓励 UV                                                         | 不推荐用于登录         |\n\n> **服务端也要对应开启**：`verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })` 才算真正强制。\n\n## 4.2 `authenticatorSelection`\n\n| 字段                      | 值                                       | 说明                                     |\n| ------------------------- | ---------------------------------------- | ---------------------------------------- |\n| `authenticatorAttachment` | `platform` / `cross-platform`            | 本机认证器 vs 外接钥匙；不填=都可        |\n| `residentKey`             | `required` / `preferred` / `discouraged` | 是否创建**可发现凭证**（一键直登的前提） |\n| `requireResidentKey`      | `boolean`                                | 旧字段；等价于 `residentKey: 'required'` |\n\n## 4.3 `attestationType`（simplewebauthn）\n\n| 值                    | 说明                     | 备注         |\n| --------------------- | ------------------------ | ------------ |\n| `none`                | 不收集证明链（隐私友好） | **最常用**   |\n| `indirect` / `direct` | 收集不同强度的证明链     | 较少用       |\n| `enterprise`          | 企业场景                 | 需要配套策略 |\n\n## 4.4 `allowCredentials` / `excludeCredentials`（描述符）\n\n```ts\n{\n  id: Uint8Array | Buffer,     // 凭证ID（服务端存 base64url，生成时转回二进制）\n  type: 'public-key',\n  transports?: ('usb'|'nfc'|'ble'|'internal'|'cable'|'hybrid')[]\n}\n```\n\n## 4.5 `supportedAlgorithmIDs`（替代 `pubKeyCredParams`）\n\n- 传 **COSE 算法 ID** 数组（见上表）。\n- 浏览器最终在前端 JSON 里仍会以 `pubKeyCredParams` 形式出现（这是 WebAuthn 原生结构），不冲突。\n\n---\n\n# 五、生产推荐模板\n\n### 注册（Creation）\n\n```ts\nawait generateRegistrationOptions({\n  rpName: \"Your App\",\n  rpID: \"yourdomain.com\",\n  userID: Buffer.from(userId, \"utf8\"),\n  userName: userNameOrEmail,\n  supportedAlgorithmIDs: [-7], // 如需更广：[-7, -257]\n  userVerification: \"required\",\n  authenticatorSelection: {\n    authenticatorAttachment: \"platform\",\n    residentKey: \"required\",\n    userVerification: \"required\",\n  },\n  attestationType: \"none\",\n  timeout: 60_000,\n  // excludeCredentials: [...],      // 防重复注册（可选）\n  extensions: { credProps: true },\n});\n```\n\n### 登录（Request）\n\n```ts\nawait generateAuthenticationOptions({\n  rpID: \"yourdomain.com\",\n  timeout: 60_000,\n  userVerification: \"required\",\n  // 省略 allowCredentials → 可发现凭证（推荐做“一键直登”）\n  // allowCredentials: [...],       // 指定账号登录时使用\n  // extensions: { uvm: true },\n});\n```\n\n> 核心校验与安全实践：\n>\n> 1. **challenge** 统一按 **base64url 字符串** 存/比；用后删除；短 TTL（≤5 分钟）。\n> 2. **requireUserVerification: true**（服务端）与前端的 `userVerification: 'required'` 配套。\n> 3. 注册时显式 `residentKey: 'required'`，保证后面能做“无用户名一键登录（conditional UI）”。\n\n---\n\n# 六、常见疑问\n\n- **为什么我的 `options` 字段很少？**\n  浏览器/库会省略默认字段；只要关键项（`rpId`、`challenge`、用户/算法/策略）正确，功能完全等价。\n- **`challenge` 看起来很短，安全吗？**\n  默认 32 字节随机数（base64url 后 ≈43 字符）已足够安全。\n- **字段大小写为何不一致？**\n  库的**入参**是 `rpID`、`userID`（TypeScript 结构）；前端 JSON 是 WebAuthn 原生的 `rpId`、`user.id`。库会正确映射。\n\n---\n\n如果你想把现有 NestJS 代码里的配置**替换为上面的“生产推荐模板”**，告诉我你文件里的具体几行；我只给“需要替换的片段”，并在复杂逻辑上一行加注释，符合你的改码规则。\n",
            "url": "https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys：options",
            "title": "WebAuthn Passkeys：options 全字段长啥样？取值有哪些？（simplewebauthn v11+ 实战）",
            "date_modified": "2025-09-08T00:33:31.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/需求实现/登录鉴权/preferred是啥",
            "content_html": "\n好，我逐条拆解你看到的这段响应，并把“该用什么值”“挑战长度”为啥看起来短、“大厂是不是也这样返回”讲清楚；最后给出**只需改几行**的建议（不贴整文件）。\n\n---\n\n# 1、`\"userVerification\": \"preferred\"` 是啥？\n\n**它告诉浏览器/认证器：是否必须做“本地用户验证（UV）”**（指纹/人脸/PIN）。可选值只有 3 个：\n\n| 值                            | 含义                                                     | 常见效果/场景                                                                                                |\n| ----------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| **`required`**                | **必须**进行本地用户验证（没有 UV 能力的认证器会被排除） | 金融、后台管理、提升安全性。旧 U2F 钥匙（无 PIN）会被拒。                                                    |\n| **`preferred`**（你现在的值） | **优先**做 UV，如果设备支持就做；不支持也可以继续        | 一般网站登录、降低失败率。绝大多数“平台 passkey”（Android/Apple）都会做 UV，所以体验和 `required` 基本一样。 |\n| **`discouraged`**             | **不鼓励**做 UV（允许仅“持有设备”就通过）                | 很少用；降低安全门槛，适合低风险二级操作（不建议用于登录）。                                                 |\n\n> 注意：这只是“**意愿**”。真正的**强制**要在**服务端验证**时也打开：\n> `verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })`。\n> 否则前端说 `required`，服务端放宽为 `false`，就**没有被强制**。\n\n**给你的建议：**\n\n- 如果这是**员工后台**或敏感操作：前端设 `userVerification: 'required'`，服务端配套 `requireUserVerification: true`。\n- 如果是**大众登录**：`preferred` + 风控/设备指纹/异常登录再二次验证。\n\n# 2、这个 `challenge` 看起来“很短”，正常吗？\n\n**正常。**\n\n- simplewebauthn 默认生成 **32 字节**随机挑战（≈ **256 bit**）。\n- 32 字节用 **base64url** 表示通常是 **43\\~44 个字符**（无 `=` 填充）。\n- 你看到的：`jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg`，长度 43，很标准。\n- 我们服务端已把 challenge 统一按 **base64url** 存/比（你代码里已处理），与前端 `clientDataJSON.challenge` 能**精确一致**。\n\n> 若你担心强度，也可以自定义更长挑战（例如 64 字节），但 32 字节已足够随机且是行业常见默认。\n\n# 3、大厂实践里返回的也是这种结构吗？\n\n**是的。**这就是 WebAuthn 规范的 **PublicKeyCredentialRequestOptions(JSON)** 的形态，各家（Google、Apple、微软、GitHub、PayPal…）都会返回类似结构。差异主要在**有没有 `allowCredentials`** 和某些可选字段：\n\n- 一键直登/可发现凭证：**省略 `allowCredentials`**（你现在就是），浏览器会弹出该 RP 的可用 passkey 列表。\n- 指定账号登录：会带 `allowCredentials: [{ id, type: 'public-key' }, ...]`。\n- 其他常见字段：`rpId`、`challenge`、`timeout`、`userVerification`、有时 `extensions`。\n- 前端会另外传 `mediation: 'conditional'`（这不是 options 里的字段，而是 `navigator.credentials.get` 的参数，用于条件式 UI）。\n\n所以你这个响应：\n\n```json\n{\n  \"options\": {\n    \"rpId\": \"localhost\",\n    \"challenge\": \"…\",\n    \"timeout\": 60000,\n    \"userVerification\": \"preferred\"\n  }\n}\n```\n\n**完全合理**、符合规范，也符合大厂常见做法（本地开发把 `rpId` 设为 `localhost` 没问题，上线要换为你的主域）。\n\n# 4、如果你要“更安全”，只改这几行（前后端各一处）\n\n**后端·验证时强制 UV（把 `false` 改为 `true`）**\n\n```ts\n// 复杂：强制需要本地用户验证（指纹/人脸/PIN）\nrequireUserVerification: true,\n```\n\n> 出现位置：\n>\n> - `verifyRegistrationResponse({...})`\n> - `verifyAuthenticationResponse({...})`\n\n**生成登录 options 时（可选）：把首选项也改为 required**\n\n```ts\n// 复杂：要求认证器执行 UV\nuserVerification: 'required',\n```\n\n> 这两处配合使用，才能做到“名副其实的强制 UV”。\n\n---\n\n# 5、小补充：别名/大小写别差异别担心\n\n- simplewebauthn（v11+）返回的 JSON 用 `rpId`（小写 d）；\n- 你传入 `generateAuthenticationOptions({ rpID: '…' })` 是库的入参写法；\n- **这是正常的**：入参/出参字段命名略有差异，但库会正确映射。\n",
            "url": "https://herongdev.github.io/blog/posts/需求实现/登录鉴权/preferred是啥",
            "title": "userVerification:",
            "date_modified": "2025-09-08T00:12:36.000Z"
        },
        {
            "id": "https://herongdev.github.io/blog/posts/需求实现/登录鉴权/test",
            "content_html": "",
            "url": "https://herongdev.github.io/blog/posts/需求实现/登录鉴权/test",
            "title": "test",
            "date_modified": "2025-09-08T00:19:02.000Z"
        }
    ]
}