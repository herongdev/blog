---
title: "什么是闭包？——从直觉到 Swift 实战（顺带和 JS 对比）"
date: 2025-09-16
tags: [Swift, 闭包, 语法, 并发, 语言基础, 教程]
---

## 一句话定义

**闭包（Closure）**就是**能“记住”其创建时所在环境的函数值**。它不仅有代码，还**捕获**了周围用到的变量，因此即使这些变量所在的作用域已经结束，闭包仍能访问它们。

> 换句话说：闭包 = 函数 + 被它用到的“外部变量的快照/引用”（捕获环境）。

## Swift 中闭包的基本语法

```swift
// 完整形态
{ (参数列表) -> 返回类型 in
    // 闭包体
}

// 简写（可省类型、返回、参数名）：
{ value in value * 2 }
{ $0 * 2 }
```

> Swift 把**函数也是一等公民**，所以“函数”与“闭包表达式”本质上都是**可以存到变量里、当参数传递、作为返回值**的“可调用值”。

## 闭包做了什么：**捕获（Capture）**

```swift
func makeCounter() -> () -> Int {
    var n = 0        // 将被捕获的“自由变量”
    return {
        n += 1       // 闭包持有对 n 的访问权
        return n
    }
}

let next = makeCounter()
next() // 1
next() // 2  （即使 makeCounter 已经返回，n 仍然存在于闭包的捕获环境里）
```

- **自由变量**：在闭包体内使用、但不在闭包参数或局部定义的变量（上例中的 `n`）。
- **生命周期延长**：被捕获的变量会跟着闭包一起活得更久。

## 与 JavaScript 的快速对比

- JS 里 `function`/箭头函数天然是闭包，**捕获的是词法作用域**。
- Swift 也一样是**词法闭包**，但有**强类型系统**和**值/引用类型**的区别：

  - 捕获 `struct` 值时拷贝语义更明确；
  - 捕获 `class` 实例默认**强引用**，需要注意循环引用。

## Swift 的捕获细节与内存管理

### 强/弱/无主引用（防循环引用）

```swift
class A {
    var handler: (() -> Void)?
    func setup() {
        // 复杂逻辑：异步闭包可能长期存活，这里用 weak 打破强引用环
        handler = { [weak self] in
            self?.doWork()
        }
    }
    func doWork() {}
}
```

- 默认**强捕获** `self` → 容易产生 `A -> handler -> 闭包 -> A` 的**环**。
- 用 `[weak self]` 或 `[unowned self]`（更激进，要求生命周期保证）打破环。

### 值捕获 vs 引用捕获

```swift
var x = 0
let c1 = { print(x) }    // 捕获对 x 的访问（变量本身的存储位置）
let c2 = { [x] in print(x) } // 捕获当时的“值快照”，后续外部修改不影响
x = 42
c1() // 42
c2() // 0
```

## `@escaping` 与非逃逸闭包

- **非逃逸（默认）**：闭包在函数调用结束前就会执行完，不会被存起来。
- **逃逸 `@escaping`**：闭包可能被**异步保存并在稍后执行**，如网络回调、GCD。

```swift
func fetch(_ done: @escaping (Data?) -> Void) {
    DispatchQueue.global().async { done(nil) }
}
```

> 是否尾随闭包**与逃逸无关**；`@escaping` 取决于**函数如何使用**闭包。

## 尾随闭包只是“写法糖”，语义不变

```swift
// 普通写法
animate(duration: 0.25, animations: { ... }, completion: { _ in ... })

// 多尾随闭包（Swift 5.3+）
animate(duration: 0.25) {
    // animations
} completion: { finished in
    // completion
}
```

> **尾随闭包**只是把“最后一个闭包参数”移出 `()`，代码更好读；并不改变执行时机与线程模型。

## 典型用法

- **回调/异步**：网络请求、磁盘 IO、GCD。
- **函数式链式处理**：`map/filter/reduce`。
- **资源管理**：把“前后处理”打包成闭包式 API。
- **构建 DSL**：如 Auto Layout/动画/配置器风格。

```swift
let doubled = [1,2,3].map { $0 * 2 }   // 函数式闭包
```

---

## 性能与可读性建议

- **能用简写就简写**（类型推断、`$0`）但别过度；长逻辑请起**具名参数**提升可读性。
- **热点路径**避免创建过多短生命周期闭包（尤其是捕获大对象时）。
- 异步长期存活的闭包**总是考虑捕获列表**（`[weak self]`）。
- 如需同步等待闭包回调（不推荐），务必**不要在主线程**执行等待。

---

## 小结

- 闭包是**能带着上下文变量一起走的函数值**；这使得**回调、异步、函数式**成为可能。
- Swift 中闭包**默认强捕获**，要用**捕获列表**避免循环引用。
- `@escaping` 描述的是**生命周期**，尾随闭包只是**语法糖**。
- 理解“捕获”的本质，就能写出既**优雅**又**安全**的闭包代码。
