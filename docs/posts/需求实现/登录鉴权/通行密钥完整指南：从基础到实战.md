---
title: é€šè¡Œå¯†é’¥å®Œæ•´æŒ‡å—ï¼šä»åŸºç¡€åˆ°å®æˆ˜
date: 2025-01-27
tags: [Passkeys, WebAuthn, èº«ä»½è®¤è¯, æ— å¯†ç ç™»å½•]
---

# é€šè¡Œå¯†é’¥å®Œæ•´æŒ‡å—ï¼šä»åŸºç¡€åˆ°å®æˆ˜

> æœ¬æŒ‡å—å°†é€šè¡Œå¯†é’¥ï¼ˆPasskeysï¼‰ä»åŸºç¡€æ¦‚å¿µåˆ°é«˜çº§åº”ç”¨è¿›è¡Œåˆ†å±‚è®²è§£ï¼Œå¸®åŠ©å¼€å‘è€…å¿«é€ŸæŒæ¡å¹¶è½åœ°å®ç°ã€‚

## ç›®å½•

1. [åŸºç¡€æ¦‚å¿µ](#åŸºç¡€æ¦‚å¿µ)
2. [æ ¸å¿ƒé…ç½®è¯¦è§£](#æ ¸å¿ƒé…ç½®è¯¦è§£)
3. [å®æˆ˜åº”ç”¨åœºæ™¯](#å®æˆ˜åº”ç”¨åœºæ™¯)
4. [é«˜çº§ç‰¹æ€§ä¸æ‰©å±•](#é«˜çº§ç‰¹æ€§ä¸æ‰©å±•)
5. [å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ](#å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ)

---

## åŸºç¡€æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯é€šè¡Œå¯†é’¥ï¼ˆPasskeysï¼‰ï¼Ÿ

é€šè¡Œå¯†é’¥æ˜¯åŸºäº WebAuthn æ ‡å‡†çš„æ— å¯†ç èº«ä»½è®¤è¯æŠ€æœ¯ï¼Œé€šè¿‡ç”Ÿç‰©è¯†åˆ«ã€PIN ç æˆ–ç¡¬ä»¶å®‰å…¨å¯†é’¥æ¥éªŒè¯ç”¨æˆ·èº«ä»½ã€‚

**æ ¸å¿ƒä¼˜åŠ¿ï¼š**

- ğŸ” **æ›´å®‰å…¨**ï¼šåŸºäºå…¬é’¥å¯†ç å­¦ï¼Œç§é’¥æ°¸ä¸ç¦»å¼€è®¾å¤‡
- ğŸš€ **æ›´ä¾¿æ·**ï¼šæ— éœ€è®°å¿†å¯†ç ï¼Œæ”¯æŒè·¨è®¾å¤‡åŒæ­¥
- ğŸ›¡ï¸ **é˜²é’“é±¼**ï¼šæ¯ä¸ªç½‘ç«™ä½¿ç”¨ä¸åŒçš„å¯†é’¥å¯¹

### å…³é”®æœ¯è¯­

| æœ¯è¯­                   | è¯´æ˜                                             |
| ---------------------- | ------------------------------------------------ |
| **Relying Party (RP)** | ä¾èµ–æ–¹ï¼Œå³ä½ çš„ç½‘ç«™æˆ–åº”ç”¨                         |
| **Authenticator**      | è®¤è¯å™¨ï¼Œæ‰§è¡Œè®¤è¯çš„è®¾å¤‡ï¼ˆæ‰‹æœºã€ç”µè„‘ã€å®‰å…¨é’¥åŒ™ç­‰ï¼‰ |
| **Credential**         | å‡­æ®ï¼ŒåŒ…å«å…¬é’¥å’Œå…ƒæ•°æ®çš„è®¤è¯ä¿¡æ¯                 |
| **Challenge**          | æŒ‘æˆ˜ï¼Œé˜²é‡æ”¾æ”»å‡»çš„éšæœºå€¼                         |
| **Attestation**        | è¯æ˜ï¼ŒéªŒè¯è®¤è¯å™¨æ¥æºçš„å¯é€‰ä¿¡æ¯                   |

### è®¤è¯æµç¨‹æ¦‚è§ˆ

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant B as æµè§ˆå™¨
    participant A as è®¤è¯å™¨
    participant S as æœåŠ¡å™¨

    Note over U,S: æ³¨å†Œæµç¨‹
    U->>B: ç‚¹å‡»æ³¨å†Œ
    B->>S: è¯·æ±‚æ³¨å†Œé€‰é¡¹
    S->>B: è¿”å› challenge + é…ç½®
    B->>A: åˆ›å»ºå‡­æ®
    A->>B: è¿”å›å…¬é’¥ + ç­¾å
    B->>S: æäº¤æ³¨å†Œæ•°æ®
    S->>S: éªŒè¯å¹¶å­˜å‚¨å…¬é’¥

    Note over U,S: ç™»å½•æµç¨‹
    U->>B: ç‚¹å‡»ç™»å½•
    B->>S: è¯·æ±‚è®¤è¯é€‰é¡¹
    S->>B: è¿”å› challenge
    B->>A: è¯·æ±‚ç­¾å
    A->>B: è¿”å›ç­¾å
    B->>S: æäº¤è®¤è¯æ•°æ®
    S->>S: éªŒè¯ç­¾å
    S->>B: ç™»å½•æˆåŠŸ
```

---

## æ ¸å¿ƒé…ç½®è¯¦è§£

### 1. æ³¨å†Œé…ç½®ï¼ˆRegistration Optionsï¼‰

#### åŸºç¡€é…ç½®

```typescript
const registrationOptions = await generateRegistrationOptions({
  // ç«™ç‚¹ä¿¡æ¯
  rpName: "æˆ‘çš„åº”ç”¨", // ç”¨æˆ·å¯è§çš„ç«™ç‚¹åç§°
  rpID: "example.com", // åŸŸåï¼Œå¿…é¡»ä¸å½“å‰é¡µé¢åŒ¹é…

  // ç”¨æˆ·ä¿¡æ¯
  userID: Buffer.from("user-123", "utf8"), // ç”¨æˆ·å”¯ä¸€IDï¼ˆäºŒè¿›åˆ¶ï¼‰
  userName: "user@example.com", // ç”¨æˆ·å
  userDisplayName: "å¼ ä¸‰", // æ˜¾ç¤ºåç§°

  // å®‰å…¨é…ç½®
  challenge: generateChallenge(), // éšæœºæŒ‘æˆ˜ï¼ˆé€šå¸¸è‡ªåŠ¨ç”Ÿæˆï¼‰
  timeout: 60000, // è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
});
```

#### ç®—æ³•é…ç½®

```typescript
// æ”¯æŒçš„ç®—æ³•ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
supportedAlgorithmIDs: [
  -7, // ES256 (ECDSA w/ SHA-256) - æœ€æ¨è
  -257, // RS256 (RSA w/ SHA-256) - å…¼å®¹æ€§å¥½
  -8, // EdDSA (Ed25519) - ç°ä»£ç®—æ³•
];
```

**ç®—æ³•é€‰æ‹©å»ºè®®ï¼š**

- **ç”Ÿäº§ç¯å¢ƒ**ï¼š`[-7, -257]`ï¼ˆES256 + RS256ï¼‰
- **ç°ä»£åº”ç”¨**ï¼š`[-7, -8]`ï¼ˆES256 + EdDSAï¼‰
- **å…¼å®¹æ€§ä¼˜å…ˆ**ï¼š`[-7, -257, -8]`

#### è®¤è¯å™¨é€‰æ‹©

```typescript
authenticatorSelection: {
  // è®¤è¯å™¨ç±»å‹
  authenticatorAttachment: "platform",     // "platform" | "cross-platform"

  // å¯å‘ç°å‡­æ®ï¼ˆPasskey æ ¸å¿ƒç‰¹æ€§ï¼‰
  residentKey: "required",                 // "required" | "preferred" | "discouraged"

  // ç”¨æˆ·éªŒè¯è¦æ±‚
  userVerification: "preferred",           // "required" | "preferred" | "discouraged"
}
```

**é…ç½®è¯´æ˜ï¼š**

| å­—æ®µ               | å€¼            | è¯´æ˜               | æ¨èåœºæ™¯     |
| ------------------ | ------------- | ------------------ | ------------ |
| `residentKey`      | `required`    | å¿…é¡»åˆ›å»ºå¯å‘ç°å‡­æ® | Passkey ä½“éªŒ |
| `residentKey`      | `preferred`   | ä¼˜å…ˆåˆ›å»ºå¯å‘ç°å‡­æ® | å…¼å®¹æ€§è€ƒè™‘   |
| `residentKey`      | `discouraged` | ä¸åˆ›å»ºå¯å‘ç°å‡­æ®   | ä¼ ç»Ÿè®¤è¯å™¨   |
| `userVerification` | `required`    | å¿…é¡»ç”Ÿç‰©è¯†åˆ«/PIN   | é«˜å®‰å…¨åœºæ™¯   |
| `userVerification` | `preferred`   | ä¼˜å…ˆç”Ÿç‰©è¯†åˆ«       | é€šç”¨åœºæ™¯     |
| `userVerification` | `discouraged` | ä¸è¦æ±‚ç”Ÿç‰©è¯†åˆ«     | ä½å®‰å…¨åœºæ™¯   |

#### è¯æ˜é…ç½®

```typescript
attestationType: "none"; // "none" | "direct" | "indirect" | "enterprise"
```

**è¯æ˜ç±»å‹è¯´æ˜ï¼š**

| ç±»å‹         | è¯´æ˜           | ä½¿ç”¨åœºæ™¯           |
| ------------ | -------------- | ------------------ |
| `none`       | ä¸æ”¶é›†è¯æ˜ä¿¡æ¯ | **æ¨è**ï¼Œéšç§å‹å¥½ |
| `direct`     | ç›´æ¥è®¾å¤‡è¯æ˜   | ä¼ä¸šåˆè§„è¦æ±‚       |
| `indirect`   | é—´æ¥è¯æ˜       | å¾ˆå°‘ä½¿ç”¨           |
| `enterprise` | ä¼ä¸šçº§è¯æ˜     | ç‰¹æ®Šä¼ä¸šåœºæ™¯       |

### 2. ç™»å½•é…ç½®ï¼ˆAuthentication Optionsï¼‰

#### åŸºç¡€é…ç½®

```typescript
const authenticationOptions = await generateAuthenticationOptions({
  rpID: "example.com", // ä¸æ³¨å†Œæ—¶ä¸€è‡´
  challenge: generateChallenge(), // æ–°çš„éšæœºæŒ‘æˆ˜
  timeout: 60000, // è¶…æ—¶æ—¶é—´
  userVerification: "preferred", // ç”¨æˆ·éªŒè¯è¦æ±‚
});
```

#### å‡­æ®é™åˆ¶

```typescript
// æ–¹å¼ä¸€ï¼šæŒ‡å®šç”¨æˆ·å‡­æ®ï¼ˆä¼ ç»Ÿç™»å½•ï¼‰
allowCredentials: [
  {
    id: Buffer.from("credential-id", "base64url"),
    type: "public-key",
    transports: ["internal", "hybrid", "usb"],
  },
];

// æ–¹å¼äºŒï¼šå¯å‘ç°å‡­æ®ï¼ˆPasskey ç›´ç™»ï¼‰
allowCredentials: []; // ç©ºæ•°ç»„æˆ–ä¸ä¼ 
```

**ä¼ è¾“æ–¹å¼è¯´æ˜ï¼š**

| ä¼ è¾“æ–¹å¼   | è¯´æ˜           | ä½¿ç”¨åœºæ™¯               |
| ---------- | -------------- | ---------------------- |
| `internal` | å¹³å°å†…ç½®è®¤è¯å™¨ | æ‰‹æœºæŒ‡çº¹ã€Face ID      |
| `usb`      | USB å®‰å…¨é’¥åŒ™   | ç¡¬ä»¶å®‰å…¨å¯†é’¥           |
| `nfc`      | è¿‘åœºé€šä¿¡       | NFC å®‰å…¨é’¥åŒ™           |
| `ble`      | è“ç‰™ä½åŠŸè€—     | è“ç‰™å®‰å…¨é’¥åŒ™           |
| `hybrid`   | æ··åˆä¼ è¾“       | è·¨è®¾å¤‡è®¤è¯ï¼ˆæ‰‹æœºæ‰«ç ï¼‰ |

### 3. æ‰©å±•åŠŸèƒ½

```typescript
extensions: {
  // å‡­æ®å±æ€§
  credProps: true,              // è·å–å‡­æ®ç±»å‹ä¿¡æ¯

  // å¤§å¯¹è±¡å­˜å‚¨
  largeBlob: { support: "preferred" },

  // ä¼ªéšæœºå‡½æ•°
  prf: { eval: { first: new Uint8Array(32) } },

  // U2F å…¼å®¹
  appid: "https://example.com/u2f-app-id.json"
}
```

---

## å®æˆ˜åº”ç”¨åœºæ™¯

### åœºæ™¯ä¸€ï¼šæ–°ç”¨æˆ· Passkey-first æ³¨å†Œ

```typescript
// æœåŠ¡ç«¯ï¼šç”Ÿæˆæ³¨å†Œé€‰é¡¹
const options = await generateRegistrationOptions({
  rpName: "æˆ‘çš„åº”ç”¨",
  rpID: "example.com",
  userID: Buffer.from(userId, "utf8"),
  userName: userEmail,
  userDisplayName: userDisplayName,

  // Passkey æ ¸å¿ƒé…ç½®
  supportedAlgorithmIDs: [-7, -257],
  authenticatorSelection: {
    residentKey: "required", // å¿…é¡»å¯å‘ç°å‡­æ®
    userVerification: "preferred", // ä¼˜å…ˆç”Ÿç‰©è¯†åˆ«
  },
  attestationType: "none",
  extensions: { credProps: true },
  timeout: 120000,
});

// å‰ç«¯ï¼šåˆ›å»ºå‡­æ®
const credential = await navigator.credentials.create({
  publicKey: options,
});

// æœåŠ¡ç«¯ï¼šéªŒè¯æ³¨å†Œ
const verification = await verifyRegistrationResponse({
  response: credential,
  expectedChallenge: options.challenge,
  expectedOrigin: "https://example.com",
  expectedRPID: "example.com",
  requireUserVerification: true,
});
```

### åœºæ™¯äºŒï¼šæ— ç”¨æˆ·åç›´ç™»ï¼ˆConditional UIï¼‰

```typescript
// æœåŠ¡ç«¯ï¼šç”Ÿæˆè®¤è¯é€‰é¡¹ï¼ˆä¸é™åˆ¶å‡­æ®ï¼‰
const options = await generateAuthenticationOptions({
  rpID: "example.com",
  userVerification: "preferred",
  timeout: 120000,
  // allowCredentials ç•™ç©ºï¼Œæ”¯æŒå¯å‘ç°å‡­æ®
});

// å‰ç«¯ï¼šå¯ç”¨æ¡ä»¶å¼ UI
const credential = await navigator.credentials.get({
  publicKey: options,
  mediation: "conditional", // å…³é”®ï¼šå¯ç”¨æ¡ä»¶å¼ UI
});

// æœåŠ¡ç«¯ï¼šéªŒè¯è®¤è¯
const verification = await verifyAuthenticationResponse({
  response: credential,
  expectedChallenge: options.challenge,
  expectedOrigin: "https://example.com",
  expectedRPID: "example.com",
  authenticator: storedCredential,
  requireUserVerification: true,
});
```

### åœºæ™¯ä¸‰ï¼šè·¨è®¾å¤‡è®¤è¯

```typescript
// æ„å»ºæ”¯æŒè·¨è®¾å¤‡çš„å‡­æ®åˆ—è¡¨
function buildAllowCredentials(userCredentials) {
  return userCredentials.map((cred) => ({
    id: Buffer.from(cred.credentialId, "base64url"),
    type: "public-key",
    transports: [
      "internal", // æœ¬æœºè®¤è¯å™¨
      "hybrid", // è·¨è®¾å¤‡è®¤è¯ï¼ˆæ‰‹æœºæ‰«ç ï¼‰
      "usb", // USB å®‰å…¨é’¥åŒ™
      "nfc", // NFC å®‰å…¨é’¥åŒ™
      "ble", // è“ç‰™å®‰å…¨é’¥åŒ™
    ],
  }));
}

// ç”Ÿæˆè®¤è¯é€‰é¡¹
const options = await generateAuthenticationOptions({
  rpID: "example.com",
  allowCredentials: buildAllowCredentials(userCredentials),
  userVerification: "preferred",
  timeout: 120000,
});
```

### åœºæ™¯å››ï¼šå¤šå‡­æ®ç®¡ç†

```typescript
// è·å–ç”¨æˆ·æ‰€æœ‰å‡­æ®
async function getUserCredentials(userId) {
  return await db.credentials.findMany({
    where: { userId },
    select: {
      credentialId: true,
      publicKey: true,
      counter: true,
      transports: true,
      aaguid: true,
      createdAt: true,
      lastUsedAt: true,
    },
  });
}

// å‡­æ®ç®¡ç†æ¥å£
class CredentialManager {
  // æ·»åŠ å‡­æ®
  async addCredential(userId, credentialData) {
    return await db.credentials.create({
      data: {
        userId,
        credentialId: credentialData.credentialId,
        publicKey: credentialData.publicKey,
        counter: credentialData.counter,
        transports: credentialData.transports,
        aaguid: credentialData.aaguid,
      },
    });
  }

  // åˆ é™¤å‡­æ®
  async removeCredential(credentialId) {
    return await db.credentials.delete({
      where: { credentialId },
    });
  }

  // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
  async updateLastUsed(credentialId) {
    return await db.credentials.update({
      where: { credentialId },
      data: { lastUsedAt: new Date() },
    });
  }
}
```

---

## é«˜çº§ç‰¹æ€§ä¸æ‰©å±•

### 1. è®¾å¤‡è¯†åˆ«ä¸æ¥æºè¿½è¸ª

```typescript
// AAGUID æ˜ å°„è¡¨
const AAGUID_MAP = {
  "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4": "Google Password Manager",
  "adce0002-35bc-c60a-648b-0b25f1f05503": "Chrome on Mac",
  "08987058-cadc-4b81-b6e1-30de50dcbe96": "Windows Hello",
  "9ddd1817-af5a-4672-a2b9-3e3dd95000a9": "Windows Hello",
  "6028b017-b1d4-4c02-b4b3-afcdafc96bb2": "Windows Hello",
  "fbfc3007-154e-4ecc-8c0b-6e020557d7bd": "iCloud Keychain",
  "00000000-0000-0000-0000-000000000000": "Apple/Unknown",
};

// è¯†åˆ«è®¾å¤‡æ¥æº
function identifyDeviceSource(aaguid) {
  return AAGUID_MAP[aaguid] || "Unknown";
}

// åœ¨æ³¨å†ŒéªŒè¯åè®°å½•è®¾å¤‡ä¿¡æ¯
const verification = await verifyRegistrationResponse({...});
const deviceSource = identifyDeviceSource(verification.registrationInfo.aaguid);

await db.credentials.create({
  data: {
    // ... å…¶ä»–å­—æ®µ
    aaguid: verification.registrationInfo.aaguid,
    deviceSource,
    userAgent: req.headers['user-agent'],
  }
});
```

### 2. é£æ§ä¸å®‰å…¨ç­–ç•¥

```typescript
class SecurityPolicy {
  // æ£€æŸ¥ç”¨æˆ·éªŒè¯è¦æ±‚
  static shouldRequireUserVerification(operation, riskLevel) {
    if (operation === "login" && riskLevel === "high") {
      return "required";
    }
    if (operation === "sensitive_action") {
      return "required";
    }
    return "preferred";
  }

  // æ£€æŸ¥è®¾å¤‡ä¿¡ä»»åº¦
  static isDeviceTrusted(credential, userHistory) {
    const deviceAge = Date.now() - credential.createdAt.getTime();
    const usageCount = userHistory.filter(
      (h) => h.credentialId === credential.credentialId
    ).length;

    return deviceAge > 30 * 24 * 60 * 60 * 1000 && usageCount > 5; // 30å¤©ä¸”ä½¿ç”¨5æ¬¡ä»¥ä¸Š
  }

  // ç”Ÿæˆé£é™©è¯„åˆ†
  static calculateRiskScore(context) {
    let score = 0;

    if (context.isNewDevice) score += 30;
    if (context.isNewLocation) score += 20;
    if (context.isUnusualTime) score += 10;
    if (context.hasRecentFailures) score += 25;

    return Math.min(score, 100);
  }
}
```

### 3. é”™è¯¯å¤„ç†ä¸é™çº§ç­–ç•¥

```typescript
class PasskeyErrorHandler {
  static async handleAuthenticationError(error, context) {
    switch (error.name) {
      case "NotAllowedError":
        if (error.message.includes("timeout")) {
          return { action: "retry", message: "è®¤è¯è¶…æ—¶ï¼Œè¯·é‡è¯•" };
        }
        if (error.message.includes("user")) {
          return {
            action: "fallback",
            message: "ç”¨æˆ·å–æ¶ˆï¼Œè¯·é€‰æ‹©å…¶ä»–ç™»å½•æ–¹å¼",
          };
        }
        break;

      case "SecurityError":
        if (error.message.includes("rpId")) {
          return {
            action: "fallback",
            message: "åŸŸåä¸åŒ¹é…ï¼Œè¯·ä½¿ç”¨æ­£ç¡®çš„ç½‘ç«™",
          };
        }
        break;

      case "NotSupportedError":
        return {
          action: "fallback",
          message: "è®¾å¤‡ä¸æ”¯æŒé€šè¡Œå¯†é’¥ï¼Œè¯·ä½¿ç”¨å¯†ç ç™»å½•",
        };

      default:
        return { action: "fallback", message: "è®¤è¯å¤±è´¥ï¼Œè¯·ä½¿ç”¨å…¶ä»–ç™»å½•æ–¹å¼" };
    }
  }

  // é™çº§åˆ°å¯†ç ç™»å½•
  static async fallbackToPassword(email) {
    // å‘é€é­”æ³•é“¾æ¥æˆ–éªŒè¯ç 
    const magicLink = await generateMagicLink(email);
    await sendEmail(email, magicLink);
    return { action: "magic_link_sent", message: "å·²å‘é€ç™»å½•é“¾æ¥åˆ°æ‚¨çš„é‚®ç®±" };
  }
}
```

### 4. æ€§èƒ½ä¼˜åŒ–

```typescript
class PasskeyOptimizer {
  // ç¼“å­˜è®¤è¯é€‰é¡¹
  private static optionsCache = new Map();

  static async getCachedOptions(userId, operation) {
    const key = `${userId}:${operation}`;
    const cached = this.optionsCache.get(key);

    if (cached && Date.now() - cached.timestamp < 30000) {
      // 30ç§’ç¼“å­˜
      return cached.options;
    }

    const options = await this.generateOptions(userId, operation);
    this.optionsCache.set(key, {
      options,
      timestamp: Date.now(),
    });

    return options;
  }

  // æ‰¹é‡éªŒè¯å‡­æ®
  static async batchVerifyCredentials(credentials, expectedChallenge) {
    const promises = credentials.map((cred) =>
      verifyAuthenticationResponse({
        response: cred.response,
        expectedChallenge,
        expectedOrigin: process.env.ORIGIN,
        expectedRPID: process.env.RP_ID,
        authenticator: cred.authenticator,
        requireUserVerification: true,
      }).catch((error) => ({ error, credentialId: cred.credentialId }))
    );

    const results = await Promise.allSettled(promises);
    return results.filter((result) => result.status === "fulfilled");
  }
}
```

---

## å¸¸è§é—®é¢˜ä¸æœ€ä½³å®è·µ

### 1. å¸¸è§é—®é¢˜

#### Q: ä¸ºä»€ä¹ˆæˆ‘çš„é€šè¡Œå¯†é’¥åœ¨æŸäº›è®¾å¤‡ä¸Šæ— æ³•ä½¿ç”¨ï¼Ÿ

**A:** å¯èƒ½çš„åŸå› ï¼š

- è®¾å¤‡ä¸æ”¯æŒ WebAuthn æˆ–ç‰ˆæœ¬è¿‡ä½
- æµè§ˆå™¨ä¸æ”¯æŒæˆ–æœªå¯ç”¨ç›¸å…³åŠŸèƒ½
- ä¼ä¸šç­–ç•¥ç¦ç”¨äº†é€šè¡Œå¯†é’¥
- ç½‘ç»œç¯å¢ƒé™åˆ¶ï¼ˆå¦‚ä»£ç†ã€é˜²ç«å¢™ï¼‰

**è§£å†³æ–¹æ¡ˆï¼š**

```typescript
// æ£€æµ‹è®¾å¤‡æ”¯æŒåº¦
async function checkDeviceSupport() {
  const support = {
    webauthn: !!window.PublicKeyCredential,
    conditionalUI:
      await PublicKeyCredential.isConditionalMediationAvailable?.(),
    platformAuthenticator:
      await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable?.(),
  };

  return support;
}
```

#### Q: å¦‚ä½•å¤„ç†è·¨è®¾å¤‡åŒæ­¥é—®é¢˜ï¼Ÿ

**A:** é€šè¡Œå¯†é’¥çš„è·¨è®¾å¤‡åŒæ­¥ä¾èµ–äºå¹³å°æä¾›å•†ï¼š

- **Apple**: iCloud Keychain è‡ªåŠ¨åŒæ­¥
- **Google**: Google Password Manager åŒæ­¥
- **Microsoft**: Microsoft Account åŒæ­¥

**æœ€ä½³å®è·µï¼š**

- é¼“åŠ±ç”¨æˆ·åœ¨åŒä¸€ç”Ÿæ€ç³»ç»Ÿä¸­ä½¿ç”¨
- æä¾›å¤šå‡­æ®ç»‘å®šé€‰é¡¹
- å®ç°è·¨è®¾å¤‡è®¤è¯ï¼ˆHybrid ä¼ è¾“ï¼‰

#### Q: å¦‚ä½•ç¡®ä¿å®‰å…¨æ€§ï¼Ÿ

**A:** å®‰å…¨æœ€ä½³å®è·µï¼š

1. **å¼ºåˆ¶ç”¨æˆ·éªŒè¯**ï¼šè®¾ç½® `userVerification: "required"`
2. **éªŒè¯æŒ‘æˆ˜**ï¼šç¡®ä¿ challenge ä¸€æ¬¡æ€§ä½¿ç”¨
3. **æ›´æ–°è®¡æ•°å™¨**ï¼šæ£€æŸ¥å¹¶æ›´æ–° signCount
4. **è®¾å¤‡ç»‘å®š**ï¼šè®°å½•è®¾å¤‡ä¿¡æ¯ç”¨äºé£æ§
5. **å¤šå› ç´ è®¤è¯**ï¼šç»“åˆå…¶ä»–éªŒè¯æ–¹å¼

### 2. æœ€ä½³å®è·µ

#### ç”¨æˆ·ä½“éªŒä¼˜åŒ–

```typescript
// æ¸è¿›å¼å¢å¼º
class ProgressiveEnhancement {
  static async enhanceLoginForm() {
    const support = await checkDeviceSupport();

    if (support.webauthn) {
      // æ˜¾ç¤ºé€šè¡Œå¯†é’¥é€‰é¡¹
      this.showPasskeyOption();

      if (support.conditionalUI) {
        // å¯ç”¨è‡ªåŠ¨å¡«å……
        this.enableAutofill();
      }
    } else {
      // é™çº§åˆ°ä¼ ç»Ÿç™»å½•
      this.showTraditionalLogin();
    }
  }

  static showPasskeyOption() {
    const passkeyButton = document.createElement("button");
    passkeyButton.textContent = "ä½¿ç”¨é€šè¡Œå¯†é’¥ç™»å½•";
    passkeyButton.onclick = this.handlePasskeyLogin;
    document.querySelector(".login-form").appendChild(passkeyButton);
  }
}
```

#### é”™è¯¯å¤„ç†

```typescript
// ç»Ÿä¸€é”™è¯¯å¤„ç†
class UnifiedErrorHandler {
  static handle(error, context) {
    const errorInfo = {
      name: error.name,
      message: error.message,
      timestamp: new Date().toISOString(),
      context,
    };

    // è®°å½•é”™è¯¯
    console.error("Passkey Error:", errorInfo);

    // ç”¨æˆ·å‹å¥½æç¤º
    const userMessage = this.getUserFriendlyMessage(error);

    // é™çº§ç­–ç•¥
    if (this.shouldFallback(error)) {
      return this.initiateFallback(context);
    }

    return { error: userMessage };
  }

  static getUserFriendlyMessage(error) {
    const messages = {
      NotAllowedError: "è®¤è¯è¢«å–æ¶ˆæˆ–è¶…æ—¶",
      SecurityError: "å®‰å…¨éªŒè¯å¤±è´¥",
      NotSupportedError: "è®¾å¤‡ä¸æ”¯æŒé€šè¡Œå¯†é’¥",
      InvalidStateError: "è®¤è¯å™¨çŠ¶æ€æ— æ•ˆ",
      ConstraintError: "è®¤è¯å™¨çº¦æŸä¸æ»¡è¶³",
    };

    return messages[error.name] || "è®¤è¯å¤±è´¥ï¼Œè¯·é‡è¯•";
  }
}
```

#### æ€§èƒ½ä¼˜åŒ–

```typescript
// æ€§èƒ½ç›‘æ§
class PerformanceMonitor {
  static async measureOperation(operation, fn) {
    const start = performance.now();

    try {
      const result = await fn();
      const duration = performance.now() - start;

      // è®°å½•æ€§èƒ½æŒ‡æ ‡
      this.recordMetric(operation, duration, "success");

      return result;
    } catch (error) {
      const duration = performance.now() - start;

      // è®°å½•é”™è¯¯æŒ‡æ ‡
      this.recordMetric(operation, duration, "error");

      throw error;
    }
  }

  static recordMetric(operation, duration, status) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    analytics.track("passkey_operation", {
      operation,
      duration,
      status,
      timestamp: Date.now(),
    });
  }
}
```

### 3. éƒ¨ç½²æ£€æŸ¥æ¸…å•

#### å¼€å‘ç¯å¢ƒ

- [ ] ä½¿ç”¨ HTTPSï¼ˆlocalhost é™¤å¤–ï¼‰
- [ ] é…ç½®æ­£ç¡®çš„ rpID
- [ ] å®ç° challenge ç”Ÿæˆå’ŒéªŒè¯
- [ ] è®¾ç½®åˆé€‚çš„è¶…æ—¶æ—¶é—´
- [ ] å¯ç”¨ç”¨æˆ·éªŒè¯

#### ç”Ÿäº§ç¯å¢ƒ

- [ ] é…ç½®æ­£ç¡®çš„åŸŸåå’Œ rpID
- [ ] å®ç°é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥
- [ ] è®¾ç½®ç›‘æ§å’Œæ—¥å¿—
- [ ] é…ç½®å¤‡ä»½å’Œæ¢å¤æœºåˆ¶
- [ ] è¿›è¡Œå®‰å…¨å®¡è®¡

#### ç”¨æˆ·ä½“éªŒ

- [ ] æä¾›æ¸…æ™°çš„è¯´æ˜å’Œå¼•å¯¼
- [ ] å®ç°æ¸è¿›å¼å¢å¼º
- [ ] æ”¯æŒå¤šè®¾å¤‡ç»‘å®š
- [ ] æä¾›å‡­æ®ç®¡ç†åŠŸèƒ½
- [ ] å®ç°è·¨è®¾å¤‡è®¤è¯

---

## æ€»ç»“

é€šè¡Œå¯†é’¥æ˜¯æœªæ¥èº«ä»½è®¤è¯çš„é‡è¦æ–¹å‘ï¼Œé€šè¿‡æœ¬æŒ‡å—çš„åˆ†å±‚è®²è§£ï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

1. **ç†è§£åŸºç¡€æ¦‚å¿µ**ï¼šæŒæ¡ WebAuthn å’Œ Passkeys çš„æ ¸å¿ƒåŸç†
2. **é…ç½®æ­£ç¡®å‚æ•°**ï¼šæ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚çš„é…ç½®é€‰é¡¹
3. **å®ç°å®æˆ˜åº”ç”¨**ï¼šæ„å»ºå®Œæ•´çš„æ³¨å†Œå’Œç™»å½•æµç¨‹
4. **å¤„ç†é«˜çº§ç‰¹æ€§**ï¼šå®ç°è®¾å¤‡è¯†åˆ«ã€é£æ§å’Œå®‰å…¨ç­–ç•¥
5. **éµå¾ªæœ€ä½³å®è·µ**ï¼šä¼˜åŒ–ç”¨æˆ·ä½“éªŒå’Œç³»ç»Ÿæ€§èƒ½

è®°ä½ï¼Œé€šè¡Œå¯†é’¥çš„æˆåŠŸå®æ–½éœ€è¦å‰åç«¯çš„ç´§å¯†é…åˆï¼Œä»¥åŠè‰¯å¥½çš„ç”¨æˆ·ä½“éªŒè®¾è®¡ã€‚å§‹ç»ˆä»¥ç”¨æˆ·ä¸ºä¸­å¿ƒï¼Œæä¾›å®‰å…¨ã€ä¾¿æ·çš„è®¤è¯ä½“éªŒã€‚

---

## å‚è€ƒèµ„æº

- [WebAuthn è§„èŒƒ](https://www.w3.org/TR/webauthn-3/)
- [SimpleWebAuthn æ–‡æ¡£](https://simplewebauthn.dev/)
- [Passkeys å¼€å‘è€…æŒ‡å—](https://developers.google.com/identity/passkeys)
- [Apple Passkeys æ–‡æ¡£](https://developer.apple.com/passkeys/)
- [FIDO Alliance èµ„æº](https://fidoalliance.org/passkeys/)
