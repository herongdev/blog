太对路了——把“所有配置项 + 有效值 + 作用”讲清楚，前后端各怎么用，以及**如何判断注册来源是谷歌 / 苹果 / 微软**。下面一次性讲透，并给你几段**只需粘贴的最小改动**代码（遵循你“不整段贴全”的要求）。

---

# 一、后端（SimpleWebAuthn）配置项总览

## 1) `generateRegistrationOptions(...)`（注册发起）

**常用参数（含有效值 & 作用）**

- `rpName: string`
  你的站点/应用展示名称（出现在系统弹窗里）。

- `rpID: string`
  Relying Party ID（通常就是你的域名，如 `example.com`；App 内使用同 RP ID）。用于**同源校验**，必须与前端 `origin`、系统 UI 一致。

- `userID: BufferSource`
  你后端的用户唯一 ID（建议将数字/UUID 转成 `Buffer.from(...)`）。注册后可反查到用户。

- `userName: string`
  用户名（可用 userId 占位），供系统 UI 展示/内部标识。

- `userDisplayName?: string`
  友好展示名（可选）。

- `attestationType: 'none' | 'direct' | 'indirect' | 'enterprise'`
  **建议：`'none'`**。iOS/Android 平台 Passkey **常不给可验证的证明**；`direct` 往往拿不到签名链。除非企业场景才考虑 `enterprise`。([web.dev][1])

- `authenticatorSelection?: { ... }`

  - `residentKey: 'required' | 'preferred' | 'discouraged'`
    **建议：`'required'`**（= 可发现凭据 / Discoverable Credential），才能**无用户名直登**。
  - `userVerification: 'required' | 'preferred' | 'discouraged'`
    **建议：`'required'` 或 `preferred`**（Face/Touch/Windows Hello）。
  - `authenticatorAttachment?: 'platform' | 'cross-platform'`
    仅当你**只想收平台内置**时可设 `platform`；多数场景**不设**，允许安全钥匙。

- `supportedAlgorithmIDs: number[]`（COSE 算法）

  - `-7` = ES256（**最广泛支持**：Apple/Google/Windows）
  - `-257` = RS256（部分平台/旧设备）
  - `-8` = EdDSA（Ed25519，逐步普及）
    **建议**：至少 `[-7]`；为兼容性可加 `-257`；前瞻可再加 `-8`。

- `excludeCredentials?: [{ id, type, transports? }...]`
  避免同一 Authenticator 重复注册（也可限制每供应商最多 1\~2 把）。([web.dev][1])

- `extensions?: { credProps?: true, ... }`
  建议打开 `credProps: true`，以便在回包里知道是否生成了 `rk`（resident key = 可发现凭据）。

> 这些字段的“形状”和默认值与 WebAuthn 规范一致，SimpleWebAuthn 会帮你生成随机 `challenge` 并做类型转换。参考其“Passkeys”与包文档。([simplewebauthn.dev][2])

---

## 2) `verifyRegistrationResponse(...)`（注册校验）

**关键输入**

- `response`：前端原样回传的对象
- `expectedChallenge`：你发出的那个 challenge
- `expectedOrigin`：前端实际 origin（H5 如 `https://a.com`；App WebView/中间层同）
- `expectedRPID`：上文 `rpID`
- `requireUserVerification: boolean`：**建议 true/或至少 preferred**，确保生物特征/系统 PIN 过一遍。

**关键输出（部分）**

- `verified: boolean`
- `registrationInfo`:

  - `credential: { id, publicKey, counter, transports, aaguid? }`
  - `credentialDeviceType: 'singleDevice' | 'multiDevice'`
  - `credentialBackedUp: boolean`（云端已备份，多设备同步）
    这些在理解“passkey 是不是云同步、多设备”等非常有用。([simplewebauthn.dev][2])

---

## 3) `generateAuthenticationOptions(...)`（登录发起）

- `rpID: string`：同上
- `allowCredentials?: [{ id, type, transports? }...]`
  **不传** → 走**无用户名发现式**（条件 UI / 可发现凭据）。
  如要“只允许此用户的凭据”，可传该用户的已绑定 credentialId 列表。
- `userVerification: 'required' | 'preferred' | 'discouraged'`
  **建议：`required` 或 `preferred`**。
- `timeout?: number`：如 60000
- `extensions?: { appidExclude?, largeBlob? ... }`：一般默认即可。

---

## 4) `verifyAuthenticationResponse(...)`（登录校验）

- `response` / `expectedChallenge` / `expectedOrigin` / `expectedRPID` 同注册
- `authenticator`：从你库里取出的该 credential 的
  `{ credentialID<Buffer>, credentialPublicKey<Buffer>, counter<number>, transports? }`
- `requireUserVerification`：同上
- 输出包含 `newCounter`（要**入库更新**，抵御重放）。

---

# 二、前端配置项（H5 & App）

你前端已经封装了：

- `createRegistrationPayload(publicKeyOptions)`
- `createAuthenticationPayload(publicKeyOptions, { conditional })`

**它们要的 `publicKeyOptions` 就是 WebAuthn 规范里的**：

### A) `PublicKeyCredentialCreationOptions`（注册）

- `rp: { id, name }` —— **rp.id 必须与后端 rpID 一致**
- `user: { id<BufferSource>, name, displayName }`
- `challenge: BufferSource`
- `pubKeyCredParams: [{ type: 'public-key', alg: -7 | -257 | -8 ... }]`
- `timeout?: number`
- `attestation: 'none' | 'direct' | 'indirect' | 'enterprise'` —— 建议 `'none'`
- `authenticatorSelection`（同后端）
- `excludeCredentials?: ...`
- `extensions?: { credProps?: true }`

### B) `PublicKeyCredentialRequestOptions`（登录）

- `rpId: string`
- `challenge: BufferSource`
- `allowCredentials?: ...`（**不传**=可发现凭据）
- `userVerification: 'required' | 'preferred' | 'discouraged'`
- `timeout?: number`
- `extensions?: ...`

### C) H5 的“条件 UI”（无用户名直登）

- Chrome 需传 `mediation: 'conditional'`（有些库用 second param `{ conditional: true }` 实现）
- Safari/iOS/macOS 会自动弹出
  参考 SimpleWebAuthn browser 包文档（含 auto/conditional 说明）。([simplewebauthn.dev][3])

### D) App 端（iOS/Android 原生）

- **iOS** 用 `ASAuthorizationPlatformPublicKeyCredentialProvider`；
  **Android** 用 `androidx.credentials` 的 `CreatePublicKeyCredentialRequest` / `GetPublicKeyCredentialOption`。
  它们都吃**同一份 `publicKey` JSON**（即上面 Options），所以你的 UTS 插件只需**透传**。
  （这也是官方推荐形态，减少 JS ↔ 原生映射误差。）

---

# 三、如何识别“谷歌/苹果/微软”平台？

**权威方式：看 AAGUID**（注册阶段返回的 `authenticatorData` 里带的**设备模型 GUID**）。

- SimpleWebAuthn 在 `verifyRegistrationResponse` 的结果里就可取到（见下方补丁）。
- 然后对照**社区维护的映射表**（含名称与图标 SVG）。

  - **Android / Google Password Manager** 示例 AAGUID：`ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4`。([web.dev][1])
  - **Windows Hello** 常见 AAGUID：
    `08987058-cadc-4b81-b6e1-30de50dcbe96`、`9ddd1817-af5a-4672-a2b9-3e3dd95000a9`、`6028b017-b1d4-4c02-b4b3-afcdafc96bb2`。([Corbado][4])
  - **Apple / iCloud Keychain**：**常返回全零**（出于隐私/无证明情况下），即：`00000000-0000-0000-0000-000000000000`，因此“无法唯一识别”，可标注为“Apple/未知”。([Apple Developer][5])
  - 第三方管理器（1Password、Bitwarden…）请用社区清单匹配（长期维护）。([GitHub][6])

> 注意：**只有在有可验证的 attestation 时，AAGUID 才能被强信任**；iOS/Android 常不给直接证明，所以**只能当“展示用途”**（比如在“已绑定的通行密钥”列表里显示来源与图标）。([web.dev][1])

---

# 四、与前端过程的联动 —— 每个配置项如何在“流”里落位

**注册流（JIT + 可发现凭据）**

1. 前端调 `/passkeys/register/options`
   服务器用上述“推荐值”生成：

   - `attestationType: 'none'`
   - `authenticatorSelection: { residentKey: 'required', userVerification: 'preferred' }`
   - `supportedAlgorithmIDs: [-7]`（可再加 `-257`）
   - `extensions: { credProps: true }`

2. 前端拿到 `options` 后：

   - H5：`createRegistrationPayload(options)`；
   - App：UTS 插件把 `options.publicKey` 透传给 iOS/Android 原生。

3. 后端 `verifyRegistrationResponse(...)`：

   - 对 `expectedChallenge/Origin/RPID` 校验
   - 成功后**落 DB**：`credentialId`、`publicKey`、`counter`、`transports`、`aaguid`、`credentialDeviceType`、`credentialBackedUp`、**（可选）clientEnv**（前端传的系统信息，便于“来源”辅助展示）。

4. 在“我的通行密钥”页：

   - 显示**创建时间**、**最近使用时间**、**来源**（由 AAGUID 映射 + `clientEnv` 兜底）。

**登录流（无用户名直登）**

1. 前端调 `/passkeys/login/options`（不传 `allowCredentials`）

   - 服务器 `generateAuthenticationOptions({ rpID, userVerification: 'required' })`。
   - H5：传 `{ conditional: true }` 开条件 UI；App：直接调原生 GetAPI。

2. `verifyAuthenticationResponse(...)`：

   - 验证签名 + 更新 `counter`；
   - 颁发会话；
   - 记录使用时间（用于“最近使用”展示）。

---

# 五、**最小改动代码片段**（仅贴需要添加/修改的行）

> 遵循你“不要整段完整代码”的偏好。以下三处直接加入即可。

### 1) **注册校验**里：保存 `aaguid` 并映射供应商

**位置**：你的 `verifyRegistration(...)` 逻辑保存凭据之后

```ts
// 在“入库凭据”代码之后，追加以下几行：

// —— 读取 AAGUID（库版本不同，可能在 registrationInfo 或 registrationInfo.credential 下）
// 复杂：兼容字段差异，先取 registrationInfo.aaguid，再尝试 credential.aaguid
const aaguid =
  (verification.registrationInfo as any)?.aaguid ??
  (verification.registrationInfo as any)?.credential?.aaguid ??
  null;

// —— 供应商映射（最小内置 + 可扩展）
const provider = mapAAGUIDToProvider(aaguid);

// —— 更新凭据的元信息（你已有 creds.createCredential，可补个 updateMetadata）
await this.creds.updateCredentialMetadata(credentialIdB64, {
  aaguid,
  provider, // 'Google Password Manager' | 'Windows Hello' | 'Apple/Unknown' | '1Password' | ...
});
```

**并新增一个工具函数（放 service 尾部或 utils）：**

```ts
// 简单映射；建议你结合“社区 AAGUID 列表”按需扩展
function mapAAGUIDToProvider(aaguid?: string | null) {
  if (!aaguid) return "Unknown";
  const v = aaguid.toLowerCase();
  // Google Password Manager (Android)
  if (v === "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4")
    return "Google Password Manager"; // Android
  // Windows Hello
  if (
    v === "08987058-cadc-4b81-b6e1-30de50dcbe96" ||
    v === "9ddd1817-af5a-4672-a2b9-3e3dd95000a9" ||
    v === "6028b017-b1d4-4c02-b4b3-afcdafc96bb2"
  )
    return "Windows Hello";
  // Apple 常返回全零（无证明），只能标注 Unknown/Apple
  if (v === "00000000-0000-0000-0000-000000000000") return "Apple/Unknown";
  // 其他第三方（1Password/Bitwarden…）可按社区清单补充
  return "Unknown";
}
```

> 参考：AAGUID 识别 & 示例、Windows Hello AAGUID 列表、社区映射清单。([web.dev][1])

---

### 2) **注册发起**里：确保“可发现凭据 + credProps”

**位置**：`generateRegistrationOptions(...)` 调用处

```ts
// 调整/补充字段（只示例关键行）
attestationType: 'none',
supportedAlgorithmIDs: [-7], // 兼容性再加 -257
authenticatorSelection: {
  residentKey: 'required',          // ★ 允许无用户名直登
  userVerification: 'preferred',    // 或 'required'
  // authenticatorAttachment: 'platform' // 如你只想收平台内置再打开
},
extensions: { credProps: true },
```

---

### 3) **前端 Verify Body**：附带“环境指纹”（用于供应商兜底判定/显示）

**位置**：你生成 `verifyRegBody` / `verifyBody` 处

```ts
// 复杂：结合 uni.getSystemInfo 的关键字段，告诉后端“来自哪个端”
const sys = await uni.getSystemInfo();
const clientEnv = {
  osName: sys.osName, // 'ios' | 'android' | 'harmonyos' | ...
  uniPlatform: sys.uniPlatform, // 'app' | 'web' | 'mp-weixin' ...
  hostName: sys.hostName || null, // 浏览器/宿主标识（H5/小程序）
};
const verifyRegBody = { ...corePayload, userId, clientEnv }; // 注册 verify
const verifyBody = { ...payload, clientEnv }; // 登录 verify
```

> 这样当 AAGUID 是全零/缺失时（苹果常见），你也能在后台列表用 `osName` 做轻量标注（如 “来自 iOS（Apple/Unknown）”）。

---

# 六、**最佳默认模板**（直接抄）

### 注册 options（后端）

```ts
generateRegistrationOptions({
  rpName: "你的产品名",
  rpID: rpID, // 你的域
  userID: Buffer.from(String(user.id), "utf8"),
  userName: String(user.id),
  attestationType: "none",
  supportedAlgorithmIDs: [-7],
  authenticatorSelection: {
    residentKey: "required",
    userVerification: "preferred",
    // authenticatorAttachment: 'platform'
  },
  extensions: { credProps: true },
});
```

### 登录 options（后端）

```ts
generateAuthenticationOptions({
  rpID,
  userVerification: "required", // 或 preferred
  // 不传 allowCredentials → 可发现凭据直登
});
```

### H5 条件 UI（前端）

```ts
// 复杂：开启条件 UI（Chrome）
const verifyBody = await createAuthenticationPayload(options, {
  conditional: true,
});
```

---

# 七、常见坑 & 提醒

- **RPID / Origin 严格匹配**：H5 与 App WebView/中间层均需一致，否则验签失败。
- **iOS & Android 多数“无 attestation”**：AAGUID 仅作展示，不作强风控。([web.dev][1])
- **计数器务必更新**：每次登录校验通过后，把 `newCounter` 入库。
- **多把 Passkey 管理**：建议列表里展示：创建时间、最近使用、**来源（AAGUID/环境兜底）**，并允许删除。([web.dev][1])
- **算法兼容**：主打 `-7(ES256)`，必要时加 `-257(RS256)`；`-8(EdDSA)`逐步普及但不必强依赖。
- **Android “Credential Manager”** 和 **iOS ASAuthorization**：都吃同一份 `publicKey` JSON，UTS 插件只需透传（你的结构已满足“只在 index.uts 做薄层”的最佳实践）。
- **AAGUID 映射表**：可定期拉取社区清单（本地缓存一份 JSON），但注意它**不是安全来源**，仅供 UI 显示。([GitHub][6])

---

如果你愿意，我可以再给你把**后端 `creds` 表结构里新增 `aaguid/provider/last_used_at`** 的迁移 SQL 和\*\*“通行密钥管理”接口**的最小改动补丁，也按你的规则只贴**修改行\*\*。

[1]: https://web.dev/articles/webauthn-aaguid "Determine the passkey provider with AAGUID  |  Articles  |  web.dev"
[2]: https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com "Passkeys"
[3]: https://simplewebauthn.dev/docs/packages/browser?utm_source=chatgpt.com "simplewebauthn/browser"
[4]: https://www.corbado.com/glossary/windows-hello?utm_source=chatgpt.com "What is Windows Hello? Definition, AAGUID and Role in ..."
[5]: https://developer.apple.com/forums/tags/passkeys-in-icloud-keychain/?page=2&sortBy=lastUpdated&utm_source=chatgpt.com "Passkeys in iCloud Keychain"
[6]: https://github.com/passkeydeveloper/passkey-authenticator-aaguids "GitHub - passkeydeveloper/passkey-authenticator-aaguids: This repo contains a community sourced list of AAGUIDs for passkey credential managers to help with naming in end user management UIs"
