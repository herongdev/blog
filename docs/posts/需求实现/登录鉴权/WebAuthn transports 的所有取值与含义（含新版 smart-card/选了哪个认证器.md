---
title: 选了哪个认证器？能否区分「Google / Windows Hello / 安卓手机 / 苹果钥匙串」
date: 2025-09-16
tags: [WebAuthn, Passkeys, FIDO2]
---

## 结论速答

- **浏览器不会把“品牌/提供方”直接告诉前端**（这是刻意的隐私设计）。你**无法**仅凭 `navigator.credentials.get()` 的返回结果直接断言“用户点的是 Google、Windows Hello、Android 手机还是 Apple 钥匙串”。([W3C][1])
- 你**能拿到**的是**认证器类别**：`credential.authenticatorAttachment` → `"platform"`（平台，如 Windows Hello/Touch ID/Android 平台密钥）或 `"cross-platform"`（漫游，如安全钥/YubiKey，或手机经 Hybrid/蓝牙/扫码）。但它**不是品牌级别**。([MDN Web Docs][2])
- 如需在 UI 中展示“来自 Google / Apple / Windows Hello”等，正确做法是：**在注册时记录 AAGUID → 服务端映射到提供方**；认证时根据 `rawId` 找回该凭据的“提供方标签”并返回给前端显示。注意：移动端大多用 **none attestation**，AAGUID 仅用于**展示**，不应作为安全决策。([web.dev][3])

## 能拿到的前端信号

### 1) 认证器“类别”

- `credential.authenticatorAttachment`：`"platform"` / `"cross-platform"`。仅代表**本机平台**还是**漫游/跨设备**，**不能**细化到“Google/Apple/Windows”。([MDN Web Docs][2])

> 例：若你想在“跨设备登录”后建议用户把凭据保存到本机，可用它来判断（Chrome 指南里就是这么建议的）。([web.dev][4])

### 2) 扩展结果（可选）

- `credential.getClientExtensionResults()`：如你在 `publicKey.extensions` 里请求了扩展，这里会返回结果对象。它**可能**用于风险/设备判别（如 `devicePubKey` 帮你识别**具体使用的那台设备**），但**仍不揭示“品牌”**。([MDN Web Docs][5])

### 3) 客户端能力/提示（非识别）

- `PublicKeyCredential.getClientCapabilities()` 可让你探知**是否支持 hybrid transport / 条件式自动填充**等，以便调整 UI，但**不是“用的是谁家”**。([MDN Web Docs][6])

---

## 想显示“Google/Apple/Windows”的正确方案（服务端主导）

### A. 注册时：记录 AAGUID → 映射“提供方”

- AAGUID 是“认证器型号/提供方”的 UUID。**注册时**（`create()`）在服务端解析并**保存到凭据表**，后续用于 UI 文案（例如“由 Google 密码管理器创建”）。官方示例与社区清单可直接映射 AAGUID → 提供方名称/图标。**注意**：无签名背书的场景仅用于展示。([web.dev][3])

> 复杂逻辑：提取 AAGUID 并存库
>
> ```ts
> // 上一行：SimpleWebAuthn 注册校验后，拿到 AAGUID 并持久化（仅展示用途）
> const { verified, registrationInfo } = await verifyRegistrationResponse(...);
> const aaguid = registrationInfo?.aaguid; // 可能为 '00000000-0000-0000-0000-000000000000'
> // 上一行：用官方推荐的社区清单将 AAGUID → 提供方标签（Google/Apple/…）
> const provider = mapAAGUIDToProvider(aaguid); // 例：'Google Password Manager' | 'iCloud Keychain' | ...
> await db.credentials.upsert({ credentialId, userId, aaguid, providerLabel: provider });
> ```
>
> 资料：如何用 AAGUID 判定提供方 & 社区清单链接（web.dev 文章）。([web.dev][3])

### B. 认证时：凭 `rawId` 找回“提供方标签”

- 登录 `get()` 成功后，前端把 `rawId` 发回；服务端校验通过后，**根据 `rawId` 查询凭据表**，把**保存的 `providerLabel`** 回传给前端用于 UI 展示。
- SimpleWebAuthn 还会告诉你**凭据类型/是否多设备**（`credentialDeviceType` / `credentialBackedUp`），可做补充标签（例如“多设备同步的 passkey”）。([简单网页认证][7])

---

## 仅做“类别”与“跨设备”判断时（无需品牌）

> 只改你现有前端**必要行**（按你的要求“只给改动”）：

```ts
// 上一行：读取认证器类别（platform/cross-platform），随 payload 发回，便于统计/风控/UI
const attachment = (cred as PublicKeyCredential).authenticatorAttachment as
  | "platform"
  | "cross-platform"
  | null;

// 上一行：如你启用了扩展，这里拿到客户端扩展结果（可能含 devicePubKey 等），可一并上传分析
const clientExt = (cred as PublicKeyCredential).getClientExtensionResults?.();

// 上一行：把两个“提示性”字段附在 payload 里（非安全必需，仅用于展示/分析）
payload.meta = {
  authenticatorAttachment: attachment,
  clientExtensionResults: clientExt,
};
```

---

## 为什么不能直接知道“Google / Apple / Windows Hello”

- **规范与浏览器刻意最小化披露**：避免把用户的设备/账户生态暴露给站点（隐私原则）。API 仅给“类别”（platform/cross-platform），**不会**告诉你“是 Google 还是 Apple”。([W3C][1])
- **AAGUID 仅在注册态可得且常为匿名化**：很多平台默认 `none attestation`，即便有 AAGUID，也**只适合做 UI 标签**，不应做强安全策略。([web.dev][3])

---

## 进阶：区分“手机（Hybrid）” vs “U 盘钥匙”

- **严格来说，结果里也不直接告诉你**。`"cross-platform"` 既可能是 **安全钥（USB/NFC/BLE）**，也可能是**手机经 Hybrid**。([MDN Web Docs][2])
- 可行的**推断**思路（仍非 100% 准确）：

  1. 检查**客户端能力**是否支持 `hybridTransport`（仅做 UI/流程分支）。([MDN Web Docs][6])
  2. 在请求里**开启 `devicePubKey` 扩展**并在服务端校验其输出，可用于**识别“这次是同一台手机/设备”**（设备指纹化的合规替代），但**仍不是品牌信息**。([GitHub][8])

---

## 小抄：你可以立刻加的最小改动

> 前端（认证）——只贴**需新增**行：

```ts
// 上一行：把 authenticatorAttachment 带回去，便于服务端记录这次是平台还是漫游
const attachment =
  (cred as PublicKeyCredential).authenticatorAttachment ?? null;

// 上一行：如你要研究扩展结果（例如 devicePubKey），连同其他字段一起上传
const ext = (cred as PublicKeyCredential).getClientExtensionResults?.() ?? {};
await loginByCredential({ ...payload, meta: { attachment, ext } });
```

> 服务端（注册验证后）——只贴**需新增**行：

```ts
// 上一行：注册成功后，提取 AAGUID 并映射“提供方标签”（仅显示用途）
const { aaguid } = verification.registrationInfo!;
const providerLabel = mapAAGUIDToProvider(aaguid); // 例：'Google Password Manager' | 'iCloud Keychain' | 'Windows Hello' | 'YubiKey' | 'Unknown'
await saveCredential({ credentialId, userId, aaguid, providerLabel });
```

> 服务端（认证成功后）——只贴**需新增**行：

```ts
// 上一行：用 rawId 找回凭据，连同 providerLabel 返回前端做 UI 展示
const cred = await getCredentialById(credentialId);
return { ok: true, providerLabel: cred?.providerLabel ?? "Unknown" };
```

---

## 参考

- `authenticatorAttachment` 仅提供**类别**（platform / cross-platform），不包含品牌。([MDN Web Docs][2])
- 用 AAGUID 在**注册时**标注“哪个提供方创建了该 passkey”（仅用于展示；无背书时不要做安全决策）。([web.dev][3])
- WebAuthn 的**隐私/最小披露**模型（无法直接知道品牌）。([W3C][1])
- 客户端能力探测（hybridTransport/conditional UI 等）。([MDN Web Docs][6])
- SimpleWebAuthn：注册/认证与 **multiDevice/credentialBackedUp** 语义，用于补充标签。([简单网页认证][7])

---

需要的话，我可以顺手给你一份**AAGUID→ 提供方**的 JSON 映射样例（含 Google/Apple/YubiKey/Windows Hello 的常见 AAGUID），以及**注册环节如何在 none attestation 下做“仅展示用途”的安全说明**。

[1]: https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com "An API for accessing Public Key Credentials - Level 3"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/authenticatorAttachment "PublicKeyCredential: authenticatorAttachment property - Web APIs | MDN"
[3]: https://web.dev/articles/webauthn-aaguid "Determine the passkey provider with AAGUID  |  Articles  |  web.dev"
[4]: https://web.dev/articles/passkey-form-autofill?utm_source=chatgpt.com "Sign in with a passkey through form autofill | Articles"
[5]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions "Web Authentication extensions - Web APIs | MDN"
[6]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/getClientCapabilities_static?utm_source=chatgpt.com "PublicKeyCredential: getClientCapabilities() static method"
[7]: https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com "Passkeys"
[8]: https://github.com/w3c/webauthn/issues/1691?utm_source=chatgpt.com "devicePubKey extension MUST be supported if multi- ..."

好嘞，给你一套**可直接用的 AAGUID → 提供方映射样例（JSON）**，再配**后端最小改动片段**（注册提取并存 AAGUID、登录返回 providerLabel）。我只给**必要片段**，复杂逻辑在上一行写中文注释，符合你的习惯。

---

## 1) AAGUID → 提供方映射（建议放到 `aaguid.providers.ts`）

> 说明：这只是**用于 UI 展示**的“友好标签”，**不要**据此做安全决策；Apple/Safari 常见全 0 AAGUID，无法唯一指向 Apple。Google/Windows/YubiKey 取值参考了权威与社区清单（见文末引用）。

```ts
// 上一行：AAGUID → 人类可读标签（仅展示用途）
export const AAGUID_PROVIDER_MAP: Record<string, string> = {
  // Google Password Manager（Chrome/Android 等）
  "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4": "Google Password Manager", // :contentReference[oaicite:0]{index=0}

  // Windows Hello（多种形态）
  "6028b017-b1d4-4c02-b4b3-afcdafc96bb2": "Windows Hello (Software)", // :contentReference[oaicite:1]{index=1}
  "9ddd1817-af5a-4672-a2b9-3e3dd95000a9": "Windows Hello (VBS Hardware)", // :contentReference[oaicite:2]{index=2}
  "08987058-cadc-4b81-b6e1-30de50dcbe96": "Windows Hello (Hardware)", // :contentReference[oaicite:3]{index=3}

  // Apple iCloud Keychain：常见 none attestation → 全 0（仅提示用，不可靠）
  "00000000-0000-0000-0000-000000000000":
    "Unknown (可能是 iCloud Keychain / none attestation)", // :contentReference[oaicite:4]{index=4}

  // YubiKey（示例，型号/固件不同对应不同 AAGUID；更多见官方表）
  "ee882879-721c-4913-9775-3dfcce97072a": "YubiKey 5 (USB-A/5.2/5.4)", // :contentReference[oaicite:5]{index=5}
  "2fc0579f-8113-47ea-b116-bb5a8db9202a": "YubiKey 5 NFC / 5C NFC (5.2/5.4)", // :contentReference[oaicite:6]{index=6}
  "fa2b99dc-9e39-4257-8f92-4a30d23c4118": "YubiKey 5 NFC (5.1)", // :contentReference[oaicite:7]{index=7}
  "f8a011f3-8c0a-4d15-8006-17111f9edc7": "Security Key by Yubico (Blue/5.1)", // :contentReference[oaicite:8]{index=8}
};
```

> 可选增强：你也可以在启动时拉取**社区维护清单**（`passkeydeveloper/passkey-authenticator-aaguids`）缓存合并，用于展示；该清单不保证长期可用且**不是**安全来源。([GitHub][1])

---

## 2) 映射函数（空/未知兜底）

```ts
// 上一行：把 AAGUID 映射成“展示用标签”，未知或空值兜底
export function mapAAGUIDToProvider(aaguid?: string | null): string {
  if (!aaguid) return "Unknown";
  const key = aaguid.toLowerCase();
  return AAGUID_PROVIDER_MAP[key] ?? "Unknown";
}
```

---

## 3) 注册成功后，提取并持久化 AAGUID（NestJS + simplewebauthn v11+）

```ts
// 上一行：注册校验成功后，提取 aaguid，仅用于 UI 展示（不要做安全准入）
const { verified, registrationInfo } = await verifyRegistrationResponse(params);
if (!verified || !registrationInfo)
  throw new UnauthorizedException("Invalid attestation");

const aaguid = registrationInfo.aaguid ?? null;
const providerLabel = mapAAGUIDToProvider(aaguid);

// 上一行：把 aaguid / providerLabel 和 credentialId、公钥、counter 等一起存库
await credentialsRepo.upsert({
  userId,
  credentialId: base64url(credentialIDBuffer),
  publicKey: base64url(publicKeyBuffer),
  counter: registrationInfo.credential?.counter ?? 0,
  aaguid,
  providerLabel, // ← 认证时可直接回传做 UI 展示
});
```

> 注：很多平台/浏览器默认 **none attestation**，AAGUID 可能是全 0 或不可用；因此**只能展示**，**不要据此放行/拒绝**。([Stack Overflow][2])

---

## 4) 认证成功后，把 providerLabel 回给前端（方便 UI 显示“来自…”）

```ts
// 上一行：校验断言通过后，用 rawId 定位凭据
const cred = await credentialsRepo.findById(payload.rawId);

// 上一行：把之前存的 providerLabel 返回给前端，仅作展示
return {
  ok: true,
  providerLabel: cred?.providerLabel ?? "Unknown",
  // 也可以带上 credentialDeviceType/credentialBackedUp 做补充标签
};
```

---

## 5) 关键注意

- **Apple / Safari**：经常拿到**全 0 AAGUID**（或拿不到），这是隐私设计 + none attestation 的结果，**不能**唯一指向“Apple”。([Apple Developer][3])
- **Windows Hello**：存在**多个 AAGUID**（Software / Hardware / VBS Hardware），上面的三枚是公开常见值。([corbado.com][4])
- **Google Password Manager**：目前常见 AAGUID 为 `ea9b8d66-...`（历史上有过变化）。([谷歌集团][5])
- **YubiKey**：**型号 + 固件版本**不同会有不同 AAGUID，请以**官方表**为准（我在样例里只挑了几条常用）。([Yubico Support][6])
- **用途边界**：AAGUID 适合**给用户看**（“这把凭据来自 … ”），**安全策略**应以 FIDO MDS、证书链、政策（UV/UP、signCount 等）为主。([W3C][7])

---

## 参考

- Google Password Manager AAGUID（官方/社区多处一致）。([corbado.com][8])
- Windows Hello 常见 AAGUID。([corbado.com][4])
- YubiKey 官方 AAGUID 列表（持续更新）。([Yubico Support][6])
- Apple/iCloud Keychain 常见全 0 AAGUID（none attestation）。([Apple Developer][3])
- web.dev：用 AAGUID 仅做**展示**用途的最佳实践与社区清单。([web.dev][9])

需要的话我可以再给一版**带图标的映射**（顺手接入 `webauthn.passwordless.id` 的图标 CDN，命名为 `{aaguid}-light.png` / `{aaguid}-dark.png`），这样前端账号设置页能直接显示小图标。([webauthn.passwordless.id][10])

[1]: https://github.com/passkeydeveloper/passkey-authenticator-aaguids?utm_source=chatgpt.com "passkeydeveloper/passkey-authenticator-aaguids"
[2]: https://stackoverflow.com/questions/76815329/does-webauthn-support-finding-out-where-passkeys-are-stored?utm_source=chatgpt.com "Does WebAuthn support finding out where passkeys are ..."
[3]: https://developer.apple.com/forums/tags/passkeys-in-icloud-keychain/?page=2&sortBy=lastUpdated&utm_source=chatgpt.com "Passkeys in iCloud Keychain"
[4]: https://www.corbado.com/glossary/windows-hello?utm_source=chatgpt.com "What is Windows Hello? Definition, AAGUID and Role in ..."
[5]: https://groups.google.com/a/fidoalliance.org/g/fido-dev/c/o-wZ1LeWKIM?utm_source=chatgpt.com "Google Passkey AAGUID"
[6]: https://support.yubico.com/hc/en-us/articles/360016648959-YubiKey-hardware-FIDO2-AAGUIDs "YubiKey hardware FIDO2 AAGUIDs – Yubico"
[7]: https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com "Web Authentication: An API for accessing Public Key ..."
[8]: https://www.corbado.com/glossary/google-password-manager?utm_source=chatgpt.com "What is Google Password Manager? Definition, AAGUID ..."
[9]: https://web.dev/articles/webauthn-aaguid?utm_source=chatgpt.com "Determine the passkey provider with AAGUID | Articles"
[10]: https://webauthn.passwordless.id/demos/authenticators?utm_source=chatgpt.com "Passkeys authenticators list"
