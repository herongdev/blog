<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>我的博客</title>
        <link>https://herongdev.github.io/blog</link>
        <description>个人博客 RSS</description>
        <lastBuildDate>Tue, 09 Sep 2025 14:23:19 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <atom:link href="https://herongdev.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）]]></title>
            <link>https://herongdev.github.io/blog/posts/requirement-realization-1</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/requirement-realization-1</guid>
            <pubDate>Fri, 05 Sep 2025 00:54:31 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: 已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）
date: 2025-09-05
tags:

- Passkeys
- WebAuthn
- 账号绑定
- 设备唯一

---

## 摘要

当**用户已经登录（本地有 JWT/token）**时，常见需求是“**再绑定一把通行密钥**”（或在新设备上补绑）。本文给出一个**稳妥的一次点击方案**：

- 前端：带上 **Authorization: Bearer \<token>** 与 **X-Device-Id（设备唯一码）** 请求 `/passkeys/register/options`。
- 浏览器完成 `navigator.credentials.create(...)` 后，将结果 + `deviceIdentifier` 回传 `/passkeys/register/verify`。
- 后端：从 **token 解析 userId**，生成/校验 challenge、**入库凭证**，并执行**设备唯一绑定**（`deviceId -> userId`）。

> 关键点：**不要尝试枚举本地是否已有凭证**；隐私模型不允许。登录态下的“绑定”其实就是“已知用户的注册流程”。

---

## 设计要点

- **用户唯一标识**：后端**不靠前端传 userId**，而是从 **JWT** 中解析（`sub`）→ 更安全。
- **设备唯一**：前端生成/缓存 `deviceId`，通过 `X-Device-Id` 头传给后端；后端使用 `dvc:owner:${deviceId}` 在 Redis 做“一致性绑定”。
- **防重复注册**：注册 options 中使用 `excludeCredentials`（由后端查询该用户已绑定的 credentialId）。
- **风控与速率限制**：对 `deviceId` 做限流（如 1h/3 次），并在 verify 阶段二次校验。
- **协议对齐**：保持与登录/JIT 注册完全相同的编码规范（字节字段统一 **base64url**）。

---

## 前端实现（Web）

> 仅新增**一个按钮事件**用于“绑定通行密钥”。代码自包含；把 `BASE_URL` 改成你的后端地址即可。
> 复杂逻辑均在上一行写注释。

```html
<!-- 你的页面按钮 -->
<button id="btn-bind-passkey">绑定通行密钥</button>
<pre
  id="log"
  style="background:#111;color:#9f9;padding:12px;white-space:pre-wrap"
></pre>

<script type="module">
  // ========= 工具：设备ID与 base64url 转换 =========
  function getDeviceId() {
    let id = localStorage.getItem("device_id");
    if (!id) {
      id =
        crypto?.randomUUID?.() ||
        "dev-" + Date.now() + "-" + Math.random().toString(16).slice(2);
      localStorage.setItem("device_id", id);
    }
    return id;
  }
  function b64urlToBuf(b64url) {
    const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
    const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
    const bin = atob(b64);
    const buf = new ArrayBuffer(bin.length);
    const view = new Uint8Array(buf);
    for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
    return buf;
  }
  function bufToB64url(buf) {
    const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
    let s = "";
    for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
    return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  // 复杂：把 CreationOptions 中的 base64url → ArrayBuffer
  function toCreationOptions(serverOpts) {
    const opts = structuredClone(serverOpts);
    if (typeof opts.challenge === "string")
      opts.challenge = b64urlToBuf(opts.challenge);
    if (opts.user && typeof opts.user.id === "string")
      opts.user.id = b64urlToBuf(opts.user.id);
    if (Array.isArray(opts.excludeCredentials)) {
      opts.excludeCredentials = opts.excludeCredentials.map((c) => ({
        ...c,
        id: b64urlToBuf(c.id),
      }));
    }
    return opts;
  }
  // 复杂：将 create() 结果打包为后端可校验的 JSON（统一 base64url）
  function packAttestation(cred) {
    return {
      id: cred.id,
      rawId: bufToB64url(cred.rawId),
      type: cred.type,
      response: {
        clientDataJSON: bufToB64url(cred.response.clientDataJSON),
        attestationObject: bufToB64url(cred.response.attestationObject),
      },
      clientExtensionResults: cred.getClientExtensionResults?.() || {},
    };
  }
  // 复杂：通用 POST，附带 token 与设备ID
  async function postJSON(url, body, token) {
    const res = await fetch(url, {
      method: "POST",
      credentials: "include",
      headers: {
        "content-type": "application/json",
        "X-Device-Id": getDeviceId(), // 设备唯一
        ...(token ? { Authorization: `Bearer ${token}` } : {}), // 已登录用户必带
      },
      body: JSON.stringify(body || {}),
    });
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return res.json();
  }

  // ========= 绑定入口：用户已登录（本地有 token） =========
  const BASE_URL = ""; // 同源可留空；跨域改成你的后端地址
  function getToken() {
    // 复杂：示例从 localStorage 取；实际按你的项目来源（Cookie/JWT 管理方案）
    return localStorage.getItem("token");
  }
  async function bindPasskey() {
    const log = (m) =>
      (document.getElementById(
        "log"
      ).textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`);
    const token = getToken();
    if (!token) {
      log("未登录：请先登录再绑定");
      return;
    }

    try {
      // 复杂：步骤1——向后端请求“注册（绑定）options”，后端将从 JWT 解析 userId
      log("请求 /passkeys/register/options ...");
      const data = await postJSON(
        `${BASE_URL}/passkeys/register/options`,
        {},
        token
      );
      const serverOptions = data.options || data; // 兼容返回形态
      const publicKey = toCreationOptions(serverOptions);

      // 复杂：步骤2——发起浏览器创建凭据
      log("调用 navigator.credentials.create ...");
      const att = await navigator.credentials.create({ publicKey });

      // 复杂：步骤3——打包 + 回传 verify，并带上 deviceIdentifier 以完成设备唯一绑定
      log("提交 /passkeys/register/verify ...");
      const verifyBody = {
        ...packAttestation(att),
        deviceIdentifier: getDeviceId(),
      };
      const verifyResp = await postJSON(
        `${BASE_URL}/passkeys/register/verify`,
        verifyBody,
        token
      );

      log("绑定完成 ✅ " + JSON.stringify(verifyResp));
      alert("通行密钥绑定成功");
    } catch (e) {
      console.error(e);
      alert("绑定失败：" + (e?.message || e));
    }
  }

  // 绑定按钮点击
  document
    .getElementById("btn-bind-passkey")
    ?.addEventListener("click", bindPasskey);
</script>
```

> 若你在 **uni-app**（H5）里使用，也可沿用同样逻辑；在 **App（UTS 插件）** 上只需把 `navigator.credentials.create` 替换为你的 `passkeys.createPasskey(optionsJson)` 即可，其余协议不变。

---

## 后端实现（NestJS，仅给“增量/改动片段”）

> 你的工程里已有 JIT 与登录接口。这里**新增/完善**“**已登录的注册（绑定）**”两个端点，并对 Service 增强**按 token 解析 user** 与**设备唯一**。

### 1）Controller 片段

```ts
// 复杂：新增“已登录绑定”端点；依赖 JWT 守卫把 user 注入 request.user
import { Controller, Post, Req, UseGuards, Body } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
import { PasskeysService } from "../../services/passkeys.service";

@Controller("passkeys")
export class PasskeysController {
  constructor(private readonly passkeysService: PasskeysService) {}

  // 复杂：注册（绑定）options——登录态
  @UseGuards(AuthGuard("jwt"))
  @Post("register/options")
  getBindOptions(@Req() req: any) {
    // 复杂：设备ID从 Header/Cookie/IP 提取，用于风控与后续绑定一致性
    const deviceIdentifier =
      req.headers["x-device-id"] || req.cookies?.dvc || `ip:${req.ip}`;
    const userId = req.user?.sub; // 复杂：从 JWT 解析出的 userId
    return this.passkeysService.issueRegistrationOptionsForUser(
      userId,
      deviceIdentifier
    );
  }

  // 复杂：注册（绑定）verify——登录态
  @UseGuards(AuthGuard("jwt"))
  @Post("register/verify")
  verifyBind(@Req() req: any, @Body() body: any) {
    const deviceIdentifier =
      req.headers["x-device-id"] ||
      body.deviceIdentifier ||
      req.cookies?.dvc ||
      `ip:${req.ip}`;
    const userId = req.user?.sub;
    return this.passkeysService.verifyRegistrationForUser(
      userId,
      body,
      deviceIdentifier
    );
  }
}
```

### 2）Service 片段

```ts
// 复杂：为“已登录绑定”增加两个方法
@Injectable()
export class PasskeysService {
  // ... 省略已有依赖与构造

  // 复杂：签发已登录用户的注册 options（含 excludeCredentials 与限流）
  async issueRegistrationOptionsForUser(
    userId: string,
    deviceIdentifier?: string
  ) {
    if (!userId) throw new UnauthorizedException("未登录");

    // 复杂：限流（1h/3次）
    if (deviceIdentifier) {
      const rlKey = `rl:bind:${deviceIdentifier}`;
      const n = await this.redisService.incrementKey(rlKey);
      if (n === 1) await this.redisService.expireKey(rlKey, 3600);
      if (n > 3) throw new BadRequestException("操作过于频繁，请稍后再试");
    }

    const rpId = this.configService.get<string>("RP_ID");

    // 复杂：查询该用户已有凭证，构造 excludeCredentials 防重复注册
    const existing = await this.staffService.findManyCredentialsByUserId(
      userId
    ); // 需要你实现查询
    const exclude = (existing || []).map((c: any) => ({
      id: Buffer.from(c.credentialId, "base64url"),
      type: "public-key" as const,
    }));

    const options = await generateRegistrationOptions({
      rpName: "Your App",
      rpID: rpId,
      // 复杂：v11+ 要求 userID 为字节；这里直接用 UTF-8 Buffer
      userID: Buffer.from(String(userId), "utf8"),
      userName: String(userId),
      attestationType: "none",
      // 复杂：兼容性更好（ES256 + RS256）
      supportedAlgorithmIDs: [-7, -257],
      authenticatorSelection: {
        residentKey: "required", // 复杂：要求可发现凭证，便于后续一键直登
        userVerification: "preferred",
      },
      excludeCredentials: exclude,
      extensions: { credProps: true },
    });

    // 复杂：将 challenge(base64url) 与 user 绑定，TTL 5 分钟
    const ch =
      typeof options.challenge === "string"
        ? options.challenge
        : Buffer.from(options.challenge).toString("base64url");
    await this.redisService.setWithTimeToLive(
      `webauthn:register:${userId}`,
      ch,
      300
    );

    return { options };
  }

  // 复杂：校验 attestation + 入库 + 设备唯一绑定（不重新发 token，也可选择刷新）
  async verifyRegistrationForUser(
    userId: string,
    requestBody: any,
    deviceIdentifier?: string
  ) {
    if (!userId) throw new UnauthorizedException("未登录");

    const rpId = this.configService.get<string>("RP_ID");
    const origin = this.configService.get<string>("ORIGIN");
    const cachedChallenge = await this.redisService.getValue(
      `webauthn:register:${userId}`
    );
    if (!cachedChallenge)
      throw new BadRequestException("注册挑战不存在或已过期");

    const verification = await verifyRegistrationResponse({
      response: requestBody,
      expectedRPID: rpId,
      expectedOrigin: origin,
      expectedChallenge: cachedChallenge,
      requireUserVerification: true, // 复杂：绑定建议要求 UV
    });
    if (!verification.verified || !verification.registrationInfo) {
      throw new UnauthorizedException("注册校验失败");
    }

    const { credential } = verification.registrationInfo;
    const credentialIdB64url = Buffer.from(credential.id).toString("base64url");
    const publicKey = Buffer.from(credential.publicKey); // 存二进制或 base64 皆可
    const counter = credential.counter ?? 0;

    // 复杂：入库（若同 credentialId 已存在且属同人，可忽略/幂等）
    await this.staffService.upsertCredential({
      userId,
      credentialId: credentialIdB64url,
      publicKey,
      counter,
      transports: credential.transports
        ? JSON.stringify(credential.transports)
        : null,
    });

    // 复杂：设备唯一绑定（若存在 deviceId 且已被他人占用，则拒绝）
    if (deviceIdentifier) {
      const key = `dvc:owner:${deviceIdentifier}`;
      const existed = await this.redisService.getValue(key);
      if (existed && existed !== String(userId)) {
        throw new ForbiddenException("此设备已绑定其他账号");
      }
      // 绑定一年（或不设 TTL）
      await this.redisService.setWithTimeToLive(key, String(userId), 31536000);
    }

    await this.redisService.deleteKey(`webauthn:register:${userId}`);
    // 已登录状态下可不必重签 token；如需刷新可在此签新 JWT
    return { verified: true, userId, credentialId: credentialIdB64url };
  }
}
```

> 你只需要实现（或补齐）`staffService.findManyCredentialsByUserId` 与 `upsertCredential` 两个数据存取方法；字段即你现有的 `credentialId/publicKey/counter/transports/userId`。

---

## 时序对照（已登录绑定）

1. 前端带 **Authorization** 与 **X-Device-Id** → `POST /passkeys/register/options`
2. 后端从 **JWT** 取 `userId`，构造 **excludeCredentials**，保存 **challenge**
3. 前端调用 **`navigator.credentials.create({ publicKey })`**
4. 前端回传 **attestation + deviceIdentifier** → `/passkeys/register/verify`
5. 后端 **verify + 入库 + 设备唯一绑定** → 返回 `{ verified: true, userId }`

---

## 常见问题

- **为什么不让前端直接传 userId？**
  防止伪造。登录态下应以 **Authorization** 为准，由后端解析身份。

- **若用户已绑定过此设备，再次点击绑定会怎样？**
  由于 `excludeCredentials` 与 `dvc:owner:*` 绑定同时生效，**不会重复写入**；可返回幂等成功或提示“已绑定”。

- **如何与一键直登/JIT 流程共存？**

  - **未登录**：走 `/login/options` → 失败回退 `/register-or-login/*`。
  - **已登录**：走本文 `/register/*`（绑定专用）。两套互不冲突。

---

## 小结

- **唯一标识传递**：已登录场景下，把 **用户身份交给 JWT**，把 **设备唯一交给 `X-Device-Id`**。
- **绑定即注册**：本质是“已知用户”的注册流程；用 `excludeCredentials` 防重复，用 Redis 绑定 `deviceId -> userId`。
- **最少交互**：一次点击完成整个绑定，协议与登录/JIT 完全一致，维护成本低。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[在你现有 uvue 登录页集成“一键通行密钥登录”（含回退注册），完整代码可直接替换]]></title>
            <link>https://herongdev.github.io/blog/posts/requirement-realization-2</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/requirement-realization-2</guid>
            <pubDate>Fri, 05 Sep 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
## 目标

把我们讨论的“**先尝试通行密钥登录 → 失败自动回退到 JIT 注册并登录**”接到你这份 **uvue（uni-app x）页面** 上，**保留原有微信登录按钮**，新增一个“通行密钥登录”按钮。
支持：

- **App 端（Android/iOS）**：走你自定义的 **UTS 插件** `@/uni_modules/pass-keys`（`getPasskey`/`createPasskey`）。
- **H5 端**：走浏览器 WebAuthn（`navigator.credentials.get/create`）。
- **设备唯一**：用 `deviceIdentifier`（App 用 `plus.device.uuid`，H5 用本地生成）传后端，便于 `deviceId -> userId` 绑定。

> 复杂逻辑均在代码**上一行加中文注释**。下面给出**整文件覆盖式代码**（符合你“Passkeys 项目优先给完整文件”的约定）。

---

## 完整代码（直接替换你当前页面）

```vue
<template>
  <view class="container">
    <view class="header">
      <text class="title">欢迎使用商户平台</text>
    </view>

    <view v-if="!baseUrl" class="tip">
      <text class="tip-text">未配置后端地址，请先配置</text>
      <button size="mini" @tap="openConfig">去配置</button>
    </view>

    <view class="actions">
      <button
        type="primary"
        :disabled="!baseUrl || loading"
        @tap="onWeChatLogin"
      >
        {{
          baseUrl
            ? isWeChatInstalled
              ? "微信登录"
              : "登录"
            : "请先配置后端地址"
        }}
      </button>

      <!-- 新增：通行密钥一键登录（失败自动回退注册并登录） -->
      <button
        style="margin-top:12rpx"
        :disabled="!baseUrl || loading"
        @tap="onPasskeyLogin"
      >
        {{ loading ? "处理中..." : "通行密钥登录" }}
      </button>
    </view>

    <view v-if="loading" class="loading-mask">
      <view class="loading-box"><text>处理中...</text></view>
    </view>

    <view v-if="showConfig" class="modal-mask" @tap="closeConfig">
      <view class="modal" @tap.stop>
        <text class="modal-title">配置后端地址</text>
        <input
          class="modal-input"
          type="text"
          v-model="configInput"
          placeholder="例如：https://api.example.com"
        />
        <view class="modal-actions">
          <button size="mini" @tap="closeConfig">取消</button>
          <button type="primary" size="mini" @tap="saveConfig">保存</button>
        </view>
      </view>
    </view>
  </view>
</template>

<script>
// #ifdef APP-PLUS
// 复杂逻辑：App 端引入你的 UTS 插件（Android/iOS 调平台原生 Credential/AuthenticationServices）
import * as passkeys from "@/uni_modules/pass-keys";
// #endif

export default {
  data() {
    return {
      baseUrl: "",
      loading: false,
      isWeChatInstalled: true,
      showConfig: false,
      configInput: "",
      // 复杂逻辑：设备唯一标识；App=plus.device.uuid；H5=本地生成并持久化
      deviceId: "",
    };
  },
  onLoad() {
    this.baseUrl = uni.getStorageSync("BASE_URL") || "";
    // 复杂逻辑：初始化设备ID（用于 deviceId -> userId 绑定与风控）
    // #ifdef APP-PLUS
    this.deviceId =
      plus && plus.device && plus.device.uuid
        ? plus.device.uuid
        : "app-" + Date.now();
    // #endif
    // #ifdef H5
    const key = "DEVICE_ID";
    this.deviceId = localStorage.getItem(key);
    if (!this.deviceId) {
      this.deviceId =
        crypto?.randomUUID?.() ||
        "web-" + Date.now() + "-" + Math.random().toString(16).slice(2);
      localStorage.setItem(key, this.deviceId);
    }
    // #endif
  },
  methods: {
    openConfig() {
      this.configInput = this.baseUrl;
      this.showConfig = true;
    },
    closeConfig() {
      this.showConfig = false;
    },
    saveConfig() {
      this.baseUrl = (this.configInput || "").trim();
      uni.setStorageSync("BASE_URL", this.baseUrl);
      this.showConfig = false;
      uni.showToast({ title: "已保存", icon: "success" });
    },

    // 复杂逻辑：统一 POST 封装；把 deviceIdentifier 一并传给后端（也可由 Header 传）
    async post(path, body) {
      return await new Promise((resolve, reject) => {
        uni.request({
          url: `${this.baseUrl}${path}`,
          method: "POST",
          data: { deviceIdentifier: this.deviceId, ...(body || {}) },
          dataType: "json",
          header: { "content-type": "application/json" },
          success: (res) => resolve(res.data),
          fail: reject,
        });
      });
    },

    // 保留原有：微信登录
    async onWeChatLogin() {
      if (!this.baseUrl) return;
      this.loading = true;
      try {
        let code = "";
        // 小程序端获取 code
        // #ifdef MP-WEIXIN
        const res = await new Promise((resolve, reject) => {
          uni.login({ provider: "weixin", success: resolve, fail: reject });
        });
        code = res.code || "";
        // #endif

        // 其他端未集成微信登录，给出提示
        // #ifndef MP-WEIXIN
        throw new Error("当前平台未集成微信登录");
        // #endif

        if (!code) throw new Error("获取登录凭证失败");
        const data = await this.post("/admin/wechat/login", { code });
        if (
          data &&
          data.success === true &&
          data.userInfo &&
          data.userInfo.approved === true &&
          data.userInfo.token
        ) {
          uni.setStorageSync("TOKEN", data.userInfo.token);
          uni.showToast({ title: "登录成功", icon: "success" });
          setTimeout(() => {
            uni.reLaunch({ url: "/pages/index/index" });
          }, 600);
        } else {
          throw new Error(data?.message || "登录失败");
        }
      } catch (e) {
        uni.showToast({ title: e?.message || String(e), icon: "none" });
      } finally {
        this.loading = false;
      }
    },

    // ================== 通行密钥一键登录入口（失败回退注册） ==================
    async onPasskeyLogin() {
      if (!this.baseUrl) return;
      this.loading = true;
      try {
        // 复杂逻辑：步骤A——请求登录 options（无用户名直登；后端可按设备ID定向返回 allowCredentials）
        const resp = await this.post("/passkeys/login/options", {});
        const options = resp.options || resp;

        // #ifdef APP-PLUS
        // 复杂逻辑：App 端调用 UTS 插件进行“使用通行密钥”
        const requestOptionsJson = JSON.stringify(options);
        const authRespJson = await passkeys.getPasskey(requestOptionsJson, {
          conditional: true,
        });
        const verifyBody = JSON.parse(authRespJson);
        // #endif

        // #ifdef H5
        // 复杂逻辑：H5 端使用 WebAuthn —— 将 base64url 字段转 ArrayBuffer
        const publicKey = this.toWebAuthnRequestOptions(options);
        // 复杂逻辑：若支持条件UI，mediation='conditional'，否则 'required'（需用户手势）
        const mediation = (await this.isConditionalUI())
          ? "conditional"
          : "required";
        const assertion = await navigator.credentials.get({
          publicKey,
          mediation,
        });
        const verifyBody = this.packAssertion(assertion);
        // #endif

        // 复杂逻辑：步骤B——提交登录 verify
        const verify = await this.post("/passkeys/login/verify", verifyBody);
        this.onLoginSucceed(verify);
      } catch (e) {
        // 复杂逻辑：登录失败（无凭据/取消/过期）→ 步骤C——回退到 JIT 注册
        try {
          const jit = await this.post(
            "/passkeys/register-or-login/options",
            {}
          );
          const userId = jit.userId || jit?.user?.id;
          const creationOptions = jit.options || jit;

          // #ifdef APP-PLUS
          // 复杂逻辑：App 端调用 UTS 插件“创建通行密钥”
          const creationOptionsJson = JSON.stringify(creationOptions);
          const regRespJson = await passkeys.createPasskey(creationOptionsJson);
          const verifyRegBody = {
            ...JSON.parse(regRespJson),
            userId,
            deviceIdentifier: this.deviceId,
          };
          // #endif

          // #ifdef H5
          // 复杂逻辑：H5 端 WebAuthn —— 转换 base64url → ArrayBuffer，发起 create
          const publicKey = this.toWebAuthnCreationOptions(creationOptions);
          const attestation = await navigator.credentials.create({ publicKey });
          const verifyRegBody = {
            ...this.packAttestation(attestation),
            userId,
            deviceIdentifier: this.deviceId,
          };
          // #endif

          // 复杂逻辑：步骤D——提交注册 verify（完成入库+设备唯一绑定+签发会话）
          const verify = await this.post(
            "/passkeys/register-or-login/verify",
            verifyRegBody
          );
          this.onLoginSucceed(verify, true);
        } catch (e2) {
          uni.showToast({ title: e2?.message || String(e2), icon: "none" });
        }
      } finally {
        this.loading = false;
      }
    },

    // 复杂逻辑：登录/注册成功后的统一处理（落 token + 跳转）
    onLoginSucceed(verify, isRegister = false) {
      if (verify?.verified) {
        if (verify.token) {
          uni.setStorageSync("TOKEN", verify.token);
        }
        uni.showToast({
          title: isRegister ? "已注册并登录" : "登录成功",
          icon: "success",
        });
        setTimeout(() => {
          uni.reLaunch({ url: "/pages/index/index" });
        }, 600);
      } else {
        throw new Error("校验失败");
      }
    },

    // ================== H5 专用辅助：WebAuthn 转换与打包 ==================
    // #ifdef H5
    // 复杂逻辑：检测是否支持条件UI
    async isConditionalUI() {
      try {
        return !!(await PublicKeyCredential.isConditionalMediationAvailable?.());
      } catch {
        return false;
      }
    },
    // 复杂逻辑：base64url → ArrayBuffer
    b64urlToBuf(b64url) {
      const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
      const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
      const bin = atob(b64);
      const buf = new ArrayBuffer(bin.length);
      const view = new Uint8Array(buf);
      for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
      return buf;
    },
    // 复杂逻辑：ArrayBuffer/Uint8Array → base64url
    bufToB64url(buf) {
      const b = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
      let s = "";
      for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);
      return btoa(s)
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/g, "");
    },
    // 复杂逻辑：将登录 options（服务端 base64url）转为 WebAuthn 可用结构
    toWebAuthnRequestOptions(serverOpts) {
      const opts = JSON.parse(JSON.stringify(serverOpts));
      if (typeof opts.challenge === "string")
        opts.challenge = this.b64urlToBuf(opts.challenge);
      if (Array.isArray(opts.allowCredentials)) {
        opts.allowCredentials = opts.allowCredentials.map((c) => ({
          ...c,
          id: typeof c.id === "string" ? this.b64urlToBuf(c.id) : c.id,
        }));
      }
      return opts;
    },
    // 复杂逻辑：将注册 options 转为 WebAuthn 可用结构
    toWebAuthnCreationOptions(serverOpts) {
      const opts = JSON.parse(JSON.stringify(serverOpts));
      if (typeof opts.challenge === "string")
        opts.challenge = this.b64urlToBuf(opts.challenge);
      if (opts.user && typeof opts.user.id === "string")
        opts.user.id = this.b64urlToBuf(opts.user.id);
      if (Array.isArray(opts.excludeCredentials)) {
        opts.excludeCredentials = opts.excludeCredentials.map((c) => ({
          ...c,
          id: typeof c.id === "string" ? this.b64urlToBuf(c.id) : c.id,
        }));
      }
      return opts;
    },
    // 复杂逻辑：将 get() 结果打包为后端可校验的 JSON（统一 base64url）
    packAssertion(cred) {
      const resp = cred.response;
      return {
        id: cred.id,
        rawId: this.bufToB64url(cred.rawId),
        type: cred.type,
        response: {
          clientDataJSON: this.bufToB64url(resp.clientDataJSON),
          authenticatorData: this.bufToB64url(resp.authenticatorData),
          signature: this.bufToB64url(resp.signature),
          userHandle: resp.userHandle
            ? this.bufToB64url(resp.userHandle)
            : null,
        },
        clientExtensionResults: cred.getClientExtensionResults?.() || {},
      };
    },
    // 复杂逻辑：将 create() 结果打包为后端可校验的 JSON（统一 base64url）
    packAttestation(cred) {
      const resp = cred.response;
      return {
        id: cred.id,
        rawId: this.bufToB64url(cred.rawId),
        type: cred.type,
        response: {
          clientDataJSON: this.bufToB64url(resp.clientDataJSON),
          attestationObject: this.bufToB64url(resp.attestationObject),
        },
        clientExtensionResults: cred.getClientExtensionResults?.() || {},
      };
    },
    // #endif
  },
};
</script>

<style>
.container {
  padding: 24rpx;
}
.header {
  margin-top: 40rpx;
  margin-bottom: 24rpx;
}
.title {
  font-size: 36rpx;
  font-weight: 600;
  text-align: center;
}
.tip {
  display: flex;
  align-items: center;
  gap: 16rpx;
  padding: 16rpx;
  margin: 12rpx 0;
  border: 1px solid #ffc107;
  background: #fff8e1;
  border-radius: 12rpx;
}
.tip-text {
  color: #8d6e63;
  font-size: 26rpx;
}
.actions {
  margin-top: 24rpx;
  display: flex;
  flex-direction: column;
}
.loading-mask {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
}
.loading-box {
  padding: 20rpx;
  background: #fff;
  border-radius: 12rpx;
}
.modal-mask {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
}
.modal {
  width: 80%;
  background: #fff;
  border-radius: 16rpx;
  padding: 24rpx;
}
.modal-title {
  font-size: 30rpx;
  font-weight: 600;
}
.modal-input {
  border: 1px solid #eee;
  margin: 16rpx 0;
  padding: 12rpx;
  border-radius: 8rpx;
}
.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12rpx;
}
</style>
```

---

## 说明与对接要点

- **后端路由**保持为：

  - `/passkeys/login/options` → 返回 `PublicKeyCredentialRequestOptions`（`challenge`/`allowCredentials[].id` 为 **base64url**）。
  - `/passkeys/login/verify` → 接收 `packAssertion` 结果。
  - `/passkeys/register-or-login/options` → 返回 `{ userId, options }`（注册用，`challenge`/`user.id` 为 **base64url**）。
  - `/passkeys/register-or-login/verify` → 接收 `packAttestation` + `{ userId, deviceIdentifier }`。

- **设备唯一**：页面已在所有请求体中带上 `deviceIdentifier`（`this.deviceId`），你的服务端即可写入/校验 `dvc:owner:*`。
- **H5 前置条件**：需 HTTPS 或 `localhost`；Safari/移动端有平台限制。
- **App 端**：确保 `@/uni_modules/pass-keys` 已实现 `getPasskey`/`createPasskey` 且返回 **JSON 字符串**（与我们前面约定一致）。

需要我把 **“已登录场景的绑定按钮”** 也加到这个页面吗（即 `/passkeys/register/options|verify`，走绑定而非 JIT）？如果要，加哪个位置，我按你“只给改动段”的规范再补。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现]]></title>
            <link>https://herongdev.github.io/blog/posts/requirement-realization</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/requirement-realization</guid>
            <pubDate>Fri, 05 Sep 2025 00:21:16 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现
date: 2025-09-05
tags:

- Passkeys
- WebAuthn
- 前端实战
- 一键直登

---

## 摘要

本文给出 **Web 端** 的最小可用实现：**点击一个按钮 → 优先尝试登录（可发现凭证）→ 若无可用凭证或用户取消，则自动走 JIT 注册并直接登录**。
重点说明：“**不能事先枚举本地是否存在凭据**”（浏览器出于隐私不允许），正确姿势是**拿到服务端的 options 再调用 WebAuthn**，并对失败分支做平滑回退。

---

## 背景与原则

- 浏览器不会暴露“本地是否已有你家 RP 的通行密钥”的枚举 API（防侧信道追踪）。
- 正确流程永远是：**后端发 options（含 challenge）→ 前端发起 `get()`/`create()` → 前端把回包交给后端 `verify`**。
- 若想“先感知再决定”，只能做**能力探测**（如 `isConditionalMediationAvailable()`、`isUserVerifyingPlatformAuthenticatorAvailable()`），但这**不等于**“确有凭据”。
- 因此，本实现直接：**先请求登录 options** → `navigator.credentials.get` → 失败则 **请求注册 options** → `navigator.credentials.create` → 验证成功后**注册即登录**。

---

## 交互时序（简述）

1. 用户点击「一键登录」按钮
2. 前端 `POST /passkeys/login/options`（携带 `X-Device-Id`）
3. 浏览器 `navigator.credentials.get({ publicKey, mediation })`
4. 成功 → 回传 `/passkeys/login/verify` → **登录完成**
5. 失败（无匹配凭据/取消等）→ `POST /passkeys/register-or-login/options`
6. `navigator.credentials.create({ publicKey })`
7. 回传 `/passkeys/register-or-login/verify` → **注册并登录完成**

---

## 完整代码

> 下面给出**可直接粘贴落地**的最小实现（HTML + JS）。
> 复杂逻辑的上一行均有中文注释。
> 假设你的后端路由与本文一致：
>
> - `/passkeys/login/options`、`/passkeys/login/verify`
> - `/passkeys/register-or-login/options`、`/passkeys/register-or-login/verify`

### 1）页面与按钮

```html
<!-- index.html 片段：按钮与日志面板 -->
<button id="btn-passkey">一键通行密钥</button>

<pre
  id="log"
  style="background:#111;color:#9f9;padding:12px;white-space:pre-wrap"
></pre>

<script type="module" src="./passkeys-web.js"></script>
```

### 2）前端模块：`passkeys-web.js`

```js
// ======================= 基础工具 =======================

// 复杂：生成稳定的设备ID（首访生成并持久化，用于设备→账号绑定与风控）
function getDeviceId() {
  const key = "device_id";
  let id = localStorage.getItem(key);
  if (!id) {
    id =
      crypto?.randomUUID?.() ||
      "dev-" + Date.now() + "-" + Math.random().toString(16).slice(2);
    localStorage.setItem(key, id);
  }
  return id;
}

// 复杂：base64url ↔ ArrayBuffer 转换，确保与后端统一
function b64urlToBuf(b64url) {
  const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
  const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
  const str = atob(b64);
  const buf = new ArrayBuffer(str.length);
  const view = new Uint8Array(buf);
  for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);
  return buf;
}
function bufToB64url(buf) {
  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
  let str = "";
  for (let i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

// 复杂：把 AuthenticationOptions 中的 base64url 字段转 ArrayBuffer
function toWebAuthnRequestOptions(serverOpts) {
  const opts = structuredClone(serverOpts);
  // challenge 需要转 ArrayBuffer
  if (typeof opts.challenge === "string")
    opts.challenge = b64urlToBuf(opts.challenge);
  // allowCredentials 中的 id 也需要转 ArrayBuffer
  if (Array.isArray(opts.allowCredentials)) {
    opts.allowCredentials = opts.allowCredentials.map((c) => ({
      ...c,
      id: typeof c.id === "string" ? b64urlToBuf(c.id) : c.id,
    }));
  }
  return opts;
}

// 复杂：把 RegistrationOptions 中的 base64url 字段转 ArrayBuffer/Uint8Array
function toWebAuthnCreationOptions(serverOpts) {
  const opts = structuredClone(serverOpts);
  if (typeof opts.challenge === "string")
    opts.challenge = b64urlToBuf(opts.challenge);
  if (opts.user && typeof opts.user.id === "string")
    opts.user.id = b64urlToBuf(opts.user.id);
  if (Array.isArray(opts.excludeCredentials)) {
    opts.excludeCredentials = opts.excludeCredentials.map((c) => ({
      ...c,
      id: typeof c.id === "string" ? b64urlToBuf(c.id) : c.id,
    }));
  }
  return opts;
}

// 复杂：把 get() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）
function packAssertion(cred) {
  const resp = cred.response;
  return {
    id: cred.id,
    rawId: bufToB64url(cred.rawId),
    type: cred.type,
    response: {
      clientDataJSON: bufToB64url(resp.clientDataJSON),
      authenticatorData: bufToB64url(resp.authenticatorData),
      signature: bufToB64url(resp.signature),
      userHandle: resp.userHandle ? bufToB64url(resp.userHandle) : null,
    },
    clientExtensionResults: cred.getClientExtensionResults?.() || {},
  };
}

// 复杂：把 create() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）
function packAttestation(cred) {
  const resp = cred.response;
  return {
    id: cred.id,
    rawId: bufToB64url(cred.rawId),
    type: cred.type,
    response: {
      clientDataJSON: bufToB64url(resp.clientDataJSON),
      attestationObject: bufToB64url(resp.attestationObject),
    },
    clientExtensionResults: cred.getClientExtensionResults?.() || {},
  };
}

// 复杂：通用 POST 封装，自动带上设备ID
async function postJSON(url, body) {
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      // 设备ID写入 Header，便于后端风控/设备绑定。后端也可从 body 读取。
      "X-Device-Id": getDeviceId(),
    },
    body: JSON.stringify(body || {}),
    credentials: "include",
  });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}

// 复杂：检测“条件UI”与平台验证器可用性（仅做能力判断，不代表一定有凭据）
async function detectSupport() {
  const hasWebAuthn = "PublicKeyCredential" in window;
  let conditional = false,
    uvpa = false;
  try {
    conditional =
      !!(await PublicKeyCredential.isConditionalMediationAvailable?.());
  } catch {}
  try {
    uvpa =
      !!(await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable?.());
  } catch {}
  return { hasWebAuthn, conditional, uvpa };
}

// ======================= 业务主流程 =======================

// 复杂：优先尝试登录（可发现凭证/或定向 allowCredentials）；失败则自动转注册并登录
export async function oneTapPasskey(baseUrl = "") {
  const log = (msg) => {
    const pre = document.getElementById("log");
    if (pre) pre.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    console.log(msg);
  };

  const deviceId = getDeviceId();
  const { hasWebAuthn, conditional, uvpa } = await detectSupport();
  if (!hasWebAuthn) throw new Error("当前环境不支持 WebAuthn");

  log(`检测：conditional=${conditional}, uvpa=${uvpa}`);

  try {
    // ========== 步骤A：请求“登录 options” ==========
    log("请求登录 options...");
    const loginOptsResp = await postJSON(`${baseUrl}/passkeys/login/options`, {
      deviceIdentifier: deviceId,
    });
    const requestOptions = loginOptsResp.options || loginOptsResp; // 兼容你的返回结构
    const publicKey = toWebAuthnRequestOptions(requestOptions);

    // 复杂：若支持条件UI，则 mediation 设为 'conditional'；否则 'required'（需用户手势）
    const mediation = conditional ? "conditional" : "required";

    // ========== 步骤B：发起 credentials.get ==========
    log(`调用 navigator.credentials.get (mediation=${mediation})...`);
    const assertion = await navigator.credentials.get({ publicKey, mediation });

    // ========== 步骤C：打包并回传后端校验 ==========
    log("提交登录 verify...");
    const verifyBody = packAssertion(assertion);
    const verifyResp = await postJSON(
      `${baseUrl}/passkeys/login/verify`,
      verifyBody
    );

    log("登录成功 ✅ " + JSON.stringify(verifyResp));
    return { mode: "login", result: verifyResp };
  } catch (err) {
    // 复杂：常见失败 1）用户取消 2）设备没有匹配凭据 3）options 过期
    console.warn("登录失败，准备转注册：", err);
    // ========== 步骤D：请求“一键注册 options” ==========
    const regOptsResp = await postJSON(
      `${baseUrl}/passkeys/register-or-login/options`,
      {
        deviceIdentifier: deviceId,
      }
    );
    const { userId, options: creationOptionsServer } = regOptsResp.userId
      ? regOptsResp
      : { userId: regOptsResp.userId, options: regOptsResp.options };

    const publicKey = toWebAuthnCreationOptions(creationOptionsServer);

    // ========== 步骤E：发起 credentials.create（注册） ==========
    log("调用 navigator.credentials.create ...");
    const attestation = await navigator.credentials.create({ publicKey });

    // ========== 步骤F：打包并回传后端，完成绑定+激活+登录 ==========
    log("提交注册 verify...");
    const verifyBody = {
      ...packAttestation(attestation),
      userId, // 复杂：JIT 返回的临时/访客 userId
      deviceIdentifier: deviceId, // 复杂：用于设备→账号唯一绑定
    };
    const verifyResp = await postJSON(
      `${baseUrl}/passkeys/register-or-login/verify`,
      verifyBody
    );

    log("注册并登录成功 ✅ " + JSON.stringify(verifyResp));
    return { mode: "register-then-login", result: verifyResp };
  }
}

// ======================= 页面挂载：按钮点击即触发 =======================
document.getElementById("btn-passkey")?.addEventListener("click", () => {
  // 复杂：这里的 baseUrl 请改为你的后端地址；同源部署可留空
  oneTapPasskey("").catch((e) => {
    const pre = document.getElementById("log");
    if (pre) pre.textContent += `❌ ${e?.message || e}\n`;
    console.error(e);
  });
});
```

---

## 与后端契约（对齐要点）

- `/passkeys/login/options`

  - **入参**：`{ deviceIdentifier?: string }`（Header 也可）
  - **返回**：`{ options: PublicKeyCredentialRequestOptions }`（`challenge`、`allowCredentials[].id` 为 **base64url** 字符串）

- `/passkeys/login/verify`

  - **入参**：上文 `packAssertion()` 的结果（所有字节字段 **base64url**）
  - **返回**：`{ verified: true, token, userId }`

- `/passkeys/register-or-login/options`

  - **入参**：`{ deviceIdentifier?: string }`
  - **返回**：`{ userId: string, options: PublicKeyCredentialCreationOptions }`（`challenge`、`user.id`、`excludeCredentials[].id` 为 **base64url**）

- `/passkeys/register-or-login/verify`

  - **入参**：`packAttestation()` + `{ userId, deviceIdentifier }`
  - **返回**：`{ verified: true, token, userId }`

> 以上与您现有的 `PasskeysService` 设计完全兼容。你也可以在“已绑定设备”场景下返回 `allowCredentials`，以提升命中率（文中已说明）。

---

## 常见问题（FAQ）

- **能不能“先看一下本地有没有凭据”，有就登录、没有就不调后端？**
  不能。浏览器不允许枚举凭据。你能做的只是能力探测与**尝试调用** `credentials.get`。而调用 `get/create` 都必须先有**服务端下发的 options（含 challenge）**。

- **什么时候用条件 UI（conditional mediation）？**
  页面加载即拿到 `login options` 后即可“无提示等候”；但为简化，这里在**按钮点击**后再调，用 `mediation='conditional'`（若可用）+ `required` 作为兜底。

- **后端 challenge 过期怎么办？**
  统一设置较短 TTL（如 300s），一旦 `get/create` 抛出 `InvalidStateError/NotAllowedError`，前端直接重拉 options 再试。

---

## 测试步骤

1. **HTTPS 环境**部署（本地可用 `localhost`）
2. **确保后端 RP_ID/ORIGIN 正确**、Redis 正常、四个路由可达
3. 首次访问：点击按钮 → 预期走注册 → 后端 verify 成功后返回 token
4. 再次访问：点击按钮 → 直接 `get()` 登录成功
5. Android/Chrome 测试条件 UI：地址栏出现通行密钥提示；Safari 需同源 HTTPS

---

## 小结

- “先判断本地是否有凭据”在浏览器上**不可行**；
- **正确做法**是**每次先拿登录 options**，用 `credentials.get` 尝试登录；
- **失败则无缝切到注册**（JIT 建号 + 可发现凭证 + 注册即登录）。
- 上文代码开箱即用，你只需要把 `baseUrl` 指向你的后端即可。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[鉴权判定“最佳实践”：别维护白名单数组，用“前缀约定 + 显式覆盖”]]></title>
            <link>https://herongdev.github.io/blog/posts/显式覆盖</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/显式覆盖</guid>
            <pubDate>Fri, 05 Sep 2025 21:13:27 GMT</pubDate>
            <content:encoded><![CDATA[
## 结论（一句话）

**不要维护 `noAuthPaths` 白名单数组。**
大厂常用是**约定式路径前缀**（如 `/api/pub/**` 全部公开，其余默认鉴权）+ **显式 `auth:false` 覆盖**个别特殊接口（如登录/注册）。必要时再做**双实例**（`authHttp`/`pubHttp`）隔离。

## 你只需做的最小改动（片段）

### 1) 用“前缀约定”替换白名单数组

> 复杂逻辑：将“是否需要鉴权”收敛为**实例级默认值** + **URL 前缀** + **每次请求的显式覆盖**。

**删除：**

```ts
// 删除这行
const noAuthPaths = [
  "/login",
  "/register",
  "/public-endpoint",
  "/api/pub/get_feednews",
];
```

**在 `createAxiosHttp` 定义处新增第二个参数（不改已有调用方也能有默认值）：**

```ts
// 复杂逻辑：通过 opts 控制默认鉴权与公开前缀
function createAxiosHttp(
  config: AxiosRequestConfig,
  opts: { authDefault?: boolean; publicPrefixes?: string[] } = {},
) {
  const authDefault = opts.authDefault ?? true
  const publicPrefixes = opts.publicPrefixes ?? ['/api/pub']  // 仅维护“前缀”，而非逐个接口
  // ...
```

**在请求拦截器里替换 needAuth 判定：**

```ts
_axios.interceptors.request.use((req) => {
  // ...（保留你已有的 AbortController 代码）

  // 复杂逻辑：先按前缀判定是否公开，再由显式 req.auth 覆盖
  const url = req.url || "";
  const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));

  // 复杂逻辑：优先使用 req.auth（true/false），否则用实例默认值 + 前缀约定
  const needAuth = (req as any).auth ?? (authDefault && !isPublicByPrefix);

  const accToken = storage.get(ACCESS_TOKEN);
  const tokenType = storage.get(TOKEN_TYPE) || "Bearer";
  if (needAuth && !accToken) {
    ((req as any).__abortController as AbortController | undefined)?.abort();
    return Promise.reject(new Error("UNAUTHENTICATED"));
  }
  if (needAuth && accToken) {
    req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };
  }
  return req;
});
```

**创建实例时传入前缀约定（一次配置，全局生效）：**

```ts
// 复杂逻辑：默认需要鉴权，唯独 /api/pub/** 前缀走公开
const http = createAxiosHttp(
  {
    timeout: 10000,
    baseURL: API_BASE,
    withCredentials: true,
    xsrfCookieName: "Authorization",
    xsrfHeaderName: "Authorization",
  },
  { authDefault: true, publicPrefixes: ["/api/pub"] }
);
```

### 2) 显式覆盖个别公开接口（例如登录/注册）

> 复杂逻辑：无需继续维护数组；在调用时给 `{ auth:false }`。

```ts
// 复杂逻辑：显式声明无需鉴权
http.request("/auth/login", "POST", body, { auth: false });
http.request("/auth/register", "POST", body, { auth: false });
```

### 3) 小修 bug：统一释放键，避免内存泄露

> 你在请求里写的是 `__abortController`，但错误拦截里读取的是 `__ac`。统一成同一个键。

**在错误拦截器里替换：**

```ts
// 复杂逻辑：统一用 __abortController
const abortController = (err?.config as any)?.__abortController as
  | AbortController
  | undefined;
if (abortController) abortPool.delete(abortController);
```

---

## 为什么这是“更像大厂”的做法

- **约定 > 配置**：接口分层（`/api/pub/**` 公开，其他默认鉴权）是**稳定、低维护**的组织方式；新增公开接口只需放在该前缀下。
- **按需覆盖**：极少数“路径不在公开前缀但仍需公开”的接口，用 `auth:false` **显式声明**，可读性强。
- **可扩展**：未来要拆网关/多后端时，可用**双实例**进一步隔离（见下方“进阶”）。
- **类型友好**：`AxiosRequestConfig` 扩展 `auth?: boolean`，IDE 自动提示，避免遗漏。

---

## 进阶可选（按需采纳）

### 方案 B：双实例隔离（最常见于中大型前端）

> 公有与鉴权接口**不同实例**，互不影响，拦截器更简单。

```ts
// 复杂逻辑：一个实例默认鉴权，一个实例默认公开
export const authHttp = createAxiosHttp(config, {
  authDefault: true,
  publicPrefixes: [],
});
export const pubHttp = createAxiosHttp(config, {
  authDefault: false,
  publicPrefixes: ["/api/pub"],
});

// 使用时不再传 auth:false
pubHttp.request("/api/pub/get_feednews", "GET");
authHttp.request("/api/secure/profile", "GET");
```

### 方案 C：API 分层封装（类型安全）

> 给每个后端接口包一层函数：在函数里固定 `auth:true/false`，业务层不再关心 `auth`。

```ts
// 复杂逻辑：在 API 层固定鉴权语义
export const Api = {
  getFeedNews: () =>
    http.request<Feed[]>("/api/pub/get_feednews", "GET", undefined, {
      auth: false,
    }),
  getProfile: () => http.request<Profile>("/api/secure/profile", "GET"), // 默认为鉴权
};
```

---

## 小结

- **最佳实践**：**前缀约定 + 显式覆盖**，别再维护接口白名单数组。
- 这样新增公开接口只要放到 `/api/pub/**`，其余默认鉴权；个别例外 `auth:false` 即可。
- 若项目更复杂，进一步采用**双实例**或**API 分层**，把鉴权语义固化到“调用入口”，彻底杜绝分散判断。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AI 时代：工程师不可替代的价值与协作边界]]></title>
            <link>https://herongdev.github.io/blog/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界</guid>
            <pubDate>Tue, 09 Sep 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[这些是 AI 相对更弱、人类工程师显著更强的领域，以及落地的人机协作做法与质量保障。]]></description>
            <content:encoded><![CDATA[
## 为什么要谈“边界”

AI 擅长“已知知识的重组与加速”，但在“问题定义、系统性权衡、非完备信息推理、组织沟通与落地”上存在天然短板。明确人机边界，能让 AI 负责“快且广”，工程师负责“准与稳”。

## 人类工程师显著更强的领域

### 1）需求澄清与问题定义

- 把模糊诉求变成可验证的目标/约束/验收标准
- 在成本/性能/上市时间等冲突目标之间做取舍并对齐干系人

### 2）系统设计与演进路线

- 跨模块/跨团队的架构升级、灰度与回滚策略
- 面向未来不确定性的扩展点，平衡复杂度与收益

### 3）真实生产问题定位（非完备信息）

- 偶发、不可复现故障的“信号拼图”与因果链验证
- 跨层关联日志/指标/链路，形成可复现实验和结论

### 4）领域知识与隐性约定

- 行业合规/风控/结算/对账等隐性“黑话”与规则
- 团队历史技术债与未显式表达的不变量

### 5）安全、隐私与合规（PIPL/GDPR/许可证）

- 供应链安全、最小权限、日志脱敏、审计与存证
- 在业务价值与合规要求之间做可落地的折中

### 6）分布式与性能工程

- 幂等/重试/限流/熔断等系统级设计与验证
- 基准测试设计，硬件/内核/网络抖动下的性能归因

### 7）复杂交互与可用性

- 真用户的边界输入、可访问性与可用性权衡
- 多端/多浏览器/容器内嵌环境的微妙差异处理

### 8）数据与正确性

- 事务边界、最终一致、补偿/重放的业务落地
- 数据质量/血缘/稽核与“可追责”的数据治理

### 9）产品感觉与工程品味

- API 的语义一致性与长期可维护性
- 何时“少做/不做”，把复杂度留在正确层次

### 10）组织沟通与推动落地

- 与上下游谈判、拆分排期与风险缓解、跨团队协作
- 方案说服与共识形成，真正“从纸面到生产”

### 11）实验设计与度量

- 指标选择、A/B 边界、因果与相关的区分
- 防“纸面最优”，用业务闭环指标检验技术方案

### 12）零先例创新与复盘文化

- 无公开资料时的原型验证、快速试错与知识沉淀
- 事后复盘（Postmortem）与最小可复现仓库建设

## 可落地的人机协作流程（模板化执行）

### A. 文档先行（AI 起草，人类定锚）

- 产出《问题定义/约束/验收标准》与《设计评审提纲》
- 用清单化模板：输入、假设、边界、风险、观测项

### B. 强化“验证链路”

- 最小可复现（MRE）、自动化测试、基准测试与可观测性基线
- 对高风险改动设护栏：灰度/回滚/特性开关/错误预算

### C. 产物分级与质量关卡

- AI 产物只进“开发态/草稿态”，上线前必须经 CR 与度量验证
- 引入“拒收条件”：不满足验收标准/观测项即退回补强

### D. 知识显性化与复用

- 维护《事故复盘》《设计评审》《发布流程》三套 Checklist
- 以专题/系列沉淀：生产复盘、系统权衡、行业隐性规则

## 建议的长期专题（可做成系列与课程）

- 生产问题复盘：从信号采集到因果验证的全链路
- 系统权衡与演进：灰度、回滚、演进路线与“变更即文档”
- 性能与分布式：限流/熔断/幂等等“系统级能力”的可验证实践
- 数据治理：质量/血缘/稽核与数据可追责体系
- 安全与合规：供应链安全、最小权限、合规落地与审计
- 工程化流程：评审/发布/观测/复盘的标准化与自动化

## 结语

AI 让“生成更快”，工程师让“正确落地”。边界越清晰，协作越高效。把“不可替代”的能力沉淀为流程、清单与课程，才是个人品牌与团队战斗力的复利来源。

## 延伸阅读

- 请求层与鉴权：
  - [/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线](/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线)
  - [/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）](/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）)
- Vue 性能与交互：
  - [/posts/前端/Vue/Vue 项目请求处理优化](/posts/前端/Vue/Vue项目请求处理优化)
  - [/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）](/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）)
- 实时通信与网络：
  - [/posts/前端/实时通信/web 应用开发-前端-Web-应用如何做到实时消息通知](/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知)
- 下载与文件：
  - [/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）](/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）)
- Web 推送与标识：
  - [/posts/Web-API-与推送/Web-Push/Web-Push-推送简介](/posts/Web-API-与推送/Web-Push/Web-Push-推送简介)
  - [/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取](/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[<替换为标题>]]></title>
            <link>https://herongdev.github.io/blog/posts/_templates/article</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/_templates/article</guid>
            <pubDate>Wed, 01 Jan 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[<一句话摘要，便于 SEO>]]></description>
            <content:encoded><![CDATA[
## 背景与目标

- 业务/技术背景
- 这篇文章要解决什么问题？如何验证？

## 问题分析（可复现）

- 最小复现或真实案例
- 误区与常见失败路径

## 解决方案（可验证）

- 方案对比与取舍
- 步骤/代码/配置
- 验证与指标

## 探索与延伸

- 边界条件、兼容性、性能与安全
- 与相关专题的链接

## 结论与行动项

- 关键结论
- 下一步可执行清单
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[<专题导言：描述系列价值与对象>]]></title>
            <link>https://herongdev.github.io/blog/posts/_templates/series-intro</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/_templates/series-intro</guid>
            <pubDate>Wed, 01 Jan 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[<系列摘要与读者收益>]]></description>
            <content:encoded><![CDATA[
## 系列对象与前置

- 适合谁？需要什么前置知识？

## 目录与进度

- [第 1 篇：主题 A](/posts/...) —— 进度：✅/进行中
- [第 2 篇：主题 B](/posts/...)

## 学习方式

- 推荐阅读顺序
- 配套 Demo/最小复现仓库

## 常见问题

- FAQ 1
- FAQ 2
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Web Push 推送简介]]></title>
            <link>https://herongdev.github.io/blog/posts/Web-API-与推送/Web-Push/Web-Push-推送简介</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/Web-API-与推送/Web-Push/Web-Push-推送简介</guid>
            <pubDate>Fri, 05 Sep 2025 14:10:59 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: Web Push 推送简介
date: 2025-09-05
categories: \[Web 实时通讯, 浏览器推送]
tags: \[Web Push, Service Worker, PWA, VAPID, 离线通知, 实时消息]
description: 全面介绍 Web Push 技术的原理、特点、实现步骤和典型应用场景，帮助前端/全栈开发者理解并快速落地。

---

# 什么是 Web Push？

**Web Push** 是浏览器层面的 **推送通知机制**。与 WebSocket 或 SSE 不同，它不依赖页面是否处于前台，甚至用户没有打开网页也能收到通知。核心依赖：

- **Service Worker**：浏览器的后台脚本，常驻运行。
- **Push API**：浏览器与推送服务（FCM、APNs 等）之间的推送通道。
- **Notification API**：展示系统级通知。

特点：

- **跨平台**：Chrome、Firefox、Edge、Safari（部分版本）均支持。
- **后台可达**：即使网页未激活或浏览器最小化也能收到。
- **需用户授权**：必须 HTTPS，且用户点击“允许通知”。
- **带有身份机制**：通过 VAPID（Voluntary Application Server Identification for Web Push）实现应用级认证。

---

# 工作流程

```mermaid
sequenceDiagram
  participant User as 用户浏览器
  participant SW as Service Worker
  participant PushSrv as 浏览器厂商推送服务(FCM等)
  participant Server as 应用服务端

  User->>Server: 注册并获取 VAPID 公钥
  User->>SW: 注册 Service Worker
  User->>PushSrv: 订阅推送 (PushSubscription)
  User->>Server: 上报订阅信息 (endpoint+keys)

  Server->>PushSrv: 使用 VAPID 私钥加密并发送消息
  PushSrv->>SW: 转发推送
  SW->>User: Notification API 展示通知
```

---

# 核心实现步骤

## 1. 生成 VAPID 密钥对

```bash
npx web-push generate-vapid-keys
```

会得到 **公钥 / 私钥**，公钥发给前端，私钥保存在服务端。

---

## 2. 前端注册 Service Worker

```js
const reg = await navigator.serviceWorker.register("/sw.js");

// 申请通知权限
const permission = await Notification.requestPermission();
if (permission === "granted") {
  // 订阅推送
  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: "<VAPID_PUBLIC_KEY_BASE64URL>",
  });
  // 上报给服务端保存
  await fetch("/push/subscribe", { method: "POST", body: JSON.stringify(sub) });
}
```

---

## 3. Service Worker 处理推送

```js
// sw.js
self.addEventListener("push", (event) => {
  const data = event.data?.json() ?? {};
  event.waitUntil(
    self.registration.showNotification(data.title || "通知", {
      body: data.body,
      icon: "/icon.png",
    })
  );
});
```

---

## 4. 服务端发送推送

以 Node.js 为例：

```js
import webpush from "web-push";

// 设置 VAPID
webpush.setVapidDetails(
  "mailto:admin@example.com",
  process.env.VAPID_PUBLIC,
  process.env.VAPID_PRIVATE
);

// subs 存储用户的 PushSubscription
export async function sendPush(sub, payload) {
  await webpush.sendNotification(sub, JSON.stringify(payload));
}
```

---

# 典型应用场景

- **消息提醒**：聊天应用收到新消息。
- **电商营销**：用户未登录页面也能收到促销信息。
- **系统告警**：后台监控推送紧急故障。
- **PWA（渐进式 Web 应用）**：接近原生 App 的体验。

---

# 优缺点对比

✅ 优点：

- 浏览器级支持，后台可达。
- 无需页面常驻，适合通知类消息。
- 跨浏览器标准（W3C Push API）。

⚠️ 缺点：

- 依赖用户同意，存在拒绝率。
- Safari 支持有限制（macOS 较晚才全面支持）。
- 消息大小有限制（通常 4KB）。
- 不适合大流量/高频推送（需 WebSocket/SSE）。

---

# 小结

**Web Push** = **Service Worker + Push API + Notification API**
适合“提醒/通知”类场景，不适合实时高频通信。生产实践里常和 **WebSocket/SSE** 组合：

- **WebSocket**：前台实时互动。
- **Web Push**：后台/离线通知兜底。

---

要不要我帮你写一个 **完整的最小 Web Push DEMO 项目（前端+后端）**，可以直接跑通并测试浏览器推送？
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[OAID 库的初始化与获取]]></title>
            <link>https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取</guid>
            <pubDate>Sun, 07 Sep 2025 15:44:21 GMT</pubDate>
            <content:encoded><![CDATA[
# 一、国内主流 OAID 获取的两条路线

1. **MSA 官方 SDK（闭源）**

- 由“移动安全联盟/CAICT”提供。接入要放 `oaid_sdk_x.x.x.aar`（或早期 `miit_mdid_x.x.x.aar`）、`supplierconfig.json`、证书（`xxx.cert.pem`），并**先加载安全库**再 `MdidSdkHelper.InitSdk(...)` 获取 OAID。常见混淆与加载问题官方 FAQ 也有说明。([百度移动统计][1], [网站名称][2])

2. **开源聚合库（Android_CN_OAID）**

- 由 gzu-liyujiang 提供，统一封装**各厂商 OAID + 海外 AAID + 多种替代 ID**（AndroidID/WidevineID/GUID 等），API 友好。常用入口：`DeviceIdentifier.register(app)` 预取，或者 `DeviceID.getOAID(context, IGetter)` 异步获取。([李宇江的个人网站][3])

> 额外：**华为设备**可直接通过 **HMS Ads Identifier** 获取 OAID（`AdvertisingIdClient.getAdvertisingIdInfo(context).getId()`），不依赖 MSA（很多三方 SDK 文档也这样说明）。([华为开发者][4], [Adjust][5])

---

# 二、你的两个 UTS 插件实际做法（我已解包查看）

- **`android-deviceid`**（UTS for Android）

  - 直接 `import com.github.gzuliyujiang.oaid.*`，调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!)` 进行预取；随后通过接口把结果回调出去。
  - 插件内还自带 **华为 HMS ads-identifier AAR**（`ads-identifier-*.aar`），作为获取 OAID 的华为路径支撑。
  - 这是一个\*\*标准的“开源聚合库 + （可选）HMS”\*\*实现范式。

  片段（来自 `utssdk/app-android/index.uts`）：

  ```ts
  import DeviceIdentifier from "com.github.gzuliyujiang.oaid.DeviceIdentifier";
  export const register = function () {
    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);
  };
  ```

  （随后通过自定义 `MyListener implements IDManger.OnIOAIDListener` 回传 JSON 结果）

- **`zws-uniqueid`**

  - 不取 OAID，仅根据 `android.os.Build` 若干字段计算 `MD5` 作为**伪标识**（PseudoID），没有广告/合规可重置特性，仅能用于弱追踪/灰度分配等**非广告**用途。

---

# 三、初始化 & 获取：可直接抄的代码片段库

## 方案 A：开源 Android_CN_OAID（推荐起步用）

**初始化（建议在用户同意隐私后再调用）**

```kotlin
// Application.onCreate 或隐私同意后
DeviceIdentifier.register(application)  // 预取 clientId/OAID
```

**获取 OAID（两种）**

- 同步拿预取结果（需先 register）：

  ```kotlin
  val oaid = DeviceID.getOAID()  // 若未预取会为空
  ```

- 异步获取（不需要 register）：

  ```kotlin
  DeviceID.getOAID(context, object : IGetter {
      override fun onOAIDGetComplete(result: String) { /* result 即 OAID */ }
      override fun onOAIDGetError(error: Exception) { /* 失败或不支持 */ }
  })
  ```

这些方法签名、时机说明都在官方 javadoc 文档中有清晰描述：`register(...)` 预取、`getOAID(...)` 异步、`supportedOAID(context)` 判断支持性、以及 `getGUID`、`getAndroidID` 等替代项。([李宇江的个人网站][6])

> **优点**：开源、快速落地；**缺点**：在个别厂商/系统组合上获取率可能不如官方 MSA；不过开源库会优先尝试 HMS、厂商通道，整体覆盖度已较好。([李宇江的个人网站][3])

## 方案 B：MSA 官方 SDK（企业/上量后建议切换或并行）

**准备**

- `oaid_sdk_x.x.x.aar` 放 `libs/`
- `supplierconfig.json`、`<package>.cert.pem` 放 `assets/`
- Proguard：`-keep class com.bun.miitmdid.core.** { *; }`
- **在 Init 前加载安全库**（不同版本库名可能不同，如 `msaoaidsec` 或文档示例里的 nllvm 加固库名），否则会出现 `No implementation found for ... InitCert` 之类错误。([百度移动统计][1], [网站名称][2])

**初始化 & 获取**

```java
// 1) （可选但推荐）在 Application.onCreate 尝试加载安全库
try { System.loadLibrary("msaoaidsec"); } catch(Throwable ignore) {}

// 2) 在合适时机发起初始化与获取（不要在主线程里做耗时 I/O）
MdidSdkHelper.InitSdk(
  context.getApplicationContext(),
  /* isCert = */ true,
  new IIdentifierListener() {
    @Override public void onSupport(IdSupplier supplier) {
      if (supplier != null) {
        String oaid = supplier.getOAID();
        // supplier.isSupported() / isLimited() 等也可读
      }
    }
  }
);
```

上面这段 init 与回调写法，在各家第三方接入文档里都是类似范式（百度统计、Adjust、AppsFlyer 等均说明“MSA 或 HMS”两路径），并给出了混淆、AAR、`supplierconfig.json` 的标准放置方法。([百度移动统计][1], [Adjust][5], [AppsFlyer 支持中心][7])

## 方案 C：华为设备走 HMS（若接入了 HMS Core）

```java
// 不依赖 MSA，在华为设备上直接拿 OAID
AdvertisingIdClient.Info info =
    com.huawei.hms.ads.identifier.AdvertisingIdClient.getAdvertisingIdInfo(context);
String oaid = info.getId();
// info.isLimitAdTrackingEnabled() 可读 “限制个性化广告” 状态
```

HMS 文档对 OAID / Identifier Service 的 API 有明确说明。([华为开发者][4])

---

# 四、UTS（uni-app x）里的**最佳实践**总方案

> 目标：**一个 API 跨 H5 / Android**，Android 侧**优先 MSA/HMS**，没有则回退到 **Android_CN_OAID**，最后再降级 **AndroidID / GUID**；且**必须在取得隐私同意后**再初始化与获取。

### 1) API 设计（简洁且可扩展）

```ts
// /uni_modules/uaid-kit/utssdk/index.uts
export type UaidInfo = {
  oaid: string | null;
  source: "MSA" | "HMS" | "GZU" | "NONE";
  limitAdTracking?: boolean | null;
  aaid?: string | null; // 海外广告标识，未来可补
  androidId?: string | null; // 回退项
  guid?: string | null; // 本地持久 GUID（Web/低版本回退）
};

export function initAfterConsent(): void;
export function getUaid(callback: (info: UaidInfo) => void): void;
```

### 2) UTS 源码（**可直接用**；Android + Web 双端）

> 说明：
>
> - **MSA** 部分需要你把 `oaid_sdk_x.x.x.aar` 放到 `utssdk/app-android/libs/`，并在 `manifest.json` 勾选 UTS 插件；否则请把 `// MSA 可选块` 注释掉再编译。
> - **HMS** 部分需要 `ads-identifier` 依赖；没有就留开源库/回退路径。
> - Web 端只能**生成/持久化 GUID**，OAID 是 Android 概念。

```ts
// /uni_modules/uaid-kit/utssdk/app-android/index.uts
// #ifdef APP-ANDROID
import Context from "android.content.Context";
import Application from "android.app.Application";
import System from "java.lang.System";

// 开源库（gzu-liyujiang）
import DeviceIdentifier from "com.github.gzuliyujiang.oaid.DeviceIdentifier";
import DeviceID from "com.github.gzuliyujiang.oaid.DeviceID";
import IGetter from "com.github.gzuliyujiang.oaid.IGetter";

// HMS（若集成）
import AdvertisingIdClient from "com.huawei.hms.ads.identifier.AdvertisingIdClient";

// MSA（若集成了 AAR，否则请注释下一行两行以及使用处）
import MdidSdkHelper from "com.bun.miitmdid.core.MdidSdkHelper";
import IIdentifierListener from "com.bun.miitmdid.interfaces.IIdentifierListener";
import IdSupplier from "com.bun.miitmdid.interfaces.IdSupplier";
// #endif

// #ifdef H5
import { ref } from "vue";
// #endif

export type UaidInfo = {
  oaid: string | null;
  source: "MSA" | "HMS" | "GZU" | "NONE";
  limitAdTracking?: boolean | null;
  aaid?: string | null;
  androidId?: string | null;
  guid?: string | null;
};

export function initAfterConsent(): void {
  // #ifdef APP-ANDROID
  try {
    // 优先预取开源库的 clientId/OAID
    DeviceIdentifier.register(
      UTSAndroid.getUniActivity()!!.getApplication()!! as Application
    );
  } catch (e) {}

  // （可选）若你计划走 MSA，尽早加载安全库，避免 InitCert 报错
  try {
    System.loadLibrary("msaoaidsec");
  } catch (e) {}
  // #endif
  // #ifdef H5
  // nothing
  // #endif
}

function buildGuid(): string {
  // 128bit GUID，H5/Android 均可用，H5 存 localStorage 即可
  const s = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  return s.replace(/[xy]/g, (c) => {
    const r = (Math.floor(Math.random() * 16) as number) & 0xf;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

export function getUaid(cb: (info: UaidInfo) => void): void {
  // #ifdef APP-ANDROID
  const ctx = UTSAndroid.getUniActivity()!! as Context;

  // 1) 尝试 HMS（若集成）
  try {
    const info = AdvertisingIdClient.getAdvertisingIdInfo(ctx);
    const id = info.getId();
    if (id) {
      cb({
        oaid: id,
        source: "HMS",
        limitAdTracking: info.isLimitAdTrackingEnabled(),
      });
      return;
    }
  } catch (e) {
    /* ignore */
  }

  // 2) 尝试 MSA 官方（若集成了 AAR）
  try {
    MdidSdkHelper.InitSdk(
      ctx,
      true,
      new (class implements IIdentifierListener {
        override onSupport(supplier: IdSupplier | null) {
          if (supplier != null && supplier.getOAID() != null) {
            cb({ oaid: supplier.getOAID(), source: "MSA" });
          } else {
            // 3) 回退：开源库异步
            DeviceID.getOAID(
              ctx,
              new (class implements IGetter {
                override onOAIDGetComplete(result: string) {
                  cb({ oaid: result, source: "GZU" });
                }
                override onOAIDGetError(err: any) {
                  const androidId = DeviceID.getAndroidID(ctx);
                  cb({ oaid: null, source: "NONE", androidId });
                }
              })()
            );
          }
        }
      })()
    );
    return;
  } catch (e) {
    // 没集成 MSA 或运行异常，继续走开源库回退
  }

  // 3) 开源库异步（无预取也能用）
  DeviceID.getOAID(
    ctx,
    new (class implements IGetter {
      override onOAIDGetComplete(result: string) {
        cb({ oaid: result, source: "GZU" });
      }
      override onOAIDGetError(err: any) {
        const androidId = DeviceID.getAndroidID(ctx);
        cb({ oaid: null, source: "NONE", androidId });
      }
    })()
  );
  // #endif

  // #ifdef H5
  try {
    let guid = uni.getStorageSync("UAID_GUID") as string;
    if (!guid) {
      guid = buildGuid();
      uni.setStorageSync("UAID_GUID", guid);
    }
    cb({ oaid: null, source: "NONE", guid });
  } catch (e) {
    cb({ oaid: null, source: "NONE", guid: buildGuid() });
  }
  // #endif
}
```

**混淆/配置建议（Android）**

- 若启用 **MSA**：

  ```
  -keep class com.bun.miitmdid.core.** { *; }
  ```

  同时把 `oaid_sdk_x.x.x.aar`、`supplierconfig.json`、`<pkg>.cert.pem` 放到对应目录（AAR: `libs/`，其余在 `assets/`）。初始化前加载安全库，避免 `InitCert` 报错。([百度移动统计][1], [网站名称][2])

- 若启用 **HMS**：确保引入 `com.huawei.hms:ads-identifier`（你现有 `android-deviceid` 插件已内置两个 ads-identifier AAR）。华为 OAID API 文档参考。([华为开发者][4])
- 若只用**开源库**：不需要证书，按上面 `DeviceID` / `DeviceIdentifier` 的调用即可（方法签名见官方 javadoc）。([李宇江的个人网站][6])

**隐私合规关键点**

- **必须在用户同意隐私政策后**再 `initAfterConsent()`；开源库文档也特别提示 register/获取前需获同意。([李宇江的个人网站][6])

---

# 五、再回答你“原来的插件中如何实现”的要点

- 你的 **`android-deviceid`** 正是采用**开源库（Android_CN_OAID）+（可选）HMS**的组合：

  - 预取：`DeviceIdentifier.register(...)`
  - 异步获取：`DeviceID.getOAID(context, IGetter)`
  - 附带 ad-identifier AAR，完善华为路径

  > 这与文档推荐用法一致（register 预取、或异步获取；支持 `supportedOAID` 检查）。([李宇江的个人网站][6])

- 你的 **`zws-uniqueid`** 只是**伪 ID**（基于 `Build.*` 拼接+MD5），**不属于 OAID**，适合作兜底标识，不可用于广告归因。

---

# 六、为什么推荐“先开源库 → 再视需要加 MSA/HMS”

- **落地速度**：开源库无证书/厂商注册门槛，上线快；API 稳定，文档完整（还有 `GUID/AndroidID` 兜底）。([李宇江的个人网站][3])
- **兼容与获取率**：有华为设备时可直接走 **HMS OAID**；大盘上量/商业化合规要求更高时，再**并行接入 MSA** 提升部分机型覆盖率。([华为开发者][4], [Adjust][5])
- **合规**：始终把 OAID 获取放在**隐私同意之后**。([李宇江的个人网站][6])

---

## 附：权威/一手资料（便于你对照）

- Android_CN_OAID 文档（`DeviceID.register/getOAID/supportedOAID/...` 方法签名）([李宇江的个人网站][6])
- Android_CN_OAID 项目主页/文档导航（含包结构/实现原理）([李宇江的个人网站][3])
- MSA 官方接入说明（AAR、`supplierconfig.json`、混淆、加载安全库/InitCert 问题）([百度移动统计][1], [网站名称][2])
- Adjust / AppsFlyer 对 OAID 的总述与“MSA 或 HMS”两条路径的明确表述（帮助理解生态）([Adjust][5], [AppsFlyer 支持中心][7])
- 华为 HMS Ads Identifier OAID 能力文档（API 参考）([华为开发者][4])

---

如果你同意这套方案，我可以把上面的 **UTS 插件源码**按你项目结构打包成 `uni_modules/uaid-kit`（含 `package.json`、`utssdk/app-android/config.json`、`README.md`、示例页），并给出在 **uni-app x** 项目里如何调用的示例页（含隐私弹窗 → 同意后初始化 → 展示结果）的完整代码。

[1]: https://mtj.baidu.com/static/userguide/book/android/oaid.html?utm_source=chatgpt.com "Android OAID 接入"
[2]: https://16054554.s21i.faiusr.com/61/ABUIABA9GAAgx5iGjgYo2_j-1AE.pdf?utm_source=chatgpt.com "常见问题问答F&Q - 信息资源系统"
[3]: https://gzu-liyujiang.github.io/Android_CN_OAID/?utm_source=chatgpt.com ":library"
[4]: https://developer.huawei.com/consumer/en/doc/hmscore-references/overview-0000001050066887?utm_source=chatgpt.com "Overview-com.huawei.hms.ads.identifier-Android-Java- ..."
[5]: https://dev.adjust.com/zh/sdk/android/plugins/oaid-plugin/?utm_source=chatgpt.com "OAID"
[6]: https://gzu-liyujiang.github.io/Android_CN_OAID/com/github/gzuliyujiang/oaid/DeviceID.html "DeviceID "
[7]: https://support.appsflyer.com/hc/en-us/articles/360006278797-Android-OAID-implementation-in-the-SDK?utm_source=chatgpt.com "Android OAID implementation in the SDK"
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[id-kit]]></title>
            <link>https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit</guid>
            <pubDate>Sun, 07 Sep 2025 12:35:03 GMT</pubDate>
            <content:encoded><![CDATA[
棒～这个方向很实用。按你的节奏来：**先取名 → 再讲实现思路 → 之后我们再一步步落地**。

---

## 先取个名字（我给你几个风格不同的备选）

**强推：`UniIdKit`（中文：一体设备 ID 工具包）**

- 简洁、易记、和 uni-app 生态贴合（Uni 前缀）。
- “Kit” 体现工具集合的定位（OAID/AAID/AndroidID/GUID…聚合）。

其它好选项（任选其一也行）：

- `UniDeviceID`（直白、上手即懂）
- `IdFusion` / 中文：ID 融合（强调多源融合）
- `OmniIdKit` / 中文：全域 ID 工具包（强调覆盖广泛）
- `SignalID` / 中文：设备信标（更“概念化”，偏品牌感）

> 没有特别诉求的话，我后续以 **`UniIdKit`** 为默认名继续讲实现与代码。

---

## 实现思路（先把“大图”画清楚）

### 1) 目标与边界

- **平台覆盖**：Android（App-Plus 原生）、iOS（可选：IDFV）、H5（本地持久 GUID）。
- **能力聚合**：OAID、AAID、AndroidID、（可选）IMEI/MEID、WidevineID、PseudoID、GUID。
- **合规优先**：

  - 默认**不采集强隐私**（如 IMEI），需**显式同意**与**动态权限**才允许。
  - 提供**哈希化输出**（SHA-256）选项，避免直传原始标识。
  - 尊重系统/用户“广告追踪限制”（AAID/OAID 可能返回空或受限标志）。

### 2) 能力分层（便于维护与扩展）

```
UniIdKit（JS/TS 封装与 API ）
 ├─ ConsentManager（隐私同意、选项管理、状态缓存）
 ├─ CacheLayer（本地缓存：uni.storage / iOS Keychain / Android MMKV）
 ├─ Aggregator（聚合各 Adapter 的结果、去重、优先级策略、哈希化）
 └─ Adapters
     ├─ Android:
     │   ├─ OAIDAdapter（MSA SDK）
     │   ├─ AAIDAdapter（Google Play 服务）
     │   ├─ AndroidIdAdapter（SSAID）
     │   ├─ WidevineIdAdapter（DRM ID，有些机型/ROM可能不可用）
     │   ├─ PseudoIdAdapter（Build 信息拼接的伪 ID，稳定性一般）
     │   └─ IMEI/MEIDAdapter（需权限；默认关闭）
     ├─ iOS:
     │   └─ IDFVAdapter（IdentifierForVendor）
     └─ H5:
         └─ GuidAdapter（首访生成 UUID，localStorage/IndexedDB/Cookie 持久化）
```

### 3) API 设计（兼容回调，也提供 Promise 风格）

与 Ba-IdCode 的 API 兼容，但**统一返回结构**、并补充 Promise 版本：

- `register(options?)`：完成 SDK 初始化/权限请求/合规弹窗接入（**只有用户同意后才能继续**）。
- `getIdCodes(options?)`：一次性返回所有可用标识（含哈希/明文二选一），并标出可用性/限制信息。
- `getOAID()` / `getAAID()` / `getAndroidId()` / `getGuid()`：单项拉取。
- `getBestId(options?)`：按优先级策略返回“一个最合适的设备标识”（例如：`OAID > AAID > AndroidID > IDFV > GUID`）。
- `setSalt(salt: string)`：设置服务端协商的哈希盐（建议）；前端仅输出 hash 以降低风险。

**统一返回结构（示例）**：

```ts
type IdValue = {
  value?: string; // 原始值（默认可关闭）
  hash?: string; // SHA-256(value + salt) 的十六进制
  available: boolean; // 是否成功获取
  limited?: boolean; // 是否受限制（如关闭广告标识、受 ROM 策略限制）
  source?: string; // 具体来源：oaid/aaid/androidId/idfv/guid/...
  message?: string; // 失败/限制说明
};

type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue; // iOS
  widevineId?: IdValue;
  pseudoId?: IdValue;
  imei?: IdValue; // 默认不返回，需开启 & 权限通过
  guid?: IdValue; // H5/兜底
  ts: number; // 时间戳
  consent: boolean; // 是否已取得用户隐私同意
};
```

**调用风格**：

```ts
// 回调
idKit.getIdCodes((res) => {
  /* ... */
});

// Promise（推荐）
const res = await UniIdKit.getIdCodes({
  hashOnly: true,
  include: ["oaid", "aaid", "androidId", "guid"],
});
```

### 4) 平台实现要点

- **Android**：

  - OAID：集成 **MSA (移动安全联盟) SDK** 或厂商合规通道（插件市场常用做法）。
  - AAID：Google Play 服务 `AdvertisingIdClient`（需处理“限制广告跟踪”返回）。
  - AndroidID：`Settings.Secure.ANDROID_ID`。
  - IMEI/MEID：`READ_PHONE_STATE` 动态权限 + Play 政策；**默认关闭**、强提醒不建议依赖。
  - 缓存：优先使用 MMKV/SharedPreferences，配合有效期（如 24 小时）避免频繁拉取。

- **iOS**：

  - IDFV：`UIDevice.current.identifierForVendor`；卸载所有同一 Vendor 应用后可能变。
  - 不建议用 IDFA（需要 ATT 授权且涉广告用途，与你目标不匹配）。

- **H5**：

  - 生成 `uuid`，持久化在 `localStorage` + `cookie` 双存；被清理会变，属于“弱设备 ID”。
  - 返回 `guid` 字段；可选加“服务端长 Cookie dvc=xxx”作为辅助。

### 5) 合规与配置

- 插件默认只返回 **hash**；要返回原值需显式 `exposeRaw: true`。
- 提供 `register()` 用于展示你的隐私弹窗（或与现有弹窗 SDK 对接），**未同意**则所有采集接口返回 `available=false`。
- 允许配置 `include/exclude` 字段（避免不必要的请求/权限）。
- 提供 `fallback: 'guid' | 'none'` 选项控制 H5 的兜底行为。

---

## 3) 先给你一份可直接用的 JS 封装（跨端 & 可渐进增强）

> 先从 JS 层开始（不依赖原生插件也可工作），App 端等你绑定好原生插件后，再把 `native` 分支接上即可。

```ts
// src/utils/uni-id-kit.ts  —— 先做纯JS壳子，后续接原生
function uuid4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function sha256Hex(msg: string): Promise<string> {
  if (typeof window !== "undefined" && window.crypto?.subtle) {
    const enc = new TextEncoder().encode(msg);
    const buf = await window.crypto.subtle.digest("SHA-256", enc);
    return Array.from(new Uint8Array(buf))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  // 非 H5（App 小程序）用简易实现或交给原生
  // 这里先用最简单的占位：直接返回 msg（上线前请接真 SHA-256，如 plus.crypto / 原生）
  return msg;
}

type GetIdOptions = {
  include?: Array<
    | "oaid"
    | "aaid"
    | "androidId"
    | "idfv"
    | "widevineId"
    | "pseudoId"
    | "imei"
    | "guid"
  >;
  exposeRaw?: boolean; // 默认 false，默认仅返回 hash
  salt?: string; // 建议传服务端下发的盐
  fallback?: "guid" | "none";
  ttlMs?: number; // 缓存有效期，默认 1 天
};

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: any } | null = null;

export const UniIdKit = {
  setSalt(salt: string) {
    _salt = salt || "";
  },

  async register(): Promise<{ consent: boolean }> {
    // TODO: 这里接你的隐私弹窗或第三方隐私 SDK
    _consent = true; // 演示先直接同意
    return { consent: _consent };
  },

  async getIdCodes(opts: GetIdOptions = {}) {
    const include = opts.include || [
      "oaid",
      "aaid",
      "androidId",
      "idfv",
      "guid",
    ]; // 先常用
    const ttl = opts.ttlMs ?? 24 * 3600 * 1000;

    // 简单缓存
    if (_cache && Date.now() - _cache.ts < ttl) {
      return _cache.data;
    }

    const data: any = { ts: Date.now(), consent: _consent };

    // App 原生插件（占位），后续把 requireNativePlugin 接上
    let native: any = null;
    try {
      // @ts-ignore
      native = uni.requireNativePlugin && uni.requireNativePlugin("Uni-IdKit");
    } catch {}

    // 工具：组装返回（含 hash）
    const build = async (
      source: string,
      value?: string,
      limited?: boolean,
      msg?: string
    ) => {
      const available = !!value;
      const raw = opts.exposeRaw ? value : undefined;
      const hash = value ? await sha256Hex(value + (_salt || "")) : undefined;
      return { value: raw, hash, available, limited, source, message: msg };
    };

    // Android / iOS / H5 分支（先写 H5 + 纯 JS 兜底，原生等你接上）
    const isH5 =
      typeof window !== "undefined" && typeof document !== "undefined";

    // OAID / AAID / AndroidID / IDFV —— 占位：若未接原生，返回不可用
    if (include.includes("oaid"))
      data.oaid = await build(
        "oaid",
        native?.getOAID ? await native.getOAID() : undefined
      );
    if (include.includes("aaid"))
      data.aaid = await build(
        "aaid",
        native?.getAAID ? await native.getAAID() : undefined
      );
    if (include.includes("androidId"))
      data.androidId = await build(
        "androidId",
        native?.getAndroidID ? await native.getAndroidID() : undefined
      );
    if (include.includes("idfv"))
      data.idfv = await build(
        "idfv",
        native?.getIDFV ? await native.getIDFV() : undefined
      );
    if (include.includes("widevineId"))
      data.widevineId = await build(
        "widevineId",
        native?.getWidevineID ? await native.getWidevineID() : undefined
      );
    if (include.includes("pseudoId"))
      data.pseudoId = await build(
        "pseudoId",
        native?.getPseudoID ? await native.getPseudoID() : undefined
      );
    if (include.includes("imei"))
      data.imei = await build(
        "imei",
        native?.getIMEI ? await native.getIMEI() : undefined
      );

    // H5 / 兜底 GUID
    if (include.includes("guid")) {
      let guid = uni.getStorageSync("UNI_ID_KIT_GUID");
      if (!guid) {
        guid = `web:${uuid4()}`;
        uni.setStorageSync("UNI_ID_KIT_GUID", guid);
      }
      data.guid = await build("guid", guid);
    }

    // 如果要求有“最佳 ID”
    data.best = (() => {
      const order = ["oaid", "aaid", "androidId", "idfv", "guid"];
      for (const k of order) {
        if (data[k]?.available) return k;
      }
      return null;
    })();

    _cache = { ts: Date.now(), data };
    return data;
  },

  async getBestId(opts: GetIdOptions = {}) {
    const res = await this.getIdCodes(opts);
    const key = res.best;
    return key ? res[key] : { available: false, source: "none" };
  },
};
```

> 这份 JS 壳子**现在就能在 H5 返回一个稳定的 GUID**；等你把 Android/iOS 原生侧接上 `Uni-IdKit` 插件，就能自动获得 OAID/AAID/AndroidID/IDFV 等真实值，API 不变。

---

## 下一步怎么干？

1. **确定名字**（默认我用 `UniIdKit` 继续）。
2. 我给你 **Android 原生插件最小实现骨架（Kotlin）**：

   - 暴露 `getOAID/getAAID/getAndroidID/...` 方法；
   - 可先不接 MSA/AAID，返回占位，跑通桥接；
   - 再逐个接入 MSA SDK、Google Play Advertising ID。

3. 同步给 **iOS 原生插件（Swift）** 获取 IDFV；
4. 最后在你的登录流程里，把 `const dvc = await UniIdKit.getBestId({ hashOnly: true })` 接上，作为 `x-device-id` 传后端。

要不要我直接开始贴 **Android 插件骨架（可云打包）**？你点个头我就开写。

太好了，我们就按 **UTS 插件**来落地。下面我先给出**项目结构 & API 设计（最佳实践版）**，然后直接给你**可运行的首版代码骨架**（先支持 Web；Android 提供可运行的基础实现 + OAID/AAID 预留点），后续你把 MSA/GP 的 SDK 接上即可。

---

# 一、插件命名 & 目录结构

**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）

- 英文：**UniIdKit**
- 中文：**一体设备 ID 工具包**

**目录（uni_modules 标准）**：

```
uni_modules/
  uni-id-kit/
    package.json
    module.json
    utssdk/
      index.uts              # 聚合导出（按平台分发）
      common/
        types.uts            # 类型与常量定义（复用）
        hash.uts             # SHA-256 工具（Web/Android 均可）
        storage.uts          # 本地缓存工具（uni.storage封装）
      web/
        index.uts            # Web 实现（GUID、hash、缓存）
      app-android/
        index.uts            # Android 实现（AndroidID，OAID/AAID占位）
        adapters/
          android_id.uts     # ANDROID_ID
          aaid.uts           # Google AAID（待接SDK）
          oaid.uts           # MSA OAID  （待接SDK）
          pseudo_id.uts      # 伪ID（可选）
```

> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。
> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。

---

# 二、API 设计（Promise + 回调兼容）

> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。

## 公开方法

```ts
// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）
export function register(options?: {
  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗
}): Promise<{ consent: boolean }>;

// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash
export function setSalt(salt: string): void;

// 3) 一次性获取所有可用的 ID（聚合）
export function getIdCodes(options?: {
  include?: Array<
    | "oaid"
    | "aaid"
    | "androidId"
    | "idfv"
    | "widevineId"
    | "pseudoId"
    | "imei"
    | "guid"
  >;
  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value
  ttlMs?: number; // 缓存有效期，默认 24h
}): Promise<IdCodesResult>;

// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）
export function getBestId(options?: {
  prefer?: Array<"oaid" | "aaid" | "androidId" | "idfv" | "guid">; // 可自定义优先级
  exposeRaw?: boolean;
  ttlMs?: number;
}): Promise<IdValue>;

// 5) 单项拉取（必要时）
export function getOAID(): Promise<IdValue>;
export function getAAID(): Promise<IdValue>;
export function getAndroidId(): Promise<IdValue>;
export function getGuid(): Promise<IdValue>;
```

## 返回类型（最佳实践）

```ts
// utssdk/common/types.uts
export type IdValue = {
  value?: string; // 原始值（exposeRaw=true 才返回）
  hash?: string; // SHA-256(value + salt) 十六进制
  available: boolean; // 是否获取成功
  limited?: boolean; // 是否受限（系统关闭广告跟踪等）
  source: string; // oaid/aaid/androidId/idfv/guid/...
  message?: string; // 失败或说明
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue; // 预留给 iOS
  widevineId?: IdValue; // 可选
  pseudoId?: IdValue; // 可选
  imei?: IdValue; // 不建议默认启用
  guid?: IdValue; // H5/兜底
  best?: string | null; // 最佳项的 key
  consent: boolean;
  ts: number; // 生成时间戳
};
```

---

# 三、首版代码（可直接放进项目）

> **说明**：以下代码为 **可运行骨架**。
>
> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。
> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。
> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。

## 1）`uni_modules/uni-id-kit/module.json`

```json
{
  "id": "uni-id-kit",
  "displayName": "UniIdKit - 一体设备ID工具包",
  "version": "0.1.0",
  "description": "聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出",
  "keywords": ["deviceid", "oaid", "aaid", "androidid", "guid", "uts"],
  "repository": "",
  "engines": {
    "HBuilderX": "^3.8.0"
  },
  "uni_modules": {
    "platforms": {
      "app-android": {
        "utssdk": {
          "kotlin": ">=1.7.0"
        }
      },
      "web": {
        "utssdk": {}
      }
    }
  }
}
```

## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`

```ts
export type IdValue = {
  value?: string;
  hash?: string;
  available: boolean;
  limited?: boolean;
  source: string;
  message?: string;
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue;
  widevineId?: IdValue;
  pseudoId?: IdValue;
  imei?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`

```ts
// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）
export async function sha256Hex(input: string): Promise<string> {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const enc = new TextEncoder().encode(input);
    const buf = await g.crypto.subtle.digest("SHA-256", enc);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现
  return input;
}
```

## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`

```ts
export function get(key: string): string | null {
  try {
    // @ts-ignore
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}

export function set(key: string, val: string) {
  try {
    // @ts-ignore
    uni.setStorageSync(key, val);
  } catch {}
}
```

## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";

let _consent = false;
let _salt = "";

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getAndroidId(): Promise<IdValue> {
  // Web 没有 AndroidID
  return await build(
    "androidId",
    undefined,
    false,
    false,
    "Not supported on Web"
  );
}

export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Not supported on Web");
}

export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Not supported on Web");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;

  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("androidId") >= 0) res.androidId = await getAndroidId();
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();

  // 国内默认优先级
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }

  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`

```ts
// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）
export function getAndroidIdRaw(): string | null {
  try {
    // @ts-ignore
    const ctx = plus.android.runtimeMainActivity();
    // @ts-ignore
    const SettingsSecure = plus.android.importClass(
      "android.provider.Settings$Secure"
    );
    // @ts-ignore
    const contentResolver = ctx.getContentResolver();
    // @ts-ignore
    const id = SettingsSecure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch (e) {
    return null;
  }
}
```

## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";

let _consent = false;
let _salt = "";

// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：
// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现
async function sha256Hex(input: string): Promise<string> {
  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256
}

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 这里接入你的合规弹窗/SDK；同意前建议不采集
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  const v = getAndroidIdRaw();
  return await build("androidId", v || undefined, exposeRaw);
}

// 预留：接入 Google Advertising ID（AAID）
export async function getAAID(): Promise<IdValue> {
  // TODO：集成 com.google.android.gms:play-services-ads-identifier
  return await build("aaid", undefined, false, true, "AAID not integrated");
}

// 预留：接入 MSA OAID（国内主流）
export async function getOAID(): Promise<IdValue> {
  // TODO：接入 MSA/OAID SDK
  return await build("oaid", undefined, false, true, "OAID not integrated");
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  // 国内优先级：oaid > androidId > guid
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）

```ts
// 平台分发：同名导出，业务方 import 一处即可
// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif
```

---

# 四、在页面中使用（uni-app x）

```ts
// pages/login/index.uvue (示例)
import {
  register,
  setSalt,
  getBestId,
  getIdCodes,
} from "@/uni_modules/uni-id-kit/utssdk/index.uts";

onMounted(async () => {
  await register(); // 视需求弹你的隐私协议
  setSalt("server-salt-xxx"); // 建议从服务端下发

  const best = await getBestId({ exposeRaw: false });
  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）
  const dvc = best.hash || best.value || "unknown";

  await uni.request({
    url: `${baseUrl}/passkeys/login/options`,
    method: "POST",
    header: { "x-device-id": dvc },
    data: {},
  });
});
```

---

# 五、后续接入指引（Android OAID/AAID）

- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。
- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。
- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。
- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。
- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。

---

如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[id-kit开发]]></title>
            <link>https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit开发</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit开发</guid>
            <pubDate>Sun, 07 Sep 2025 12:57:14 GMT</pubDate>
            <content:encoded><![CDATA[
# 一、插件命名 & 目录结构

**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）

- 英文：**UniIdKit**
- 中文：**一体设备 ID 工具包**

**目录（uni_modules 标准）**：

```
uni_modules/
  uni-id-kit/
    package.json
    module.json
    utssdk/
      index.uts              # 聚合导出（按平台分发）
      common/
        types.uts            # 类型与常量定义（复用）
        hash.uts             # SHA-256 工具（Web/Android 均可）
        storage.uts          # 本地缓存工具（uni.storage封装）
      web/
        index.uts            # Web 实现（GUID、hash、缓存）
      app-android/
        index.uts            # Android 实现（AndroidID，OAID/AAID占位）
        adapters/
          android_id.uts     # ANDROID_ID
          aaid.uts           # Google AAID（待接SDK）
          oaid.uts           # MSA OAID  （待接SDK）
          pseudo_id.uts      # 伪ID（可选）
```

> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。
> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。

---

# 二、API 设计（Promise + 回调兼容）

> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。

## 公开方法

```ts
// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）
export function register(options?: {
  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗
}): Promise<{ consent: boolean }>;

// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash
export function setSalt(salt: string): void;

// 3) 一次性获取所有可用的 ID（聚合）
export function getIdCodes(options?: {
  include?: Array<
    | "oaid"
    | "aaid"
    | "androidId"
    | "idfv"
    | "widevineId"
    | "pseudoId"
    | "imei"
    | "guid"
  >;
  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value
  ttlMs?: number; // 缓存有效期，默认 24h
}): Promise<IdCodesResult>;

// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）
export function getBestId(options?: {
  prefer?: Array<"oaid" | "aaid" | "androidId" | "idfv" | "guid">; // 可自定义优先级
  exposeRaw?: boolean;
  ttlMs?: number;
}): Promise<IdValue>;

// 5) 单项拉取（必要时）
export function getOAID(): Promise<IdValue>;
export function getAAID(): Promise<IdValue>;
export function getAndroidId(): Promise<IdValue>;
export function getGuid(): Promise<IdValue>;
```

## 返回类型（最佳实践）

```ts
// utssdk/common/types.uts
export type IdValue = {
  value?: string; // 原始值（exposeRaw=true 才返回）
  hash?: string; // SHA-256(value + salt) 十六进制
  available: boolean; // 是否获取成功
  limited?: boolean; // 是否受限（系统关闭广告跟踪等）
  source: string; // oaid/aaid/androidId/idfv/guid/...
  message?: string; // 失败或说明
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue; // 预留给 iOS
  widevineId?: IdValue; // 可选
  pseudoId?: IdValue; // 可选
  imei?: IdValue; // 不建议默认启用
  guid?: IdValue; // H5/兜底
  best?: string | null; // 最佳项的 key
  consent: boolean;
  ts: number; // 生成时间戳
};
```

---

# 三、首版代码（可直接放进项目）

> **说明**：以下代码为 **可运行骨架**。
>
> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。
> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。
> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。

## 1）`uni_modules/uni-id-kit/module.json`

```json
{
  "id": "uni-id-kit",
  "displayName": "UniIdKit - 一体设备ID工具包",
  "version": "0.1.0",
  "description": "聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出",
  "keywords": ["deviceid", "oaid", "aaid", "androidid", "guid", "uts"],
  "repository": "",
  "engines": {
    "HBuilderX": "^3.8.0"
  },
  "uni_modules": {
    "platforms": {
      "app-android": {
        "utssdk": {
          "kotlin": ">=1.7.0"
        }
      },
      "web": {
        "utssdk": {}
      }
    }
  }
}
```

## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`

```ts
export type IdValue = {
  value?: string;
  hash?: string;
  available: boolean;
  limited?: boolean;
  source: string;
  message?: string;
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue;
  widevineId?: IdValue;
  pseudoId?: IdValue;
  imei?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`

```ts
// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）
export async function sha256Hex(input: string): Promise<string> {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const enc = new TextEncoder().encode(input);
    const buf = await g.crypto.subtle.digest("SHA-256", enc);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现
  return input;
}
```

## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`

```ts
export function get(key: string): string | null {
  try {
    // @ts-ignore
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}

export function set(key: string, val: string) {
  try {
    // @ts-ignore
    uni.setStorageSync(key, val);
  } catch {}
}
```

## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";

let _consent = false;
let _salt = "";

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getAndroidId(): Promise<IdValue> {
  // Web 没有 AndroidID
  return await build(
    "androidId",
    undefined,
    false,
    false,
    "Not supported on Web"
  );
}

export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Not supported on Web");
}

export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Not supported on Web");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;

  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("androidId") >= 0) res.androidId = await getAndroidId();
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();

  // 国内默认优先级
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }

  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`

```ts
// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）
export function getAndroidIdRaw(): string | null {
  try {
    // @ts-ignore
    const ctx = plus.android.runtimeMainActivity();
    // @ts-ignore
    const SettingsSecure = plus.android.importClass(
      "android.provider.Settings$Secure"
    );
    // @ts-ignore
    const contentResolver = ctx.getContentResolver();
    // @ts-ignore
    const id = SettingsSecure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch (e) {
    return null;
  }
}
```

## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";

let _consent = false;
let _salt = "";

// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：
// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现
async function sha256Hex(input: string): Promise<string> {
  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256
}

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 这里接入你的合规弹窗/SDK；同意前建议不采集
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  const v = getAndroidIdRaw();
  return await build("androidId", v || undefined, exposeRaw);
}

// 预留：接入 Google Advertising ID（AAID）
export async function getAAID(): Promise<IdValue> {
  // TODO：集成 com.google.android.gms:play-services-ads-identifier
  return await build("aaid", undefined, false, true, "AAID not integrated");
}

// 预留：接入 MSA OAID（国内主流）
export async function getOAID(): Promise<IdValue> {
  // TODO：接入 MSA/OAID SDK
  return await build("oaid", undefined, false, true, "OAID not integrated");
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  // 国内优先级：oaid > androidId > guid
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）

```ts
// 平台分发：同名导出，业务方 import 一处即可
// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif
```

---

# 四、在页面中使用（uni-app x）

```ts
// pages/login/index.uvue (示例)
import {
  register,
  setSalt,
  getBestId,
  getIdCodes,
} from "@/uni_modules/uni-id-kit/utssdk/index.uts";

onMounted(async () => {
  await register(); // 视需求弹你的隐私协议
  setSalt("server-salt-xxx"); // 建议从服务端下发

  const best = await getBestId({ exposeRaw: false });
  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）
  const dvc = best.hash || best.value || "unknown";

  await uni.request({
    url: `${baseUrl}/passkeys/login/options`,
    method: "POST",
    header: { "x-device-id": dvc },
    data: {},
  });
});
```

---

# 五、后续接入指引（Android OAID/AAID）

- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。
- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。
- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。
- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。
- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。

---

如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。

# 参考实现

太好了，我把你这两个现成插件解包看过了，简单总结下各自实现，然后给一套“最佳实践”的统一 API 和落地改造方案（含可以直接替换的 UTS 代码片段）。

---

## 现有两个插件的实现差异（速览）

### 1) `android-deviceid`（UTS，App-Android）

- **用到的库**：`com.github.gzuliyujiang.oaid`（常用 OAID SDK 聚合库），还打包了 3 个 AAR（`ads-identifier-*.aar`、`IDlibrary-release.aar`）。
- **关键点**：

  - 在 `register()` 里调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity().getApplication())` 完成 **OAID 初始化**。
  - 暴露了一个 **监听器**（`IDManger.OnIOAIDListener`），把厂商返回的 JSON 结果转成你定义的 `Device` 对象回调出去。

- **优点**：能拿到 **OAID**，并且是较为标准的做法；兼容多厂商。
- **需要补强**：

  - **统一 Promise API**（目前是回调），方便在页面里用 `await`。
  - **AAID（Google 广告 ID）**、**AndroidID** 的兜底与优先级策略。
  - **隐私合规**（register 同意前不采集）、**hash-only** 输出（默认只回传哈希，原值可开关）。
  - **缓存**（ttl），防止频繁拉取。
  - 错误/受限标记（例如用户关闭了广告跟踪）。

### 2) `zws-uniqueid`（UTS，App-Android）

- **实现**：拼接 `Build.*` 信息做一段文本，MD5 后作为“唯一 ID”。
- **优点**：无需权限/SDK，易用。
- **问题**：这是典型 **PseudoID**，**同型号/同批次设备可能相同**，也可能因 ROM/版本变更；不适合用来做**设备唯一绑定**或风控。
- **建议**：可以作为 `pseudoId` 字段的**最末位兜底**，不要当主标识。

---

## 建议的统一方案（名字可用你之前认可的：**`uni-id-kit`**）

**目标**：同一份 UTS 插件，覆盖 Web/H5 与 App-Android；API 一致、返回结构一致、默认合规（hash-only），国内优先级 `OAID > AndroidID > GUID > PseudoID`，海外可加 `AAID`。

### 统一 API（Promise 风格）

```ts
// 注册/合规：未同意前一律 available=false
export function register(options?: {
  showPrivacyDialog?: boolean;
}): Promise<{ consent: boolean }>;

// 配置哈希盐（建议服务端下发）
export function setSalt(salt: string): void;

// 一次性获取所有（含可用性、受限说明、hash）
export function getIdCodes(options?: {
  include?: Array<"oaid" | "aaid" | "androidId" | "pseudoId" | "guid">;
  exposeRaw?: boolean; // 默认 false
  ttlMs?: number; // 默认 24h
}): Promise<IdCodesResult>;

// 返回“最合适”的一个（按优先级，可定制）
export function getBestId(options?: {
  prefer?: Array<"oaid" | "androidId" | "guid" | "pseudoId" | "aaid">;
  exposeRaw?: boolean;
  ttlMs?: number;
}): Promise<IdValue>;

// 单项
export function getOAID(): Promise<IdValue>;
export function getAAID(): Promise<IdValue>;
export function getAndroidId(): Promise<IdValue>;
export function getGuid(): Promise<IdValue>;
```

**统一返回结构**

```ts
type IdValue = {
  value?: string; // exposeRaw=true 才返回
  hash?: string; // SHA-256(value + salt)
  available: boolean;
  limited?: boolean; // 例如系统关闭广告跟踪
  source: string; // oaid/aaid/androidId/pseudoId/guid
  message?: string;
};

type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  pseudoId?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

---

## 如何改造你现有的两个插件

> 下面给的都是 **直接能塞进工程** 的 UTS 代码。你可以新建一个 `uni_modules/uni-id-kit`，把这两个插件的“能力”合在一起；或者在你现有 `android-deviceid` 里重构导出，效果一致。

### 1) 公共类型与工具（`common/types.uts`、`common/storage.uts`、`common/hash.uts`）

```ts
// common/types.uts
export type IdValue = {
  value?: string;
  hash?: string;
  available: boolean;
  limited?: boolean;
  source: string;
  message?: string;
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  pseudoId?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

```ts
// common/storage.uts
export function get(key: string): string | null {
  try {
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}
export function set(key: string, val: string) {
  try {
    uni.setStorageSync(key, val);
  } catch {}
}
```

```ts
// common/hash.uts（Web 有 crypto.subtle；Android 建议换成 MessageDigest）
export async function sha256Hex(input: string): Promise<string> {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const enc = new TextEncoder().encode(input);
    const buf = await g.crypto.subtle.digest("SHA-256", enc);
    return Array.from(new Uint8Array(buf))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  return input; // Android 再换成原生 MessageDigest（见下）
}
```

### 2) Web 实现（先把 H5 跑起来：GUID + hash + 缓存）

```ts
// web/index.uts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";

let _consent = false;
let _salt = "";

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  _consent = true; // 你可在这里弹你的隐私协议
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getAndroidId(): Promise<IdValue> {
  return await build(
    "androidId",
    undefined,
    false,
    false,
    "Not supported on Web"
  );
}
export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Not supported on Web");
}
export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Not supported on Web");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  res.best = res.guid?.available ? "guid" : null;
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const r = await getIdCodes(options);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

### 3) Android 实现（融合你两个插件思路，Promise 化 + 兜底 + 可拓展）

- **AndroidID**：直接取 `Settings.Secure.ANDROID_ID`（不需要权限）。
- **OAID**：沿用你 `android-deviceid` 的库，包装为 Promise；初始化要在 `register()` 里做。
- **AAID**：先留占位，后续加 `play-services-ads-identifier`。
- **PseudoID**：把 `zws-uniqueid` 的思路做成可选兜底，不当主标识。
- **SHA-256**：建议在 Android 侧用 `java.security.MessageDigest`，比 web 占位靠谱。

```ts
// app-android/adapters/android_id.uts
export function getAndroidIdRaw(): string | null {
  try {
    // @ts-ignore
    const ctx = plus.android.runtimeMainActivity();
    // @ts-ignore
    const SettingsSecure = plus.android.importClass(
      "android.provider.Settings$Secure"
    );
    // @ts-ignore
    const contentResolver = ctx.getContentResolver();
    // @ts-ignore
    const id = SettingsSecure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch (e) {
    return null;
  }
}
```

```ts
// app-android/adapters/pseudo_id.uts（把 zws 的实现收编为兜底项）
import Build from "android.os.Build";
import MessageDigest from "java.security.MessageDigest";
import BigInteger from "java.math.BigInteger";

export function getPseudoIdRaw(): string | null {
  try {
    const text =
      Build.BOARD +
      Build.BRAND +
      Build.DEVICE +
      Build.DISPLAY +
      Build.FINGERPRINT +
      "uni-id-kit";
    const md5s = MessageDigest.getInstance("MD5").digest(
      (text as any).toString().toByteArray()
    );
    return new BigInteger(1, md5s).toString(16);
  } catch {
    return null;
  }
}
```

```ts
// app-android/index.uts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";
import { getPseudoIdRaw } from "./adapters/pseudo_id.uts";

// ==== 引入你 android-deviceid 插件用到的 OAID 库 ====
import DeviceIdentifier from "com.github.gzuliyujiang.oaid.DeviceIdentifier";
// 你现有的监听器写法是 IDManger.OnIOAIDListener + JSON 回调，这里改 Promise 风格：
// 如果库支持 IGetter 回调也可以（取决于版本），我这里按你包内的风格保留 register 初始化。

let _consent = false;
let _salt = "";

// 使用 Android 的 MessageDigest 实现 SHA-256（优于 web 占位）
function sha256HexSync(input: string): string {
  try {
    // @ts-ignore
    const MessageDigest = plus.android.importClass(
      "java.security.MessageDigest"
    );
    // @ts-ignore
    const md = MessageDigest.getInstance("SHA-256");
    // @ts-ignore
    const bytes = (input as any).toString().getBytes();
    const out = md.digest(bytes);
    let hex = "";
    for (let i = 0; i < out.length; i++) {
      const b = (out[i] as number) & 0xff;
      hex += (b < 16 ? "0" : "") + b.toString(16);
    }
    return hex;
  } catch {
    return input;
  }
}

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

function buildSync(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): IdValue {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? sha256HexSync(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  try {
    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);
  } catch {}
  _consent = true; // 这里接你的隐私弹窗
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  const v = getAndroidIdRaw();
  return buildSync("androidId", v || undefined, exposeRaw);
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return buildSync("guid", guid as string, exposeRaw);
}

// OAID：基于你现有库封装为 Promise（示例：如果库是同步 API 换成同步返回即可）
export async function getOAID(): Promise<IdValue> {
  try {
    // 你包里是通过监听器把结果 JSON 回调出来的；
    // 这里建议写一个同步/异步包装（示意）：
    // 假设库提供 DeviceIdentifier.getOAID(ctx) 或者 DeviceID.getOAID(...)
    // 如果仅有回调形式，就 new Promise 包一下。
    // 先占位为“未集成”，避免误用：
    return buildSync(
      "oaid",
      undefined,
      false,
      true,
      "OAID not integrated to Promise wrapper"
    );
  } catch (e) {
    return buildSync("oaid", undefined, false, false, (e as any).toString());
  }
}

// AAID：等你接 play-services-ads-identifier，这里先占位
export async function getAAID(): Promise<IdValue> {
  return buildSync("aaid", undefined, false, true, "AAID not integrated");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;

  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("pseudoId") >= 0)
    res.pseudoId = buildSync(
      "pseudoId",
      getPseudoIdRaw() || undefined,
      exposeRaw
    );

  // 国内默认优先级：oaid > androidId > guid > pseudoId
  const order = ["oaid", "androidId", "guid", "pseudoId"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const prefer = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

### 4) 平台聚合导出（`utssdk/index.uts`）

```ts
// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif
```

---

## 要不要“调整现在的代码”？

**要的**，但改动并不大，主要集中在 4 点：

1. **Promise 化**：把回调/监听器的导出改为 Promise，页面里可以 `await`。
2. **统一返回结构**：所有方法都返回 `IdValue/IdCodesResult`，好串联与埋点。
3. **合规默认 & hash-only**：提供 `register()` 和 `setSalt()`，未同意前不采集；默认只回 `hash`。
4. **兜底与优先级**：在拿不到 OAID 时，**自动回退**到 `AndroidID`、`GUID`、`pseudoId`，并清晰标出 `limited`/`message`。

> 你的 `android-deviceid` 插件可以直接把库继续用；我在上面的安卓实现里已经把“桥接位”留好了。
> `zws-uniqueid` 的算法我收编到 `pseudoId`，作为兜底，不再当主标识使用。

---

## 下一步

- 你确认用 **`uni-id-kit`** 的方案我就把 **OAID Promise 包装**（基于你现有 `DeviceIdentifier` 监听回调）也给你写上，并且给出 **AAID 接入**（`play-services-ads-identifier`）的 `gradle` 依赖与 UTS 调用示例。
- 如果需要，我也可以给 **iOS（IDFV）** 的 UTS 版本，一起并到这个套件里。

没问题。我把你给的两个 UTS 插件（`android-deviceid` / `zws-uniqueid`）的可取之处吸收，做成一套\*\*“最佳实践版”统一插件\*\*：**`uni-id-kit`**。它满足：

- 跨端（H5 / App-Android / App-iOS），统一 Promise API；
- 默认合规：需先 `register()` 才采集；默认只回 **hash**（可开 `exposeRaw` 返回原值）；
- 国内优先级（可自定义）：**OAID > AndroidID > GUID > PseudoID**，海外可加 **AAID**；
- 安全版 UUID：多端用系统级安全随机（`crypto.getRandomValues` / `SecureRandom` / `SecRandomCopyBytes`），兜底 `Math.random`；
- 缓存、错误与受限标记（如“限制广告跟踪”）；
- 兼容你现有后端（请求头携带 `x-device-id` 即可）。

> 下方给出**可直接落地**的文件结构与代码（可直接新建 `uni_modules/uni-id-kit`），Android 的 OAID/AAID 留好“可用的占位与接入点”；如果你确认要接哪套 SDK（MSA 官方/聚合库），我再把桥接也补全为可跑版本。

---

# 目录结构（放到项目的 `uni_modules/uni-id-kit`）

```
uni_modules/
  uni-id-kit/
    module.json
    package.json
    utssdk/
      index.uts
      common/
        types.uts
        uuid.uts
        hash.uts
        storage.uts
      web/
        index.uts
      app-android/
        index.uts
        adapters/
          android_id.uts
          oaid.uts
          aaid.uts
          pseudo_id.uts
      app-ios/
        index.uts
```

---

# 1) module.json

```json
{
  "id": "uni-id-kit",
  "displayName": "UniIdKit - 一体设备ID工具包",
  "version": "0.2.0",
  "description": "聚合 OAID/AAID/AndroidID/GUID/IDFV 等设备标识，合规 & 哈希化输出，UTS 插件",
  "keywords": ["deviceid", "oaid", "aaid", "androidid", "idfv", "guid", "uts"],
  "engines": { "HBuilderX": ">=3.8.0" },
  "uni_modules": {
    "platforms": {
      "web": { "utssdk": {} },
      "app-android": { "utssdk": { "kotlin": ">=1.7.0" } },
      "app-ios": { "utssdk": {} }
    }
  }
}
```

---

# 2) 公共类型/工具

## `utssdk/common/types.uts`

```ts
export type IdValue = {
  value?: string; // exposeRaw=true 才返回
  hash?: string; // SHA-256(value + salt)
  available: boolean; // 是否成功获取
  limited?: boolean; // 广告跟踪受限/ROM限制
  source: string; // oaid/aaid/androidId/idfv/guid/pseudoId
  message?: string; // 说明/错误
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue;
  guid?: IdValue;
  pseudoId?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

## `utssdk/common/hash.uts`

```ts
// Web 有 crypto.subtle；原生侧建议用平台 API（Android 代码里换成 MessageDigest；iOS 侧可换 CommonCrypto）
export async function sha256Hex(input: string): Promise<string> {
  // #ifdef H5
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const buf = await g.crypto.subtle.digest(
      "SHA-256",
      new TextEncoder().encode(input)
    );
    return Array.from(new Uint8Array(buf))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  // #endif
  return input; // 非H5先返回原文；Android/iOS在各自实现中用系统哈希
}
```

## `utssdk/common/storage.uts`

```ts
export function get(key: string): string | null {
  try {
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}
export function set(key: string, val: string) {
  try {
    uni.setStorageSync(key, val);
  } catch {}
}
```

## `utssdk/common/uuid.uts`（跨端安全 UUIDv4）

```ts
function toHex(): string[] {
  const h: string[] = [];
  for (let i = 0; i < 256; i++) h[i] = (i + 0x100).toString(16).substring(1);
  return h;
}
function formatUuid(b: Uint8Array): string {
  b[6] = (b[6] & 0x0f) | 0x40; // version=4
  b[8] = (b[8] & 0x3f) | 0x80; // variant=10
  const H = toHex();
  return (
    H[b[0]] +
    H[b[1]] +
    H[b[2]] +
    H[b[3]] +
    "-" +
    H[b[4]] +
    H[b[5]] +
    "-" +
    H[b[6]] +
    H[b[7]] +
    "-" +
    H[b[8]] +
    H[b[9]] +
    "-" +
    H[b[10]] +
    H[b[11]] +
    H[b[12]] +
    H[b[13]] +
    H[b[14]] +
    H[b[15]]
  );
}

// #ifdef H5
function getRandom16(): Uint8Array {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.getRandomValues)
    return g.crypto.getRandomValues(new Uint8Array(16));
  const a = new Uint8Array(16);
  for (let i = 0; i < 16; i++) a[i] = Math.floor(Math.random() * 256);
  return a;
}
// #endif

// #ifdef APP-ANDROID
function getRandom16(): Uint8Array {
  const sr = new java.security.SecureRandom(); // UTS 原生：直接 Java 类
  const arr: number[] = new Array<number>(16);
  for (let i = 0; i < 16; i++) arr[i] = sr.nextInt(256);
  return new Uint8Array(arr);
}
// #endif

// #ifdef APP-IOS
// 使用 Security 的 SecRandomCopyBytes（UTS 映射到 Swift）
function getRandom16(): Uint8Array {
  const bytes = new Uint8Array(16);
  // @ts-ignore
  const ok = SecRandomCopyBytes(kSecRandomDefault, 16, bytes);
  if (ok === 0) return bytes;
  // 兜底 arc4random_buf
  // @ts-ignore
  arc4random_buf(bytes, 16);
  return bytes;
}
// #endif

export function uuid4(): string {
  return formatUuid(getRandom16());
}
```

---

# 3) H5 实现

## `utssdk/web/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";
import { uuid4 } from "../common/uuid.uts";

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: IdCodesResult } | null = null;

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 这里接你的隐私弹窗；Demo 直接视为同意
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}
export async function getAndroidId(): Promise<IdValue> {
  return await build("androidId", undefined, false, false, "Web unsupported");
}
export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Web unsupported");
}
export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Web unsupported");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const ttl = (options?.getNumber("ttlMs") || 24 * 3600 * 1000) as number;

  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  res.best = res.guid?.available ? "guid" : null;
  _cache = { ts: Date.now(), data: res };
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const r = await getIdCodes(options);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

---

# 4) Android 实现（融合两插件思路）

- **参考自** `android-deviceid`：OAID 初始化/拉取（此处给出 Promise 版接口占位，方便你把已购库接上）；
- **参考自** `zws-uniqueid`：PseudoID 作为**兜底**而非主标识；
- **AndroidID**：不需权限，稳定性较好；
- **AAID**：留占位（接入 `play-services-ads-identifier` 后即可实现）；
- **哈希**：用 `java.security.MessageDigest`（强于 H5 占位）。

## `utssdk/app-android/adapters/android_id.uts`

```ts
export function getAndroidIdRaw(): string | null {
  try {
    const contentResolver = uni.getContext().getContentResolver();
    const id = android.provider.Settings$Secure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch {
    return null;
  }
}
```

## `utssdk/app-android/adapters/pseudo_id.uts`

```ts
export function getPseudoIdRaw(): string | null {
  try {
    const text =
      android.os.Build.BOARD +
      android.os.Build.BRAND +
      android.os.Build.DEVICE +
      android.os.Build.DISPLAY +
      android.os.Build.FINGERPRINT +
      "uni-id-kit";
    const md = java.security.MessageDigest.getInstance("MD5");
    md.update((text as any).toString().getBytes("UTF-8"));
    const out = md.digest();
    let hex = "";
    for (let i = 0; i < out.length; i++) {
      const b = (out[i] as number) & 0xff;
      hex += (b < 16 ? "0" : "") + b.toString(16);
    }
    return hex;
  } catch {
    return null;
  }
}
```

## `utssdk/app-android/adapters/oaid.uts`（接入点）

```ts
// 这里封装你现有的 OAID 库调用（例如使用 com.github.gzuliyujiang.oaid）
// 由于每家库的接口不完全一致，这里给 Promise 化占位；你把实际调用贴进来即可。
export async function getOAIDRaw(): Promise<{
  value?: string;
  limited?: boolean;
  message?: string;
}> {
  try {
    // TODO: 用你的库实际实现（初始化 register 在 index.uts 的 register() 里做）
    // 例如：DeviceIdentifier.getOAID(context, callback) -> 在 callback 里 resolve
    return {
      value: undefined,
      limited: true,
      message: "OAID not integrated yet",
    };
  } catch (e) {
    return { value: undefined, limited: false, message: (e as any).toString() };
  }
}
```

## `utssdk/app-android/adapters/aaid.uts`（接入点）

```ts
export async function getAAIDRaw(): Promise<{
  value?: string;
  limited?: boolean;
  message?: string;
}> {
  try {
    // TODO: 接入 play-services-ads-identifier：
    // AdvertisingIdClient.getAdvertisingIdInfo(context).getId()
    return {
      value: undefined,
      limited: true,
      message: "AAID not integrated yet",
    };
  } catch (e) {
    return { value: undefined, limited: false, message: (e as any).toString() };
  }
}
```

## `utssdk/app-android/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { uuid4 } from "../common/uuid.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";
import { getOAIDRaw } from "./adapters/oaid.uts";
import { getAAIDRaw } from "./adapters/aaid.uts";
import { getPseudoIdRaw } from "./adapters/pseudo_id.uts";

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: IdCodesResult } | null = null;

function sha256HexSync(input: string): string {
  try {
    const md = java.security.MessageDigest.getInstance("SHA-256");
    md.update((input as any).toString().getBytes("UTF-8"));
    const out = md.digest();
    let hex = "";
    for (let i = 0; i < out.length; i++) {
      const b = (out[i] as number) & 0xff;
      hex += (b < 16 ? "0" : "") + b.toString(16);
    }
    return hex;
  } catch {
    return input;
  }
}

function buildSync(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): IdValue {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? sha256HexSync(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 1) OAID 库初始化（把你 android-deviceid 的 register 放到这里）
  //    例：DeviceIdentifier.register(uni.getContext().getApplicationContext())
  try {
    // TODO: 调你的 OAID 库 register
  } catch {}

  // 2) 你的隐私弹窗/合规流程
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  return buildSync("androidId", getAndroidIdRaw() || undefined, exposeRaw);
}
export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return buildSync("guid", guid as string, exposeRaw);
}
export async function getOAID(): Promise<IdValue> {
  const r = await getOAIDRaw();
  return buildSync("oaid", r.value, false, r.limited, r.message);
}
export async function getAAID(): Promise<IdValue> {
  const r = await getAAIDRaw();
  return buildSync("aaid", r.value, false, r.limited, r.message);
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
    "aaid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const ttl = (options?.getNumber("ttlMs") || 24 * 3600 * 1000) as number;

  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("pseudoId") >= 0)
    res.pseudoId = buildSync(
      "pseudoId",
      getPseudoIdRaw() || undefined,
      exposeRaw
    );

  // 国内默认优先级（可通过 getBestId 覆盖）
  const order = ["oaid", "androidId", "guid", "pseudoId", "aaid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  _cache = { ts: Date.now(), data: res };
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const prefer = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
    "aaid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

---

# 5) iOS 实现（IDFV）

> 你说先国内为主；这里把 **IDFV** 实现好，方便未来开 iOS 端复用。

## `utssdk/app-ios/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { uuid4 } from "../common/uuid.uts";

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: IdCodesResult } | null = null;

function sha256HexSync(input: string): string {
  // TODO: 可换成 CommonCrypto(CC_SHA256)；演示先返回原文
  return input;
}
function buildSync(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): IdValue {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? sha256HexSync(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

function getIDFVRaw(): string | null {
  try {
    const idfv = UIDevice.currentDevice.identifierForVendor?.UUIDString;
    return idfv ? `idfv:${idfv}` : null;
  } catch {
    return null;
  }
}
export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `ios:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return buildSync("guid", guid as string, exposeRaw);
}
export async function getAndroidId(): Promise<IdValue> {
  return buildSync("androidId", undefined, false, false, "iOS unsupported");
}
export async function getOAID(): Promise<IdValue> {
  return buildSync("oaid", undefined, false, false, "iOS unsupported");
}
export async function getAAID(): Promise<IdValue> {
  return buildSync("aaid", undefined, false, false, "iOS unsupported");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "idfv",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const ttl = (options?.getNumber("ttlMs") || 24 * 3600 * 1000) as number;

  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("idfv") >= 0)
    res.idfv = buildSync("idfv", getIDFVRaw() || undefined, exposeRaw);
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  const order = ["idfv", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  _cache = { ts: Date.now(), data: res };
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const prefer = (options?.getArray<string>("prefer") || [
    "idfv",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

---

# 6) 平台聚合导出

## `utssdk/index.uts`

```ts
// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif

// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef APP-IOS
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-ios/index.uts";
// #endif
```

---

# 7) 使用示例（在你的登录页中）

```ts
import {
  register,
  setSalt,
  getBestId,
} from "@/uni_modules/uni-id-kit/utssdk/index.uts";

onMounted(async () => {
  await register({}); // 你的隐私弹窗/合规逻辑
  setSalt("server-salt-xyz"); // 建议服务端下发；默认只回 hash

  const best = await getBestId({
    prefer: ["oaid", "androidId", "guid"],
    exposeRaw: false,
  });
  const dvc = best.hash || best.value || "unknown";

  await uni.request({
    url: `${baseUrl}/passkeys/login/options`,
    method: "POST",
    header: { "x-device-id": dvc },
    data: {},
  });
});
```

---

# 8) 和你两个插件的关系（怎么“融合/替换”）

- `android-deviceid`：

  - **保留其 OAID 能力**，把初始化 `register()` 与获取流程**Promise 化**放到 `adapters/oaid.uts`；
  - 如果你用的是 **gzu 的聚合库**（`com.github.gzuliyujiang.oaid`），我可按它的 IGetter/Client 回调写成可跑代码；你只需告诉我当前项目里的依赖坐标/使用方式即可（或把现有 `register/getOAID` 调用片段贴我）。

- `zws-uniqueid`：

  - 仅作为 **PseudoID 兜底**（`adapters/pseudo_id.uts` 已收编）；
  - 不再把它当“设备唯一标识”，它稳定性不够（但当兜底是有意义的）。

---

# 9) 你可能需要的依赖与打包说明（Android）

**OAID**

- 如果用 **MSA 官方 SDK**：按其文档接入（添加 AAR、初始化、回调）。
- 如果用 **gzu 聚合库**：在 `module.json` 的 `app-android -> utssdk` 里加配置，或在 HBuilderX 的原生配置里勾选对应依赖；随后把 `adapters/oaid.uts` 里按该库接口实现 `getOAIDRaw()` 即可。

**AAID**（Google 广告 ID）

- `com.google.android.gms:play-services-ads-identifier`（需要科学上网/可用镜像）；
- 通过 `AdvertisingIdClient.getAdvertisingIdInfo(context).id` 获取；若用户限制广告跟踪，返回 limited=true。

> 我可以根据你环境（国内私服/镜像）给出具体 Gradle 依赖配置方式。

---

## 总结

- 这套 **`uni-id-kit`** 是把你两个 UTS 插件做了**统一封装、Promise 化、合规默认与安全加强（哈希/安全随机）**，并提供**清晰可扩展**的适配层。
- 你现在就可以把上述文件落地，H5 和 Android 的 **AndroidID/GUID/PseudoID** 已可用；**OAID/AAID** 只需在 `adapters/*.uts` 里按你现有库补上调用即可（导出接口已经定好）。
- 一旦接上 OAID，你就能在国内端得到优先使用的稳定设备标识；其余平台自动回退到 AndroidID/IDFV/GUID。

需要的话，你把你现在 OAID 库的 **初始化 & 获取代码片段**贴我，我直接把 `adapters/oaid.uts` 写成可用实现版（不再占位）。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[passkeys 通行密钥 登录+注册一体化方案]]></title>
            <link>https://herongdev.github.io/blog/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案</guid>
            <pubDate>Thu, 04 Sep 2025 23:29:49 GMT</pubDate>
            <content:encoded><![CDATA[
结论先说：**可以把“登录+注册”做成一体化体验**。

主流做法是 **“先尝试登录（可发现凭证）→ 如果用户或设备上没有可用通行密钥，再走 JIT 注册并在验证成功后直接登录”**。

原因是 WebAuthn 天生是“**两步握手**”：
**options**（服务端签发挑战）→ **客户端做凭证仪式** → **verify**（服务端校验）。
所以无论登录还是注册，都至少要走这一来一回；想“完全无交互”是不可能的。但你可以把 **登录与注册的分支逻辑** 封装好，让前端只调用 1\~2 次 API 就完成。

你的代码里已经有这个形态了：

- `/passkeys/login/options|verify`：**无用户名直登**（allowCredentials 留空 → 可发现凭证）
- `/passkeys/register-or-login/options|verify`：**JIT 建号 + 设备唯一 + 注册即登录**

这就是一体化的正确方向。下面给你**微调点**，让体验更顺滑，并回答“是否必须先绑定”的顾虑。

## 推荐落地流程（与大厂一致的用户体验）

1. **进入应用 → 前端先调用** `/passkeys/login/options`（不传 allowCredentials）。

   - Android/iOS 原生会列出与 **RP ID** 匹配的“可发现凭证”(resident key)。
   - 若用户设备上已有你的 RP 的通行密钥 → 用户点一下即返回 **assertion** → 你后端 `verifyAuthentication` → **直接登录**。

2. **若返回“没有可用凭证/用户取消/NotFound”**：前端**立即**调用 `/passkeys/register-or-login/options`（带上 `deviceIdentifier`）。

   - 后端 **JIT 建号**（或使用你已有的访客/待激活账号策略），签发 **registration options**（residentKey=required）。
   - 前端发起注册仪式 → 拿到 **attestation** 回 `/register-or-login/verify`。
   - 服务端 **校验 + 入库 + 绑定设备(可选) + 激活账号 + 签发 JWT** → **注册即登录**。

> 是否必须先“绑定再登录”？
> **不必须。**对已存在通行密钥的用户，第一步就能登录；对新设备/新用户，第二步完成**注册+登录**。
> “设备唯一绑定”是**风控策略**（特别适合你的“仅内部员工”场景），不是通行密钥的强制要求。

## 只给需要修改/新增的代码（复杂逻辑上一行有注释）

### A) `PasskeysService.issueAuthenticationOptions`：若发现设备已绑定账号，则**定向登录**（加速成功率）

```ts
// 复杂逻辑：若 deviceIdentifier 已绑定 userId，则定向下发 allowCredentials（命中率更高，更快）
async issueAuthenticationOptions({ deviceIdentifier }: { deviceIdentifier?: string }) {
  const relyingPartyId = this.configService.get<string>('RP_ID');

  // 可选的速率限制（60s/5次）
  if (deviceIdentifier) {
    const rlKey = `rl:authpub:${deviceIdentifier}`;
    const c = await this.redisService.incrementKey(rlKey);
    if (c === 1) await this.redisService.expireKey(rlKey, 60);
    if (c > 5) throw new BadRequestException('请求过于频繁，请稍后重试');
  }

  let allowCredentials: { id: Buffer; type: 'public-key' }[] | undefined;
  let preferUserId: string | null = null;

  if (deviceIdentifier) {
    // 复杂逻辑：如果该设备已绑定过账号，优先走“定向登录”
    preferUserId = await this.redisService.getValue(`dvc:owner:${deviceIdentifier}`);
    if (preferUserId) {
      // 复杂逻辑：查询该用户的所有凭证，拼出 allowCredentials（按你的持久层接口调整）
      const creds = await this.staffService.findManyCredentialsByUserId(preferUserId);
      allowCredentials = (creds || []).map((c: any) => ({
        id: Buffer.from(c.credentialId, 'base64url'),
        type: 'public-key' as const,
      }));
    }
  }

  const opts = await generateAuthenticationOptions({
    rpID: relyingPartyId,
    userVerification: 'preferred',
    // 复杂逻辑：存在 allowCredentials → 定向登录；否则留空 = 可发现凭证
    allowCredentials,
  });

  // 复杂逻辑：挑战转为 base64url，分别按“userId”或“challenge”做校验键
  const ch = typeof opts.challenge === 'string'
    ? opts.challenge
    : Buffer.from(opts.challenge).toString('base64url');

  if (preferUserId) {
    // 定向登录：按 userId 存
    await this.redisService.setWithTimeToLive(`webauthn:auth:${preferUserId}`, ch, 300);
  } else {
    // 无用户名直登：按 challenge 存
    await this.redisService.setWithTimeToLive(`webauthn:auth:ch:${ch}`, '1', 300);
  }

  // 兼容前端：无需改协议，仍返回纯 AuthenticationOptions
  return { options: opts };
}
```

> 说明：
>
> - 这段逻辑**不改变你的路由与前端协议**，仅在“已绑定设备”的情况下给出 `allowCredentials`，成功率会更高，且仍保留“可发现凭证”的默认路径。
> - `findManyCredentialsByUserId` 请在你的 `AdminStaffService` 或凭据仓库里补一个简单查询（只要返回 `credentialId` 列表即可）。

---

### B) 前端（你刚写的 `<script setup>` 页面）**登录按钮**增加“失败回退到注册”的兜底（只给改动段）

```ts
// 复杂逻辑：登录失败时自动回退到 JIT 注册（注册成功即登录）
async function onLogin() {
  try {
    appendLog("请求登录 options...");
    const { options } = await post("/passkeys/login/options", {
      deviceIdentifier: deviceId.value,
    });
    const requestOptionsJson = JSON.stringify(options);

    // 复杂逻辑：先尝试登录（Android 支持 conditional UI；iOS 忽略该参数）
    const authRespJson = await passkeys.getPasskey(requestOptionsJson, {
      conditional: true,
    });

    appendLog("登录响应返回，提交后端 verify...");
    const verify = await post(
      "/passkeys/login/verify",
      JSON.parse(authRespJson)
    );
    appendLog("登录完成：" + JSON.stringify(verify));
    uni.showToast({ title: "登录成功", icon: "success" });
  } catch (e: any) {
    appendLog("未找到可用通行密钥或用户取消，转入一键注册...");
    // ===== 回退到 JIT 注册 =====
    const { userId, options } = await post(
      "/passkeys/register-or-login/options",
      deviceId.value ? { deviceIdentifier: deviceId.value } : {}
    );
    const creationOptionsJson = JSON.stringify(options);
    const regRespJson = await passkeys.createPasskey(creationOptionsJson);

    appendLog("注册响应返回，提交后端 verify...");
    const verify = await post("/passkeys/register-or-login/verify", {
      ...JSON.parse(regRespJson),
      userId,
      deviceIdentifier: deviceId.value,
    });
    appendLog("注册并登录完成：" + JSON.stringify(verify));
    uni.showToast({ title: "已注册并登录", icon: "success" });
  }
}
```

---

### C) 小修小补（可选但建议）

```ts
// ✅ 注册 options：建议同时允许 ES256 与 RS256，兼容性更好
supportedAlgorithmIDs: [-7, -257],  // ES256 + RS256

// ✅ 注册时强制 residentKey=required 已很好；登录时建议 UV 至少 preferred（你已这么做）
// 可对内网/高敏环境将 requireUserVerification 提升为 true
requireUserVerification: true, // 在 verify* 中按需要切换
```

---

## 关键答疑

- **“能不能只请求一次后端就完成登录？”**
  不行。WebAuthn 必须由服务器先发“带签名挑战”的 **options**，客户端拿到后**本地安全硬件**完成签名/生成数据，再发给服务器 **verify**。这是设计使然，无法省略。

- **“新用户是否必须先走‘绑定’页面？”**
  不必须。你现在的 JIT 路线就是“**注册即登录**”。首次访问：登录失败 → 自动发起注册 → 验证成功后立刻签发会话即可。后续访问就直接“可发现凭证”一键登录了。

- **“设备唯一绑定是必须的吗？”**
  不是 WebAuthn 的硬性要求，但对**内部员工场景非常有用**（合规+风控）。你已经在 JIT 验证里写了 `dvc:owner:*` 的校验与写入，这就够了。

---

如果你愿意，我可以**补一个 `findManyCredentialsByUserId` 的最小实现**（Prisma/TypeORM 任一版）或把你的 `PasskeysController` 的“登录按钮”分支写成更干净的状态机。你说一声，我按你的“只给改动段”规范继续补。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/Next.js/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/Next.js/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）</guid>
            <pubDate>Sat, 06 Sep 2025 14:41:39 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: 最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）
date: 2025-09-06
tags:

- TanStack Query
- React Query
- Next.js 14
- TypeScript

---

## 目标

在**不改动你现有 http 封装**（`http.call` + `api/modules/price.ts`）前提下，最小成本接入 TanStack Query，用于价格趋势这类“读多写少”的数据获取与缓存。

---

## 步骤总览

1. 安装依赖
2. 新增 `QueryProvider` 并在 `app/layout.tsx` 注入
3. 写一个最小的 `usePriceTrend` 查询 Hook
4. 在一个客户端组件里调用展示

> 说明：只给**新增/变更**的文件内容；复杂逻辑在上一行加注释。

---

## 1) 安装

```bash
pnpm add @tanstack/react-query
# 可选：开发工具
pnpm add -D @tanstack/react-query-devtools
```

---

## 2) Provider：在全局注入 QueryClient

**新增：`src/lib/query/QueryProvider.tsx`**

```tsx
"use client";

import { PropsWithChildren, useState } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
// 可选：开发时打开
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

export default function QueryProvider({ children }: PropsWithChildren) {
  // 复杂逻辑上一行注释：用 useState 确保在客户端持久化一个 QueryClient 单例
  const [client] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // 复杂逻辑上一行注释：避免频繁重复请求，数据 5 分钟内视为新鲜
            staleTime: 5 * 60 * 1000,
            // 复杂逻辑上一行注释：失败最多重试 2 次，指数退避
            retry: 2,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={client}>
      {children}
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
}
```

**修改：`src/app/layout.tsx`（只贴需要插入的代码）**

```tsx
// ➊ 新增这一行
import QueryProvider from "@/lib/query/QueryProvider";

// ... 省略你的现有代码
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh-CN">
      <body>
        {/* ➋ 用 Provider 包裹全局 */}
        <QueryProvider>{children}</QueryProvider>
      </body>
    </html>
  );
}
```

---

## 3) 查询 Hook：封装价格趋势获取

**新增：`src/features/price-trend/queries.ts`**

```ts
"use client";

import { useQuery } from "@tanstack/react-query";
import { priceApi } from "@/api/modules/price";

// 复杂逻辑上一行注释：以业务语义定义查询 Hook，统一 queryKey 与调用的 API 函数
export function usePriceTrend(gameId: string, stores: string[]) {
  return useQuery({
    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参
    queryKey: ["priceTrend", gameId, stores],
    // 复杂逻辑上一行注释：交给领域 API，返回 Promise<any>
    queryFn: () => priceApi.getTrend({ gameId, stores }),
    // 复杂逻辑上一行注释：没有必要参数时不发起请求
    enabled: Boolean(gameId) && stores.length > 0,
    // 可选：覆盖全局默认值
    staleTime: 5 * 60 * 1000,
    gcTime: 60 * 60 * 1000,
  });
}
```

> 你之前已经有 `priceApi.getTrend`，这里直接复用即可。

---

## 4) 页面示例：客户端组件中使用

**新增：`src/app/price-trend-demo/page.tsx`（最小可跑 Demo 页）**

```tsx
"use client";

import { useState } from "react";
import { usePriceTrend } from "@/features/price-trend/queries";

export default function PriceTrendDemoPage() {
  const [gameId, setGameId] = useState("wukong");
  const [stores, setStores] = useState<string[]>(["Steam", "Epic"]);

  const { data, isLoading, error, refetch } = usePriceTrend(gameId, stores);

  return (
    <div className="p-4 space-y-3">
      <div className="flex gap-2 items-center">
        <input
          value={gameId}
          onChange={(e) => setGameId(e.target.value)}
          placeholder="gameId"
          className="border px-2 py-1 rounded"
        />
        <button
          // 复杂逻辑上一行注释：演示手动刷新（一般可不需要，TanStack 会按策略自动刷新）
          onClick={() => refetch()}
          className="px-3 py-1 rounded border"
        >
          Refresh
        </button>
      </div>

      {isLoading && <div>加载中...</div>}
      {error && (
        <div className="text-red-600">出错了：{(error as any)?.message}</div>
      )}

      <pre className="bg-gray-100 p-3 rounded text-sm overflow-auto">
        {JSON.stringify(data, null, 2)}
      </pre>
    </div>
  );
}
```

> 想接上图表时，把 `data` 交给你的图表组件即可；后续可以把 `stores` 做成可搜索多选，与你主页筛选一致。

---

## 可选：SSR 预取（以后再加）

最小集成里我们**不做 SSR**，直接用客户端渲染即可；若将来需要 SSR/Hydration，可用 `@tanstack/react-query` 的 `dehydrate/hydrate` 在 Server Component 里预取数据、在 Client 端复水。等你需要时我再给“最小 SSR 版本”的差异补丁即可。

下面给你**Vue 3 最小可用示例**（基于 `@tanstack/vue-query`，不改你的 http 封装与 `priceApi`）。只包含**必要的新文件/改动**；复杂逻辑已在上一行加注释。

---

### 1) 安装

```bash
pnpm add @tanstack/vue-query
# 可选：开发工具
pnpm add -D @tanstack/vue-query-devtools
```

---

### 2) 全局注册 Vue Query 插件

**新增：`src/plugins/vue-query.ts`**

```ts
// 复杂逻辑上一行注释：创建全局 QueryClient，设定默认缓存/重试策略
import {
  QueryClient,
  VueQueryPlugin,
  type VueQueryPluginOptions,
} from "@tanstack/vue-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 复杂逻辑上一行注释：5 分钟内视为新鲜，避免频繁请求
      staleTime: 5 * 60 * 1000,
      // 复杂逻辑上一行注释：失败自动重试 2 次，指数退避
      retry: 2,
      // 聚焦窗口时不强制刷新（按需可改为 true）
      refetchOnWindowFocus: false,
    },
  },
});

export function installVueQuery(app: import("vue").App) {
  const options: VueQueryPluginOptions = { queryClient };
  app.use(VueQueryPlugin, options);
  // 可选：开发工具
  // if (import.meta.env.DEV) {
  //   const { VueQueryDevtools } = await import('@tanstack/vue-query-devtools')
  //   app.use(VueQueryDevtools, { initialIsOpen: false })
  // }
}
```

**修改：`src/main.ts`（只贴需要新增的行）**

```ts
import { createApp } from "vue";
import App from "./App.vue";

// + 新增：注册 Vue Query 插件
import { installVueQuery } from "@/plugins/vue-query";

const app = createApp(App);
installVueQuery(app);
app.mount("#app");
```

---

### 3) 查询 Hook（Composable）

**新增：`src/features/price-trend/usePriceTrend.ts`**

```ts
// 复杂逻辑上一行注释：以业务语义封装 useQuery，统一 queryKey 与调用的 API
import { useQuery } from "@tanstack/vue-query";
import { priceApi } from "@/api/modules/price";

export function usePriceTrend(gameId: string, stores: string[]) {
  return useQuery({
    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参
    queryKey: ["priceTrend", gameId, stores],
    // 复杂逻辑上一行注释：交给领域 API，返回 Promise
    queryFn: () => priceApi.getTrend({ gameId, stores }),
    // 复杂逻辑上一行注释：参数不全时不发起请求
    enabled: Boolean(gameId) && stores.length > 0,
    // 可选：覆盖默认策略
    staleTime: 5 * 60 * 1000,
    gcTime: 60 * 60 * 1000,
  });
}
```

> 这里直接复用你已有的 `priceApi.getTrend`（基于 `http.call`）。

---

### 4) 最小页面示例（组件中使用）

**新增：`src/views/PriceTrendDemo.vue`**

```vue
<script setup lang="ts">
import { ref } from "vue";
import { usePriceTrend } from "@/features/price-trend/usePriceTrend";

const gameId = ref("wukong");
const stores = ref<string[]>(["Steam", "Epic"]);

const { data, isLoading, error, refetch } = usePriceTrend(
  gameId.value,
  stores.value
);
</script>

<template>
  <div class="p-4 space-y-3">
    <div class="flex gap-2 items-center">
      <input
        v-model="gameId"
        placeholder="gameId"
        class="border px-2 py-1 rounded"
      />
      <button class="px-3 py-1 rounded border" @click="refetch()">
        Refresh
      </button>
    </div>

    <div v-if="isLoading">加载中...</div>
    <div v-else-if="error" class="text-red-600">
      出错了：{{ (error as any)?.message }}
    </div>

    <pre class="bg-gray-100 p-3 rounded text-sm overflow-auto"
      >{{ JSON.stringify(data ?? null, null, 2) }}
    </pre>
  </div>
</template>
```

> 路由按你的项目来：例如在 `vue-router` 里把该组件挂到 `/price-trend-demo`。

---

#### 可选：当 `gameId/stores` 在页面中会变更时

把 `usePriceTrend(gameId.value, stores.value)` 改成**侦听式**：

```ts
const { data, isLoading, error, refetch } = usePriceTrend(
  // 复杂逻辑上一行注释：传入原始值即可；依赖变化时 useQuery 会按 key 缓存/重取
  gameId.value,
  stores.value
);
```

若你希望**自动**随着 `gameId/stores` 的变更而刷新，可在外层 `watch([gameId, stores], refetch)`；不过通常让 `queryKey` 变化即可自动生效（会根据 key 命中缓存或重新请求）。

---

### 5) 与你现有封装的关系

- **无需修改** `http.call` / `client.ts` / `cancel.ts`；Vue Query 只是把“请求何时发起、如何缓存/重试/并发合并”的**状态机**托管出去。
- 其他简单页面仍可直接用 `http.get/post` 或 `http.call`。把 **“读多写少、复用度高”的接口**（比如价格趋势、列表）逐步迁到 Vue Query 即可，**按需引入**、零破坏。

如果你需要 **SSR（Nuxt 3）** 的最小示例或 **分页/无限滚动** 的 Query 示例，我也可以在此基础上给出只含必要代码的增量补丁。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/Vue/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/Vue/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）</guid>
            <pubDate>Fri, 05 Sep 2025 16:25:03 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）
date: 2025-09-05
tags: \[Vue3, Ant Design Vue, 组件封装, v-model]

---

## 思路概述

- 用 `defineModel` 直接驱动 `a-checkbox-group` / `a-radio-group`，去掉中间层 `innerValue` 与 `watch`，减少响应式开销与同步复杂度。
- 加上 `defineOptions({ inheritAttrs: false })`，避免 attrs 同时落在根节点与 `a-*group` 上导致副作用。
- `Checkbox` 明确 `value` 为 **数组**，默认 `[]`；`Radio` 的 `value` 为任意，默认 `null`。

---

## 最简实现步骤

1. 删除 `innerValue` 与所有 `watch`。
2. 用 `const value = defineModel<...>('value', { default: ... })`，模板直接 `v-model:value="value"`。
3. 设置 `inheritAttrs: false`，并将 `attrs` 仅透传给 `a-*group`。

---

## 完整代码（Checkbox）

```vue
<template>
  <div
    class="gtc-checkbox"
    :class="[`gtc-checkbox-${size}`, disabled ? 'is-disabled' : '']"
  >
    <a-checkbox-group v-model:value="value" :disabled="disabled" v-bind="attrs">
      <slot />
    </a-checkbox-group>
  </div>
</template>

<script setup lang="ts">
import { useAttrs } from "vue";

// 复杂：避免 attrs 同时落到根节点与 a-checkbox-group
defineOptions({ inheritAttrs: false });

const attrs = useAttrs();

const props = defineProps({
  size: { type: String, default: "md" },
  disabled: { type: Boolean, default: false },
});

// 复杂：CheckboxGroup 期望数组；默认应为 []
const value = defineModel<any[]>("value", { default: [] });
</script>

<style lang="less" scoped>
.gtc-checkbox {
  .ant-checkbox-wrapper {
    color: var(--ink-950);
  }
  .ant-checkbox {
    &-inner {
      border-color: var(--rim-300);
      background: none;
      box-shadow: none;
    }
    &-checked .ant-checkbox-inner {
      background-color: var(--blue-primary);
      border-color: var(--blue-primary);
    }
    &:hover .ant-checkbox-inner {
      border-color: var(--ink-400);
    }
  }
}

.gtc-checkbox-sm .ant-checkbox-inner {
  width: 14px;
  height: 14px;
}
.gtc-checkbox-md .ant-checkbox-inner {
  width: 16px;
  height: 16px;
}
.gtc-checkbox-lg .ant-checkbox-inner {
  width: 18px;
  height: 18px;
}

.is-disabled {
  .ant-checkbox-inner {
    background: var(--ground-50);
    border-color: var(--rim-300);
  }
}
</style>
```

---

## 完整代码（Radio）

```vue
<template>
  <div
    class="gtc-radio"
    :class="[`gtc-radio-${size}`, disabled ? 'is-disabled' : '']"
  >
    <a-radio-group v-model:value="value" :disabled="disabled" v-bind="attrs">
      <slot />
    </a-radio-group>
  </div>
</template>

<script setup lang="ts">
import { useAttrs } from "vue";

// 复杂：避免 attrs 同时落到根节点与 a-radio-group
defineOptions({ inheritAttrs: false });

const attrs = useAttrs();

const props = defineProps({
  size: { type: String, default: "md" },
  disabled: { type: Boolean, default: false },
});

// 复杂：RadioGroup 接收单值；默认 null
const value = defineModel<any>("value", { default: null });
</script>

<style lang="less" scoped>
.gtc-radio {
  .ant-radio-wrapper {
    color: var(--ink-950);
  }
  .ant-radio-inner {
    border-color: var(--rim-300);
    background: none;
    box-shadow: none;
  }
  .ant-radio-checked .ant-radio-inner {
    border-color: var(--blue-primary);
  }
  .ant-radio-checked .ant-radio-inner::after {
    background-color: var(--blue-primary);
  }
  .ant-radio:hover .ant-radio-inner {
    border-color: var(--ink-400);
  }
}

.gtc-radio-sm .ant-radio-inner {
  width: 14px;
  height: 14px;
}
.gtc-radio-md .ant-radio-inner {
  width: 16px;
  height: 16px;
}
.gtc-radio-lg .ant-radio-inner {
  width: 18px;
  height: 18px;
}

.is-disabled {
  .ant-radio-inner {
    background: var(--ground-50);
    border-color: var(--rim-300);
  }
}
</style>
```

---

## 备注

- 现在两个组件都是\*\*“零 watch、零中间层”\*\*：父表单直接通过 `v-model:value` 与 antd 组件对齐；
- 与你表单规则的“复选框至少选一项”自定义校验配合使用即可（在 `getValidationRules` 里对 `checkbox` 做长度判断）。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）</guid>
            <pubDate>Sat, 06 Sep 2025 14:49:38 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）
date: 2025-09-06
tags:

- Vue3
- TanStack Vue Query
- 分页
- 无限滚动

---

## 前提

已安装并在 `main.ts` 里注册了 `@tanstack/vue-query`（你之前那步已经完成）。下面示例直接复用你的 `http.call` 封装。

---

## 一、页码分页（page/pageSize）

### 1) 组合式函数：`usePagedItems.ts`

```ts
// src/features/demo/usePagedItems.ts
"use client";

import { ref } from "vue";
import { useQuery } from "@tanstack/vue-query";
import { http } from "@/lib/http";

// 复杂逻辑上一行注释：后端返回 PageResp 结构（list/total/page/pageSize）
type Item = { id: string; title: string };
type PageResp<T> = { list: T[]; total: number; page: number; pageSize: number };

// 复杂逻辑上一行注释：拉取某页数据的纯函数，便于测试与复用
async function fetchPage(
  page: number,
  pageSize: number
): Promise<PageResp<Item>> {
  return http.call<PageResp<Item>>({
    url: "/api/items",
    method: "GET",
    params: { page, pageSize },
  });
}

export function usePagedItems(initialPageSize = 20) {
  const page = ref(1);
  const pageSize = ref(initialPageSize);

  const query = useQuery({
    // 复杂逻辑上一行注释：将页码作为 queryKey 的一部分，命中不同页的缓存
    queryKey: () => ["items", page.value, pageSize.value],
    // 复杂逻辑上一行注释：当 page 或 pageSize 改变时，自动按新 key 请求/复用缓存
    queryFn: () => fetchPage(page.value, pageSize.value),
    staleTime: 60_000,
    keepPreviousData: true, // 复杂逻辑上一行注释：翻页时保留上一页数据，避免闪烁
  });

  // 复杂逻辑上一行注释：对外暴露翻页方法
  const next = () => {
    page.value += 1;
  };
  const prev = () => {
    page.value = Math.max(1, page.value - 1);
  };
  const setPage = (p: number) => {
    page.value = Math.max(1, p);
  };

  return { page, pageSize, ...query, next, prev, setPage };
}
```

### 2) 组件示例：`PagedList.vue`

```vue
<!-- src/views/PagedList.vue -->
<script setup lang="ts">
import { usePagedItems } from "@/features/demo/usePagedItems";

const { data, isFetching, error, page, next, prev } = usePagedItems(10);
</script>

<template>
  <div class="p-4 space-y-3">
    <div class="flex items-center gap-2">
      <button class="border px-3 py-1 rounded" @click="prev">上一页</button>
      <span>第 {{ page }} 页</span>
      <button class="border px-3 py-1 rounded" @click="next">下一页</button>
    </div>

    <div v-if="isFetching">加载中...</div>
    <div v-else-if="error" class="text-red-600">
      出错：{{ (error as any)?.message }}
    </div>

    <ul v-else class="list-disc pl-5">
      <li v-for="it in data?.list ?? []" :key="it.id">{{ it.title }}</li>
    </ul>
  </div>
</template>
```

---

## 二、无限滚动（cursor/nextCursor）

### 1) 组合式函数：`useInfiniteItems.ts`

```ts
// src/features/demo/useInfiniteItems.ts
"use client";

import { computed } from "vue";
import { useInfiniteQuery } from "@tanstack/vue-query";
import { http } from "@/lib/http";

type Item = { id: string; title: string };
// 复杂逻辑上一行注释：后端返回游标结构（items + nextCursor），没有更多时 nextCursor 为空/undefined
type CursorResp<T> = { items: T[]; nextCursor?: string | null };

async function fetchByCursor(
  cursor: string | null,
  limit: number
): Promise<CursorResp<Item>> {
  // 复杂逻辑上一行注释：第一页用 null/空串，后续带上 nextCursor
  return http.call<CursorResp<Item>>({
    url: "/api/items/cursor",
    method: "GET",
    params: { cursor, limit },
  });
}

export function useInfiniteItems(limit = 20) {
  const q = useInfiniteQuery({
    queryKey: ["items-infinite", limit],
    // 复杂逻辑上一行注释：pageParam 是上一次 getNextPageParam 返回的值；第一页由 initialPageParam 提供
    queryFn: ({ pageParam }) => fetchByCursor(pageParam ?? null, limit),
    initialPageParam: null as string | null,
    // 复杂逻辑上一行注释：从返回值中取下一页的游标；无则表示到底
    getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,
    staleTime: 60_000,
  });

  // 复杂逻辑上一行注释：将多页的 items 扁平合并，便于组件直接渲染
  const flatItems = computed(
    () => q.data.value?.pages.flatMap((p) => p.items) ?? []
  );

  return { ...q, flatItems };
}
```

### 2) 组件示例（IntersectionObserver 自动触底加载）：`InfiniteList.vue`

```vue
<!-- src/views/InfiniteList.vue -->
<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from "vue";
import { useInfiniteItems } from "@/features/demo/useInfiniteItems";

const { flatItems, isFetchingNextPage, hasNextPage, fetchNextPage, error } =
  useInfiniteItems(15);

const sentinel = ref<HTMLDivElement | null>(null);
let observer: IntersectionObserver | null = null;

onMounted(() => {
  // 复杂逻辑上一行注释：使用 IntersectionObserver 观察“页尾哨兵”，进入视口即加载下一页
  observer = new IntersectionObserver(
    (entries) => {
      const e = entries[0];
      if (e.isIntersecting && hasNextPage.value && !isFetchingNextPage.value) {
        fetchNextPage();
      }
    },
    { root: null, rootMargin: "0px", threshold: 0.1 }
  );

  if (sentinel.value) observer.observe(sentinel.value);
});

onBeforeUnmount(() => {
  if (observer && sentinel.value) observer.unobserve(sentinel.value);
  observer = null;
});
</script>

<template>
  <div class="p-4 space-y-3">
    <div v-if="error" class="text-red-600">
      出错：{{ (error as any)?.message }}
    </div>

    <ul class="space-y-2">
      <li v-for="it in flatItems" :key="it.id" class="border rounded p-2">
        {{ it.title }}
      </li>
    </ul>

    <!-- 复杂逻辑上一行注释：页尾“哨兵”元素，用于触发下一页加载 -->
    <div
      ref="sentinel"
      class="h-8 flex items-center justify-center text-gray-500"
    >
      <span v-if="isFetchingNextPage">加载更多...</span>
      <span v-else-if="!hasNextPage">没有更多了</span>
      <span v-else>下拉加载</span>
    </div>

    <!-- 兜底：手动加载更多按钮（可选） -->
    <div class="text-center">
      <button
        class="mt-2 border px-3 py-1 rounded"
        :disabled="!hasNextPage || isFetchingNextPage"
        @click="fetchNextPage()"
      >
        {{
          isFetchingNextPage
            ? "加载中…"
            : hasNextPage
            ? "加载更多"
            : "没有更多了"
        }}
      </button>
    </div>
  </div>
</template>
```

---

## 关键点与小贴士

- **keepPreviousData**：页码分页时避免闪屏；无限滚动用 `useInfiniteQuery` 不需要它。
- **queryKey 设计**：把影响结果的入参（如 `page/pageSize`、`limit/filters`）放进 key，缓存才可命中。
- **getNextPageParam**：返回 `undefined` 代表“没有下一页”；返回游标字符串（或对象）将作为下一次 `pageParam` 传入。
- **触底加载**：`IntersectionObserver` 比 `scroll` 事件更稳、成本更低；确保有合理的 `rootMargin/threshold`。
- **错误重试**：默认会自动重试 2 次（取决于你的全局设置）。对幂等读接口通常是安全的。

需要我把这两个 Demo 接到你现有的某个真实接口（比如你“价格趋势”或“攻略列表”）上，我可以直接给**最小改动的代码片段**。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vue项目pinia中的Store中的请求时机管理]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/Vue/Vue项目请求处理优化</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/Vue/Vue项目请求处理优化</guid>
            <pubDate>Fri, 05 Sep 2025 18:07:15 GMT</pubDate>
            <content:encoded><![CDATA[
现在的我的 vue+vite+pinia 项目有个问题，我的有些请求，我在 store 中就直接调用，但 store 的执行时机很早，这时用户可能没有登录，发出这些需要 token 的请求是不合适的，但如果我们把请求放到具体页面中，那每个页面都要请求，违背了我们放入 store 中的初衷，如何处理？

**核心结论**：

> **把“请求放在 Store”与“何时触发请求”解耦**。
> 数据仍由 Pinia Store 管，但所有“首次加载/刷新”的触发统一由**受保护布局(ProtectedLayout)**或**集中启动钩子**在“已登录且当前路由需要鉴权”时一次性触发。
> 请求层（Axios 封装）负责：自动带 Token、401 统一刷新/重试、（可选）对标记 `auth` 的请求在无 Token 时直接拒绝。

## 路由：只给受保护页面打上 `requiresAuth`

**修改位置：`src/router/index.ts`**

```ts
// 在需要登录的路由上增加 meta.requiresAuth
{
  path: '/dashboard',
  name: 'dashboard',
  component: () => import('@/pages/dashboard/index.vue'),
  meta: { requiresAuth: true }
}
```

## 受保护布局：只在“已登录 && 受保护路由”时触发各 Store 的初始化

**新增文件：`src/composables/useAppBootstrap.ts`**

```ts
import { watch } from "vue";
import { useRouter } from "vue-router";
import { useAuthStore } from "@/stores/auth";
import { useUserStore } from "@/stores/user";
import { useXStore } from "@/stores/x"; // 你的其他数据模块按需引入

export function useAppBootstrap() {
  const router = useRouter();
  const auth = useAuthStore();
  const user = useUserStore();
  const x = useXStore();

  // 复杂逻辑：仅在“已登录 && 当前路由需要鉴权”时做一次性初始化（可幂等）
  watch(
    [
      () => auth.isAuthenticated,
      () => router.currentRoute.value.meta.requiresAuth,
    ],
    async ([ok, need]) => {
      if (ok && need) {
        // 复杂逻辑：各 store 的 init() 必须“幂等”，重复调用不重复发请求
        await Promise.all([user.init(), x.init()]);
      }
    },
    { immediate: true }
  );
}
```

**在你的受保护布局/根布局里调用（例如 `src/layouts/ProtectedLayout.vue`）**：

```ts
// <script setup>
// 复杂逻辑：在受保护布局挂载时调用集中引导
import { useAppBootstrap } from "@/composables/useAppBootstrap";
useAppBootstrap();
// </script>
```

> 如果你没有单独的布局文件，可以在 `App.vue` 里根据 `route.meta.requiresAuth` 切出一个“受保护区域”再调用 `useAppBootstrap()`。

---

## Store：移除“定义即请求”的副作用，提供幂等 `init()`

**修改位置：`src/stores/user.ts`（示例）**

```ts
// 删除：顶层的立即请求（例如 defineStore 里一创建就 fetch 的代码）

// 新增：幂等 init()
let _initPromise: Promise<void> | null = null;

export const useUserStore = defineStore("user", () => {
  const profile = ref<User | null>(null);

  // 复杂逻辑：单例 Promise，保证多处调用只触发一次真实请求
  async function init() {
    if (_initPromise) return _initPromise;
    _initPromise = (async () => {
      if (profile.value) return;
      const { data } = await http.get("/me", { meta: { auth: true } });
      profile.value = data;
    })();
    return _initPromise;
  }

  // 可选：在登出时清理，便于下次重新 init
  function reset() {
    profile.value = null;
    _initPromise = null;
  }

  return { profile, init, reset };
});
```

> 你的其他 Store（如 `x.ts`、`projects.ts` 等）都按这个\*\*“删除副作用 + 提供幂等 init()”\*\*的模式改一遍。

---

## 请求层：自动带 Token、401 统一刷新并队列重试、无 Token 阻断受保护请求

**修改位置：`src/http/axios.ts`（或你的请求封装文件）**

**（1）扩展 Axios 类型，支持 `meta.auth` 与 `_retry`**

```ts
// 复杂逻辑：为请求增加自定义元信息与重试标记
declare module "axios" {
  export interface AxiosRequestConfig {
    meta?: { auth?: boolean };
    _retry?: boolean;
  }
}
```

**（2）请求拦截：自动加 Authorization；无 Token 且需要鉴权时直接拒绝**

```ts
import axios from "axios";
import { useAuthStore } from "@/stores/auth";
import router from "@/router";

export const http = axios.create({ baseURL: import.meta.env.VITE_API_BASE });

http.interceptors.request.use((config) => {
  const auth = useAuthStore();

  // 复杂逻辑：仅对标记了 meta.auth 的请求自动带 token
  if (config.meta?.auth) {
    if (!auth.token) {
      // 复杂逻辑：阻断未登录时的鉴权请求（避免在 /user/login 等页面误发）
      return Promise.reject(new Error("AUTH_REQUIRED"));
    }
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${auth.token}`,
    };
  }
  return config;
});
```

**（3）响应拦截：统一处理 401，带刷新队列（避免并发多次刷新）**

```ts
let refreshing = false;
let waitQueue: Array<() => void> = [];

http.interceptors.response.use(
  (r) => r,
  async (error) => {
    const auth = useAuthStore();
    const { response, config } = error || {};
    if (response?.status === 401 && config && !config._retry) {
      // 复杂逻辑：给当前请求打 _retry，防止递归
      config._retry = true;

      if (!refreshing) {
        refreshing = true;
        try {
          await auth.refreshToken(); // 你在 auth store 中实现这个方法
          refreshing = false;
          // 复杂逻辑：刷新成功后，放行所有队列中的请求
          waitQueue.splice(0).forEach((fn) => fn());
          return http(config);
        } catch (e) {
          refreshing = false;
          // 复杂逻辑：刷新失败，清空队列并跳转登录
          waitQueue.splice(0).forEach((fn) => fn());
          auth.logout();
          router.replace({
            name: "login",
            query: { redirect: router.currentRoute.value.fullPath },
          });
          return Promise.reject(e);
        }
      }

      // 复杂逻辑：如果正在刷新，把当前请求加入队列，等待刷新完成后重试
      return new Promise((resolve, reject) => {
        waitQueue.push(() => http(config).then(resolve).catch(reject));
      });
    }
    return Promise.reject(error);
  }
);
```

---

## Auth Store：提供 `isAuthenticated`、`refreshToken()`、`logout()`

**修改位置：`src/stores/auth.ts`**

```ts
export const useAuthStore = defineStore("auth", () => {
  const token = ref<string | null>(null);
  const refresh = ref<string | null>(null);

  // 复杂逻辑：派生登录态，集中判断是否有有效 token
  const isAuthenticated = computed(() => !!token.value);

  async function setToken(t: string, r?: string) {
    token.value = t;
    if (r) refresh.value = r;
  }

  async function refreshToken() {
    // 复杂逻辑：用 refresh_token 换新 token，失败则抛错
    const { data } = await axios.post("/auth/refresh", {
      refresh_token: refresh.value,
    });
    token.value = data.access_token;
    refresh.value = data.refresh_token ?? refresh.value;
  }

  function logout() {
    token.value = null;
    refresh.value = null;
    // 复杂逻辑：通知其他 store 清空并重置 init()
    useUserStore().reset();
    // 其他 store 同理按需 reset()
  }

  return { token, isAuthenticated, setToken, refreshToken, logout };
});
```

---

## 登录成功后：只需设置 token 并跳转，初始化会自动发生

**修改位置：`/user/login` 提交成功回调处**

```ts
// 复杂逻辑：写入 token 并跳到受保护路由；受保护布局会自动触发所有 store.init()
await authStore.setToken(res.access_token, res.refresh_token);
router.replace((route.query.redirect as string) || "/");
```

---

## 为什么这是“最佳做法”

1. **单一职责清晰**：Store 只做“状态与方法”，不在定义期发请求；“什么时候发”交给受保护布局的引导钩子统一触发。
2. **避免重复请求**：`init()` 使用**单例 Promise**，多次调用只会发一次请求。
3. **页面无侵入**：页面无需关心是否登录、是否首发，页面只消费 Store 的 state。
4. **错误集中处理**：401 统一刷新与队列重试，避免因并发导致多次刷新或脏状态。
5. **登录页零干扰**：登录页不再误发需要 Token 的请求；即使误调，Axios 层也会拦截并拒绝。
6. **易扩展**：新增数据域时，只需在受保护引导中 `store.init()` 一行接入。

---

如果你愿意，我可以基于你当前的目录结构，把上述“幂等 init + 受保护布局引导 + Axios 刷新队列”的改动**逐个落到你的具体文件**（只贴需要改的片段）。你把相关文件名和关键片段贴给我就行。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vite + Vue3 打包后如何查看“体积分布分析图”]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/Vue/体积分布分析图</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/Vue/体积分布分析图</guid>
            <pubDate>Sat, 06 Sep 2025 16:59:20 GMT</pubDate>
            <content:encoded><![CDATA[
## 总览

想在 **Vite + Vue3** 打包后看到类似 Webpack Bundle Analyzer 的交互式“依赖体积分布图”，最简单稳妥的方法是接入 `rollup-plugin-visualizer`。本文给出**最小改动**方案：按需启用分析模式、构建、自动打开 `stats.html`。

---

## 实现思路

- 使用 Rollup 可视化插件（Vite 打包底层是 Rollup）。
- 仅在“分析模式”挂载插件，避免影响日常构建速度。
- 构建完成自动生成并打开 `stats.html`（Treemap/Sunburst 可选）。
- 可选：开启 `sourcemap` 便于二次分析。

---

## 分步操作

### 1）安装依赖

```bash
# 任选包管理器
pnpm add -D rollup-plugin-visualizer
# 或
npm i -D rollup-plugin-visualizer
# 或
yarn add -D rollup-plugin-visualizer
```

### 2）修改 `vite.config.ts`（只给需要改的片段）

> 说明：以下片段为**增量修改**，请在你的 `vite.config.ts` 里按位置插入即可。

```ts
// ① 顶部新增一行：导入可视化插件
import { visualizer } from "rollup-plugin-visualizer";
```

```ts
// ② 在 defineConfig 回调里按需启用（若你当前不是回调形式，可改为回调：defineConfig(({ mode }) => ({ ... }))）
const enableAnalyze = process.env.ANALYZE === "true" || mode === "analyze";

// 复杂逻辑：仅在分析模式下挂载插件，避免常规构建受影响
enableAnalyze &&
  plugins.push(
    visualizer({
      // 复杂逻辑：输出 treemap 到项目根目录，并在构建结束自动打开
      filename: "stats.html",
      template: "treemap", // 可选：'treemap' | 'sunburst' | 'network'
      open: true,
      gzipSize: true,
      brotliSize: true,
    })
  );
```

```ts
// ③（可选）为了配合二次分析或排查问题，开启源码映射
build: {
  // 复杂逻辑：仅在分析模式下开启 sourcemap（若你已有 build 配置，请合并到其中）
  sourcemap: enableAnalyze;
}
```

> 小贴士：若你的 `plugins` 是直接字面量数组，改成先声明 `const plugins = [vue(/*...*/)]` 再 `.push(...)`，最后 `return { plugins }`。不想改结构也行：`plugins: [vue(), enableAnalyze && visualizer({...})].filter(Boolean)`。

### 3）新增构建脚本（二选一）

**方案 A（推荐，跨平台零依赖）：用 `--mode analyze` 触发**

```json
{
  "scripts": {
    "build": "vite build",
    "build:analyze": "vite build --mode analyze"
  }
}
```

**方案 B：用环境变量触发（类 Unix 系统方便）**

```json
{
  "scripts": {
    "build": "vite build",
    // 复杂逻辑：通过环境变量开启分析模式；Windows 可用 cross-env 做兼容
    "build:analyze": "ANALYZE=true vite build"
  }
}
```

---

## 使用方法

```bash
# 触发分析构建（使用你选择的方案）
pnpm run build:analyze

# 构建完成后会自动打开 stats.html
# 若未自动打开，可手动在项目根目录双击/用浏览器打开 stats.html
```

---

## 进阶玩法（可选）

### A. 自定义输出位置/图表类型

```ts
// 复杂逻辑：将报告输出到 dist 目录下并改为 sunburst 风格
visualizer({
  filename: "dist/bundle-report.html",
  template: "sunburst",
  open: true,
});
```

### B. 快速“拆包”以便观察效果

> 仅示例，按你实际依赖调整：

```ts
// 复杂逻辑：演示常见手动分包，便于在图里更清晰地区分
build: {
  rollupOptions: {
    output: {
      manualChunks: {
        vue: ['vue', 'vue-router', 'pinia'],
        // 如果你用到 Ant Design Vue / ECharts / AntV 等，可分别拆
        // antdv: ['ant-design-vue'],
        // echarts: ['echarts'],
        // antv: ['@antv/g2', '@antv/g2plot'],
      }
    }
  }
}
```

### C. 二次分析（Source Map）

```bash
# 可选：安装 source-map-explorer 做“按文件”体积分析
pnpm add -D source-map-explorer
# 构建（确保 sourcemap 已开启）
pnpm run build:analyze
# 生成 HTML 报告（路径按你的 dist 实际文件调整）
npx source-map-explorer "dist/assets/*.js" --html dist/sme.html
```

---

## 常见问题

- **stats.html 是空白/打不开？**
  多半是构建被缓存或浏览器拦截了本地文件。先清理 `dist` 再构建；或换个浏览器打开，必要时关闭浏览器的本地文件限制。

- **报告没自动打开？**
  CI/无头环境不会自动打开。把 `open: false`，直接到输出目录找报告 HTML 即可。

- **Windows 下 `ANALYZE=true` 不生效？**
  用方案 A（`--mode analyze`），或安装 `cross-env`：
  `cross-env ANALYZE=true vite build`。

- **体积异常大但定位不到模块？**
  开启 `sourcemap` 后再看 `stats.html`；若仍不清晰，配合 `source-map-explorer` 交叉验证。

---

## 小结

- 装一个 `rollup-plugin-visualizer`，按需启用分析模式，构建即得可交互分析图。
- 报告默认 `stats.html`，Treemap/Sunburst 随选。
- 需要更深入排查时，打开 `sourcemap` + `source-map-explorer` 双管齐下。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[动态表单「已勾选仍提示必填」的两处修复]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/Vue/动态表单「已勾选仍提示必填」的两处修复</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/Vue/动态表单「已勾选仍提示必填」的两处修复</guid>
            <pubDate>Fri, 05 Sep 2025 16:22:47 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: 动态表单「已勾选仍提示必填」的两处修复
date: 2025-09-05
tags: \[Vue3, Ant Design Vue, 表单校验, 组件封装]

---

## 问题概述

复选框（`a-checkbox-group`）在 **必填** 时，即使勾选了第一项仍提示“请选择”。根因有两点：

1. 你的 `Checkbox` 包装组件把 `v-model:value` **定义成了 boolean**（默认 `false`），而 `a-checkbox-group` 需要 **数组**；
2. 通用的 `required: true` 规则对 **数组长度** 不做判断，需要为复选框补一条“至少选一项”的自定义校验。

下面给出**最小修改**代码片段（仅展示需要调整的部分）。

> 说明：按你的偏好，复杂逻辑的代码段我在**上一行加了注释**。

---

## 修改 1：`Checkbox` 组件把模型改为数组

把 `defineModel<boolean>` 改为 **`defineModel<any[]>`**，默认值设为 `[]`，并确保内部状态是数组。

```ts
// 复杂：CheckboxGroup 期望数组类型；默认值必须为 []，否则 antd 校验无法判定“是否已选择”
const model = defineModel<any[]>("value", { default: [] });
const innerValue = ref<any[]>(Array.isArray(model.value) ? model.value : []);

watch(model, (v) => (innerValue.value = Array.isArray(v) ? v : []));
watch(innerValue, (v) => (model.value = Array.isArray(v) ? v : []));
```

---

## 修改 2：为复选框补充“至少选一项”的校验规则

在 `getValidationRules` 中，为 `controlType === 'checkbox'` 增加自定义校验（**在你现有的特殊控件分支里添加一段即可**）。

```ts
// 复杂：CheckboxGroup 的必填校验——至少选择 1 项
} else if (field.controlType === 'checkbox') {
  rules.push({
    validator: async (_: any, v: any[]) => {
      const ok = Array.isArray(v) && v.length > 0
      if (!ok && field.required)
        return Promise.reject(t('files.form.rule.required', { label: field.label }))
      return Promise.resolve()
    },
    trigger: ['change', 'blur'],
  })
```

> 放置位置建议：就放在你现有的 `/* 特殊控件校验 */` 分支里，和 `stockholder / image / file` 同级。

---

## 可选增强：初始化把错误类型矫正为数组

若后端历史数据里该字段可能是 `false/null/''/单值`，可以在你已有的 `watch(_fields, ...)` 预处理里顺手矫正为数组，避免初始值导致“已选中但校验失败”。

```ts
// 复杂：把历史/异常初始值统一矫正为 CheckboxGroup 需要的数组
} else if (f.controlType === 'checkbox') {
  const v = formData[f.name]
  if (!Array.isArray(v)) formData[f.name] = v == null || v === false ? [] : [v]
}
```

---

## 结论

- **关键修复**在于：复选框的 `v-model` 类型必须是 **数组**；
- **规则层面**补充“至少一项”的自定义校验，避免通用 `required` 漏判。

应用以上两处修改后，勾选第一项即可通过校验，不再提示“请选择”。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一个 downloadFile 就够了：直链与鉴权下载自动切换（Vue/TS）]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）</guid>
            <pubDate>Sat, 06 Sep 2025 15:13:25 GMT</pubDate>
            <content:encoded><![CDATA[
## 需求背景

- 有的文件**公开直链**，直接点就能下；
- 有的需要**携带 Cookie/Token、自定义 Header 或用 POST** 才能拿到二进制流；
- 我们希望**一个函数**即可应对两类场景，并自动选择最优策略。

## 设计要点

- **优先直链（a.click）**：不加 header/body/credentials 时，直接跳转下载；
- **按需请求（fetch→Blob）**：当需要鉴权/自定义 Header/POST，先拿 Blob，再用 Object URL 触发下载；
- **文件名解析**：未显式传 `fileName` 时，尝试从 `Content-Disposition` 读取；
- **内存友好**：使用 Object URL 并及时 `URL.revokeObjectURL`。

## 代码

```ts
export type DownloadOptions = Omit<RequestInit, "signal"> & {
  fileName?: string;
  forceRequest?: boolean;
};

function _pickNameFromContentDisposition(
  cd: string | null
): string | undefined {
  if (!cd) return;
  const star = cd.match(/filename\*=(?:UTF-8'')?([^;]+)/i);
  const norm = cd.match(/filename=([^;]+)/i);
  const raw = (star?.[1] ?? norm?.[1])?.trim().replace(/^["']|["']$/g, "");
  try {
    return raw ? decodeURIComponent(raw) : undefined;
  } catch {
    return raw;
  }
}

export async function downloadFile(url: string, options: DownloadOptions = {}) {
  const { fileName, forceRequest, ...req } = options;
  const needRequest =
    !!forceRequest ||
    (req.method && req.method.toUpperCase() !== "GET") ||
    !!req.headers ||
    !!req.body ||
    !!req.credentials;

  if (!needRequest) {
    const a = document.createElement("a");
    a.href = url;
    if (fileName) a.download = fileName; // 跨域直链可能被忽略
    a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return;
  }

  const res = await fetch(url, req);
  if (!res.ok)
    throw new Error(`Download failed: ${res.status} ${res.statusText}`);

  let name =
    fileName ??
    _pickNameFromContentDisposition(res.headers.get("content-disposition"));
  const blob = await res.blob();
  const href = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.style.display = "none";
  a.href = href;
  if (name) a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(href);
}
```

## 使用示例

### 直链（公开资源）

```ts
await downloadFile("https://cdn.example.com/file.pdf", {
  fileName: "文档.pdf",
});
```

### 携带 Cookie/Token

```ts
await downloadFile("/api/report/export", {
  credentials: "include",
  headers: { Authorization: "Bearer xxx" },
  fileName: "报表.xlsx",
});
```

### POST 导出

```ts
await downloadFile("/api/export", {
  method: "POST",
  headers: { "Content-Type": "application/json", Authorization: "Bearer xxx" },
  body: JSON.stringify({ range: "2025-01-01~2025-09-01" }),
  fileName: "导出.csv",
});
```

## 注意事项

- **跨域直链**时，浏览器可能**忽略 `download` 文件名**，以服务器或默认名为准；
- 如需强制走请求分支，可传 `forceRequest: true`；
- 服务器若返回 `Content-Disposition`，无需传 `fileName` 也能自动命名；
- 大文件下载建议结合服务端分片/断点续传方案（本函数仅负责触发下载）。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[web应用开发/前端/Web 应用如何做到实时消息通知]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知</guid>
            <pubDate>Fri, 05 Sep 2025 14:10:20 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: Web 应用如何做到“实时消息通知”
date: 2025-09-05
categories: \[Web 实时通讯, 架构设计]
tags: \[WebSocket, SSE, Web Push, 长轮询, 消息队列, Redis, 可用性, 安全]
description: 面向前端/全栈开发者，从选型到最小可行代码，教你在 Web 应用中实现稳定的实时消息通知。

---

# 总览

**目标**：在浏览器里第一时间看到来自服务端的新消息（聊天、新订单、系统告警等）。
**常见方案**：

- **WebSocket**：全双工、低延迟、最通用。
- **SSE（Server-Sent Events）**：服务端到客户端的单向推送，轻量、易用。
- **长轮询（Long Polling）**：兼容性最佳的兜底方案。
- **Web Push（Service Worker）**：浏览器级推送，页面不在前台也能收到（需用户同意）。

**快速选型**（简表）：

| 需求/约束                | 推荐                         |
| ------------------------ | ---------------------------- |
| 双向通信（聊天/协作）    | **WebSocket**                |
| 只下行推送、需超轻量     | **SSE**                      |
| 公司网络/代理限制 WS     | **SSE 或 长轮询**            |
| 需离线/后台通知          | **Web Push**                 |
| 海量连接、水平扩展       | **WS + Redis Pub/Sub 或 MQ** |
| 服务端易实现、兼容老后端 | **长轮询**                   |

---

# 实现思路（一图流）

1. **连接层**：浏览器（WS/SSE/HTTP） ↔ 反向代理（Nginx/Ingress） ↔ **推送网关服务**
2. **消息路由层**：**Redis Pub/Sub / Kafka / RabbitMQ** 做 fan-out 与广播
3. **业务层**：订单/聊天/告警服务把事件写入 **消息总线**
4. **状态与可靠性**：在线用户表、订阅关系、**Ack/重试/幂等**、**断线重连**、**心跳**、**权限校验**

---

# 分步实践

## 方案一：WebSocket（最通用）

### 最小可行后端（Node.js + `ws`）

```js
// 复杂逻辑：保存连接、鉴权、心跳、按用户分组转发
import { WebSocketServer } from "ws";
import jwt from "jsonwebtoken";

const wss = new WebSocketServer({ port: 8080 });
const clients = new Map(); // userId -> Set<ws>

wss.on("connection", (ws, req) => {
  // 复杂逻辑：从 ?token= 解析并校验用户身份
  const token = new URL(req.url, "http://x").searchParams.get("token");
  let userId = null;
  try {
    userId = jwt.verify(token, process.env.JWT_SECRET).sub;
  } catch {
    ws.close();
    return;
  }

  if (!clients.has(userId)) clients.set(userId, new Set());
  clients.get(userId).add(ws);

  // 复杂逻辑：心跳保活，清理僵尸连接
  ws.isAlive = true;
  ws.on("pong", () => (ws.isAlive = true));

  ws.on("message", (buf) => {
    // 这里可处理客户端上行，如已读回执/输入中状态
  });

  ws.on("close", () => {
    clients.get(userId).delete(ws);
    if (clients.get(userId).size === 0) clients.delete(userId);
  });
});

// 复杂逻辑：定时 ping
setInterval(() => {
  wss.clients.forEach((ws) => {
    if (!ws.isAlive) return ws.terminate();
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// 示例：向某用户推送
export function pushToUser(userId, payload) {
  const set = clients.get(userId);
  if (!set) return;
  const msg = JSON.stringify(payload);
  set.forEach((ws) => ws.readyState === ws.OPEN && ws.send(msg));
}
```

### 前端最小连接封装（浏览器）

```js
// 复杂逻辑：自动重连、指数退避、前台/后台状态感知
export function createWsClient(urlWithToken, onMsg) {
  let ws,
    retry = 0,
    timer;

  const connect = () => {
    ws = new WebSocket(urlWithToken);
    ws.onopen = () => {
      retry = 0;
    };
    ws.onmessage = (e) => onMsg(JSON.parse(e.data));
    ws.onclose = () => scheduleReconnect();
    ws.onerror = () => ws.close();
  };

  const scheduleReconnect = () => {
    clearTimeout(timer);
    const delay = Math.min(30000, 1000 * 2 ** retry++);
    timer = setTimeout(connect, delay);
  };

  // 复杂逻辑：页面隐藏时减小重连频率
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && ws?.readyState !== WebSocket.OPEN) {
      retry = Math.max(retry, 4); // 慢一些
    }
  });

  connect();
  return () => {
    clearTimeout(timer);
    ws?.close();
  };
}
```

### Nginx 反代（启用 WS 协议升级）

```nginx
# 复杂逻辑：确保 upgrade 头转发
location /ws/ {
  proxy_pass http://realtime:8080;
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 60s;
}
```

---

## 方案二：SSE（Server-Sent Events，轻量下行推送）

### 后端（Node.js + Express）

```js
// 复杂逻辑：SSE 连接池、心跳注释行、按用户推送
import express from "express";
import jwt from "jsonwebtoken";

const app = express();
const streams = new Map(); // userId -> res

app.get("/sse", (req, res) => {
  const token = req.query.token;
  let userId;
  try {
    userId = jwt.verify(token, process.env.JWT_SECRET).sub;
  } catch {
    return res.sendStatus(401);
  }

  res.set({
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
  });
  res.flushHeaders();
  streams.set(userId, res);

  // 复杂逻辑：心跳，防止中间设备断开
  const hb = setInterval(() => res.write(":hb\n\n"), 25000);

  req.on("close", () => {
    clearInterval(hb);
    streams.delete(userId);
  });
});

export function ssePush(userId, data) {
  const res = streams.get(userId);
  if (!res) return;
  res.write(`data: ${JSON.stringify(data)}\n\n`);
}

app.listen(8081);
```

### 前端

```js
// 复杂逻辑：SSE 自动重连由浏览器原生完成
const ev = new EventSource(`/sse?token=${encodeURIComponent(token)}`);
ev.onmessage = (e) => {
  const payload = JSON.parse(e.data);
  // 渲染消息
};
```

**何时用 SSE**：仅需服务端 → 浏览器推送（如系统广播、价格/进度更新），无需上行交互；在某些企业代理/防火墙下比 WS 更稳定。

---

## 方案三：长轮询（兼容兜底）

### 后端（Koa/Express 任意）

```js
// 复杂逻辑：如果没有新消息就挂起请求，直到有消息或超时
const waiters = new Map(); // userId -> res[]

app.get("/poll", (req, res) => {
  const userId = auth(req); // 自行实现鉴权
  (waiters.get(userId) ?? waiters.set(userId, []).get(userId)).push(res);
  req.setTimeout(65000); // 与前端超时一致
  req.on("close", () => cleanup(userId, res));
});

function notify(userId, payload) {
  const list = waiters.get(userId) || [];
  for (const res of list) res.json(payload);
  waiters.set(userId, []);
}
```

### 前端

```js
// 复杂逻辑：递归调用保持“长连接”效果
async function longPoll() {
  try {
    const r = await fetch("/poll", { credentials: "include" });
    if (r.ok) {
      const data = await r.json();
      // 处理消息
    }
  } catch (_) {
    /* 忽略网络错误 */
  } finally {
    setTimeout(longPoll, 100);
  } // 轻微间隔
}
longPoll();
```

---

## 方案四：Web Push（离线/后台通知）

> 适合 **提醒类** 场景：即便用户没打开页面、浏览器在后台，仍可收到通知（需 HTTPS 与用户授权）。

### 前端注册 Service Worker

```js
// 复杂逻辑：注册 SW 并申请通知权限，然后向后端上报订阅
const reg = await navigator.serviceWorker.register("/sw.js");
const permission = await Notification.requestPermission();
if (permission === "granted") {
  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: "<VAPID_PUBLIC_KEY_BASE64URL>",
  });
  await fetch("/push/subscribe", { method: "POST", body: JSON.stringify(sub) });
}
```

### Service Worker 接收

```js
// 复杂逻辑：展示系统级通知
self.addEventListener("push", (e) => {
  const data = e.data?.json() ?? {};
  e.waitUntil(
    self.registration.showNotification(data.title || "通知", {
      body: data.body,
    })
  );
});
```

### 后端发送（Node.js + web-push）

```js
// 复杂逻辑：使用 VAPID 签名向浏览器推送
import webpush from "web-push";
webpush.setVapidDetails(
  "mailto:admin@example.com",
  VAPID_PUBLIC,
  VAPID_PRIVATE
);

// subs 为持久化的订阅列表
export async function sendPush(sub, payload) {
  await webpush.sendNotification(sub, JSON.stringify(payload));
}
```

---

# 可扩展与高可用

- **水平扩展**：WS/SSE 多实例时，用 **Redis Pub/Sub** 或 **消息队列（Kafka/RabbitMQ）** 做广播/定向投递。
- **在线表/路由**：`userId -> connectionIds`（内存 + Redis）。
- **可靠性**：业务消息落库 → 推送 → 客户端 **Ack** → 未 Ack 重试；**消息去重键** 防止重复渲染。
- **断线重连**：客户端带 **上次 offset/lastId** 续传（SSE 原生有 `Last-Event-ID`）。
- **背压控制**：批量合并（coalesce）、节流；超大消息用链接拉取。
- **监控告警**：连接数、发送量、队列堆积、投递耗时、重试率、失败率。

---

# 安全与合规

- **鉴权**：连接时附带 **短期 JWT**，服务端校验与续期；不同通道（WS/SSE/HTTP）统一鉴权层。
- **权限**：服务端二次校验资源访问（不要把 topic 名称当权限）。
- **限流**：IP / 用户 / 通道维度限速；异常断开与重连风暴保护。
- **加密**：HTTPS/WSS；敏感字段服务端脱敏。
- **审计**：关键通知落库，包含投递结果与阅读状态。

---

# 最简“端到端”范例清单

> 你可以基于此快速拼装生产可用的实时通知：

1. **连接层**：WebSocket（上面 Node + `ws` 代码）
2. **消息总线**：Redis（`PUBLISH notifications:user:123 {...}`）
3. **业务写入**：订单服务下单成功 → 发布事件
4. **推送网关**：订阅 Redis 通道 → `pushToUser(userId, payload)`
5. **前端**：`createWsClient` 接收 → 写入本地状态/弹出提醒
6. **兜底**：前端检测 WS 不可用则回退 SSE/长轮询
7. **离线补充**：允许用户开启 Web Push 作后台提醒

---

# 常见坑与排错

- **公司代理挡 WS**：优先尝试 **SSE**；Nginx/Ingress 需正确配置 `Upgrade/Connection`。
- **连接泄漏**：记得 **清理 close** 事件、设置 **心跳**。
- **消息乱序/重复**：加入 **自增 offset / 事件时间戳 / 幂等键**。
- **大房间广播**：用 **频道广播 + 客户端过滤** 或 **服务端分片广播**。
- **移动网络切换**：重连后用 **lastId** 请求增量补齐。

---

# 结语

- **单点小流量**：直接 **SSE 或 WS** 即可。
- **中大型/海量**：**WS + Redis/MQ**，加上 **Ack/重试/幂等/监控**。
- **提醒类**：配上 **Web Push**，覆盖离线/后台。

需要我结合你现有技术栈（如 Next.js、Spring Boot、NestJS、Redis、Kafka）给出**最小改造的落地方案**和**只改动的代码片段**吗？我可以按你的项目结构直接贴可替换的文件/增量修改。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[/user 会不会匹配根路由 ‘/’？]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/路由/user-会不会匹配根路由-‘-’？</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/路由/user-会不会匹配根路由-‘-’？</guid>
            <pubDate>Fri, 05 Sep 2025 19:00:06 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: “/user 会不会匹配根路由 ‘/’？”
date: 2025-09-05
tags: \[Vue Router 4, 路由匹配, 懒加载]

---

## 结论

不会。`/user` **不会**匹配到你定义的根路由 `{ path: '/' }`。它只会匹配到**自己**这条顶层路由 `{ path: '/user' }`，因此也**不会**渲染 `@/views/(public)/layout.vue`。

## 为什么

- Vue Router 使用基于 `path-to-regexp` 的**精确匹配**。`'/'` 不是“前缀匹配一切”，只匹配根路径本身，或作为**父路由**被命中的**相对子路由**所包含。
- 你现在把 `/user` 定义为**顶层**路由（不在 `children` 里），所以跳转到 `/user` 时，`to.matched` 里只有 `/user` 这一条记录，不会包含 `'/'` 那个布局。

## 什么时候会经过 `'/'` 布局？

只有当你把 **子路由写成相对路径** 时，例如：

```ts
// 复杂逻辑：相对子路由会被拼成 /user，且会渲染父布局
{
  path: '/',
  component: () => import('@/views/(public)/layout.vue'),
  children: [
    { path: 'user', component: () => import('@/views/user/page.vue') } // 注意没有前导斜杠
  ]
}
```

上面这种写法才会让 `/user` 经过 `layout.vue`。而你当前是：

```ts
{ path: '/user', component: () => import('@/views/user/page.vue') } // 顶层、绝对路径
```

两者行为不同。

## 快速自检（可在控制台验证）

```ts
// 复杂逻辑：查看匹配链，确认是否包含根布局
console.log(router.resolve("/user").matched.map((r) => r.path));
// 期望：['/user']，而不是 ['/', '/user']
```
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Axios 封装优化（登出后“仍有请求”与 401 统一处理）]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/鉴权-登录/仍有请求与401统一处理）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/鉴权-登录/仍有请求与401统一处理）</guid>
            <pubDate>Fri, 05 Sep 2025 20:15:05 GMT</pubDate>
            <content:encoded><![CDATA[
> 只给**需要改的代码片段**；复杂逻辑我都在上一行加了**中文注释**。以下改动基于你贴的这份 `http` 封装。

## 1) 请求可“集中取消”& 退出后不再飞行

**位置：请求拦截器内（`_axios.interceptors.request.use`）头部插入**

```ts
// 复杂逻辑：为每个请求创建可集中取消的 AbortController，并桥接外部 signal
const ac = new AbortController();
if (req.signal) {
  const ext = req.signal as AbortSignal;
  if (ext.aborted) ac.abort();
  else ext.addEventListener?.("abort", () => ac.abort());
}
req.signal = ac.signal;
abortPool.add(ac);
// 复杂逻辑：把本次请求的 controller 暂存到 config 上，方便响应阶段释放
(req as any).__ac = ac;
```

**位置：响应成功拦截器（`res` 分支）里，`return res` 之前插入**

```ts
// 复杂逻辑：请求完成后，从取消池中释放 controller
const ac = (res.config as any).__ac as AbortController | undefined;
if (ac) abortPool.delete(ac);
```

**位置：响应失败拦截器（`err` 分支）里，`return Promise.reject(err)` 之前插入**

```ts
// 复杂逻辑：请求失败同样释放 controller，避免池子泄漏
const ac = (err?.config as any)?.__ac as AbortController | undefined;
if (ac) abortPool.delete(ac);
```

> 这样就和你现有的 `cancelAll()` 打通了：登出时执行 `cancelAll()`，所有在途请求立刻中止。

---

## 2) “未登录硬拦”鉴权请求（默认需要鉴权）

**位置：请求拦截器内，给你现有的加 Token 逻辑**改为如下\*\*

```ts
// 复杂逻辑：统一鉴权开关——默认需要鉴权，白名单或显式 { auth:false } 不需要
const needAuth =
  (req as any).auth !== false && !noAuthPaths.includes(req.url || "");

// 复杂逻辑：无 Token 且需要鉴权时，直接阻断请求，避免未登录拉数据
const at = storage.get(ACCESS_TOKEN);
const tt = storage.get(TOKEN_TYPE) || "Bearer";
if (needAuth && !at) {
  // 同时中止本次请求，确保不会真正发出
  ((req as any).__ac as AbortController | undefined)?.abort();
  return Promise.reject(new Error("UNAUTHENTICATED"));
}

// 复杂逻辑：有 Token 再注入 Authorization 头
if (needAuth && at) {
  req.headers = { ...req.headers, Authorization: `${tt} ${at}` };
}
```

> 使用方式：需要鉴权的 API **不用写任何额外配置**（默认会拦），公开 API（或登录/注册）**明确**加上 `{ auth: false }` 即可。

---

## 3) 统一 401 处理（去掉 `useRouter` 的非法使用）

**位置：你的 `codeResponseParser` 内，将 401 分支替换为：**

```ts
// 复杂逻辑：统一未授权处理（不在解析器里用 useRouter）
if (code === 401) {
  storage.remove(ACCESS_TOKEN);
  storage.remove(TOKEN_TYPE);
  // 复杂逻辑：避免组合式 API 环境限制，使用硬跳转到登录页
  if (window.location.pathname !== LOGIN_ROUTE.path) {
    window.location.replace(LOGIN_ROUTE.path);
  }
  throw new Error("未授权，请重新登录");
}
```

**位置：响应失败拦截器（`err` 分支）里，加入 HTTP 401 fallback**

```ts
// 复杂逻辑：后端直接返回 HTTP 401 时的兜底处理
if (err?.response?.status === 401) {
  storage.remove(ACCESS_TOKEN);
  storage.remove(TOKEN_TYPE);
  if (window.location.pathname !== LOGIN_ROUTE.path) {
    window.location.replace(LOGIN_ROUTE.path);
  }
}
```

> 说明：`useRouter()` 不能在解析器（组件外）调用，上面用 `window.location.replace` 做了上下文无关的重定向。

---

## 4) 实例方法：供登出调用（清鉴权头 & 集中取消）

**位置：`createAxiosHttp` 末尾、`return _axios as unknown as AxiosInstance` 前插入**

```ts
// 复杂逻辑：向实例挂载工具方法，供外部优雅下线使用
(_axios as any).cancelAll = cancelAll;
(_axios as any).setAuthToken = (token?: string | null, type = "Bearer") => {
  if (token) {
    _axios.defaults.headers.common.Authorization = `${type} ${token}`;
    storage.set(ACCESS_TOKEN, token);
    storage.set(TOKEN_TYPE, type);
  } else {
    delete _axios.defaults.headers.common.Authorization;
    storage.remove(ACCESS_TOKEN);
    storage.remove(TOKEN_TYPE);
  }
};
```

> 这样在 `logout()` 里可以写：`http.cancelAll?.(); http.setAuthToken?.(null)`。

---

## 5) （可选）请求方法支持 `formdata` 与 `auth` 透传

**位置：你重写的 `(_axios as any).request = async function ...` 的**函数签名**与**组装 `cfg`**部分替换为：**

```ts
// 复杂逻辑：扩展 contentType，支持 formdata；透传 { auth?: boolean, signal?: AbortSignal }
(_axios as any).request = async function <T, P = RequestParams>(
  url: string,
  method: Method = "GET",
  params?: P,
  reqCfg?: AxiosRequestConfig & { auth?: boolean; signal?: AbortSignal },
  contentType: "json" | "urlencoded" | "formdata" = "json"
): Promise<T> {
  const cfg: AxiosRequestConfig & { auth?: boolean } = {
    url,
    method,
    ...reqCfg,
    headers: { ...reqCfg?.headers },
  };

  if (method === "GET" || method === "HEAD") {
    cfg.params = params;
    cfg.paramsSerializer = (d) =>
      qs.stringify(d, { indices: false, skipNulls: true });
  } else {
    // 复杂逻辑：根据 contentType 选择编码方式
    if (contentType === "formdata") cfg.data = toFormData(params as any);
    else if (contentType === "urlencoded")
      cfg.data = toUrlencoded(params ?? ({} as any));
    else cfg.data = params;

    if (contentType === "urlencoded")
      cfg.headers = {
        ...cfg.headers,
        "Content-Type": "application/x-www-form-urlencoded",
      };
    if (contentType === "json")
      cfg.headers = { ...cfg.headers, "Content-Type": "application/json" };
    // formdata 让浏览器自动带 boundary，不手动设 Content-Type
  }

  return nativeRequest(cfg) as Promise<T>;
};
```

> 有了 `{ auth?: boolean }`，你在公开接口（如 `/api/pub/get_feednews`）调用时可以：

```ts
http.request("/api/pub/get_feednews", "GET", undefined, { auth: false });
```

---

## 6) （配合改动）登出时的两行调用（在你的 `authStore.logout()` 里加）

```ts
// 复杂逻辑：登出时立即中止所有在途请求 + 清鉴权头
http.cancelAll?.();
http.setAuthToken?.(null);
```

---

## 7) （可选）类型补充，便于在项目里显式写 `auth`

**新建：`types/axios.d.ts`**

```ts
// 复杂逻辑：为 AxiosRequestConfig 增加自定义字段 auth
import "axios";
declare module "axios" {
  interface AxiosRequestConfig {
    auth?: boolean;
  }
}
```

---

### 验证 Checklist

- 退出登录瞬间 Network 面板**无新的业务请求**（只有静态资源预取不算）。
- 任何标记 `{ auth: true | 默认 }` 的请求在**无 Token**时不会发出。
- 后端返回 **HTTP 401** 或 **业务码 401**，都能统一清理并跳到登录页。
- `cancelAll()` 能把“已发起未完成”的请求**立即中断**。

以上改完，你截图里“跳转后还发请求”的现象就会消失；即使有极短时序触发，也会被 **AbortController** 和 **未登录硬拦**兜住。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[在 composable 里“公共初始化 + 登录后初始化”的双阶段启动（增量修改）]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/鉴权-登录/登录后初始化的双阶段启动（增量修改）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/鉴权-登录/登录后初始化的双阶段启动（增量修改）</guid>
            <pubDate>Sat, 06 Sep 2025 18:30:01 GMT</pubDate>
            <content:encoded><![CDATA[
## 思路

- 把**不需要登录**的请求抽成“公共初始化（public bootstrap）”，在应用进入时就触发（只触发一次）。
- 把**需要登录**且**命中鉴权路由**时才需要的数据，保留在你现有的 `watch` 分支里，但也确保只跑一次。
- 用**模块级 once 标记**避免多组件重复调用；必要时可加 `online` 事件进行弱网重试（可选）。

---

## 需要调整的代码（仅片段）

> 放在你这个 composable 文件里，**按位置插入**即可；复杂逻辑我已在上一行加中文注释。

### 1）导入（在文件顶部补充）

```ts
// 复杂逻辑：公私两段初始化需要生命周期/事件
import { watch, onMounted } from "vue";
```

### 2）模块级 once 标记（在文件顶部、`export function useAppBootstrap` 外面）

```ts
// 复杂逻辑：模块级“只执行一次”标记，防止多组件重复初始化
let __BOOT_PUBLIC_ONCE__ = false;
let __BOOT_PRIVATE_ONCE__ = false;
```

### 3）在 `useAppBootstrap` 内部新增“公共初始化”方法与调用（建议贴在你定义完各个 store 之后）

```ts
// 复杂逻辑：公共初始化——无需登录的数据，进入站点即预取，且只执行一次
const bootstrapPublic = async () => {
  if (__BOOT_PUBLIC_ONCE__) return;
  __BOOT_PUBLIC_ONCE__ = true;

  await Promise.all([
    // ⬇️ 把“无需 token 的初始化”放这里；按你项目实际取舍
    country.init().catch(() => {}),
    exchange.init({ keyword: "" }).catch(() => {}),
    marketCalendar.init().catch(() => {}),
    // 如果 server.init() 不依赖用户态，也可放到公共初始化
    server.init().catch(() => {}),
    // …你还有其它完全公开的数据，也可加进来
  ]);
};
```

```ts
// 复杂逻辑：进入应用即触发公共初始化（SSR/CSR 兼容性考虑，放到 onMounted 最稳妥）
onMounted(() => {
  bootstrapPublic();
});
```

### 4）给你原来的 `watch` 回调加“私有初始化只跑一次”的保护

```ts
// 复杂逻辑：仅在“已登录 && 路由需要鉴权 && 未跑过私有初始化”时执行
if (ok && need && !__BOOT_PRIVATE_ONCE__) {
  __BOOT_PRIVATE_ONCE__ = true;
  await Promise.all([
    user.fetchUserInfo().catch(() => {}),
    account.init({ withCategory: true, withExternal: true }).catch(() => {}),
    leverage.init().catch(() => {}),
    accountCurrency.init().catch(() => {}),
    externalServer.init().catch(() => {}),
    payChannel.init({ opt_type: "deposit" }).catch(() => {}),
    verifyStore.initVerifyInfo().catch(() => {}),
    inviteStore.getInviteGroupOptions().catch(() => {}),
    // ⚠️ server.init()/country/exchange/marketCalendar 已在公共初始化里跑过的可移除，避免重复
  ]);
}
```

---

## 可选增强

### A. 弱网场景“上线即补跑”

```ts
// 复杂逻辑：若用户初次进入时离线，恢复网络后自动补跑公共初始化（最多触发一次）
onMounted(() => {
  const handler = () => {
    bootstrapPublic();
  };
  window.addEventListener("online", handler, { once: true });
});
```

### B. Store 级幂等（示例片段，放到各自的 Pinia store 里）

```ts
// 复杂逻辑：在每个 init() 入口加幂等保护，彻底避免重复请求
if ((this as any)._inited) return;
(this as any)._inited = true;
```

---

## 小结

- 公共数据：`onMounted` 里 **立刻预取一次**，全站可复用。
- 私有数据：沿用你的 `watch`，但加一次性保护，避免路由/状态抖动造成的重复请求。
- 若存在弱网：监听 `online` 事件，**一次性**补跑公共初始化即可。

---

title: useAppBootstrap 放在哪？给你一份可直接复制的完整文件（含用法）
date: 2025-09-06
tags:

- Vue3
- Vite
- Pinia
- composable
  categories:
- 前端工程化

---

## 位置推荐

把文件放到：

```
src/composables/useAppBootstrap.ts
```

理由：可复用的启动逻辑属于“组合式函数（composable）”，与业务无关的初始化也方便在这里统一管理。

---

## 完整代码（可直接替换 `src/composables/useAppBootstrap.ts`）

```ts
// src/composables/useAppBootstrap.ts
import { onMounted, watch } from "vue";
import { useRouter } from "vue-router";
import {
  useAuthStore,
  useUserStore,
  useAccountStore,
  useServerStore,
  useLeverageStore,
  useAccountCurrencyStore,
  useCountryStore,
  useExchangeStore,
  useExternalServerStore,
  useMarketCalendarStore,
  usePayChannelStore,
} from "@/store";
import { useVerifyStore } from "@/store/verify";
import { useInviteStore } from "@/store/invite";

// 复杂逻辑：模块级“只执行一次”标记，避免多组件/多次进入页面重复请求
let __BOOT_PUBLIC_ONCE__ = false;
let __BOOT_PRIVATE_ONCE__ = false;

export function useAppBootstrap() {
  const router = useRouter();
  const auth = useAuthStore();
  const user = useUserStore();
  const account = useAccountStore();
  const server = useServerStore();
  const leverage = useLeverageStore();
  const accountCurrency = useAccountCurrencyStore();
  const country = useCountryStore();
  const exchange = useExchangeStore();
  const externalServer = useExternalServerStore();
  const marketCalendar = useMarketCalendarStore();
  const payChannel = usePayChannelStore();
  const verifyStore = useVerifyStore();
  const inviteStore = useInviteStore();

  // 复杂逻辑：公共初始化——无需登录可获取的数据，进入站点即预取，且只执行一次
  const bootstrapPublic = async () => {
    if (__BOOT_PUBLIC_ONCE__) return;
    __BOOT_PUBLIC_ONCE__ = true;

    await Promise.all([
      // ⬇️ 放“无需 token”的初始化
      country.init().catch(() => {}),
      exchange.init({ keyword: "" }).catch(() => {}),
      marketCalendar.init().catch(() => {}),
      server.init().catch(() => {}),
      // 如有其它公开数据，也可加在这里
    ]);
  };

  // 复杂逻辑：进入应用即触发公共初始化；若首次访问时离线，恢复网络后补跑一次（仅一次）
  onMounted(() => {
    bootstrapPublic();
    const handler = () => {
      bootstrapPublic();
    };
    window.addEventListener("online", handler, { once: true });
  });

  // 复杂逻辑：仅在“已登录 && 目标路由需要鉴权 && 未跑过私有初始化”时执行一次性私有初始化
  watch(
    [
      () => auth.isAuthenticated,
      () => router.currentRoute.value.meta?.requiresAuth,
    ],
    async ([ok, need]) => {
      if (ok && need && !__BOOT_PRIVATE_ONCE__) {
        __BOOT_PRIVATE_ONCE__ = true;

        await Promise.all([
          user.fetchUserInfo().catch(() => {}),
          account
            .init({ withCategory: true, withExternal: true })
            .catch(() => {}),
          leverage.init().catch(() => {}),
          accountCurrency.init().catch(() => {}),
          externalServer.init().catch(() => {}),
          payChannel.init({ opt_type: "deposit" }).catch(() => {}),
          verifyStore.initVerifyInfo().catch(() => {}),
          inviteStore.getInviteGroupOptions().catch(() => {}),
          // ⚠️ 已在公共初始化中完成的 server/country/exchange/marketCalendar 无需重复
        ]);
      }
    },
    { immediate: true }
  );
}

// （可选）测试/登出时重置标记
export function __resetBootstrapFlagsForTestOnly() {
  __BOOT_PUBLIC_ONCE__ = false;
  __BOOT_PRIVATE_ONCE__ = false;
}
```

---

## 如何使用（最小改动）

> 你**不需要**在每个页面手动调用，只需在 **App.vue** 顶层调用一次即可。

在 `src/App.vue` 的 `<script setup>` 里加入一行（**增量修改**）：

```ts
// 复杂逻辑：顶层调用一次，注册 watch + onMounted，即可全局生效
import { useAppBootstrap } from "@/composables/useAppBootstrap";
useAppBootstrap();
```

> 如果你的项目还没在 `main.ts` 里安装 Pinia/Router，请确认已安装（一般你已经有了）：

```ts
// 仅供核对：main.ts 应该已包含这些
// import { createApp } from 'vue'
// import { createPinia } from 'pinia'
// import router from './router'
// import App from './App.vue'
// createApp(App).use(createPinia()).use(router).mount('#app')
```

---

## 小结

- 文件放在：`src/composables/useAppBootstrap.ts`。
- 在 `App.vue` 顶层调用一次 `useAppBootstrap()` 即全局生效。
- 公共初始化：站点进入即跑；私有初始化：登录且命中鉴权路由时只跑一次。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[退出登录后跳转与请求是否会发出]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录后跳转与请求是否会发出</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录后跳转与请求是否会发出</guid>
            <pubDate>Fri, 05 Sep 2025 18:55:38 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: 退出登录后跳转与请求是否会发出？（Vue Router 4 实战）
date: 2025-09-05
tags: \[Vue, Vue Router, Pinia, Axios, 登录, 退出]

---

## TL;DR（先给结论）

- `router.push('/user')` **不会**去加载 `@/views/(public)/layout.vue`；`/user` 是独立的**公开路由**，全局前置守卫会**先**跑，再决定是否进入目标路由，受保护布局组件不会被解析/执行。
- 真正会“误发请求”的常见来源是：① 旧页中**已发起但未取消**的请求；② `<keep-alive>` 相关的激活/停用副作用；③ 你在 HTTP 层没有对“无 Token 的鉴权请求”做**硬性拦截**。
- 给你三道保险：**彻底清 Token + 取消未决请求 + 请求层强拦**（可选再加根路由 `beforeEnter`）。

---

## 最小修改（仅给需要改的代码片段）

> 说明：按你的偏好，只给**需修改**片段；复杂逻辑在上一行加注释。

### 1) `auth` Store：退出时同时清理本地存储 Token、取消所有请求、清默认头

**文件：** `useAuthStore` 所在文件

```ts
// 新增导入
import storage from "store";
import { STORAGE_KEYS } from "@/constants";
const { ACCESS_TOKEN } = STORAGE_KEYS;
```

```ts
// 新增：统一清空本地 Token（Pinia + 本地存储）
function clearToken() {
  // 复杂逻辑：双通道清理，避免路由守卫误判已登录
  token.value = null;
  refresh.value = null;
  storage.remove(ACCESS_TOKEN);
}
```

```ts
// 调整 logout 函数（仅贴需要增加的片段）
async function logout() {
  try {
    await http.post("/api/pub/loginOut").catch(() => {});
    // 复杂逻辑：优雅下线——取消所有还在飞行中的请求，防止“未登录也发请求”
    http.cancelAll?.();
    // 复杂逻辑：清掉默认鉴权头，防止后续请求夹带旧 Token
    http.setAuthToken?.(null);

    clearToken();
    resetAllStores();
  } catch (error) {
    console.error(error);
    throw error;
  }
}
```

> 你现在的调用 `await authStore.logout(); router.push('/user')` 没问题；若不想留下历史记录，可换成：

```ts
// 可选：避免回退到已登录页
await router.replace({ name: "user" });
```

---

### 2) `http` 工具：加“全局取消池 + 无 Token 时硬拦需要鉴权的请求”

**文件：** 你的 `@/utils/http`（或创建一个轻量封装）

```ts
// 新增：全局取消池
const abortPool = new Set<AbortController>();

export function cancelAll() {
  // 复杂逻辑：退出登录时集中取消所有未决请求
  abortPool.forEach((c) => c.abort());
  abortPool.clear();
}

export function setAuthToken(token?: string | null) {
  // 复杂逻辑：动态设置/清除默认鉴权头
  if (token) {
    axios.defaults.headers.common.Authorization = `Bearer ${token}`;
  } else {
    delete axios.defaults.headers.common.Authorization;
  }
}
```

```ts
// 在请求拦截里增加以下片段（保留你已有逻辑）
http.interceptors.request.use((config) => {
  // 复杂逻辑：为每个请求绑定 AbortController，纳入全局取消池
  const ac = new AbortController();
  (config as any).signal = ac.signal;
  abortPool.add(ac);

  // 复杂逻辑：对标记了 { auth: true } 的请求做硬性校验，无 Token 直接终止
  const needAuth = (config as any).auth === true;
  const token = storage.get(ACCESS_TOKEN);
  if (needAuth && !token) {
    ac.abort();
    // 用标准错误中断；也可自定义错误码
    throw new axios.Cancel("UNAUTHENTICATED");
  }
  return config;
});
```

```ts
// 在响应/错误拦截里释放对应的 controller（保持池干净）
const detach = (cfg?: any) => {
  if (!cfg?.signal) return;
  for (const ac of abortPool) {
    if (cfg.signal === ac.signal) {
      abortPool.delete(ac);
      break;
    }
  }
};
http.interceptors.response.use(
  (resp) => {
    detach(resp.config);
    return resp;
  },
  (err) => {
    detach(err?.config);
    return Promise.reject(err);
  }
);
```

> 使用方式：**凡是需要登录才能访问的接口**，在调用时带上 `{ auth: true }`：

```ts
// 复杂逻辑：打上鉴权标记，无 Token 时在请求层被硬拦
http.get("/api/secure/profile", { auth: true });
```

---

### 3) 根布局路由（可选加固）：未登录禁止进入，阻止懒加载 `layout.vue`

> 这是“冗余但稳”的**第四道锁**：即使有人误配了守卫，根布局也进不去。

**文件：** 路由表所在文件

```ts
// 新增导入（如果本文件里还没有）
import storage from "store";
import { STORAGE_KEYS } from "@/constants";
import { LOGIN_ROUTE } from "./constants";
const { ACCESS_TOKEN } = STORAGE_KEYS;
```

```ts
// 在 path: '/' 那个根路由对象上新增 beforeEnter（只贴新增的属性）
beforeEnter: (to, from, next) => {
  // 复杂逻辑：未登录直接拒绝进入受保护根布局，避免解析/执行 layout.vue
  const token = storage.get(ACCESS_TOKEN)
  if (!token) return next({ name: LOGIN_ROUTE.name, replace: true })
  next()
},
```

---

## 为什么你会怀疑 `layout.vue` 被加载？

常见场景有三种（任选对号入座）：

1. **旧页未决请求**：你还在“受保护页面”时就发出了请求，`push('/user')` 后这些请求仍会完成，除非你**主动取消**（上面第 2 步已解决）。
2. **`<keep-alive>` 激活/停用副作用**：离开/进入时有数据拉取，需要在未登录时短路。
3. **预加载 Chunk**：如果手动开启过 `webpackPrefetch` 等，会看到静态资源拉取，但这不等同于“业务请求”发出。

---

## 排查清单（按优先级）

1. 退出后 `localStorage`/`store` 里是否还残留 `ACCESS_TOKEN`？（第 1 步已处理）
2. 所有**需要登录**的接口是否统一加了 `{ auth: true }` 并被请求拦截器“硬拦”？（第 2 步）
3. 页面里有没有在 `onMounted` **直接拉数据**但无 Token 校验的逻辑？（在组件中加早返回）
4. 是否使用了 `<keep-alive>` 并在 `activated`/`deactivated` 发请求？（同样做登录短路）
5. 仍担心懒加载？给根布局加 `beforeEnter`（第 3 步“加固锁”）。

---

## 你最关心的那句直白话

- **不会**：`router.push('/user')` 不会去跑 `@/views/(public)/layout.vue` 里的业务请求。
- **会**：如果**旧页**的请求已经发出且你没有取消，它们**会继续完成**。上面给的三段修改能把这类“该停的请求”全部截住。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[退出登录要不要 resetAllStores]]></title>
            <link>https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录要不要-resetAllStores</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录要不要-resetAllStores</guid>
            <pubDate>Fri, 05 Sep 2025 20:45:33 GMT</pubDate>
            <content:encoded><![CDATA[
## 结论

- **应该保留 `resetAllStores()`**（避免残留用户数据/权限态），但**直接在登出时先重置**会触发一堆 `watchEffect` / `watch` 的依赖变化，从而在组件卸载前**又发出请求**。
- 正确做法：**先撤鉴权与在途请求 → 跳公开页卸载组件 → 最后再 `resetAllStores()`**；同时在页面副作用里用 `isAuthenticated`/`isLoggingOut` 做**登录短路**。

## 推荐顺序（一眼抄）

1. **标记登出中**（`isLoggingOut = true`）
2. **取消所有在途请求**（`http.cancelAll()`）
3. **清鉴权**（`http.setAuthToken(null)` + 清本地 `ACCESS_TOKEN/TOKEN_TYPE` + 清内存 `token`）
4. **跳到公开路由**（`router.replace('/user')`）
5. **最后** `resetAllStores()`
6. **清掉登出标记**（`isLoggingOut = false`）

## 仅需修改的代码片段

### A) `auth` Store：按顺序登出（在 store 内部做跳转，保证顺序）

```ts
// 新增
import { useRouter } from "vue-router";

// 新增
const isLoggingOut = ref(false);
```

```ts
// 调整 logout（顺序：撤鉴权→跳公开页→reset）
async function logout() {
  const router = useRouter();
  try {
    isLoggingOut.value = true;
    await http.post("/api/pub/loginOut").catch(() => {});

    // 复杂逻辑：统一掐断飞行中的请求，避免“卸载前再打一次”
    http.cancelAll?.();

    // 复杂逻辑：清鉴权（默认头 + 本地存储 + 内存）
    http.setAuthToken?.(null);
    storage.remove(ACCESS_TOKEN);
    storage.remove(TOKEN_TYPE);
    token.value = null;
    refresh.value = null;

    // 复杂逻辑：先跳到公开页，卸载受保护组件，阻断其副作用
    await router.replace({ name: "user" });

    // 复杂逻辑：组件已卸载，再重置所有 store，安全不抖动
    resetAllStores();
  } catch (error) {
    console.error(error);
    throw error;
  } finally {
    isLoggingOut.value = false;
  }
}
```

> 这样**无需**在组件里再 `router.push('/user')`；如果你保留组件层跳转，记得删除那一行以免重复。

---

### B) 页面副作用：加“登录短路”（防抖再保险）

> 示例：你在 `public/dashboard` 页和分析卡片里原来用 `watchEffect` 拉数据。

```ts
// 复杂逻辑：登出过程/未登录时直接短路，不发请求
import { useAuthStore } from '@/plugins'
import { storeToRefs } from 'pinia'
const { isAuthenticated, isLoggingOut } = storeToRefs(useAuthStore())

watch(/* 精确依赖或 isAuthenticated */ , () => {
  if (!isAuthenticated.value) return
  if (isLoggingOut?.value) return
  // 这里再发请求
}, { immediate: true })
```

> 说明：**副作用短路 + A 部分的顺序**，两层兜底，基本杜绝“退出时还在请求”。

---

## 什么时候可以“不 resetAllStores”？

- 仅在**演示/临时**场景；正式项目**不建议**。不重置会遗留：上一个用户的**列表数据、选择态、分页、缓存**等，存在隐私与越权风险。

---

## 小结

- **不是不要 `resetAllStores()`，而是要把它放在最后**，并在副作用处加“登录短路”。
- 真正能解决“跳转后还在请求”的，是**顺序**（撤鉴权 → 跳公开页 → 重置）+ **取消在途** + **副作用短路**。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）]]></title>
            <link>https://herongdev.github.io/blog/posts/后端/NestJS/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/后端/NestJS/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）</guid>
            <pubDate>Sun, 07 Sep 2025 20:40:23 GMT</pubDate>
            <content:encoded><![CDATA[
---

title: 在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）
date: 2025-09-07
tags:

- NestJS
- Redis
- ioredis
- 教程
  categories:
- 后端
  description: 手把手带你在 NestJS 中集成 Redis（基于 ioredis），涵盖安装、配置、Provider、全局模块封装、业务实践（限流/一次性令牌）、Docker、本地调试与常见报错排查。

---

# 目标与适用读者

- 目标：在 **NestJS** 项目中稳定接入 **Redis**，通过 **ioredis** 驱动，提供可复用的 `RedisService`（封装 `set/get/del/incr/expire`、NX 写入等），并支持 **全局模块**、**环境配置**、**本地/生产** 两套部署。
- 适用：会基本 NestJS 模块/依赖注入的同学；数据库用 TypeORM/Prisma 均可（与本教程无冲突）。

---

# 技术栈选型

- Redis 客户端：**ioredis**（成熟、支持集群/哨兵、TypeScript 友好）。
- Nest 集成方式：自定义 **Provider + 全局模块**，暴露 `REDIS_CLIENT` 与 `RedisService`。
- 配置：`.env` 中支持 `REDIS_URL` 或 `REDIS_HOST/PORT/PASSWORD/DB`。

---

# 目录结构（建议）

```
src/
  common/
    redis/
      redis.module.ts       # 全局模块（@Global）
      redis.service.ts      # 业务友好封装（依赖 REDIS_CLIENT）
  app.module.ts             # 或各业务模块，引入 RedisModule 一次即可
```

---

# 第一步：安装依赖

```bash
# 使用 pnpm（推荐）
pnpm add ioredis
# 或者 npm
# npm i ioredis
```

---

# 第二步：准备环境变量

建议在 `.env`（或 `.env.dev`）中添加 **二选一**：

```ini
# 方式 A：URL 一行式（含密码与 DB 索引，推荐）
REDIS_URL=redis://:password@localhost:6379/0

# 方式 B：分散式
REDIS_HOST=127.0.0.1
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0
```

---

# 第三步：编写 `RedisService`

> 放在 `src/common/redis/redis.service.ts`
> 命名**清晰可读**，复杂逻辑上方有中文注释。

```ts
import { Injectable, Inject } from "@nestjs/common";
import type { Redis } from "ioredis";

// 复杂：作为底层连接的注入令牌；项目全局唯一
export const REDIS_CLIENT = "REDIS_CLIENT";

@Injectable()
export class RedisService {
  constructor(@Inject(REDIS_CLIENT) private readonly redisClient: Redis) {}

  // 复杂：统一封装写入并设置过期时间，便于存挑战/一次性令牌
  async setWithTimeToLive(
    key: string,
    value: string,
    timeToLiveSeconds = 300
  ): Promise<void> {
    await this.redisClient.set(key, value, "EX", timeToLiveSeconds);
  }

  async getValue(key: string): Promise<string | null> {
    return this.redisClient.get(key);
  }

  async deleteKey(key: string): Promise<void> {
    await this.redisClient.del(key);
  }

  // 复杂：自增计数用于限流（第一次返回 1）
  async incrementKey(key: string): Promise<number> {
    return this.redisClient.incr(key);
  }

  // 复杂：给键设置过期时间，配合 incrementKey 实现简单窗口限流
  async expireKey(key: string, seconds: number): Promise<void> {
    await this.redisClient.expire(key, seconds);
  }

  // 复杂：仅当键不存在时写入并设置 TTL（一次性令牌/幂等防重放）
  async setIfAbsentWithTimeToLive(
    key: string,
    value: string,
    timeToLiveSeconds: number
  ): Promise<boolean> {
    // 复杂：NX 确保不存在才写入；避免并发下的重复写入
    const result = await this.redisClient.set(
      key,
      value,
      "NX",
      "EX",
      timeToLiveSeconds
    );
    return result === "OK";
  }
}
```

---

# 第四步：编写 `RedisModule`（全局模块，一次引入处处可用）

> 放在 `src/common/redis/redis.module.ts`，标记 `@Global()`，自动对全局开放。

```ts
import { Global, Module } from "@nestjs/common";
import * as IORedis from "ioredis";
import { RedisService, REDIS_CLIENT } from "./redis.service";

@Global()
@Module({
  providers: [
    {
      provide: REDIS_CLIENT,
      // 复杂：通过工厂读取 .env，创建 ioredis 客户端
      useFactory: () => {
        const url = process.env.REDIS_URL;
        const host = process.env.REDIS_HOST ?? "127.0.0.1";
        const port = parseInt(process.env.REDIS_PORT ?? "6379", 10);
        const password = process.env.REDIS_PASSWORD || undefined;
        const db = parseInt(process.env.REDIS_DB ?? "0", 10);

        const client: IORedis.Redis = url
          ? new (IORedis as any)(url)
          : new (IORedis as any)({ host, port, password, db });

        // 复杂：记录连接错误，便于排查
        client.on("error", (err: any) => {
          // eslint-disable-next-line no-console
          console.error("[Redis] connection error:", err?.message || err);
        });

        return client;
      },
    },
    RedisService,
  ],
  exports: [REDIS_CLIENT, RedisService],
})
export class RedisModule {}
```

---

# 第五步：在应用中引入 `RedisModule`

> 只需在**任意一个模块**引入一次（例如 `AppModule`），因为它是 `@Global()`。

```ts
// src/app.module.ts（或你任一根模块）
import { Module } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";
import { RedisModule } from "./common/redis/redis.module";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    RedisModule, // 复杂：全局模块，仅需引入一次
    // ... 你的其它模块
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

---

# 第六步：业务中使用示例

### 6.1 限流（每分钟最多 10 次）

```ts
import { Injectable, TooManyRequestsException } from "@nestjs/common";
import { RedisService } from "src/common/redis/redis.service";

@Injectable()
export class LoginService {
  constructor(private readonly redisService: RedisService) {}

  // 复杂：按 IP 做 60 秒/10 次 限流
  async limitByIp(ipAddress: string) {
    const rateLimitKey = `rl:login:${ipAddress}`;
    const currentCount = await this.redisService.incrementKey(rateLimitKey);
    if (currentCount === 1) {
      await this.redisService.expireKey(rateLimitKey, 60);
    }
    if (currentCount > 10) {
      throw new TooManyRequestsException("请求过于频繁，请稍后再试");
    }
  }
}
```

### 6.2 一次性令牌（幂等/防重放）

```ts
// 复杂：仅当 key 不存在时写入，5 分钟有效
const ok = await this.redisService.setIfAbsentWithTimeToLive(
  `once:${token}`,
  "1",
  300
);
if (!ok) {
  throw new Error("令牌已使用或失效");
}
```

### 6.3 短期会话/挑战值（例如 WebAuthn）

```ts
await this.redisService.setWithTimeToLive(
  `webauthn:register:${userId}`,
  challengeBase64Url,
  300
);
const cached = await this.redisService.getValue(`webauthn:register:${userId}`);
// ... 验证后删除
await this.redisService.deleteKey(`webauthn:register:${userId}`);
```

---

# 第七步：Docker Compose（本地起 Redis）

> `docker-compose.yml`（项目根目录）

```yaml
version: "3.9"
services:
  redis:
    image: redis:7-alpine
    container_name: demo-redis
    ports:
      - "6379:6379"
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - redis-data:/data
volumes:
  redis-data:
```

启动：

```bash
docker compose up -d
# .env 示例
# REDIS_URL=redis://localhost:6379
```

---

# 第八步：生产环境注意事项

- **连接池与超时**：ioredis 默认复用单连接；高并发可根据需要创建多个客户端或使用 `cluster`/`sentinel`。
- **密码与 ACL**：生产务必启用密码或 ACL；不要暴露无鉴权实例。
- **键名规范**：`<领域>:<用途>:<实体>`（如 `webauthn:auth:ch:<challenge>`），可读性与清理都更好。
- **TTL 策略**：短期挑战/令牌务必设置 TTL，并在验证后删除，避免重放。
- **监控**：监控 `connected clients`、`keyspace hits/misses`、`latency`；必要时加慢日志。
- **持久化**：默认 RDB；根据业务考虑 AOF（`appendonly yes`）与混合持久化。

---

# 第九步：常见报错与排查

- **Nest can't resolve dependencies of the RedisService (REDIS_CLIENT)**
  说明：未注册 `REDIS_CLIENT` Provider。
  解决：确保 `RedisModule`（或 `AppModule` 的 `providers`）里 **provide: REDIS_CLIENT** 已配置，并且模块被应用引入。
- **ECONNREFUSED / getaddrinfo ENOTFOUND**
  说明：Redis 未启动或地址错误。
  解决：检查 `REDIS_URL/REDIS_HOST/REDIS_PORT`，本地起容器或服务端口是否 6379。
- **WRONGPASS invalid username-password pair**
  说明：密码有误或未配置。
  解决：核对 `REDIS_URL` 中 `:password@` 或 `REDIS_PASSWORD`。
- **Ready check failed**
  说明：网络/权限/ACL 问题或连接尚未可用。
  解决：检查安全组/防火墙；对云服务需配置白名单。

---

# 第十步：单元测试（Mock Redis）

> 不在测试中连真实 Redis，可用 `ioredis-mock` 或手写假对象。

```ts
import { Test } from "@nestjs/testing";
import { RedisService, REDIS_CLIENT } from "src/common/redis/redis.service";

describe("RedisService", () => {
  it("set/get works", async () => {
    // 复杂：用最小可用的假客户端满足接口
    const fakeClient = {
      storage: new Map<string, string>(),
      set: function (k: string, v: string) {
        this.storage.set(k, v);
        return Promise.resolve("OK");
      },
      get: function (k: string) {
        return Promise.resolve(this.storage.get(k) ?? null);
      },
      del: function (k: string) {
        this.storage.delete(k);
        return Promise.resolve();
      },
      incr: function (k: string) {
        const next = Number(this.storage.get(k) ?? "0") + 1;
        this.storage.set(k, String(next));
        return Promise.resolve(next);
      },
      expire: function () {
        return Promise.resolve();
      },
    } as any;

    const moduleRef = await Test.createTestingModule({
      providers: [
        { provide: REDIS_CLIENT, useValue: fakeClient },
        RedisService,
      ],
    }).compile();

    const redis = moduleRef.get(RedisService);
    await redis.setWithTimeToLive("foo", "bar", 60);
    expect(await redis.getValue("foo")).toBe("bar");
  });
});
```

---

# 结语

至此，你已经完成了 **NestJS × Redis（ioredis）** 的完整接入：

- 全局模块提供底层连接与服务封装；
- 业务中可轻松完成 **限流**、**一次性令牌**、**短期会话/挑战** 等高频需求；
- 本地用 Docker 起 Redis，生产注意密码、ACL、监控与 TTL 策略。

需要我把你的现有项目改造为 **全局 `RedisModule` 方案** 或 **在 `AppModule` 直接注册 Provider** 的最小改动 **完整文件**，就把相关文件发我（或让我复用你上面的 `AppModule` 路径）。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AI 时代：系统课程的价值、定位与路线图]]></title>
            <link>https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图</guid>
            <pubDate>Tue, 09 Sep 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[AI 擅长局部解题，但系统性、权衡与落地需要课程提供“结构化路径”。本文给出价值判断、差异化定位、结构设计、风险与最小可行路线。]]></description>
            <content:encoded><![CDATA[
## 结论

- “系统课程＋博客”在 AI 时代更有价值：AI 能补局部知识，但难给“由浅入深的体系、场景权衡、复盘与职业路径”。
- 差异化关键：工程落地（SOP/Checklist/MRE/观测与度量）、权衡（Trade-off）、真实复盘与团队协作。
- 难度与风险：持续产出、版权合规、转化与交付。以“可验证的工程实践”做护城河，值得做。

## 为什么在 AI 时代更有价值

- AI 的短板：上下文有限、缺乏全局体系与演进路线、对 Why/Trade-off 薄弱、难处理非完备信息。
- 课程的角色：给“脉络与标准动作”；学员用 AI 追问局部细节，构成最优组合。

## 传统培训的空白

- 多停留“API/八股/题库”，少谈生产问题、平台化工程、合规/安全、观测与性能、协作与落地。
- 实战同质化，缺真实业务约束与指标验证，缺事故复盘与上线闭环。

## 差异化定位与设计

- 工程落地：每模块配 SOP ＋ Checklist ＋最小可复现（MRE）＋观测/指标模板。
- 权衡为骨架：何时做/不做，代价/收益，灰度/回滚方案，失败复盘。
- 专题系列：生产问题定位、性能与分布式、数据治理与一致性、安全与合规、团队协作与流程。
- 作品集导向：设计题 → 实现 → 观测/基准 → 复盘，形成可投递 Portfolio。

## 课程结构（由浅入深）

- Level 0：能力地图（路线图/评估表）
- Level 1：基础与最佳实践（现代前端/工程化基础，快速过）
- Level 2：体系工程（构建/测试/发布/观测/安全/合规）
- Level 3：生产问题与权衡（性能、网络、数据一致性、幂等、限流、熔断、回滚）
- Level 4：平台与协作（多仓/MonoRepo、规范化、流水线、指标治理）
- Capstone：端到端项目（灰度、回滚、SLO、事故演练与复盘）

## 与“国外系统课程＋ AI”的结合

- 参考框架与案例，必须本地化：国内云/合规、常用栈、网络/CDN/容器差异。
- AI 作“内容助理”而非“策展人”：生成素材/雏形/题库；你把关正确性、权衡、边界与度量。
- 明确来源与改编，避免版权风险。

## 难度与风险

- 产出节奏：先做一个金刚区（如“生产问题复盘”）打爆款，再扩张。
- 版权与合规：授权/引用规范；示例代码素材需可再发布。
- 转化与交付：从免费内容 → 专题导读 → 训练营 → 口碑。
- 期望管理：明确承诺边界，不做虚假“保就业”。

## 商业模式

- 免费区：系统博文、复盘、Checklist、Demo（SEO 与信任）
- 付费区：训练营/系统课（作业批改、走查、复盘、1v1）
- 长尾：模板包/脚手架/工作坊
- 定价：首期开营“半价＋强交付”，用成功案例突破冷启动

## 度量与证明

- 前/后测、作业通过率、问题解决周期、事故率/SLO 改善、作品集与面试反馈、NPS 与转介绍

## 最小可行路径（3 步）

1. 选一个差异化专题（建议“生产问题复盘”），产出系列博文＋模板包＋公开课；
2. 升级为 4 ～ 6 周试点班：每周作业＋代码走查＋复盘报告；
3. 在案例基础上扩展到“性能与分布式”“数据治理”“安全与合规”等模块，形成矩阵。

## 延伸阅读

- 生产问题复盘：
  - [/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）](/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）)
- AI 协作与边界：
  - [/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界](/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[系统课程大纲与招生 README（骨架）]]></title>
            <link>https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/系统课程大纲与招生README（骨架）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/系统课程大纲与招生README（骨架）</guid>
            <pubDate>Tue, 09 Sep 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[课程目标与对象、大纲结构、日程安排、作业与考核、报名方式与FAQ 的可复用骨架模板。]]></description>
            <content:encoded><![CDATA[
# 课程介绍

- 课程定位：工程落地为核心，强调 SOP/Checklist/MRE/观测与度量。
- 适合对象：有 1 ～ 5 年经验，想从“能写页面”进阶到“能落地系统”的工程师。
- 学习产出：可投递的作品集、问题复盘报告、基准与观测面板、团队落地 SOP。

# 课程大纲（节选）

- 模块 0：能力地图与路线
- 模块 1：现代工程基础（构建/测试/发布基础）
- 模块 2：工程体系（可观测/安全/合规/规范化）
- 模块 3：生产问题与权衡（性能/网络/一致性/幂等/限流/熔断/回滚）
- 模块 4：平台与协作（多仓/MonoRepo/流水线/指标治理）
- Capstone：端到端项目（灰度、回滚、SLO、事故演练与复盘）

# 日程与学习方式（示例：6 周）

- 第 1 周：体系化工程启航 + 能力评估
- 第 2 ～ 5 周：每周 2 次直播/录播 + 作业（代码走查/观测/复盘）
- 第 6 周：Capstone 收官展示与简历/作品集打磨

# 作业与考核

- 强制作业：每周 1 次最小可复现 + 复盘报告（含观测截图/基准数据）
- 评估维度：正确性/鲁棒性/性能/可观测/规范/表达
- 通过门槛：达到基线 + 一处可验证优化

# 度量指标（示例）

- 前/后测提升、作业通过率、问题解决周期、SLO 改善、作品集质量、NPS、转介绍

# 报名与名额

- 报名链接：<填写>
- 名额与价格：<填写>
- 退课与售后：<填写>

# FAQ（示例）

- 我基础一般可以学吗？
- 是否有助教/代码走查？
- 是否提供发票/合同？

# 延伸阅读

- 课程价值与路线：
  - [/posts/商业化与营收/课程与训练营/AI 时代：系统课程的价值、定位与路线图](/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图)
- 试点班方案：
  - [/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）](/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[用 VitePress 从零搭建个人博客（含 GitHub Pages 发布）]]></title>
            <link>https://herongdev.github.io/blog/posts/平台与博客/Hexo/hello-world</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/平台与博客/Hexo/hello-world</guid>
            <pubDate>Mon, 08 Sep 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[一步步完成初始化、写作、构建、RSS、以及 GitHub Pages 自动发布]]></description>
            <content:encoded><![CDATA[
## 前置条件

- Node.js 18+（推荐 20）
- Git 与 GitHub 账号

## 1）初始化项目

```bash
mkdir my-blog && cd my-blog
npm init -y
```

## 2）安装与创建 VitePress

```bash
npm i -D vitepress

# 快速启动开发（首次运行会创建 docs/.vitepress 基础结构）
npx vitepress init # 如未安装可用：npm create vitepress@latest
```

选择 “Blog” 模板或空模板均可。本仓库采用 `docs` 作为内容根目录。

开发预览：

```bash
npm run docs:dev
```

## 3）项目结构建议

```txt
docs/
  index.md                 # 首页（可用 hero 布局）
  posts/                   # 博文目录
    hello-world.md         # 你的第一篇文章（本页）
  .vitepress/
    config.ts              # 站点配置
    dist/                  # 构建输出（自动生成）
```

## 4）基础配置（docs/.vitepress/config.ts）

本仓库已内置一份可用于 GitHub Pages 的配置，关键点：

```ts
// 只展示关键片段
const BASE = process.env.BASE || "/";
const SITE_HOSTNAME = process.env.SITE_URL || "https://example.com";

export default {
  lang: "zh-CN",
  title: "我的博客",
  description: "记录、积累人气、可被搜索引擎良好收录的个人博客",
  base: BASE.endsWith("/") ? BASE : `${BASE}/`,
  sitemap: { hostname: SITE_HOSTNAME },
  themeConfig: {
    nav: [
      { text: "首页", link: "/" },
      { text: "文章", link: "/posts/hello-world" },
    ],
    search: { provider: "local" },
    outline: { level: [2, 3] },
  },
  // 如需在 Markdown 中写原始 HTML，可将 markdown.html 设为 true
  markdown: { html: false },
};
```

> 提示：GitHub Pages 二级路径（`https://<owner>.github.io/<repo>`）要设置 `BASE=/<repo>/`。

## 5）写第一篇文章（本页示例）

在 `docs/posts/` 下新建 Markdown 文件，建议包含 Frontmatter：

```md
---
title: 我的第一篇 VitePress 文章
description: 这是一段用于 SEO 的摘要
date: 2025-01-01
tags: [随笔]
---

这里是正文内容，可以使用 Markdown 语法、代码块等。
```

## 6）本地预览

```bash
npm run docs:dev
```

打开终端输出的本地地址，检查首页与文章路由是否可用。

## 7）生成静态站点

```bash
npm run build
```

构建产物在 `docs/.vitepress/dist` 目录。你可以用：

```bash
npm run docs:preview
```

进行本地预览。

## 8）生成 RSS（可选）

本仓库内置 `scripts/gen-rss.mjs`，`npm run build` 后会自动生成 RSS/Atom/JSON：

- 产物：`docs/.vitepress/rss.xml`、`atom.xml`、`feed.json`
- 设置站点地址：通过环境变量 `SITE_URL` 指定，例如：

```bash
SITE_URL="https://<owner>.github.io/<repo>" npm run build
```

如需单独生成：

```bash
SITE_URL="https://<owner>.github.io/<repo>" npm run rss
```

## 9）发布到 GitHub Pages（自动）

本仓库已包含工作流：`.github/workflows/deploy.yml`。

操作步骤：

1. 将仓库推送到 GitHub，分支 `main` 或 `master`。
2. 编辑工作流，将占位替换为你的信息：
   - `SITE_URL: https://<owner>.github.io/<repo>`
   - `BASE: /<repo>/`
3. 在 GitHub → Settings → Pages：
   - Build and deployment → Source 选择：GitHub Actions。

工作流会：安装依赖 → 构建 → 上传 `docs/.vitepress/dist` → 部署到 Pages。

## 10）常见问题

- 构建时报 HTML 标签错误：本配置默认 `markdown.html=false`，避免原始 HTML 引起解析问题。确需使用时改为 `true`，并确保标签闭合正确。
- 访问 404 或资源路径不对：多为 `base` 未设置为仓库名，如 `BASE=/your-repo/`。
- 中文文件名：VitePress 支持中文路径，但在 Windows 下请确保 Git 编码与终端能正确显示。

## 11）下一步

- 自定义主题外观、接入统计脚本（在 `head` 中注入）
- 组织文章分类/侧边栏
- 接入站点地图（已开启）、结构化数据、以及搜索优化

祝写作愉快！
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hexo 千篇文章的“分目录存储 + 目录树导航”实战（含 URL、分类、脚手架）]]></title>
            <link>https://herongdev.github.io/blog/posts/平台与博客/Hexo/hexo博客分类分目录组织</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/平台与博客/Hexo/hexo博客分类分目录组织</guid>
            <pubDate>Thu, 04 Sep 2025 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
> 目标：当文章**成千上万**时，既能在磁盘上**分目录管理**，又能在站点里以**目录树（分类层级）**浏览，并让 **URL 跟随分类层级**，同时保持 GitHub Project Pages 的子路径（`/blog/`）不乱。

## 1 屏跑通

1. **物理分目录**：`source/_posts/` 下建多级子目录；`hexo new post 路径/标题` 可直接写入对应子目录。
2. **URL 跟随分类层级**：把 `permalink` 改成 `:categories/:title/`，并在每篇文章的 front-matter 写层级 `categories: [父, 子]`。
3. **目录树页面**：确认有 `source/categories/index.md`（`type: categories`），NexT 会按层级展示。
4. **脚手架（scaffolds）**：为高频目录建模板，一键新建时自动带好层级分类。
5. **GitHub Pages 子路径**：你是项目页 → 继续保持 `url: https://<你>.github.io/<仓库名>` 与 `root: /<仓库名>/`。

---

## 一、物理分目录（递归扫描，直接可用）

Hexo 会**递归**读取 `source/_posts/` 的子目录，所以可以放心分层管理。

```bash
# 在 _posts 下建立层级目录
mkdir -p source/_posts/GIS/GeoServer
mkdir -p source/_posts/前端/NextJS

# 新建文章时直接带路径（两种都行）
hexo new post GIS/GeoServer/切片入门
hexo new "GIS/GeoServer/缓存与预热"
```

```yaml
# 复杂：建议开启“同名资源文件夹”，让每篇文章的图片等资产跟随文章文件夹
# _config.yml（站点根配置）只需改这一行
post_asset_folder: true
```

> 开启后，`hexo new post GIS/GeoServer/切片入门` 会生成
> `source/_posts/GIS/GeoServer/切片入门.md` 与 `source/_posts/GIS/GeoServer/切片入门/`（放图）。

## 二、URL & 页面跟“分类层级”走（而不是物理目录名）

**关键点**：页面导航与 URL 建议依赖 **front-matter 的 categories**，而不是物理目录。
这样**更可控**（物理目录可随时重构、不影响 URL）。

```yaml
# 复杂：让文章链接包含“分类层级”
# _config.yml（站点根配置）
permalink: :categories/:title/
```

> 你在 GitHub Project Pages（项目页），**继续保持子路径**（别动就对了）：

```yaml
# 复杂：站点部署在 /blog/ 子路径下
url: https://herongxhr-netizen.github.io/blog
root: /blog/
```

在每篇文章顶部写**层级分类**（数组顺序即层级）：

```md
---
title: 切片入门
date: 2025-09-04
# 复杂：层级分类会生成 /GIS/GeoServer/ 的目录层级与 URL
categories: [GIS, GeoServer]
tags: [GeoServer, 切片, 缓存]
# （可选）若想自定义更友好的英文链接
# slug: geoserver-tiling-intro
---
```

## 三、目录树页面与导航菜单

确认你已有分类页与标签页（否则先创建）：

```bash
hexo new page categories
hexo new page tags
```

编辑索引页 front-matter（**只需这几行**）：

```md
---
title: 分类
type: categories
---
```

```md
---
title: 标签
type: tags
---
```

在 NexT 主题菜单里露出入口（`themes/next/_config.yml`）：

```yaml
# 复杂：在菜单里显示分类/标签
menu:
  home: /
  categories: /categories/
  tags: /tags/
```

---

## 四、批量高效新建：自定义脚手架（scaffolds）

为高频目录做脚手架，自动带上层级分类与常用字段。

**示例 1：GIS 系列脚手架**
创建 `scaffolds/gis.md`：

```md
---
title: { { title } }
date: { { date } }
# 复杂：预置层级分类，后续文章自动套用
categories: [GIS, GeoServer]
tags:
---
```

使用（指定脚手架名）：

```bash
# 复杂：--s 指定使用自定义脚手架 "gis"
hexo new --s gis "瓦片缓存策略"
```

**示例 2：NextJS 系列脚手架**
`scaffolds/nextjs.md`：

```md
---
title: { { title } }
date: { { date } }
categories: [前端, NextJS]
tags:
---
```

使用：

```bash
hexo new --s nextjs "App Router 与 RBAC"
```

> 贴士（可选）：在 `package.json` 里加脚本别名，敲更短：

```json
{
  "scripts": {
    "new:gis": "hexo new --s gis",
    "new:next": "hexo new --s nextjs"
  }
}
```

使用：`npm run new:gis "OpenLayers 点聚合最佳实践"`

---

## 五、目录结构示例（仅供参考）

```
source/_posts/
├─ GIS/
│  └─ GeoServer/
│     ├─ 切片入门.md
│     ├─ 切片入门/         # 文章同名资源文件夹（图片等）
│     └─ 缓存与预热.md
└─ 前端/
   └─ NextJS/
      └─ App Router 与 RBAC.md
```

> **注意**：物理目录**不会**自动变成 URL；URL 由 `permalink` + 文章的 `categories` 决定。

---

## 六、搜索与站点生成（与你现有配置兼容）

你已使用 `hexo-generator-searchdb`（本地搜索），与分目录/层级分类**无冲突**，无需额外改动。
每次发文后按旧流程即可：

```bash
hexo clean && hexo g && hexo s
# 自动部署（GitHub Actions）仍是：git add . && git commit && git push
```

---

## 七、常见坑位（快速定位）

- **页面 404 / 样式丢失**：`_config.yml` 的 `url/root` 未按**项目页子路径**设置（应为 `/blog/`）。
- **URL 没有层级**：缺少 `permalink: :categories/:title/` 或文章没写 `categories: [父, 子]`。
- **分类页不展示树**：`source/categories/index.md` 的 `type` 不是 `categories`；或主题菜单未加入口。
- **物理目录改变但 URL 想保持不变**：别动 front-matter 的 `categories`，URL 就不会变。
- **想迁移到“用户页”（根路径）**：把仓库改名为 `<用户名>.github.io`，并把

  ```yaml
  # 复杂：用户页改为根路径部署
  url: https://<用户名>.github.io
  root: /
  ```

  重新部署即可。

---

## 复盘清单（照这个一项项核对）

- [ ] `_config.yml` 已设置

  ```yaml
  permalink: :categories/:title/
  url: https://herongxhr-netizen.github.io/blog
  root: /blog/
  post_asset_folder: true
  ```

- [ ] 文章 front-matter 用层级分类（`[父, 子]`）。
- [ ] 有 `source/categories/index.md` 与 `type: categories`。
- [ ] NexT 菜单里有 `/categories/` 与 `/tags/`。
- [ ] 脚手架按需要创建（`scaffolds/*.md`），新建时用 `hexo new --s <脚手架> "标题"`。

---

### FAQ

**Q：必须物理分目录吗？**
A：不是必须，但**强烈建议**。这样 Git 与编辑器里都更可管理；而 URL/导航交给分类层级来控制，二者解耦。

**Q：以后想批量重构目录怎么办？**
A：直接移动文件夹即可；只要 front-matter 的 `categories` 不改，URL 不会变（避免 SEO 损失）。

**Q：图片怎么引用？**
A：启用 `post_asset_folder: true` 后，文章内用相对路径（如 `![](切片入门/示意图.png)`）即可。

---
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用 hexo 在 github 部署个人博客]]></title>
            <link>https://herongdev.github.io/blog/posts/平台与博客/Hexo/使用-hexo-在-github-部署个人博客</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/平台与博客/Hexo/使用-hexo-在-github-部署个人博客</guid>
            <pubDate>Thu, 04 Sep 2025 18:04:44 GMT</pubDate>
            <content:encoded><![CDATA[
# 整体实现思路

- **写作方式**：本地写 Markdown（VSCode/Typora），利用 Hexo 生成静态文件。
- **站点能力**：front-matter 实现**分类/标签**；装 `hexo-generator-searchdb` 提供**本地搜索**（纯静态，无后端）。
- **部署方式**：用 **GitHub Actions** 在每次 `push main` 时自动构建，把 `public/` 发布到 **`gh-pages`** 分支；**Pages** 指向该分支即可上线。
- **路径模式**：你当前是**项目页**（仓库名不是 `<用户名>.github.io`），所以站点路径是 `https://<用户名>.github.io/<仓库名>/`，Hexo 里必须设置 `url` 和 `root`。

---

# 分步实现过程

## 1）环境与初始化（已有可跳过）

```bash
npm i -g hexo-cli
hexo init blog && cd blog
npm i
hexo s   # 本地预览 http://localhost:4000
```

## 2）启用主题与“分类/标签/搜索”

```bash
# 安装 NexT（已安装可跳过）
npm i hexo-theme-next

# 生成分类与标签页面
hexo new page categories
hexo new page tags
```

在两个索引页文件顶部加 front-matter（**只需新增这几行**）：

```md
---
title: 分类
type: categories
---
```

```md
---
title: 标签
type: tags
---
```

安装本地搜索索引插件（**一次性**）：

```bash
npm i hexo-generator-searchdb --save
```

**站点配置 `_config.yml` 里新增（或确认存在）**：

```yaml
# 复杂：生成 search.json，供主题读取（静态搜索，无后端）
search:
  path: search.json
  field: post
  content: true
```

**主题配置 `themes/next/_config.yml` 里开启**：

```yaml
# 复杂：在 NexT 主题中开启本地搜索
local_search:
  enable: true
```

## 3）Hexo 站点路径设置（项目页必改）

打开根目录的 **`_config.yml`**，**只改这两行**：

```yaml
# 复杂：GitHub Project Pages 部署在 /blog/ 子路径（用你的用户名和仓库名）
url: https://<你的GitHub名>.github.io/<你的仓库名>
root: /<你的仓库名>/
```

> 你当前仓库是 `herongxhr-netizen/blog`，因此应为：
> `url: https://herongxhr-netizen.github.io/blog` > `root: /blog/`

## 4）把项目推到 GitHub（已有仓库可跳过初始化）

```bash
git init
git add .
git commit -m "init blog"
git branch -M master
git remote add origin https://github.com/<你的GitHub名>/<你的仓库名>.git
git push -u origin master
```

## 5）创建自动部署（GitHub Actions）

在仓库中新建文件 **`.github/workflows/deploy.yml`**，内容如下：

```yaml
# 复杂：构建 Hexo 并把生成的 public/ 发布到 gh-pages
name: Deploy Hexo to GitHub Pages
on:
  push:
    # 注意检查这个分支是否存在，另外还要注意master|main 两种默认主分支
    branches: [master]
permissions:
  contents: write
jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm i
      - run: npx hexo clean && npx hexo g
      - uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          publish_branch: gh-pages
```

> 作用：每次推送到 `master`，自动构建 Hexo 并把 `public/` 发布到 `gh-pages` 分支。

## 6）打开 GitHub Pages（指向 `gh-pages`）

仓库 → **Settings → Pages**：

- **Source** 选 **Deploy from a branch**
- **Branch** 选 **`gh-pages`**，**Folder** 选 **`/(root)`** → Save
  访问：`https://<你的GitHub名>.github.io/<你的仓库名>/`

## 7）写第一篇/后续文章（固定节奏）

```bash
hexo new post "我的第一篇文章"
# 编辑 source/_posts/我的第一篇文章.md，增加分类/标签 front-matter
hexo s                 # 本地预览确认
git add . && git commit -m "post: 第一篇" && git push
# -> Actions 自动构建 -> Pages 自动更新
```

## 故障排查（按频率排序）

1. **页面样式丢失或 404**

   - 九成是 `_config.yml` 的 `url/root` 不匹配“项目页子路径”。
   - 修复：按上面的两行改好 → `git push` 触发重建。

2. **推送成功但没自动发布**

   - 检查 **Actions** 是否执行、是否报“权限不足”。
   - 修复：打开 **Read and write permissions** 或在 workflow 增加 `permissions: contents: write`。

3. **Pages 仍显示旧内容**

   - 浏览器缓存或 GitHub Pages 缓存未刷新。
   - 修复：改动任意文件再推一次，或等几分钟刷新。

4. **找不到搜索框/搜索无结果**

   - 主题未开启 `local_search.enable` 或站点未生成 `search.json`。
   - 修复：确认两处配置；本地 `hexo clean && hexo g` 看 `public/search.json` 是否存在。

5. **想改成“用户页”根路径**

   - 把仓库改名为 `<你的GitHub名>.github.io`；
   - `_config.yml` 改为：

     ```yaml
     # 复杂：用户页部署在根路径
     url: https://<你的GitHub名>.github.io
     root: /
     ```

   - Pages 的 Source 仍选 `gh-pages`。

---

需要的话，把你当前 `themes/next/_config.yml` 里想开的功能（目录、代码复制、文章 TOC、暗色主题）告诉我；我会**只列需要修改的那几行**，并在复杂行上面加注释。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[什么是 `AbortController`？]]></title>
            <link>https://herongdev.github.io/blog/posts/架构与请求/请求层/AbortController-Api的使用</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/架构与请求/请求层/AbortController-Api的使用</guid>
            <pubDate>Sat, 06 Sep 2025 11:18:10 GMT</pubDate>
            <content:encoded><![CDATA[
### 什么是 `AbortController`？

`AbortController` 是一个 Web API，允许开发者在 JavaScript 中主动取消某些异步操作，例如网络请求（`fetch`）、定时器或其他可取消的操作。它是现代 Web 开发中处理异步任务的重要工具，特别是在需要中断或取消正在进行的操作时。`AbortController` 提供了简单、标准化的方式来实现取消功能，广泛用于浏览器环境。

`AbortController` 是在 WHATWG 的 DOM 规范中定义的，最初主要与 `fetch` API 配合使用，但现在也被其他 API（如 `ReadableStream`）支持。它的核心思想是提供一个信号（`AbortSignal`），通过这个信号可以通知相关操作停止执行。

---

### 核心概念

1. **AbortController**:

   - `AbortController` 是一个构造函数，用于创建控制器对象。
   - 它有一个 `signal` 属性，返回一个 `AbortSignal` 对象，用于监听取消信号。
   - 它还有一个 `abort()` 方法，调用后会触发取消信号。

2. **AbortSignal**:

   - `AbortSignal` 是 `AbortController` 的信号对象，传递给支持取消的 API（如 `fetch`）。
   - 当 `AbortController` 的 `abort()` 方法被调用时，`AbortSignal` 会触发 `abort` 事件，通知相关操作取消。

3. **用途**:
   - 取消网络请求（例如用户切换页面时取消未完成的 `fetch` 请求）。
   - 中止某些异步任务（如文件读取、流操作）。
   - 提高性能，避免不必要的资源消耗。
   - 实现用户交互中的取消功能（如取消上传或下载）。

---

### 工作原理

`AbortController` 的工作流程可以简单总结为以下步骤：

1. 创建一个 `AbortController` 实例。
2. 将其 `signal` 属性传递给支持取消的 API（如 `fetch`）。
3. 在需要取消操作时，调用 `AbortController` 的 `abort()` 方法。
4. 相关的 API 会接收到取消信号并停止操作，同时抛出 `AbortError` 异常。

---

### 使用示例

以下是一个使用 `AbortController` 取消 `fetch` 请求的详细代码示例：

```javascript
// 创建 AbortController 实例
const controller = new AbortController();
const signal = controller.signal;

// 发起一个 fetch 请求，传入 signal
fetch("https://api.example.com/data", { signal })
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("请求被取消");
    } else {
      console.error("请求失败:", error);
    }
  });

// 假设 2 秒后取消请求
setTimeout(() => {
  controller.abort(); // 调用 abort() 方法取消请求
}, 2000);
```

#### 代码解释：

- `new AbortController()` 创建控制器。
- `controller.signal` 获取信号对象，传递给 `fetch` 的 `signal` 选项。
- `controller.abort()` 触发取消，`fetch` 请求会立即停止，并抛出 `AbortError`。
- 使用 `catch` 捕获错误并判断是否为 `AbortError`。

---

### 实际应用场景

1. **取消网络请求**:

   - 用户在页面上点击“搜索”，但在结果返回前又切换到另一个页面，可以用 `AbortController` 取消未完成的请求，避免浪费带宽。
   - 示例：用户在输入框快速输入时，取消之前的搜索请求，只处理最新的请求。

2. **清理定时器或事件监听器**:

   - 虽然 `AbortController` 本身不直接控制 `setTimeout` 或事件监听器，但可以通过监听 `AbortSignal` 的 `abort` 事件来实现类似功能。

3. **流操作**:

   - 在处理 `ReadableStream` 或 `WritableStream` 时，`AbortController` 可用于取消流传输。

4. **用户交互**:
   - 提供“取消”按钮，让用户手动中止上传、下载或其他耗时操作。

---

### 高级用法：监听 `AbortSignal` 事件

`AbortSignal` 是一个 `EventTarget`，可以监听其 `abort` 事件，用于自定义取消逻辑。

```javascript
const controller = new AbortController();
const signal = controller.signal;

// 监听 abort 事件
signal.addEventListener("abort", () => {
  console.log("操作已被取消");
});

// 模拟一个异步任务
async function doWork() {
  try {
    const response = await fetch("https://api.example.com/data", { signal });
    const data = await response.json();
    console.log(data);
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("任务被取消");
    } else {
      console.error("任务失败:", error);
    }
  }
}

doWork();

// 3 秒后取消任务
setTimeout(() => {
  controller.abort();
}, 3000);
```

#### 说明：

- `signal.addEventListener('abort', ...)` 监听取消事件。
- 可以在取消时执行额外的清理逻辑，例如关闭资源或更新 UI。

---

### 注意事项

1. **浏览器兼容性**:

   - `AbortController` 在现代浏览器（如 Chrome、Firefox、Safari）中广泛支持，IE 不支持。
   - 对于旧浏览器，可能需要使用 polyfill。

2. **异常处理**:

   - 调用 `abort()` 后，相关 API 会抛出 `AbortError`，需要在代码中捕获并处理。

3. **不可恢复**:

   - 一旦调用 `abort()`，`AbortController` 实例不可重用，必须创建新的实例。

4. **支持的 API**:

   - 目前主要与 `fetch` 和 `ReadableStream` 等 API 配合使用，其他场景需要开发者手动实现取消逻辑。

5. **性能优化**:
   - 使用 `AbortController` 可以减少不必要的资源消耗，尤其在高并发或频繁请求的场景下。

---

### 扩展：结合 React 示例

在 React 中，`AbortController` 常用于组件卸载时取消请求，避免内存泄漏。

```javascript
import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    const controller = new AbortController();
    const signal = controller.signal;

    async function fetchData() {
      try {
        const response = await fetch("https://api.example.com/data", {
          signal,
        });
        const data = await response.json();
        console.log(data);
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("请求被取消");
        } else {
          console.error("请求失败:", error);
        }
      }
    }

    fetchData();

    // 组件卸载时取消请求
    return () => {
      controller.abort();
    };
  }, []);

  return <div>加载中...</div>;
}
```

#### 说明：

- 在 `useEffect` 中创建 `AbortController`。
- 在组件卸载时（`return` 回调），调用 `abort()` 取消请求。
- 防止因组件卸载而导致的内存泄漏或状态更新错误。

---

### 总结

`AbortController` 是一个简单而强大的工具，用于在 Web 开发中取消异步操作。它通过 `AbortSignal` 提供了一种标准化的取消机制，广泛应用于 `fetch` 请求、流操作等场景。它的主要优点包括：

- **简单易用**：只需要创建控制器并调用 `abort()` 即可。
- **灵活性**：支持多种异步操作的取消。
- **性能优化**：避免不必要的资源消耗。
- **现代化**：符合现代 Web 开发的需求，特别是在用户交互和性能敏感的场景中。

通过合理使用 `AbortController`，开发者可以更好地管理异步任务，提升 Web 应用的性能和用户体验。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）]]></title>
            <link>https://herongdev.github.io/blog/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）</guid>
            <pubDate>Sat, 06 Sep 2025 16:20:26 GMT</pubDate>
            <content:encoded><![CDATA[
````yaml
title: Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）
date: 2025-09-06
tags:
  - Axios
  - Vue3
  - TypeScript
  - Interceptor
  - Auth
---

## 目标
- 保留按前缀（如 `/api/pub`）**自动放行**的白名单机制；
- 支持**逐请求显式关闭鉴权**（即便该接口不在白名单里）；
- 避免与 Axios 自带的 `config.auth`（Basic Auth）混淆；
- 兼容历史 `(req as any).auth` 写法，**渐进迁移**到 `useAuth`。

## 方案总览
1. **类型扩展**：给 `AxiosRequestConfig` 增加 `useAuth?: boolean`。
2. **对象式入口透传**：`http.call({... useAuth })` 直达拦截器。
3. **拦截器优先级**：优先读 `useAuth` → 回退老的 `auth` → 再按前缀与实例默认值判定。
4. **显式移除头**：当不需要鉴权时，从请求头里**删除** `Authorization`，避免误带默认 token。
5. **调用方式**：`http.get/post(..., { useAuth:false })` 或 `http.call({ useAuth:false })`。

---

## 关键改动（最小补丁）

### 1) 扩展 Axios 配置
> 避免与 Basic Auth 的 `config.auth` 冲突，用单独的 `useAuth`。

```ts
// src/types/http/axios.d.ts
declare module 'axios' {
  export interface AxiosRequestConfig {
    /** 覆盖实例默认鉴权：true=强制带token；false=强制不带token */
    useAuth?: boolean
  }
}
````

### 2) 对象式入口支持 `useAuth`

```ts
// src/lib/http/types.ts（RequestOptions 中新增）
useAuth?: boolean
```

```ts
// src/lib/http/call.ts（buildAxiosConfigFromOptions 末尾透传）
if (typeof (options as any).useAuth === "boolean") {
  (cfg as any).useAuth = (options as any).useAuth;
}
```

### 3) 请求拦截器：判定与显式移除头

```ts
// src/lib/http/client.ts（拦截器内替换判定片段）

// 1) 优先 useAuth，回退旧的 auth
const explicitAuth =
  typeof (req as any).useAuth === "boolean"
    ? (req as any).useAuth
    : typeof (req as any).auth === "boolean"
    ? (req as any).auth
    : undefined;

const needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);
const accToken = storage.get(ACCESS_TOKEN);
const tokenType = storage.get(TOKEN_TYPE) || "Bearer";

// 2) 不需要鉴权：显式移除 Authorization，避免误带默认头
if (!needAuth) {
  const h = (req.headers || {}) as Record<string, any>;
  delete h.Authorization;
  delete h.authorization;
  req.headers = h;
} else {
  // 需要鉴权但无 token：中断
  if (!accToken) {
    abortController.abort();
    return Promise.reject(new Error("UNAUTHENTICATED"));
  }
  // 需要鉴权且有 token：注入
  req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };
}
```

---

## 调用方式示例

### A) 传统 axios 三参（推荐）

```ts
// 公开接口（不走 /api/pub，但也不需要 token）
await http.get("/api/third/get_login_credential_code", { useAuth: false });

// POST 且不带 token
await http.post("/api/third/login_by_credential", payload, { useAuth: false });
```

### B) 对象式入口

```ts
await http.call({
  url: "/api/third/get_login_credential_code",
  method: "GET",
  useAuth: false,
});

await http.call({
  url: "/api/third/login_by_credential",
  method: "POST",
  data: payload,
  useAuth: false,
});
```

---

## 兼容与迁移

- 旧代码里的 `(req as any).auth = false` 仍可用（拦截器已回退支持），但**建议逐步统一到 `useAuth`**。
- 仍保留 `publicPrefixes`（如 `/api/pub`）自动放行；`useAuth:false` 仅在**个别不走白名单的公开接口**上使用。

---

## 常见坑

- **不要**再用 `config.auth = false`：那是 Basic Auth，类型不对、语义也不对。
- 如果调用过 `http.setAuthToken` 写了默认头，**不显式移除**就会误带 token；本方案在拦截器中已处理。
- 确保 `tsconfig.json` 的 `include` 覆盖到 `src/types`，让编辑器识别 `useAuth` 类型。

---

## 验收清单

- [ ] `src/types/http/axios.d.ts` 已生效（编辑器能识别 `useAuth`）。
- [ ] `http.call` 能接收 `useAuth` 并透传到拦截器。
- [ ] 拦截器在 `useAuth:false` 时**不发送 Authorization**；在需要鉴权但无 token 时**立即中断**。
- [ ] 现网公开接口（不在 `/api/pub`）能通过 `{ useAuth:false }` 正常调用。

> 结论：这套改动**小而稳**，语义清晰、类型安全，满足“前缀白名单 + 逐请求显式关闭鉴权”的企业级最佳实践。

```
::contentReference[oaicite:0]{index=0}
```
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[「请求层大重构」——从散乱到企业级：类型、目录与演进路线]]></title>
            <link>https://herongdev.github.io/blog/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线</guid>
            <pubDate>Sat, 06 Sep 2025 11:58:07 GMT</pubDate>
            <content:encoded><![CDATA[
## 目标与判断

你的现状：页面里混着 `api.d.ts / axios.d.ts / common.ts` 等类型与封装，随着“对象入参 + 零破坏兼容”推进，类型边界和目录粘在一起，开始“乱”。

**结论（大厂常用做法）**：保持 `axios` 原语义不覆写，新增对象式入口（如 `http.call`）；**类型集中管理**、**代码生成** 与 **运行时校验** 组合；请求层**分三层**（core/http、api/generated、api/modules），再用**查询层**（TanStack Query/Vue Query）管理缓存与重试；本地与集成测试统一用 **MSW** 拦截网络层。这些都是一线公司里稳定落地的模式。([axios-http.com][1], [orval.dev][2], [GitHub][3], [tanstack.com][4], [mswjs.io][5])

---

## 推荐目录（企业级分层）

```txt
src/
  lib/
    http/                      # Core 请求层（只做“通用能力”）
      client.ts                # axios 实例与拦截器（不覆写 axios.request）
      call.ts                  # 新增对象式入口：http.call(options)
      interceptors.ts          # 拦截器拆分：auth、retry、logging
      cancel.ts                # 取消池/AbortController 管理
      types.ts                 # RequestOptions、HttpError、CodeResponse 等
      index.ts                 # 统一导出 http 实例与类型
  api/
    __generated__/             # OpenAPI 代码生成产物（只读）
      client.ts
      schemas.ts               # 可选：导出 Zod/类型
      README.md
    modules/                   # 领域 API（手写，薄封装）
      user.ts
      order.ts
      price.ts
  features/                    # 业务功能（视框架而定：React/Vue）
    price-trend/
      queries.ts               # TanStack Query/Vue Query 的 hooks
      components/...
  types/
    http/                      # 类型声明集中地（仅 .d.ts）
      axios.d.ts               # module augmentation：扩展 AxiosInstance（如 .call）
      api.d.ts                 # 全局响应范式、工具类型
    common.ts                  # 与请求无关的通用类型
tests/
  msw/
    server.ts                  # MSW 服务端/浏览器初始化
    handlers/                  # 接口级别的 mock 处理器
```

- `lib/http` 只做“通用能力”（超时、重试、鉴权、取消、日志、错误规约），**不写任何“业务 URL”**；这能保证“可替换/可迁移”。拦截器是 axios 官方推荐扩展点。([axios-http.com][1])
- `api/__generated__` 用 OpenAPI/Swagger **生成**强类型客户端，避免手写 drift；常见工具：**orval**、**openapi-typescript-codegen**、OpenAPI Generator。([orval.dev][2], [GitHub][3], [openapi-generator.tech][6])
- `api/modules` 是“轻薄门面层”：把生成代码或 `http.call` 包一层，落地**统一的错误/返回范式**，方便埋点与切面。
- `features/*/queries.ts` 将请求函数交给 **TanStack Query/Vue Query** 管理缓存、并发、重试、失效、SSR 等。([tanstack.com][7])
- `tests/msw` 用 **MSW** 在浏览器/Node 统一拦截 HTTP，保证本地/CI 可重复。([mswjs.io][5])

---

## 类型与声明管理：收口与增量

### 1) `.d.ts` **只放声明，不放实现**

- 将你现有的 `api.d.ts / axios.d.ts` **合并/去重**后放到 `src/types/http/` 下，职责清晰：

  - `axios.d.ts`：**module augmentation**（扩展 `AxiosInstance`，如新增 `call<T>()` 签名，不改原生 `get/post`）。TypeScript 官方建议通过声明合并做到“对第三方库的扩展”。([typescriptlang.org][8], [Stack Overflow][9], [futurestud.io][10])
  - `api.d.ts`：与后端约定的响应外层、错误码、工具类型（如 `CodeResponse<T>`、`PageResp<T>`）。

- `common.ts` 只保留**与请求无关**的通用类型/常量，避免耦合。

> **示例（module augmentation）**：将 `.call` 加入 `AxiosInstance`（放 `src/types/http/axios.d.ts`）

```ts
// 在同名模块作用域内“声明合并”，不会改动运行时代码
declare module "axios" {
  export interface AxiosInstance {
    // 简化：对象式入口
    call<T = any, P = Record<string, any>>(options: {
      url: string;
      method?: import("axios").Method;
      params?: P;
      data?: unknown;
      requestConfig?: import("axios").AxiosRequestConfig;
      contentType?: "json" | "urlencoded" | "formdata";
    }): Promise<T>;
  }
}
```

### 2) **运行时校验（可选但推荐）**

- 对关键接口采用 **Zod**/生成器产出的 schema，做“入站/出站”校验，尽早暴露协议漂移。([Zod][11])
- 如果你用 **Zodios**，可直接以 Zod 定义端点 → 生成强类型 axios 客户端。([zodios.org][12], [npm][13])

---

## 代码生成：把“类型维护成本”降到最低

- **orval**：从 OpenAPI 生成 TS 客户端，内置 React/Vue Query 集成、缓存与 MSW mock 模板，工程化最佳。([orval.dev][2], [GitHub][14], [npm][15])
- **openapi-typescript-codegen**：轻量、纯客户端生成，适合你已有 Query 层。([GitHub][16])

> 建议：把生成产物放进 `src/api/__generated__`，并**加入 lint/tsc**，但**排除 format**（防止误改）。CI 里加“变更即失败”的 diff 检查，确保版本与后端规范同步。

---

## Core HTTP 的“硬规范”

1. **不覆写** `axios.request`，新增 `http.call(options)`，保持 `http.get/post/...` 零破坏兼容（你已走在正确路线上）。
2. **拦截器**：鉴权（注入 `Authorization`）、401 统一处理、取消池、日志/链路 ID、错误归一化。([axios-http.com][1])
3. **FormData 正确处理**：

   - **不要手动设置** `Content-Type: multipart/form-data`，让浏览器带 boundary；否则容易 4xx/网络错误。([axios-http.com][17], [GitHub][18])

4. **错误范式**：将 `AxiosError` → 统一 `HttpError`（含 `status`、`code`、`message`、`traceId`、`isNetworkError`）。
5. **请求命名与埋点**：在 `requestConfig` 中允许 `opName`、`skipAuth`、`retry` 等自定义键，统一日志与灰度。

---

## 查询层（React/Vue）：“把副作用交给专业工具”

- 用 **TanStack Query / Vue Query** 管理缓存、并发去重、后台刷新、窗口聚焦重刷、错误边界、SSR/Hydration、离线等硬问题；你的 `http.call` / 生成客户端只需提供 **纯函数** 即可。([tanstack.com][19])
- 典型封装（以 React 为例）：

```ts
// features/price-trend/queries.ts
import { useQuery } from "@tanstack/react-query";
import { priceApi } from "@/api/modules/price";

export const useGamePriceTrend = (gameId: string, stores: string[]) =>
  useQuery({
    queryKey: ["priceTrend", gameId, stores],
    // 复杂逻辑上一行注释：调用领域 API，返回 Promise，交由 Query 管理缓存与失败重试
    queryFn: () => priceApi.getTrend({ gameId, stores }),
    staleTime: 5 * 60 * 1000,
    gcTime: 60 * 60 * 1000,
    retry: 2,
  });
```

> TanStack 官方定位就是“声明式异步/服务端状态管理”，在大厂广泛使用。([tanstack.com][7])

---

## Mock 与测试：MSW 打通本地与 CI

- **MSW** 在浏览器/Node 拦截真实网络层，mock 定义可复用到 Storybook/E2E/单元测试，减少“环境不可用”的波动。([mswjs.io][5])
- 放到 `tests/msw/handlers`，与 `api/modules` 一一对应；生成器也能产出 mock 模板（如 orval）。([GitHub][14])

---

## 迁移策略（零停机）

1. **先落地 core/http 与 `http.call`**（不动 `get/post`）。
2. **挑 1 ～ 2 个模块**迁移到 `api/modules`（使用 `http.call` 或 `__generated__` 客户端），沉淀错误与重试策略。
3. **接入 TanStack/Vue Query** 的“易变接口”（价格趋势、榜单、列表）以验证缓存收益。
4. 稳定后再逐步 **把老的页面直连 http 的代码迁到 modules**；期间保留 `api.d.ts` 的兼容类型，避免一次性爆炸式改动。
5. 接入 **MSW** 保障端到端可测。

---

## 你现有文件的落位建议

- `/mnt/data/api.d.ts` → `src/types/http/api.d.ts`（保留响应范式与工具类型，去掉与 axios 的交叉声明）
- `/mnt/data/axios.d.ts` → `src/types/http/axios.d.ts`（**只做 module augmentation**：为 `AxiosInstance` 增加 `.call` 的签名，不定义实现）
- `/mnt/data/common.ts` → `src/types/common.ts`（与请求无关的类型保留在此；若有请求相关的工具类型，迁到 `lib/http/types.ts`）

---

## 最小代码约定（只列关键片段）

```ts
// lib/http/call.ts
import type { AxiosRequestConfig, Method } from "axios";
import http from "./client";
import { toFormData, toUrlencoded } from "./utils";

export type RequestContentType = "json" | "urlencoded" | "formdata";
export interface RequestOptions<P = Record<string, any>> {
  url: string;
  method?: Method;
  params?: P;
  data?: unknown;
  requestConfig?: AxiosRequestConfig;
  contentType?: RequestContentType;
}

export async function call<T, P = Record<string, any>>(
  opt: RequestOptions<P>
): Promise<T> {
  const {
    url,
    method = "GET",
    params,
    data,
    requestConfig,
    contentType = "json",
  } = opt;
  if (!url) throw new Error("Missing url");

  const cfg: AxiosRequestConfig = { ...(requestConfig || {}), url, method };
  if (method === "GET" || method === "HEAD") {
    cfg.params = params ?? requestConfig?.params;
  } else {
    // 复杂逻辑上一行注释：统一 body 选择并按 contentType 组织
    const body = data ?? params ?? requestConfig?.data;
    if (contentType === "formdata")
      cfg.data = body instanceof FormData ? body : toFormData(body as any);
    else if (contentType === "urlencoded")
      cfg.data =
        body instanceof URLSearchParams
          ? body
          : toUrlencoded((body ?? {}) as any);
    else cfg.data = body;
  }
  return http.request(cfg) as Promise<T>;
}
```

> `client.ts` 里注册拦截器与取消池；`index.ts` 里 `export { http }` 与 `export { call }`；FormData 时**别手动设置** `Content-Type`，让浏览器带 boundary（官方文档有说明，也有 issue 讨论）。([axios-http.com][17], [GitHub][18])

---

## 校验清单（落地前检查）

- [ ] **不覆写** `axios.request`；保留 `http.get/post/...`
- [ ] `.d.ts` **只放声明**；`axios.d.ts` 仅做 module augmentation
- [ ] `http.call` **对象式入口**可用；FormData 不手设 `Content-Type`
- [ ] 统一 `HttpError`；401/取消池/日志在拦截器层
- [ ] 关键接口用 **Zod** 校验或生成器 schema
- [ ] 接入 **TanStack/Vue Query** 管理缓存与重试
- [ ] **MSW** 拦截器与 handlers 就位；本地/CI 可跑通

---

## 参考与延伸

- Axios 拦截器官方文档（拦截请求/响应的标准扩展点）。([axios-http.com][1])
- Axios Multipart/FormData 说明（自动序列化；不要手动 `Content-Type`）。([axios-http.com][17])
- 不要手动设置 FormData 的 `Content-Type`（社区/issue 共识）。([GitHub][18], [Stack Overflow][20])
- TypeScript **声明合并 / 模块增强**（官方手册）。([typescriptlang.org][8])
- Orval（OpenAPI → TS 客户端、Query、MSW mock 一体化）。([orval.dev][2], [GitHub][14])
- openapi-typescript-codegen（轻量生成 TS 客户端）。([GitHub][16])
- TanStack Query（React/Vue 的服务端状态/数据获取）。([tanstack.com][4])
- MSW（浏览器/Node 的网络层 API Mock）。([mswjs.io][5])

---

如果你愿意，我可以把你现有的 `api.d.ts / axios.d.ts / common.ts` **逐条清点**并给出**迁移 diff**（仅贴需要修改的片段，复杂处在上一行加注释），直接落到上面的目录结构里。

[1]: https://axios-http.com/docs/interceptors?utm_source=chatgpt.com "Interceptors | Axios Docs"
[2]: https://orval.dev/?utm_source=chatgpt.com "orval - Restful client generator"
[3]: https://github.com/ferdikoomen/openapi-typescript-codegen/wiki?utm_source=chatgpt.com "Home · ferdikoomen/openapi-typescript-codegen Wiki"
[4]: https://tanstack.com/query/docs?utm_source=chatgpt.com "TanStack Query"
[5]: https://mswjs.io/docs/?utm_source=chatgpt.com "Introduction - Mock Service Worker"
[6]: https://openapi-generator.tech/docs/generators/typescript/?utm_source=chatgpt.com "Documentation for the typescript Generator"
[7]: https://tanstack.com/query/latest/docs?utm_source=chatgpt.com "Overview | TanStack Query React Docs"
[8]: https://www.typescriptlang.org/docs/handbook/declaration-merging.html?utm_source=chatgpt.com "Documentation - Declaration Merging"
[9]: https://stackoverflow.com/questions/52637028/how-can-i-use-typescripts-declaration-merging-with-an-interface-imported-from-a?utm_source=chatgpt.com "How can I use Typescript's declaration merging with an ..."
[10]: https://futurestud.io/tutorials/typescript-module-augmentation-overwrites-declarations-instead-of-merging-them?utm_source=chatgpt.com "TypeScript — Module Augmentation Overwrites Declarations ..."
[11]: https://zod.dev/?utm_source=chatgpt.com "Zod: Intro"
[12]: https://www.zodios.org/?utm_source=chatgpt.com "Zodios | Zodios"
[13]: https://www.npmjs.com/package/%40zodios/axios?activeTab=readme&utm_source=chatgpt.com "zodios/axios"
[14]: https://github.com/orval-labs/orval?utm_source=chatgpt.com "orval-labs/orval"
[15]: https://www.npmjs.com/package/orval?utm_source=chatgpt.com "orval"
[16]: https://github.com/ferdikoomen/openapi-typescript-codegen?utm_source=chatgpt.com "ferdikoomen/openapi-typescript-codegen"
[17]: https://axios-http.com/docs/multipart?utm_source=chatgpt.com "Multipart Bodies | Axios Docs"
[18]: https://github.com/axios/axios/issues/5067?utm_source=chatgpt.com "Content type changed from multipart/form-data to ..."
[19]: https://tanstack.com/query/v5/docs/react/guides/queries?utm_source=chatgpt.com "TanStack Query React Docs"
[20]: https://stackoverflow.com/questions/75742226/cant-set-content-type-header-for-axios-with-formdata?utm_source=chatgpt.com "Can't set Content-Type header for axios with FormData"

下面给你一套**可直接落地**的企业级请求层目录与**所有涉及文件的完整代码**（不使用 Hexo）。
特点：不覆盖 `axios.request`、保留 `http.get/post/...` 零破坏；新增对象式入口 `http.call(options)`；类型集中在 `.d.ts` 与 `types.ts`；复杂逻辑行已在上一行加中文注释。

---

## 目录结构

```
src/
  lib/
    http/
      client.ts
      call.ts
      types.ts
      utils.ts
      index.ts
  api/
    modules/
      user.ts
      price.ts
  types/
    http/
      axios.d.ts
      api.d.ts
    common.ts
  tests/
    msw/
      server.ts
      handlers/
        price.ts
```

> 说明：`api/__generated__`（OpenAPI 代码生成）在此略去，你可以后续接入 orval/openapi-typescript-codegen；当前示例定位为手写模块层。

---

## src/lib/http/types.ts

```ts
import type {
  AxiosInstance,
  AxiosRequestConfig,
  Method,
  AxiosResponse,
} from "axios";

/** 请求体类型枚举 */
export type RequestContentType = "json" | "urlencoded" | "formdata";

/** 对象式入参：与 axios 原生保持解耦 */
export interface RequestOptions<P = Record<string, any>> {
  url: string;
  method?: Method;
  /** GET/HEAD 下作为查询串；非 GET/HEAD 下作为 body 的回退来源 */
  params?: P;
  /** 非 GET/HEAD 的首选请求体 */
  data?: unknown;
  /** 附加的 axios 配置（headers/timeout/signal 等） */
  requestConfig?: AxiosRequestConfig;
  contentType?: RequestContentType;
}

/** 统一的错误对象，可在拦截器里规约 */
export interface HttpError extends Error {
  status?: number;
  code?: number | string;
  data?: unknown;
  traceId?: string;
  isNetworkError?: boolean;
}

/** 统一的响应解析器签名：返回 undefined 表示“跳过，让后续解析器或原始响应继续处理” */
export type ResponseParser<T = any, R = AxiosResponse<any>> = (
  resp: R
) => T | undefined;

/** 为 http 实例扩展的方法（实现见 client.ts / call.ts） */
export interface HttpInstance extends AxiosInstance {
  call<T = any, P = Record<string, any>>(
    options: RequestOptions<P>
  ): Promise<T>;
  cancelAll(): void;
  setAuthToken(token?: string | null, type?: string): void;
  setGlobalParser(parsers: ResponseParser<any, any>[]): void;
  setAuthorization(token: string, expires: number | Date, name?: string): void;
  removeAuthorization(name?: string): void;
  checkAuthorization(name?: string): boolean;
}
```

---

## src/lib/http/utils.ts

```ts
/** 将对象转为 FormData；数组按 key[] 追加；对象值 JSON.stringify */
export function toFormData(params?: Record<string | number, unknown>) {
  const formData = new FormData();
  if (!params) return formData;
  Object.entries(params).forEach(([k, v]) => {
    if (Array.isArray(v)) {
      v.forEach((val) =>
        formData.append(
          `${k}[]`,
          typeof val === "object" ? JSON.stringify(val) : String(val)
        )
      );
    } else if (typeof v === "object" && v !== null) {
      formData.append(k, JSON.stringify(v));
    } else if (v !== null && v !== undefined) {
      formData.append(k, String(v));
    }
  });
  return formData;
}

/** 将对象转为 application/x-www-form-urlencoded（支持嵌套/数组） */
export function toUrlencoded(params: Record<string | number, unknown>) {
  const urlencoded = new URLSearchParams();
  function walk(obj: Record<string | number, unknown>, parent = "") {
    for (const [k, v] of Object.entries(obj)) {
      const key = parent ? `${parent}[${k}]` : k;
      if (v === null || v === undefined) continue;
      if (Array.isArray(v)) {
        v.forEach((item) =>
          urlencoded.append(
            `${key}[]`,
            typeof item === "object" ? JSON.stringify(item) : String(item)
          )
        );
      } else if (typeof v === "object") {
        walk(v as Record<string | number, unknown>, key);
      } else {
        urlencoded.append(key, String(v));
      }
    }
  }
  walk(params);
  return urlencoded;
}
```

---

## src/lib/http/call.ts

```ts
import type { AxiosRequestConfig } from "axios";
import qs from "qs";
import type { RequestOptions } from "./types";
import { toFormData, toUrlencoded } from "./utils";

/** 复杂逻辑上一行注释：根据 contentType 组织 body 并设置 headers/paramsSerializer */
export function buildAxiosConfigFromOptions(
  options: RequestOptions
): AxiosRequestConfig {
  const {
    url,
    method = "GET",
    params,
    data,
    requestConfig,
    contentType = "json",
  } = options;

  if (!url) throw new Error("Missing url");

  const cfg: AxiosRequestConfig = {
    ...(requestConfig || {}),
    url,
    method,
    headers: {
      // 默认 Content-Type，稍后允许外部覆盖；formdata 会主动删除以让浏览器自动带 boundary
      "Content-Type":
        contentType === "urlencoded"
          ? "application/x-www-form-urlencoded"
          : "application/json",
      ...(requestConfig?.headers || {}),
    },
  };

  if (method === "GET" || method === "HEAD") {
    cfg.params = params ?? requestConfig?.params;
    // 复杂逻辑上一行注释：数组无索引、跳过 null
    cfg.paramsSerializer = (d) =>
      qs.stringify(d, { indices: false, skipNulls: true });
  } else {
    // 复杂逻辑上一行注释：优先 data，回退 params（兼容旧思路）
    const body = data ?? params ?? requestConfig?.data;
    if (contentType === "formdata") {
      // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type
      if (cfg.headers) delete (cfg.headers as any)["Content-Type"];
      cfg.data = body instanceof FormData ? body : toFormData(body as any);
    } else if (contentType === "urlencoded") {
      cfg.data =
        body instanceof URLSearchParams
          ? body
          : toUrlencoded((body ?? {}) as Record<string, any>);
      cfg.headers = {
        ...cfg.headers,
        "Content-Type": "application/x-www-form-urlencoded",
      };
    } else {
      cfg.data = body;
      cfg.headers = { ...cfg.headers, "Content-Type": "application/json" };
    }
  }
  return cfg;
}
```

---

## src/lib/http/client.ts

```ts
import axios from "axios";
import Cookie from "js-cookie";
import storage from "store";
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";
import type { HttpInstance, ResponseParser } from "./types";
import { buildAxiosConfigFromOptions } from "./call";
import { STORAGE_KEYS } from "@/constants";
import { LOGIN_ROUTE } from "@/router/constants";

const { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;

/** —— 取消池：统一管理所有请求的 AbortController —— */
const abortPool = new Set<AbortController>();

/** 对外暴露：集中取消所有未决请求（如退出登录时） */
function cancelAll() {
  abortPool.forEach((c) => c.abort());
  abortPool.clear();
}

/** 创建 axios 实例并安装拦截器 */
function createAxiosHttp(
  config: AxiosRequestConfig,
  opts: {
    authDefault?: boolean;
    publicPrefixes?: string[];
  } = {}
): HttpInstance {
  const authDefault = opts.authDefault ?? true;
  const publicPrefixes = opts.publicPrefixes ?? ["/api/pub"];

  const _axios = axios.create(config) as AxiosInstance;

  // —— 业务增强：全局解析器（按顺序尝试，返回 undefined 表示跳过） ——
  (_axios as any).setGlobalParser = (parsers: ResponseParser<any, any>[]) => {
    _axios.interceptors.response.use(
      (resp: AxiosResponse) => {
        for (const p of parsers) {
          const r = p(resp);
          if (r !== undefined) return r;
        }
        return resp;
      },
      (err) => {
        if (err?.response) {
          const e: any = new Error(err.response.statusText);
          e.status = err.response.status;
          e.code = err.response.data?.code;
          e.data = err.response.data;
          throw e;
        }
        // 网络层错误（超时/断网/跨域）
        const e: any = new Error(err?.message || "Network Error");
        e.isNetworkError = true;
        throw e;
      }
    );
  };

  // —— cookie 鉴权工具方法（部分场景需要，同你原实现保持一致） ——
  (_axios as any).setAuthorization = (
    token: string,
    expires: number | Date,
    name?: string
  ) => {
    Cookie.set(name ?? _axios.defaults.xsrfCookieName!, token, { expires });
  };
  (_axios as any).removeAuthorization = (name?: string) => {
    Cookie.remove(name ?? _axios.defaults.xsrfCookieName!);
  };
  (_axios as any).checkAuthorization = (name?: string) => {
    return Boolean(Cookie.get(name ?? _axios.defaults.xsrfCookieName!));
  };

  // —— 请求拦截器：统一接入取消池/授权头/公开前缀 ——
  _axios.interceptors.request.use((req) => {
    // 复杂逻辑上一行注释：桥接外部 signal 与内部 AbortController，并加入取消池
    const abortController = new AbortController();
    if ((req as any).signal) {
      const ext = (req as any).signal as AbortSignal;
      if (ext.aborted) abortController.abort();
      else ext.addEventListener?.("abort", () => abortController.abort());
    }
    (req as any).signal = abortController.signal;
    abortPool.add(abortController);
    // 复杂逻辑上一行注释：把 controller 暂存在 config 上，响应阶段释放
    (req as any).__abortController = abortController;

    // 复杂逻辑上一行注释：根据前缀与开关决定是否附加 Authorization
    const url = req.url || "";
    const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));
    // 优先使用 req.auth(boolean)；否则用实例默认值 + 前缀约定
    const explicitAuth =
      typeof (req as any).auth === "boolean" ? (req as any).auth : undefined;
    const needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);
    const accToken = storage.get(ACCESS_TOKEN);
    const tokenType = storage.get(TOKEN_TYPE) || "Bearer";
    if (needAuth && !accToken) {
      ((req as any).__abortController as AbortController | undefined)?.abort();
      return Promise.reject(new Error("UNAUTHENTICATED"));
    }
    if (needAuth && accToken) {
      req.headers = {
        ...req.headers,
        Authorization: `${tokenType} ${accToken}`,
      };
    }
    return req;
  });

  // —— 响应拦截器：释放取消控制器；401 统一处理 ——
  _axios.interceptors.response.use(
    (res) => {
      const abortController = (res.config as any).__abortController as
        | AbortController
        | undefined;
      if (abortController) abortPool.delete(abortController);
      return res;
    },
    (err) => {
      if (err?.response?.status === 401) {
        storage.remove(ACCESS_TOKEN);
        storage.remove(TOKEN_TYPE);
        if (window.location.pathname !== LOGIN_ROUTE.path) {
          window.location.replace(LOGIN_ROUTE.path);
        }
      }
      const abortController = (err?.config as any)?.__abortController as
        | AbortController
        | undefined;
      if (abortController) abortPool.delete(abortController);
      return Promise.reject(err);
    }
  );

  // —— 实例级取消 ——
  (_axios as any).cancelAll = cancelAll;

  // —— 实例级鉴权头设置（与本地存储联动） ——
  (_axios as any).setAuthToken = (token?: string | null, type = "Bearer") => {
    if (token) {
      _axios.defaults.headers.common.Authorization = `${type} ${token}`;
      storage.set(ACCESS_TOKEN, token);
      storage.set(TOKEN_TYPE, type);
    } else {
      delete _axios.defaults.headers.common.Authorization;
      storage.remove(ACCESS_TOKEN);
      storage.remove(TOKEN_TYPE);
    }
  };

  // —— 新增对象式入口：http.call(options) ——
  (_axios as any).call = async function <T = any>(
    options: Parameters<typeof buildAxiosConfigFromOptions>[0]
  ): Promise<T> {
    const cfg = buildAxiosConfigFromOptions(options);
    return _axios.request(cfg) as Promise<T>;
  };

  return _axios as unknown as HttpInstance;
}

const http = createAxiosHttp(
  {
    timeout: 10000,
    baseURL: import.meta.env.VITE_API_URL as string,
    withCredentials: true,
    xsrfCookieName: "Authorization",
    xsrfHeaderName: "Authorization",
  },
  { authDefault: true, publicPrefixes: ["/api/pub"] }
);

export default http;
export { cancelAll };
```

---

## src/lib/http/index.ts

```ts
export { default as http, cancelAll } from "./client";
export * from "./types";
export * from "./utils";
export * from "./call";
```

---

## src/api/modules/user.ts

```ts
import { http } from "@/lib/http";
import type { RequestOptions } from "@/lib/http/types";

/** 复杂逻辑上一行注释：领域 API 薄封装，避免页面直接感知 URL/方法/解析细节 */
export const userApi = {
  getProfile() {
    return http.get<{ id: string; name: string; roles: string[] }>(
      "/api/user/profile"
    );
  },

  updateProfile(input: { name?: string }) {
    return http.call<void>({
      url: "/api/user/profile",
      method: "PUT",
      data: input,
      contentType: "json",
    });
  },

  /** 演示：URLSearchParams */
  search(params: { keyword?: string; page?: number }) {
    const options: RequestOptions<typeof params> = {
      url: "/api/user/search",
      method: "GET",
      params,
      requestConfig: { timeout: 8000 },
    };
    return http.call<{ list: any[]; total: number }>(options);
  },
};
```

---

## src/api/modules/price.ts

```ts
import { http } from "@/lib/http";

/** 复杂逻辑上一行注释：后端采用 CodeResponse 外包裹，交由全局解析器转换 */
export const priceApi = {
  getTrend(input: { gameId: string; stores: string[] }) {
    return http.call<Array<{ store: string; date: string; price: number }>>({
      url: "/api/price/trend",
      method: "POST",
      data: input,
      contentType: "json",
      requestConfig: { timeout: 15000 },
    });
  },
};
```

---

## src/types/http/axios.d.ts

```ts
// 声明合并：扩展 AxiosInstance，而不改动运行时代码
import type { AxiosRequestConfig } from "axios";

declare module "axios" {
  export interface AxiosInstance {
    call<T = any, P = Record<string, any>>(options: {
      url: string;
      method?: Method;
      params?: P;
      data?: unknown;
      requestConfig?: AxiosRequestConfig;
      contentType?: "json" | "urlencoded" | "formdata";
    }): Promise<T>;

    cancelAll(): void;
    setAuthToken(token?: string | null, type?: string): void;
    setGlobalParser(parsers: Array<(resp: any) => any | undefined>): void;
    setAuthorization(
      token: string,
      expires: number | Date,
      name?: string
    ): void;
    removeAuthorization(name?: string): void;
    checkAuthorization(name?: string): boolean;
  }
}
```

---

## src/types/http/api.d.ts

```ts
// 与后端约定的通用响应外壳
export interface CodeResponse<T = any> {
  code: number;
  data: T;
  message?: string;
}

// 常见分页返回
export interface PageResp<T> {
  list: T[];
  total: number;
  page: number;
  pageSize: number;
}

// 解析器（如果你希望有全局类型）
export type ResponseParser<T = any, R = any> = (resp: R) => T | undefined;
```

---

## src/types/common.ts

```ts
// 放与请求无关的通用类型
export type ID = string | number;

export interface Dict<T = any> {
  [key: string]: T;
}
```

---

## （可选）全局解析器：将 CodeResponse<T> 解开

> 你可以把它放到任意初始化位置（如 `src/app.ts` 或 `src/main.ts`）并在启动时挂载。

```ts
// src/app.setup-http.ts
import type { AxiosResponse } from "axios";
import { http } from "@/lib/http";
import { LOGIN_ROUTE } from "@/router/constants";
import storage from "store";
import { STORAGE_KEYS } from "@/constants";
import type { CodeResponse } from "@/types/http/api";

const { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;

/** 复杂逻辑上一行注释：仅处理符合 CodeResponse 形状的响应，其他透传 */
function isCodeResp<T>(d: unknown): d is CodeResponse<T> {
  return (
    !!d && typeof d === "object" && "code" in (d as any) && "data" in (d as any)
  );
}

export const codeResponseParser = <T, R = CodeResponse<T>>(
  res: AxiosResponse<R>
): T | undefined => {
  const payload = res.data as any;
  if (!isCodeResp<T>(payload)) return undefined;
  const { code, data, message = "" } = payload;

  if (code === 401) {
    storage.remove(ACCESS_TOKEN);
    storage.remove(TOKEN_TYPE);
    if (window.location.pathname !== LOGIN_ROUTE.path) {
      window.location.replace(LOGIN_ROUTE.path);
    }
    throw new Error("未授权，请重新登录");
  }
  if (code === 200) return (data ?? null) as T;
  throw new Error(message || "后端错误");
};

// 启动时挂载
http.setGlobalParser([codeResponseParser]);
```

---

## tests/msw/server.ts

```ts
import { setupServer } from "msw/node";
import { handlers } from "./handlers/price";

export const server = setupServer(...handlers);

// 在测试框架的 setup 中调用：
// beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }))
// afterEach(() => server.resetHandlers())
// afterAll(() => server.close())
```

---

## tests/msw/handlers/price.ts

```ts
import { http, HttpResponse } from "msw";

// 示例：与你的 priceApi.getTrend 匹配
export const handlers = [
  http.post("/api/price/trend", async ({ request }) => {
    const body = (await request.json()) as any;
    // 复杂逻辑上一行注释：模拟后端的 CodeResponse 外壳
    return HttpResponse.json({
      code: 200,
      data: [
        { store: "Steam", date: "2025-09-01", price: 199 },
        { store: "Epic", date: "2025-09-01", price: 189 },
      ],
      message: "ok",
    });
  }),
];
```

---

# 使用要点

- 老代码：`http.get/post/...` **完全不受影响**。
- 新写法：`http.call({ url, method, data/params, contentType, requestConfig })` 更可读/可扩展。
- `FormData` 场景不要手设 `Content-Type`，已在实现里处理。
- 推荐在应用初始化处挂载 `codeResponseParser`，让模块层拿到的就是“已解壳”的数据。

如果你要把你现有的 `api.d.ts / axios.d.ts / common.ts` 内容**原封不动**迁入以上文件名，也可以把原定义贴出来，我帮你对齐/去重并完善类型冲突的 diff。

下面把你要的 **`cancel.ts` 完整代码**给出，并说明如何在 `client.ts` 接入；最后把 “FormData 自动带 boundary，需移除手动设置的 Content-Type” 的含义讲清楚。

---

## 1) `src/lib/http/cancel.ts`（完整代码）

```ts
// src/lib/http/cancel.ts

/**
 * 维护一个全局取消池，用于集中取消所有尚未完成的请求。
 * 注意：只存放“活跃中的” AbortController；请求结束后要及时释放。
 */
const abortPool = new Set<AbortController>();

/** 复杂逻辑上一行注释：把外部 signal（若有）与内部 controller 绑定，外部取消时联动内部取消 */
function linkExternalSignal(
  external?: AbortSignal,
  controller?: AbortController
) {
  if (!external || !controller) return;
  if (external.aborted) {
    // 外部已取消则立即同步内部取消
    controller.abort();
    return;
  }
  // 外部后续取消时，触发内部取消
  external.addEventListener("abort", () => controller.abort());
}

/**
 * 创建一个“已纳入取消池管理”的 AbortController。
 * - 会自动与外部 signal（如果传入）联动；
 * - 会自动加入全局 abortPool，方便统一取消；
 * - 调用方需在请求完成/失败时调用 releaseController 释放。
 */
export function makeTrackedController(
  externalSignal?: AbortSignal
): AbortController {
  const controller = new AbortController();
  linkExternalSignal(externalSignal, controller);
  abortPool.add(controller);
  return controller;
}

/** 将 controller 从取消池释放（请求完成/失败时务必调用，避免内存泄漏） */
export function releaseController(controller?: AbortController) {
  if (controller) abortPool.delete(controller);
}

/** 退出登录或全局重置时：集中取消所有未决请求 */
export function cancelAll() {
  abortPool.forEach((c) => c.abort());
  abortPool.clear();
}
```

---

## 2) 在 `client.ts` 中的**最小改动**

> 按你的偏好，这里**只给需要改的片段**，并在复杂逻辑上一行加注释。

**2.1 顶部引入：**

```ts
// + 新增
import { makeTrackedController, releaseController, cancelAll } from "./cancel";
```

**2.2 删除原本在 client.ts 里的这两段：**

```ts
// - 删除
const abortPool = new Set<AbortController>();
function cancelAll() {
  /* ...原实现... */
}
```

**2.3 请求拦截器里替换创建/管理 controller 的逻辑：**

```ts
// —— 将外部 signal 与内部 AbortController 关联，并纳入统一取消池 ——
const abortController = makeTrackedController(
  (req as any).signal as AbortSignal | undefined
);
(req as any).signal = abortController.signal;
(req as any).__abortController = abortController;
```

**2.4 响应与异常分支里释放 controller：**

```ts
// —— 请求完成：释放与该请求关联的 AbortController ——
releaseController(
  (res.config as any).__abortController as AbortController | undefined
);

// —— 异常完成：同样需要释放 AbortController ——
releaseController(
  (err?.config as any)?.__abortController as AbortController | undefined
);
```

**2.5 保持对外暴露实例方法：**

```ts
// 实例级的取消功能依然可用
(_axios as any).cancelAll = cancelAll;
```

> 这样，取消逻辑就从 `client.ts` 拆分到了独立的 `cancel.ts`，便于复用与测试；`client.ts` 里只保留“如何在拦截器中使用”的胶水代码。

---

## 3) “FormData 自动带 boundary，需移除手动设置的 Content-Type” 是啥意思？

- 当你在**浏览器环境**用 `FormData` 作为请求体时，真正发请求的是浏览器（或者 fetch/XHR），它会自动把请求头 `Content-Type` 设置成：

  ```
  Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXyz...
  ```

  这里的 `boundary` 是一段**分隔符**，用来把每个字段/文件的二进制块分割开。**这个 boundary 是浏览器动态生成的**。

- **如果你手动把 `Content-Type` 固定写成 `multipart/form-data`**（没有 `boundary=...`），服务端收到的内容就**无法正确分段解析**，经常出现 400/422 或 “Unexpected end of form / Missing boundary” 之类错误。

- 因此，在我们封装里（`contentType === 'formdata'` 分支）会：

  ```ts
  // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type
  if (cfg.headers) delete (cfg.headers as any)["Content-Type"];
  cfg.data = body instanceof FormData ? body : toFormData(body as any);
  ```

  这么做是**故意**把 `Content-Type` 删除，让浏览器自己填上带 `boundary` 的正确值。

> 小结：
>
> - **浏览器 + FormData**：不要手写 `Content-Type`，让它自动带 boundary（我们代码里已处理）。
> - **Node.js 端（无浏览器）**：若用 `form-data`/`formdata-node` 等库，也应**让库自己设置**或通过库提供的方法拿到带 `boundary` 的 header，而不是手写。

---

需要我把 `client.ts` 根据上面的片段**整合成完整文件**再贴一次，也可以说一声；但如果你已经在用我之前给的版本，只要按上面的 4 处小改即可完成 `cancel.ts` 的接入。

简短结论先给你：

- **Axios 封装没有“唯一正确解”**，但大厂普遍遵循“**分层 + 零破坏 + 渐进演进**”三原则：
  Core（http 客户端能力）→ Domain API（领域方法）→ View/State（查询层）。
- **TanStack Query（React Query / Vue Query）不是必须**。当你的页面需要**缓存、并发去重、重试、后台刷新、预取、分页/无限滚动、乐观更新**中的多项时，它的价值非常高；否则可以先不用，等复杂度上来了再加。

下面给你一套“可落地的选择题”，帮你快速拍板。

---

## 一、Axios 封装到底怎么选？

### 方案 A：**极简封装（Core + 少量 Domain API）**

适用：后端接口简单、页面少、交互不复杂，或以 **Server Actions/Route Handlers（Next.js 14）** 为主、客户端请求很少。
要点：

- Core 层：一个 `http` 实例（拦截器、取消池、统一错误、鉴权）、`http.call(options)` 对象式入口（你现在这版 ✅）。
- Domain 层：在 `src/api/modules/*` 里写薄封装函数（避免在页面拼 URL/方法）。
  优点：学习/维护成本最低；对现有代码**零破坏**。
  缺点：项目一复杂，**缓存/并发/重试**容易重复造轮子。

### 方案 B：**标准化封装（Core + Domain API + 代码生成）**

适用：接口较多、多人协作、需要**强类型**对齐后端（避免“文档/实现漂移”）。
要点：

- 在 A 的基础上加 **OpenAPI 代码生成**（orval/openapi-typescript-codegen），产物放 `api/__generated__`，**只读、不手改**。
- Domain 层再包一层“门面”，统一错误处理/埋点/灰度。
  优点：类型和接口更新**自动跟进**；减少手抄 DTO。
  缺点：引入生成链路，需要后端提供/维护 OpenAPI。

### 方案 C：**企业级（Core + Domain + 代码生成 + 查询层 TanStack）**

适用：**列表/详情很多**、需要**缓存/失效/后台刷新/并发去重/预取/SSR**等能力；或你已经遇到“重复请求、抖动、复杂 loading 状态”问题。
要点：

- 在 B 的基础上引入 **TanStack Query（React）/Vue Query（Vue3）** 做服务端状态管理。
- 页面里不直接 `http.call`，而是用 `useQuery/useMutation` 调你封装好的 Domain API。
  优点：把“**缓存/并发/重试/错误边界/重整化**”交给成熟库，页面只管渲染。
  缺点：学习成本 ↑，需要 Provider 初始化与查询键设计。

---

## 二、到底要不要用 TanStack Query？（自测 8 题）

请数一数你满足了多少条（≥3 条就**建议上**）：

1. 同一数据被**多处页面/组件复用**，且你想要**共享缓存**。
2. 同一接口在短时间内可能被**多次触发**（需要**请求去重**）。
3. 希望**失败自动重试**、**退避**，或在**网络恢复**/**窗口聚焦**时自动**后台刷新**。
4. 有**分页/无限滚动**，并且要处理**下一页预取**或**乐观更新**。
5. 需要**预取数据**（用户悬停/路由即将跳转时先打请求）。
6. 你在做 **Next.js 14** 前端页面，既有 **Server Components** 也有 **Client Components**，客户端数据要**SSR Hydration** 或 **延迟刷新**。
7. 想**显式管理缓存过期（staleTime）** 与 **垃圾回收（gcTime）**，防止反复打接口。
8. 现在已经在手写“请求缓存/合流/状态机”，感觉**心智负担**上来了。

> 结合你的项目：有**价格趋势**、**多商店选择**、**首页与详情复用价格数据**、后续还要**图表/列表**，我建议：
>
> - 在**这些“读多写少”的模块**上用 TanStack Query；
> - 其他简单页面（一次性拉取、无复杂刷新），继续用现在的 `http.call` 即可。
>   这样“**按需引入**”，增量演进，不会一刀切。

---

## 三、你现在的最佳落地路线（最少折腾）

1. **保留现有 http 层（你已完成）**

   - `client.ts + cancel.ts + call.ts + types.ts + utils.ts`，不覆盖 `axios.request`，**零破坏**保留 `get/post`。

2. **Domain API 薄封装**

   - 在 `src/api/modules/*` 暴露语义化函数（`priceApi.getTrend`等），页面不拼 URL。

3. **对“需要缓存/并发去重”的模块上 TanStack Query**

   - 只在“价格趋势、榜单、列表”这些位置用 Query，其它模块不强求。

4. **后续再接 OpenAPI 代码生成**（可选）

   - 先让 Query 跑顺，再把类型维护成本转移给生成器，逐步替换手写 DTO。

5. **MSW 做联调与测试**（可选）

   - 本地/CI 统一拦截，减少后端不可用带来的卡点。

---

## 四、常见误区（避免踩坑）

- **覆写 `axios.request`** → 破坏 `get/post` 的语义（你已经改成 `.call`，很对）。
- **手写 `Content-Type: multipart/form-data`** → FormData 的 `boundary` 会丢（我们已在 `formdata` 分支删除该头，让浏览器自动带）。
- **在组件里定义 DTO/类型** → 类型四散；建议集中到 `types/http/*` 与 `api/__generated__`。
- **重复写缓存/重试/去重** → 已有成熟轮子（TanStack Query）；自己写容易遗漏边角。
- **取消控制器不释放** → 造成内存泄漏；我们用 `releaseController` 在响应/异常两侧都释放。

---

## 五、如果暂时不用 TanStack Query，也能稳住吗？

可以。你的 `http.call + modules` 架构，配合\*\*轻量的自定义缓存（Map + 过期时间）\*\*也能顶一阵子。但一旦出现“**相同查询在多处使用**”、“**滚动列表/分页**”、“**需要重试与后台刷新**”的需求，**切到 TanStack Query 成本更低**（只需把 Domain API 包进 `useQuery`），没必要造大轮子。

---

### 你现在可以怎么做（两步）：

- **短期**：继续用现有封装；把价格趋势这块接入 Query（仅此一处），体会收益。
- **中期**：如果感觉不错，再把“新闻列表/攻略列表”等也迁到 Query；并考虑引入 OpenAPI 代码生成，降低类型维护成本。

需要的话，我可以基于你现有的模块，直接给出**一个最小的 TanStack Query 集成示例**（包含 Provider、`useQuery` 的示例调用、SSR Hydration 的注意点），只贴**必要的代码片段**，不改你现有文件结构。

结论：**你的“核心响应拦截器”（释放 AbortController + 401 跳转）先执行，`setGlobalParser` 里注册的“全局解析器”后执行**。

原因（Axios 规则）：

- **response 拦截器是 FIFO**：谁**先注册**，谁**先执行**。
- **request 拦截器是 LIFO**：谁**后注册**，谁**先执行**。（顺带一提）

在你这份代码里：

1. `createAxiosHttp` 里先注册了“核心响应拦截器”。
2. 应用启动时再调用 `http.setGlobalParser([...])`，此时**追加**一个响应拦截器。
   → 因为 response 是 FIFO，所以**核心拦截器先跑**，**全局解析器后跑**。

执行顺序具体是：

- **成功响应路径 (`fulfilled`)**
  ① 核心响应拦截器：`releaseController(...)` → `return res`
  ② 全局解析器：遍历 parsers，可能把 `AxiosResponse` 解包成你的业务数据（或继续返回原响应）

- **失败响应路径 (`rejected`)**
  ① 核心响应拦截器：遇到 `401` 清 token + 跳登录；不管什么错误都先 `releaseController(...)`；`return Promise.reject(err)`
  ② 全局解析器：拿到上一步抛出的 `err`，再做标准化/改写错误对象（如果你这么实现）

> 小提示：如果你**想让全局解析器先执行**，就必须**更早注册**它（例如把 `setGlobalParser` 的安装逻辑挪到 `createAxiosHttp` 里、并放在核心拦截器之前），或者在核心拦截器内部先调用解析器再做释放/跳转。但你当前这种“先释放/401，再解析”的顺序其实更稳：能确保无论成功还是失败，**先释放资源**再做业务级处理，避免泄漏。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[生产问题复盘：试点班（大纲/日程/作业/度量/素材）]]></title>
            <link>https://herongdev.github.io/blog/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）</guid>
            <pubDate>Tue, 09 Sep 2025 00:00:00 GMT</pubDate>
            <description><![CDATA[基于真实生产问题的 4～6 周训练营方案：大纲、日程、作业与考核、度量指标与落地素材清单。]]></description>
            <content:encoded><![CDATA[
## 课程目标

- 建立“从信号到因果”的定位方法论与可复现流程
- 搭建最小可复现（MRE）、观测面板与基准测试
- 交付可投递的复盘报告与改进方案

## 课程大纲

- Week 1：问题定义与信号采集（日志/指标/Trace 基线）
- Week 2：复现场景与最小复现（MRE），错误预算与 SLO
- Week 3：定位技术：长任务/网络抖动/资源争用/内存泄漏
- Week 4：治理与回归：限流/熔断/幂等/回滚、回归基线
- Week 5（可选）：端到端演练：灰度、回滚演练、事故演习
- Week 6（可选）：Capstone 展示与简历/作品集打磨

## 日程（示例 4 周）

- 每周 2 次直播/录播 + 1 次作业走查 + 1 次办公小时
- 每周固定提交：MRE 仓库、观测截图、复盘报告

## 作业与考核

- 作业 1：采集与基线（日志/指标/Trace 基线 + 一处异常信号）
- 作业 2：最小可复现（MRE）与故障注入脚本
- 作业 3：定位与因果链报告（含观测和对照）
- 作业 4：治理与回归（限流/熔断/幂等/回滚）
- 考核维度：正确性、鲁棒性、可观测、复盘完整性、表达与协作

## 度量指标

- 平均问题解决时长（前/后测）
- 80 分位问题解决时长
- 回滚率、事故率、SLO 改善
- 作业通过率、复盘报告评分、作品集完成率

## 落地素材清单（结合你现有文章）

- 请求层与鉴权（目录：`架构与请求/请求层`）
- Vue 性能与交互（目录：`前端/Vue`）
- 实时通信与网络抖动（目录：`前端/实时通信`）
- 登录与会话问题（目录：`前端/鉴权-登录`）
- 下载/直链 vs 鉴权（目录：`前端/下载与文件`）
- Web 推送与标识（目录：`Web-API-与推送`）

> 每周选择 1 ～ 2 篇相关文章作为阅读材料与作业素材；
> 每篇文章配套：MRE 仓库（或片段）、观测面板截图、复盘要点 Checklist。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[WebAuthn Passkeys：options 全字段长啥样？取值有哪些？（simplewebauthn v11+ 实战）]]></title>
            <link>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys：options</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys：options</guid>
            <pubDate>Mon, 08 Sep 2025 00:33:31 GMT</pubDate>
            <content:encoded><![CDATA[
> 适用版本：**@simplewebauthn/server v11+**
> 重点变化：`pubKeyCredParams` ➜ `supportedAlgorithmIDs`；注册验证结果中的 `credentialID/credentialPublicKey` ➜ 移到 `registrationInfo.credential`。

# 一、两类 options 是什么？

- **注册（Creation）**：发给前端 `navigator.credentials.create({ publicKey })` 的参数

  - 服务器生成：`generateRegistrationOptions(opts)`
  - 前端收到的是 **PublicKeyCredentialCreationOptions(JSON)**

- **登录（Request/Assertion）**：发给前端 `navigator.credentials.get({ publicKey })` 的参数

  - 服务器生成：`generateAuthenticationOptions(opts)`
  - 前端收到的是 **PublicKeyCredentialRequestOptions(JSON)**

> 前端 JSON 里的 `challenge` / `user.id` 等，通常是 **base64url** 字符串；服务端入参多数用 **Buffer/Uint8Array**。

# 二、注册：服务端入参 & 前端 options 全量长相

## 2.1 服务端入参（`generateRegistrationOptions(opts)`）

```ts
const options = await generateRegistrationOptions({
  // —— RP（你的站点） ——
  rpName: "Shop Thrive", // 展示名（弹窗可见）
  rpID: "example.com", // RP ID（域名，需与前端同源后缀匹配）

  // —— 用户信息（必须） ——
  // 注意：userID 必须是字节数组（Uint8Array/Buffer），不是 string
  userID: Buffer.from("user-123", "utf8"),
  userName: "user-123", // 可读名（设备 UI 展示）
  userDisplayName: "Alice Zhang", // 可选；不传时库会处理

  // —— 安全策略 ——
  // v11+：用 supportedAlgorithmIDs 指定算法（替代 pubKeyCredParams）
  // 常用：-7=ES256；如需兼容更广，可加 -257=RS256/-8=EdDSA 等
  supportedAlgorithmIDs: [-7, -257],

  // 要求/偏好做本地用户验证（UV：指纹/人脸/PIN）
  // 'required' | 'preferred' | 'discouraged'
  userVerification: "required",

  // 选择哪类认证器与凭证形态
  authenticatorSelection: {
    // 'platform'（本机/系统）| 'cross-platform'（外接/钥匙）| 不填（都可）
    authenticatorAttachment: "platform",
    // 要不要可发现凭证（resident key），用于“无用户名一键登录”
    // 'required' | 'preferred' | 'discouraged'
    residentKey: "required",
    // 旧字段（某些库还在）：requireResidentKey: true,
  },

  // 证明链/隐私：'none' | 'indirect' | 'direct' | 'enterprise'
  attestationType: "none",

  // —— 体验/兼容 ——
  timeout: 60_000, // 毫秒
  excludeCredentials: [
    // 防重复注册（可选）
    {
      id: Buffer.from("...", "base64url"),
      type: "public-key",
      transports: ["internal", "usb"],
    },
  ],

  // —— 扩展（按需） ——
  extensions: {
    credProps: true, // 要求返回“是否可发现凭证”等属性
    // largeBlob: { support: 'required' | 'preferred' },
    // hmacCreateSecret: true,
    // // 老 FIDO 兼容场景：
    // appidExclude: 'https://example.com'
  },
});
```

### COSE 算法常用映射

| ID              | 名称                  | 说明                                        |
| --------------- | --------------------- | ------------------------------------------- |
| **-7**          | ES256                 | ECDSA w/ SHA-256（最常用，passkey 默认）    |
| **-257**        | RS256                 | RSA w/ SHA-256（更广兼容）                  |
| **-8**          | EdDSA                 | 常见为 Ed25519（浏览器/平台支持度差异较大） |
| -35 / -36       | ES384 / ES512         | 更高位椭圆曲线                              |
| -38 / -39 / -40 | PS256 / PS384 / PS512 | RSA-PSS 系列                                |

> 生产一般 `[-7]` 足够；如有老设备需求，可加 `-257`。

---

## 2.2 前端收到的 **注册 options（完整 JSON 示例）**

```json
{
  "rp": { "name": "Shop Thrive", "id": "example.com" },
  "user": {
    "id": "dXNlci0xMjM", // base64url（服务端 userID 的 JSON 形式）
    "name": "user-123",
    "displayName": "Alice Zhang"
  },
  "challenge": "9P0mB1o0f1...Q",
  "pubKeyCredParams": [
    // 注意：这是浏览器原生结构；simplewebauthn 已根据 supportedAlgorithmIDs 生成
    { "type": "public-key", "alg": -7 },
    { "type": "public-key", "alg": -257 }
  ],
  "timeout": 60000,
  "attestation": "none",
  "authenticatorSelection": {
    "authenticatorAttachment": "platform",
    "residentKey": "required",
    "userVerification": "required"
  },
  "excludeCredentials": [
    { "type": "public-key", "id": "...", "transports": ["internal", "usb"] }
  ],
  "extensions": {
    "credProps": true
  }
}
```

> 实际上浏览器可能省略部分可选字段；**你看到的字段少，不代表“没生效”**，很多值有默认行为。

# 三、登录：服务端入参 & 前端 options 全量长相

## 3.1 服务端入参（`generateAuthenticationOptions(opts)`）

```ts
const options = await generateAuthenticationOptions({
  // —— 基本项 ——
  rpID: "example.com",
  timeout: 60_000,

  // —— UV 要求 ——
  // 'required' | 'preferred' | 'discouraged'
  userVerification: "preferred",

  // —— 可选：指定可用凭证（有用户名场景）
  // 省略则启用“可发现凭证”（一键直登：浏览器列出该站点可用 passkey）
  allowCredentials: [
    {
      id: Buffer.from("credential-id-base64url", "base64url"),
      type: "public-key",
      transports: ["internal", "usb", "nfc", "ble", "hybrid"], // 按需
    },
  ],

  // —— 扩展（按需） ——
  extensions: {
    // uvm: true,                    // 请求返回用户验证方式矩阵（支持时）
    // appid: 'https://example.com' // 老 FIDO 兼容
  },
});
```

### `transports` 可能值

- `usb` / `nfc` / `ble`：外接钥匙传输方式
- `internal`：平台认证器（如 iOS/Android/Windows 内置）
- `cable` / `hybrid`：跨设备传输（手机帮电脑解锁的流程）

---

## 3.2 前端收到的 **登录 options（完整 JSON 示例）**

```json
{
  "rpId": "example.com",
  "challenge": "jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg",
  "timeout": 60000,
  "userVerification": "preferred",
  "allowCredentials": [
    { "type": "public-key", "id": "...", "transports": ["internal", "hybrid"] }
  ],
  "extensions": {
    "uvm": true
  }
}
```

> **条件式 UI（passkeys 一键直登）**：这是 `navigator.credentials.get()` 的**第二个参数**里的 `mediation: 'conditional'`，**不在** `publicKey` 这个 JSON 里。
> 形如：
>
> ```ts
> navigator.credentials.get({ publicKey: options, mediation: "conditional" });
> ```

---

# 四、关键字段取值解释（速查表）

## 4.1 `userVerification`

| 值            | 含义                                                              | 推荐                   |
| ------------- | ----------------------------------------------------------------- | ---------------------- |
| `required`    | 必须进行本地用户验证（指纹/人脸/PIN）；不支持 UV 的认证器会被排除 | **后台/金融** 强烈推荐 |
| `preferred`   | 优先进行 UV；不支持也可继续                                       | **通用登录** 默认      |
| `discouraged` | 不鼓励 UV                                                         | 不推荐用于登录         |

> **服务端也要对应开启**：`verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })` 才算真正强制。

## 4.2 `authenticatorSelection`

| 字段                      | 值                                       | 说明                                     |
| ------------------------- | ---------------------------------------- | ---------------------------------------- |
| `authenticatorAttachment` | `platform` / `cross-platform`            | 本机认证器 vs 外接钥匙；不填=都可        |
| `residentKey`             | `required` / `preferred` / `discouraged` | 是否创建**可发现凭证**（一键直登的前提） |
| `requireResidentKey`      | `boolean`                                | 旧字段；等价于 `residentKey: 'required'` |

## 4.3 `attestationType`（simplewebauthn）

| 值                    | 说明                     | 备注         |
| --------------------- | ------------------------ | ------------ |
| `none`                | 不收集证明链（隐私友好） | **最常用**   |
| `indirect` / `direct` | 收集不同强度的证明链     | 较少用       |
| `enterprise`          | 企业场景                 | 需要配套策略 |

## 4.4 `allowCredentials` / `excludeCredentials`（描述符）

```ts
{
  id: Uint8Array | Buffer,     // 凭证ID（服务端存 base64url，生成时转回二进制）
  type: 'public-key',
  transports?: ('usb'|'nfc'|'ble'|'internal'|'cable'|'hybrid')[]
}
```

## 4.5 `supportedAlgorithmIDs`（替代 `pubKeyCredParams`）

- 传 **COSE 算法 ID** 数组（见上表）。
- 浏览器最终在前端 JSON 里仍会以 `pubKeyCredParams` 形式出现（这是 WebAuthn 原生结构），不冲突。

---

# 五、生产推荐模板

### 注册（Creation）

```ts
await generateRegistrationOptions({
  rpName: "Your App",
  rpID: "yourdomain.com",
  userID: Buffer.from(userId, "utf8"),
  userName: userNameOrEmail,
  supportedAlgorithmIDs: [-7], // 如需更广：[-7, -257]
  userVerification: "required",
  authenticatorSelection: {
    authenticatorAttachment: "platform",
    residentKey: "required",
    userVerification: "required",
  },
  attestationType: "none",
  timeout: 60_000,
  // excludeCredentials: [...],      // 防重复注册（可选）
  extensions: { credProps: true },
});
```

### 登录（Request）

```ts
await generateAuthenticationOptions({
  rpID: "yourdomain.com",
  timeout: 60_000,
  userVerification: "required",
  // 省略 allowCredentials → 可发现凭证（推荐做“一键直登”）
  // allowCredentials: [...],       // 指定账号登录时使用
  // extensions: { uvm: true },
});
```

> 核心校验与安全实践：
>
> 1. **challenge** 统一按 **base64url 字符串** 存/比；用后删除；短 TTL（≤5 分钟）。
> 2. **requireUserVerification: true**（服务端）与前端的 `userVerification: 'required'` 配套。
> 3. 注册时显式 `residentKey: 'required'`，保证后面能做“无用户名一键登录（conditional UI）”。

---

# 六、常见疑问

- **为什么我的 `options` 字段很少？**
  浏览器/库会省略默认字段；只要关键项（`rpId`、`challenge`、用户/算法/策略）正确，功能完全等价。
- **`challenge` 看起来很短，安全吗？**
  默认 32 字节随机数（base64url 后 ≈43 字符）已足够安全。
- **字段大小写为何不一致？**
  库的**入参**是 `rpID`、`userID`（TypeScript 结构）；前端 JSON 是 WebAuthn 原生的 `rpId`、`user.id`。库会正确映射。

---

如果你想把现有 NestJS 代码里的配置**替换为上面的“生产推荐模板”**，告诉我你文件里的具体几行；我只给“需要替换的片段”，并在复杂逻辑上一行加注释，符合你的改码规则。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[userVerification:]]></title>
            <link>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/preferred是啥</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/需求实现/登录鉴权/preferred是啥</guid>
            <pubDate>Mon, 08 Sep 2025 00:12:36 GMT</pubDate>
            <content:encoded><![CDATA[
好，我逐条拆解你看到的这段响应，并把“该用什么值”“挑战长度”为啥看起来短、“大厂是不是也这样返回”讲清楚；最后给出**只需改几行**的建议（不贴整文件）。

---

# 1、`"userVerification": "preferred"` 是啥？

**它告诉浏览器/认证器：是否必须做“本地用户验证（UV）”**（指纹/人脸/PIN）。可选值只有 3 个：

| 值                            | 含义                                                     | 常见效果/场景                                                                                                |
| ----------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **`required`**                | **必须**进行本地用户验证（没有 UV 能力的认证器会被排除） | 金融、后台管理、提升安全性。旧 U2F 钥匙（无 PIN）会被拒。                                                    |
| **`preferred`**（你现在的值） | **优先**做 UV，如果设备支持就做；不支持也可以继续        | 一般网站登录、降低失败率。绝大多数“平台 passkey”（Android/Apple）都会做 UV，所以体验和 `required` 基本一样。 |
| **`discouraged`**             | **不鼓励**做 UV（允许仅“持有设备”就通过）                | 很少用；降低安全门槛，适合低风险二级操作（不建议用于登录）。                                                 |

> 注意：这只是“**意愿**”。真正的**强制**要在**服务端验证**时也打开：
> `verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })`。
> 否则前端说 `required`，服务端放宽为 `false`，就**没有被强制**。

**给你的建议：**

- 如果这是**员工后台**或敏感操作：前端设 `userVerification: 'required'`，服务端配套 `requireUserVerification: true`。
- 如果是**大众登录**：`preferred` + 风控/设备指纹/异常登录再二次验证。

# 2、这个 `challenge` 看起来“很短”，正常吗？

**正常。**

- simplewebauthn 默认生成 **32 字节**随机挑战（≈ **256 bit**）。
- 32 字节用 **base64url** 表示通常是 **43\~44 个字符**（无 `=` 填充）。
- 你看到的：`jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg`，长度 43，很标准。
- 我们服务端已把 challenge 统一按 **base64url** 存/比（你代码里已处理），与前端 `clientDataJSON.challenge` 能**精确一致**。

> 若你担心强度，也可以自定义更长挑战（例如 64 字节），但 32 字节已足够随机且是行业常见默认。

# 3、大厂实践里返回的也是这种结构吗？

**是的。**这就是 WebAuthn 规范的 **PublicKeyCredentialRequestOptions(JSON)** 的形态，各家（Google、Apple、微软、GitHub、PayPal…）都会返回类似结构。差异主要在**有没有 `allowCredentials`** 和某些可选字段：

- 一键直登/可发现凭证：**省略 `allowCredentials`**（你现在就是），浏览器会弹出该 RP 的可用 passkey 列表。
- 指定账号登录：会带 `allowCredentials: [{ id, type: 'public-key' }, ...]`。
- 其他常见字段：`rpId`、`challenge`、`timeout`、`userVerification`、有时 `extensions`。
- 前端会另外传 `mediation: 'conditional'`（这不是 options 里的字段，而是 `navigator.credentials.get` 的参数，用于条件式 UI）。

所以你这个响应：

```json
{
  "options": {
    "rpId": "localhost",
    "challenge": "…",
    "timeout": 60000,
    "userVerification": "preferred"
  }
}
```

**完全合理**、符合规范，也符合大厂常见做法（本地开发把 `rpId` 设为 `localhost` 没问题，上线要换为你的主域）。

# 4、如果你要“更安全”，只改这几行（前后端各一处）

**后端·验证时强制 UV（把 `false` 改为 `true`）**

```ts
// 复杂：强制需要本地用户验证（指纹/人脸/PIN）
requireUserVerification: true,
```

> 出现位置：
>
> - `verifyRegistrationResponse({...})`
> - `verifyAuthenticationResponse({...})`

**生成登录 options 时（可选）：把首选项也改为 required**

```ts
// 复杂：要求认证器执行 UV
userVerification: 'required',
```

> 这两处配合使用，才能做到“名副其实的强制 UV”。

---

# 5、小补充：别名/大小写别差异别担心

- simplewebauthn（v11+）返回的 JSON 用 `rpId`（小写 d）；
- 你传入 `generateAuthenticationOptions({ rpID: '…' })` 是库的入参写法；
- **这是正常的**：入参/出参字段命名略有差异，但库会正确映射。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[test]]></title>
            <link>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/test</link>
            <guid isPermaLink="false">https://herongdev.github.io/blog/posts/需求实现/登录鉴权/test</guid>
            <pubDate>Mon, 08 Sep 2025 00:19:02 GMT</pubDate>
        </item>
    </channel>
</rss>