<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://herongdev.github.io/blog</id>
    <title>我的博客</title>
    <updated>2025-09-18T17:26:53.068Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://herongdev.github.io/blog"/>
    <link rel="self" href="https://herongdev.github.io/blog/atom.xml"/>
    <subtitle>个人博客 RSS</subtitle>
    <icon>https://herongdev.github.io/blog/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）]]></title>
        <id>https://herongdev.github.io/blog/posts/requirement-realization-1</id>
        <link href="https://herongdev.github.io/blog/posts/requirement-realization-1"/>
        <updated>2025-09-05T00:54:31.000Z</updated>
        <content type="html"><![CDATA[
---

title: 已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）
date: 2025-09-05
tags:

- Passkeys
- WebAuthn
- 账号绑定
- 设备唯一

---

## 摘要

当**用户已经登录（本地有 JWT/token）**时，常见需求是“**再绑定一把通行密钥**”（或在新设备上补绑）。本文给出一个**稳妥的一次点击方案**：

- 前端：带上 **Authorization: Bearer \<token>** 与 **X-Device-Id（设备唯一码）** 请求 `/passkeys/register/options`。
- 浏览器完成 `navigator.credentials.create(...)` 后，将结果 + `deviceIdentifier` 回传 `/passkeys/register/verify`。
- 后端：从 **token 解析 userId**，生成/校验 challenge、**入库凭证**，并执行**设备唯一绑定**（`deviceId -> userId`）。

> 关键点：**不要尝试枚举本地是否已有凭证**；隐私模型不允许。登录态下的“绑定”其实就是“已知用户的注册流程”。

---

## 设计要点

- **用户唯一标识**：后端**不靠前端传 userId**，而是从 **JWT** 中解析（`sub`）→ 更安全。
- **设备唯一**：前端生成/缓存 `deviceId`，通过 `X-Device-Id` 头传给后端；后端使用 `dvc:owner:${deviceId}` 在 Redis 做“一致性绑定”。
- **防重复注册**：注册 options 中使用 `excludeCredentials`（由后端查询该用户已绑定的 credentialId）。
- **风控与速率限制**：对 `deviceId` 做限流（如 1h/3 次），并在 verify 阶段二次校验。
- **协议对齐**：保持与登录/JIT 注册完全相同的编码规范（字节字段统一 **base64url**）。

---

## 前端实现（Web）

> 仅新增**一个按钮事件**用于“绑定通行密钥”。代码自包含；把 `BASE_URL` 改成你的后端地址即可。
> 复杂逻辑均在上一行写注释。

```html
<!-- 你的页面按钮 -->
<button id="btn-bind-passkey">绑定通行密钥</button>
<pre
  id="log"
  style="background:#111;color:#9f9;padding:12px;white-space:pre-wrap"
></pre>

<script type="module">
  // ========= 工具：设备ID与 base64url 转换 =========
  function getDeviceId() {
    let id = localStorage.getItem("device_id");
    if (!id) {
      id =
        crypto?.randomUUID?.() ||
        "dev-" + Date.now() + "-" + Math.random().toString(16).slice(2);
      localStorage.setItem("device_id", id);
    }
    return id;
  }
  function b64urlToBuf(b64url) {
    const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
    const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
    const bin = atob(b64);
    const buf = new ArrayBuffer(bin.length);
    const view = new Uint8Array(buf);
    for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
    return buf;
  }
  function bufToB64url(buf) {
    const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
    let s = "";
    for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
    return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  // 复杂：把 CreationOptions 中的 base64url → ArrayBuffer
  function toCreationOptions(serverOpts) {
    const opts = structuredClone(serverOpts);
    if (typeof opts.challenge === "string")
      opts.challenge = b64urlToBuf(opts.challenge);
    if (opts.user && typeof opts.user.id === "string")
      opts.user.id = b64urlToBuf(opts.user.id);
    if (Array.isArray(opts.excludeCredentials)) {
      opts.excludeCredentials = opts.excludeCredentials.map((c) => ({
        ...c,
        id: b64urlToBuf(c.id),
      }));
    }
    return opts;
  }
  // 复杂：将 create() 结果打包为后端可校验的 JSON（统一 base64url）
  function packAttestation(cred) {
    return {
      id: cred.id,
      rawId: bufToB64url(cred.rawId),
      type: cred.type,
      response: {
        clientDataJSON: bufToB64url(cred.response.clientDataJSON),
        attestationObject: bufToB64url(cred.response.attestationObject),
      },
      clientExtensionResults: cred.getClientExtensionResults?.() || {},
    };
  }
  // 复杂：通用 POST，附带 token 与设备ID
  async function postJSON(url, body, token) {
    const res = await fetch(url, {
      method: "POST",
      credentials: "include",
      headers: {
        "content-type": "application/json",
        "X-Device-Id": getDeviceId(), // 设备唯一
        ...(token ? { Authorization: `Bearer ${token}` } : {}), // 已登录用户必带
      },
      body: JSON.stringify(body || {}),
    });
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return res.json();
  }

  // ========= 绑定入口：用户已登录（本地有 token） =========
  const BASE_URL = ""; // 同源可留空；跨域改成你的后端地址
  function getToken() {
    // 复杂：示例从 localStorage 取；实际按你的项目来源（Cookie/JWT 管理方案）
    return localStorage.getItem("token");
  }
  async function bindPasskey() {
    const log = (m) =>
      (document.getElementById(
        "log"
      ).textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`);
    const token = getToken();
    if (!token) {
      log("未登录：请先登录再绑定");
      return;
    }

    try {
      // 复杂：步骤1——向后端请求“注册（绑定）options”，后端将从 JWT 解析 userId
      log("请求 /passkeys/register/options ...");
      const data = await postJSON(
        `${BASE_URL}/passkeys/register/options`,
        {},
        token
      );
      const serverOptions = data.options || data; // 兼容返回形态
      const publicKey = toCreationOptions(serverOptions);

      // 复杂：步骤2——发起浏览器创建凭据
      log("调用 navigator.credentials.create ...");
      const att = await navigator.credentials.create({ publicKey });

      // 复杂：步骤3——打包 + 回传 verify，并带上 deviceIdentifier 以完成设备唯一绑定
      log("提交 /passkeys/register/verify ...");
      const verifyBody = {
        ...packAttestation(att),
        deviceIdentifier: getDeviceId(),
      };
      const verifyResp = await postJSON(
        `${BASE_URL}/passkeys/register/verify`,
        verifyBody,
        token
      );

      log("绑定完成 ✅ " + JSON.stringify(verifyResp));
      alert("通行密钥绑定成功");
    } catch (e) {
      console.error(e);
      alert("绑定失败：" + (e?.message || e));
    }
  }

  // 绑定按钮点击
  document
    .getElementById("btn-bind-passkey")
    ?.addEventListener("click", bindPasskey);
</script>
```

> 若你在 **uni-app**（H5）里使用，也可沿用同样逻辑；在 **App（UTS 插件）** 上只需把 `navigator.credentials.create` 替换为你的 `passkeys.createPasskey(optionsJson)` 即可，其余协议不变。

---

## 后端实现（NestJS，仅给“增量/改动片段”）

> 你的工程里已有 JIT 与登录接口。这里**新增/完善**“**已登录的注册（绑定）**”两个端点，并对 Service 增强**按 token 解析 user** 与**设备唯一**。

### 1）Controller 片段

```ts
// 复杂：新增“已登录绑定”端点；依赖 JWT 守卫把 user 注入 request.user
import { Controller, Post, Req, UseGuards, Body } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
import { PasskeysService } from "../../services/passkeys.service";

@Controller("passkeys")
export class PasskeysController {
  constructor(private readonly passkeysService: PasskeysService) {}

  // 复杂：注册（绑定）options——登录态
  @UseGuards(AuthGuard("jwt"))
  @Post("register/options")
  getBindOptions(@Req() req: any) {
    // 复杂：设备ID从 Header/Cookie/IP 提取，用于风控与后续绑定一致性
    const deviceIdentifier =
      req.headers["x-device-id"] || req.cookies?.dvc || `ip:${req.ip}`;
    const userId = req.user?.sub; // 复杂：从 JWT 解析出的 userId
    return this.passkeysService.issueRegistrationOptionsForUser(
      userId,
      deviceIdentifier
    );
  }

  // 复杂：注册（绑定）verify——登录态
  @UseGuards(AuthGuard("jwt"))
  @Post("register/verify")
  verifyBind(@Req() req: any, @Body() body: any) {
    const deviceIdentifier =
      req.headers["x-device-id"] ||
      body.deviceIdentifier ||
      req.cookies?.dvc ||
      `ip:${req.ip}`;
    const userId = req.user?.sub;
    return this.passkeysService.verifyRegistrationForUser(
      userId,
      body,
      deviceIdentifier
    );
  }
}
```

### 2）Service 片段

```ts
// 复杂：为“已登录绑定”增加两个方法
@Injectable()
export class PasskeysService {
  // ... 省略已有依赖与构造

  // 复杂：签发已登录用户的注册 options（含 excludeCredentials 与限流）
  async issueRegistrationOptionsForUser(
    userId: string,
    deviceIdentifier?: string
  ) {
    if (!userId) throw new UnauthorizedException("未登录");

    // 复杂：限流（1h/3次）
    if (deviceIdentifier) {
      const rlKey = `rl:bind:${deviceIdentifier}`;
      const n = await this.redisService.incrementKey(rlKey);
      if (n === 1) await this.redisService.expireKey(rlKey, 3600);
      if (n > 3) throw new BadRequestException("操作过于频繁，请稍后再试");
    }

    const rpId = this.configService.get<string>("RP_ID");

    // 复杂：查询该用户已有凭证，构造 excludeCredentials 防重复注册
    const existing = await this.staffService.findManyCredentialsByUserId(
      userId
    ); // 需要你实现查询
    const exclude = (existing || []).map((c: any) => ({
      id: Buffer.from(c.credentialId, "base64url"),
      type: "public-key" as const,
    }));

    const options = await generateRegistrationOptions({
      rpName: "Your App",
      rpID: rpId,
      // 复杂：v11+ 要求 userID 为字节；这里直接用 UTF-8 Buffer
      userID: Buffer.from(String(userId), "utf8"),
      userName: String(userId),
      attestationType: "none",
      // 复杂：兼容性更好（ES256 + RS256）
      supportedAlgorithmIDs: [-7, -257],
      authenticatorSelection: {
        residentKey: "required", // 复杂：要求可发现凭证，便于后续一键直登
        userVerification: "preferred",
      },
      excludeCredentials: exclude,
      extensions: { credProps: true },
    });

    // 复杂：将 challenge(base64url) 与 user 绑定，TTL 5 分钟
    const ch =
      typeof options.challenge === "string"
        ? options.challenge
        : Buffer.from(options.challenge).toString("base64url");
    await this.redisService.setWithTimeToLive(
      `webauthn:register:${userId}`,
      ch,
      300
    );

    return { options };
  }

  // 复杂：校验 attestation + 入库 + 设备唯一绑定（不重新发 token，也可选择刷新）
  async verifyRegistrationForUser(
    userId: string,
    requestBody: any,
    deviceIdentifier?: string
  ) {
    if (!userId) throw new UnauthorizedException("未登录");

    const rpId = this.configService.get<string>("RP_ID");
    const origin = this.configService.get<string>("ORIGIN");
    const cachedChallenge = await this.redisService.getValue(
      `webauthn:register:${userId}`
    );
    if (!cachedChallenge)
      throw new BadRequestException("注册挑战不存在或已过期");

    const verification = await verifyRegistrationResponse({
      response: requestBody,
      expectedRPID: rpId,
      expectedOrigin: origin,
      expectedChallenge: cachedChallenge,
      requireUserVerification: true, // 复杂：绑定建议要求 UV
    });
    if (!verification.verified || !verification.registrationInfo) {
      throw new UnauthorizedException("注册校验失败");
    }

    const { credential } = verification.registrationInfo;
    const credentialIdB64url = Buffer.from(credential.id).toString("base64url");
    const publicKey = Buffer.from(credential.publicKey); // 存二进制或 base64 皆可
    const counter = credential.counter ?? 0;

    // 复杂：入库（若同 credentialId 已存在且属同人，可忽略/幂等）
    await this.staffService.upsertCredential({
      userId,
      credentialId: credentialIdB64url,
      publicKey,
      counter,
      transports: credential.transports
        ? JSON.stringify(credential.transports)
        : null,
    });

    // 复杂：设备唯一绑定（若存在 deviceId 且已被他人占用，则拒绝）
    if (deviceIdentifier) {
      const key = `dvc:owner:${deviceIdentifier}`;
      const existed = await this.redisService.getValue(key);
      if (existed && existed !== String(userId)) {
        throw new ForbiddenException("此设备已绑定其他账号");
      }
      // 绑定一年（或不设 TTL）
      await this.redisService.setWithTimeToLive(key, String(userId), 31536000);
    }

    await this.redisService.deleteKey(`webauthn:register:${userId}`);
    // 已登录状态下可不必重签 token；如需刷新可在此签新 JWT
    return { verified: true, userId, credentialId: credentialIdB64url };
  }
}
```

> 你只需要实现（或补齐）`staffService.findManyCredentialsByUserId` 与 `upsertCredential` 两个数据存取方法；字段即你现有的 `credentialId/publicKey/counter/transports/userId`。

---

## 时序对照（已登录绑定）

1. 前端带 **Authorization** 与 **X-Device-Id** → `POST /passkeys/register/options`
2. 后端从 **JWT** 取 `userId`，构造 **excludeCredentials**，保存 **challenge**
3. 前端调用 **`navigator.credentials.create({ publicKey })`**
4. 前端回传 **attestation + deviceIdentifier** → `/passkeys/register/verify`
5. 后端 **verify + 入库 + 设备唯一绑定** → 返回 `{ verified: true, userId }`

---

## 常见问题

- **为什么不让前端直接传 userId？**
  防止伪造。登录态下应以 **Authorization** 为准，由后端解析身份。

- **若用户已绑定过此设备，再次点击绑定会怎样？**
  由于 `excludeCredentials` 与 `dvc:owner:*` 绑定同时生效，**不会重复写入**；可返回幂等成功或提示“已绑定”。

- **如何与一键直登/JIT 流程共存？**

  - **未登录**：走 `/login/options` → 失败回退 `/register-or-login/*`。
  - **已登录**：走本文 `/register/*`（绑定专用）。两套互不冲突。

---

## 小结

- **唯一标识传递**：已登录场景下，把 **用户身份交给 JWT**，把 **设备唯一交给 `X-Device-Id`**。
- **绑定即注册**：本质是“已知用户”的注册流程；用 `excludeCredentials` 防重复，用 Redis 绑定 `deviceId -> userId`。
- **最少交互**：一次点击完成整个绑定，协议与登录/JIT 完全一致，维护成本低。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在你现有 uvue 登录页集成“一键通行密钥登录”（含回退注册），完整代码可直接替换]]></title>
        <id>https://herongdev.github.io/blog/posts/requirement-realization-2</id>
        <link href="https://herongdev.github.io/blog/posts/requirement-realization-2"/>
        <updated>2025-09-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 目标

把我们讨论的“**先尝试通行密钥登录 → 失败自动回退到 JIT 注册并登录**”接到你这份 **uvue（uni-app x）页面** 上，**保留原有微信登录按钮**，新增一个“通行密钥登录”按钮。
支持：

- **App 端（Android/iOS）**：走你自定义的 **UTS 插件** `@/uni_modules/pass-keys`（`getPasskey`/`createPasskey`）。
- **H5 端**：走浏览器 WebAuthn（`navigator.credentials.get/create`）。
- **设备唯一**：用 `deviceIdentifier`（App 用 `plus.device.uuid`，H5 用本地生成）传后端，便于 `deviceId -> userId` 绑定。

> 复杂逻辑均在代码**上一行加中文注释**。下面给出**整文件覆盖式代码**（符合你“Passkeys 项目优先给完整文件”的约定）。

---

## 完整代码（直接替换你当前页面）

```vue
<template>
  <view class="container">
    <view class="header">
      <text class="title">欢迎使用商户平台</text>
    </view>

    <view v-if="!baseUrl" class="tip">
      <text class="tip-text">未配置后端地址，请先配置</text>
      <button size="mini" @tap="openConfig">去配置</button>
    </view>

    <view class="actions">
      <button
        type="primary"
        :disabled="!baseUrl || loading"
        @tap="onWeChatLogin"
      >
        {{
          baseUrl
            ? isWeChatInstalled
              ? "微信登录"
              : "登录"
            : "请先配置后端地址"
        }}
      </button>

      <!-- 新增：通行密钥一键登录（失败自动回退注册并登录） -->
      <button
        style="margin-top:12rpx"
        :disabled="!baseUrl || loading"
        @tap="onPasskeyLogin"
      >
        {{ loading ? "处理中..." : "通行密钥登录" }}
      </button>
    </view>

    <view v-if="loading" class="loading-mask">
      <view class="loading-box"><text>处理中...</text></view>
    </view>

    <view v-if="showConfig" class="modal-mask" @tap="closeConfig">
      <view class="modal" @tap.stop>
        <text class="modal-title">配置后端地址</text>
        <input
          class="modal-input"
          type="text"
          v-model="configInput"
          placeholder="例如：https://api.example.com"
        />
        <view class="modal-actions">
          <button size="mini" @tap="closeConfig">取消</button>
          <button type="primary" size="mini" @tap="saveConfig">保存</button>
        </view>
      </view>
    </view>
  </view>
</template>

<script>
// #ifdef APP-PLUS
// 复杂逻辑：App 端引入你的 UTS 插件（Android/iOS 调平台原生 Credential/AuthenticationServices）
import * as passkeys from "@/uni_modules/pass-keys";
// #endif

export default {
  data() {
    return {
      baseUrl: "",
      loading: false,
      isWeChatInstalled: true,
      showConfig: false,
      configInput: "",
      // 复杂逻辑：设备唯一标识；App=plus.device.uuid；H5=本地生成并持久化
      deviceId: "",
    };
  },
  onLoad() {
    this.baseUrl = uni.getStorageSync("BASE_URL") || "";
    // 复杂逻辑：初始化设备ID（用于 deviceId -> userId 绑定与风控）
    // #ifdef APP-PLUS
    this.deviceId =
      plus && plus.device && plus.device.uuid
        ? plus.device.uuid
        : "app-" + Date.now();
    // #endif
    // #ifdef H5
    const key = "DEVICE_ID";
    this.deviceId = localStorage.getItem(key);
    if (!this.deviceId) {
      this.deviceId =
        crypto?.randomUUID?.() ||
        "web-" + Date.now() + "-" + Math.random().toString(16).slice(2);
      localStorage.setItem(key, this.deviceId);
    }
    // #endif
  },
  methods: {
    openConfig() {
      this.configInput = this.baseUrl;
      this.showConfig = true;
    },
    closeConfig() {
      this.showConfig = false;
    },
    saveConfig() {
      this.baseUrl = (this.configInput || "").trim();
      uni.setStorageSync("BASE_URL", this.baseUrl);
      this.showConfig = false;
      uni.showToast({ title: "已保存", icon: "success" });
    },

    // 复杂逻辑：统一 POST 封装；把 deviceIdentifier 一并传给后端（也可由 Header 传）
    async post(path, body) {
      return await new Promise((resolve, reject) => {
        uni.request({
          url: `${this.baseUrl}${path}`,
          method: "POST",
          data: { deviceIdentifier: this.deviceId, ...(body || {}) },
          dataType: "json",
          header: { "content-type": "application/json" },
          success: (res) => resolve(res.data),
          fail: reject,
        });
      });
    },

    // 保留原有：微信登录
    async onWeChatLogin() {
      if (!this.baseUrl) return;
      this.loading = true;
      try {
        let code = "";
        // 小程序端获取 code
        // #ifdef MP-WEIXIN
        const res = await new Promise((resolve, reject) => {
          uni.login({ provider: "weixin", success: resolve, fail: reject });
        });
        code = res.code || "";
        // #endif

        // 其他端未集成微信登录，给出提示
        // #ifndef MP-WEIXIN
        throw new Error("当前平台未集成微信登录");
        // #endif

        if (!code) throw new Error("获取登录凭证失败");
        const data = await this.post("/admin/wechat/login", { code });
        if (
          data &&
          data.success === true &&
          data.userInfo &&
          data.userInfo.approved === true &&
          data.userInfo.token
        ) {
          uni.setStorageSync("TOKEN", data.userInfo.token);
          uni.showToast({ title: "登录成功", icon: "success" });
          setTimeout(() => {
            uni.reLaunch({ url: "/pages/index/index" });
          }, 600);
        } else {
          throw new Error(data?.message || "登录失败");
        }
      } catch (e) {
        uni.showToast({ title: e?.message || String(e), icon: "none" });
      } finally {
        this.loading = false;
      }
    },

    // ================== 通行密钥一键登录入口（失败回退注册） ==================
    async onPasskeyLogin() {
      if (!this.baseUrl) return;
      this.loading = true;
      try {
        // 复杂逻辑：步骤A——请求登录 options（无用户名直登；后端可按设备ID定向返回 allowCredentials）
        const resp = await this.post("/passkeys/login/options", {});
        const options = resp.options || resp;

        // #ifdef APP-PLUS
        // 复杂逻辑：App 端调用 UTS 插件进行“使用通行密钥”
        const requestOptionsJson = JSON.stringify(options);
        const authRespJson = await passkeys.getPasskey(requestOptionsJson, {
          conditional: true,
        });
        const verifyBody = JSON.parse(authRespJson);
        // #endif

        // #ifdef H5
        // 复杂逻辑：H5 端使用 WebAuthn —— 将 base64url 字段转 ArrayBuffer
        const publicKey = this.toWebAuthnRequestOptions(options);
        // 复杂逻辑：若支持条件UI，mediation='conditional'，否则 'required'（需用户手势）
        const mediation = (await this.isConditionalUI())
          ? "conditional"
          : "required";
        const assertion = await navigator.credentials.get({
          publicKey,
          mediation,
        });
        const verifyBody = this.packAssertion(assertion);
        // #endif

        // 复杂逻辑：步骤B——提交登录 verify
        const verify = await this.post("/passkeys/login/verify", verifyBody);
        this.onLoginSucceed(verify);
      } catch (e) {
        // 复杂逻辑：登录失败（无凭据/取消/过期）→ 步骤C——回退到 JIT 注册
        try {
          const jit = await this.post(
            "/passkeys/register-or-login/options",
            {}
          );
          const userId = jit.userId || jit?.user?.id;
          const creationOptions = jit.options || jit;

          // #ifdef APP-PLUS
          // 复杂逻辑：App 端调用 UTS 插件“创建通行密钥”
          const creationOptionsJson = JSON.stringify(creationOptions);
          const regRespJson = await passkeys.createPasskey(creationOptionsJson);
          const verifyRegBody = {
            ...JSON.parse(regRespJson),
            userId,
            deviceIdentifier: this.deviceId,
          };
          // #endif

          // #ifdef H5
          // 复杂逻辑：H5 端 WebAuthn —— 转换 base64url → ArrayBuffer，发起 create
          const publicKey = this.toWebAuthnCreationOptions(creationOptions);
          const attestation = await navigator.credentials.create({ publicKey });
          const verifyRegBody = {
            ...this.packAttestation(attestation),
            userId,
            deviceIdentifier: this.deviceId,
          };
          // #endif

          // 复杂逻辑：步骤D——提交注册 verify（完成入库+设备唯一绑定+签发会话）
          const verify = await this.post(
            "/passkeys/register-or-login/verify",
            verifyRegBody
          );
          this.onLoginSucceed(verify, true);
        } catch (e2) {
          uni.showToast({ title: e2?.message || String(e2), icon: "none" });
        }
      } finally {
        this.loading = false;
      }
    },

    // 复杂逻辑：登录/注册成功后的统一处理（落 token + 跳转）
    onLoginSucceed(verify, isRegister = false) {
      if (verify?.verified) {
        if (verify.token) {
          uni.setStorageSync("TOKEN", verify.token);
        }
        uni.showToast({
          title: isRegister ? "已注册并登录" : "登录成功",
          icon: "success",
        });
        setTimeout(() => {
          uni.reLaunch({ url: "/pages/index/index" });
        }, 600);
      } else {
        throw new Error("校验失败");
      }
    },

    // ================== H5 专用辅助：WebAuthn 转换与打包 ==================
    // #ifdef H5
    // 复杂逻辑：检测是否支持条件UI
    async isConditionalUI() {
      try {
        return !!(await PublicKeyCredential.isConditionalMediationAvailable?.());
      } catch {
        return false;
      }
    },
    // 复杂逻辑：base64url → ArrayBuffer
    b64urlToBuf(b64url) {
      const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
      const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
      const bin = atob(b64);
      const buf = new ArrayBuffer(bin.length);
      const view = new Uint8Array(buf);
      for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);
      return buf;
    },
    // 复杂逻辑：ArrayBuffer/Uint8Array → base64url
    bufToB64url(buf) {
      const b = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
      let s = "";
      for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);
      return btoa(s)
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/g, "");
    },
    // 复杂逻辑：将登录 options（服务端 base64url）转为 WebAuthn 可用结构
    toWebAuthnRequestOptions(serverOpts) {
      const opts = JSON.parse(JSON.stringify(serverOpts));
      if (typeof opts.challenge === "string")
        opts.challenge = this.b64urlToBuf(opts.challenge);
      if (Array.isArray(opts.allowCredentials)) {
        opts.allowCredentials = opts.allowCredentials.map((c) => ({
          ...c,
          id: typeof c.id === "string" ? this.b64urlToBuf(c.id) : c.id,
        }));
      }
      return opts;
    },
    // 复杂逻辑：将注册 options 转为 WebAuthn 可用结构
    toWebAuthnCreationOptions(serverOpts) {
      const opts = JSON.parse(JSON.stringify(serverOpts));
      if (typeof opts.challenge === "string")
        opts.challenge = this.b64urlToBuf(opts.challenge);
      if (opts.user && typeof opts.user.id === "string")
        opts.user.id = this.b64urlToBuf(opts.user.id);
      if (Array.isArray(opts.excludeCredentials)) {
        opts.excludeCredentials = opts.excludeCredentials.map((c) => ({
          ...c,
          id: typeof c.id === "string" ? this.b64urlToBuf(c.id) : c.id,
        }));
      }
      return opts;
    },
    // 复杂逻辑：将 get() 结果打包为后端可校验的 JSON（统一 base64url）
    packAssertion(cred) {
      const resp = cred.response;
      return {
        id: cred.id,
        rawId: this.bufToB64url(cred.rawId),
        type: cred.type,
        response: {
          clientDataJSON: this.bufToB64url(resp.clientDataJSON),
          authenticatorData: this.bufToB64url(resp.authenticatorData),
          signature: this.bufToB64url(resp.signature),
          userHandle: resp.userHandle
            ? this.bufToB64url(resp.userHandle)
            : null,
        },
        clientExtensionResults: cred.getClientExtensionResults?.() || {},
      };
    },
    // 复杂逻辑：将 create() 结果打包为后端可校验的 JSON（统一 base64url）
    packAttestation(cred) {
      const resp = cred.response;
      return {
        id: cred.id,
        rawId: this.bufToB64url(cred.rawId),
        type: cred.type,
        response: {
          clientDataJSON: this.bufToB64url(resp.clientDataJSON),
          attestationObject: this.bufToB64url(resp.attestationObject),
        },
        clientExtensionResults: cred.getClientExtensionResults?.() || {},
      };
    },
    // #endif
  },
};
</script>

<style>
.container {
  padding: 24rpx;
}
.header {
  margin-top: 40rpx;
  margin-bottom: 24rpx;
}
.title {
  font-size: 36rpx;
  font-weight: 600;
  text-align: center;
}
.tip {
  display: flex;
  align-items: center;
  gap: 16rpx;
  padding: 16rpx;
  margin: 12rpx 0;
  border: 1px solid #ffc107;
  background: #fff8e1;
  border-radius: 12rpx;
}
.tip-text {
  color: #8d6e63;
  font-size: 26rpx;
}
.actions {
  margin-top: 24rpx;
  display: flex;
  flex-direction: column;
}
.loading-mask {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
}
.loading-box {
  padding: 20rpx;
  background: #fff;
  border-radius: 12rpx;
}
.modal-mask {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
}
.modal {
  width: 80%;
  background: #fff;
  border-radius: 16rpx;
  padding: 24rpx;
}
.modal-title {
  font-size: 30rpx;
  font-weight: 600;
}
.modal-input {
  border: 1px solid #eee;
  margin: 16rpx 0;
  padding: 12rpx;
  border-radius: 8rpx;
}
.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12rpx;
}
</style>
```

---

## 说明与对接要点

- **后端路由**保持为：

  - `/passkeys/login/options` → 返回 `PublicKeyCredentialRequestOptions`（`challenge`/`allowCredentials[].id` 为 **base64url**）。
  - `/passkeys/login/verify` → 接收 `packAssertion` 结果。
  - `/passkeys/register-or-login/options` → 返回 `{ userId, options }`（注册用，`challenge`/`user.id` 为 **base64url**）。
  - `/passkeys/register-or-login/verify` → 接收 `packAttestation` + `{ userId, deviceIdentifier }`。

- **设备唯一**：页面已在所有请求体中带上 `deviceIdentifier`（`this.deviceId`），你的服务端即可写入/校验 `dvc:owner:*`。
- **H5 前置条件**：需 HTTPS 或 `localhost`；Safari/移动端有平台限制。
- **App 端**：确保 `@/uni_modules/pass-keys` 已实现 `getPasskey`/`createPasskey` 且返回 **JSON 字符串**（与我们前面约定一致）。

需要我把 **“已登录场景的绑定按钮”** 也加到这个页面吗（即 `/passkeys/register/options|verify`，走绑定而非 JIT）？如果要，加哪个位置，我按你“只给改动段”的规范再补。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现]]></title>
        <id>https://herongdev.github.io/blog/posts/requirement-realization</id>
        <link href="https://herongdev.github.io/blog/posts/requirement-realization"/>
        <updated>2025-09-05T00:21:16.000Z</updated>
        <content type="html"><![CDATA[
---

title: Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现
date: 2025-09-05
tags:

- Passkeys
- WebAuthn
- 前端实战
- 一键直登

---

## 摘要

本文给出 **Web 端** 的最小可用实现：**点击一个按钮 → 优先尝试登录（可发现凭证）→ 若无可用凭证或用户取消，则自动走 JIT 注册并直接登录**。
重点说明：“**不能事先枚举本地是否存在凭据**”（浏览器出于隐私不允许），正确姿势是**拿到服务端的 options 再调用 WebAuthn**，并对失败分支做平滑回退。

---

## 背景与原则

- 浏览器不会暴露“本地是否已有你家 RP 的通行密钥”的枚举 API（防侧信道追踪）。
- 正确流程永远是：**后端发 options（含 challenge）→ 前端发起 `get()`/`create()` → 前端把回包交给后端 `verify`**。
- 若想“先感知再决定”，只能做**能力探测**（如 `isConditionalMediationAvailable()`、`isUserVerifyingPlatformAuthenticatorAvailable()`），但这**不等于**“确有凭据”。
- 因此，本实现直接：**先请求登录 options** → `navigator.credentials.get` → 失败则 **请求注册 options** → `navigator.credentials.create` → 验证成功后**注册即登录**。

---

## 交互时序（简述）

1. 用户点击「一键登录」按钮
2. 前端 `POST /passkeys/login/options`（携带 `X-Device-Id`）
3. 浏览器 `navigator.credentials.get({ publicKey, mediation })`
4. 成功 → 回传 `/passkeys/login/verify` → **登录完成**
5. 失败（无匹配凭据/取消等）→ `POST /passkeys/register-or-login/options`
6. `navigator.credentials.create({ publicKey })`
7. 回传 `/passkeys/register-or-login/verify` → **注册并登录完成**

---

## 完整代码

> 下面给出**可直接粘贴落地**的最小实现（HTML + JS）。
> 复杂逻辑的上一行均有中文注释。
> 假设你的后端路由与本文一致：
>
> - `/passkeys/login/options`、`/passkeys/login/verify`
> - `/passkeys/register-or-login/options`、`/passkeys/register-or-login/verify`

### 1）页面与按钮

```html
<!-- index.html 片段：按钮与日志面板 -->
<button id="btn-passkey">一键通行密钥</button>

<pre
  id="log"
  style="background:#111;color:#9f9;padding:12px;white-space:pre-wrap"
></pre>

<script type="module" src="./passkeys-web.js"></script>
```

### 2）前端模块：`passkeys-web.js`

```js
// ======================= 基础工具 =======================

// 复杂：生成稳定的设备ID（首访生成并持久化，用于设备→账号绑定与风控）
function getDeviceId() {
  const key = "device_id";
  let id = localStorage.getItem(key);
  if (!id) {
    id =
      crypto?.randomUUID?.() ||
      "dev-" + Date.now() + "-" + Math.random().toString(16).slice(2);
    localStorage.setItem(key, id);
  }
  return id;
}

// 复杂：base64url ↔ ArrayBuffer 转换，确保与后端统一
function b64urlToBuf(b64url) {
  const pad = "=".repeat((4 - (b64url.length % 4)) % 4);
  const b64 = (b64url + pad).replace(/-/g, "+").replace(/_/g, "/");
  const str = atob(b64);
  const buf = new ArrayBuffer(str.length);
  const view = new Uint8Array(buf);
  for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);
  return buf;
}
function bufToB64url(buf) {
  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
  let str = "";
  for (let i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}

// 复杂：把 AuthenticationOptions 中的 base64url 字段转 ArrayBuffer
function toWebAuthnRequestOptions(serverOpts) {
  const opts = structuredClone(serverOpts);
  // challenge 需要转 ArrayBuffer
  if (typeof opts.challenge === "string")
    opts.challenge = b64urlToBuf(opts.challenge);
  // allowCredentials 中的 id 也需要转 ArrayBuffer
  if (Array.isArray(opts.allowCredentials)) {
    opts.allowCredentials = opts.allowCredentials.map((c) => ({
      ...c,
      id: typeof c.id === "string" ? b64urlToBuf(c.id) : c.id,
    }));
  }
  return opts;
}

// 复杂：把 RegistrationOptions 中的 base64url 字段转 ArrayBuffer/Uint8Array
function toWebAuthnCreationOptions(serverOpts) {
  const opts = structuredClone(serverOpts);
  if (typeof opts.challenge === "string")
    opts.challenge = b64urlToBuf(opts.challenge);
  if (opts.user && typeof opts.user.id === "string")
    opts.user.id = b64urlToBuf(opts.user.id);
  if (Array.isArray(opts.excludeCredentials)) {
    opts.excludeCredentials = opts.excludeCredentials.map((c) => ({
      ...c,
      id: typeof c.id === "string" ? b64urlToBuf(c.id) : c.id,
    }));
  }
  return opts;
}

// 复杂：把 get() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）
function packAssertion(cred) {
  const resp = cred.response;
  return {
    id: cred.id,
    rawId: bufToB64url(cred.rawId),
    type: cred.type,
    response: {
      clientDataJSON: bufToB64url(resp.clientDataJSON),
      authenticatorData: bufToB64url(resp.authenticatorData),
      signature: bufToB64url(resp.signature),
      userHandle: resp.userHandle ? bufToB64url(resp.userHandle) : null,
    },
    clientExtensionResults: cred.getClientExtensionResults?.() || {},
  };
}

// 复杂：把 create() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）
function packAttestation(cred) {
  const resp = cred.response;
  return {
    id: cred.id,
    rawId: bufToB64url(cred.rawId),
    type: cred.type,
    response: {
      clientDataJSON: bufToB64url(resp.clientDataJSON),
      attestationObject: bufToB64url(resp.attestationObject),
    },
    clientExtensionResults: cred.getClientExtensionResults?.() || {},
  };
}

// 复杂：通用 POST 封装，自动带上设备ID
async function postJSON(url, body) {
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      // 设备ID写入 Header，便于后端风控/设备绑定。后端也可从 body 读取。
      "X-Device-Id": getDeviceId(),
    },
    body: JSON.stringify(body || {}),
    credentials: "include",
  });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}

// 复杂：检测“条件UI”与平台验证器可用性（仅做能力判断，不代表一定有凭据）
async function detectSupport() {
  const hasWebAuthn = "PublicKeyCredential" in window;
  let conditional = false,
    uvpa = false;
  try {
    conditional =
      !!(await PublicKeyCredential.isConditionalMediationAvailable?.());
  } catch {}
  try {
    uvpa =
      !!(await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable?.());
  } catch {}
  return { hasWebAuthn, conditional, uvpa };
}

// ======================= 业务主流程 =======================

// 复杂：优先尝试登录（可发现凭证/或定向 allowCredentials）；失败则自动转注册并登录
export async function oneTapPasskey(baseUrl = "") {
  const log = (msg) => {
    const pre = document.getElementById("log");
    if (pre) pre.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    console.log(msg);
  };

  const deviceId = getDeviceId();
  const { hasWebAuthn, conditional, uvpa } = await detectSupport();
  if (!hasWebAuthn) throw new Error("当前环境不支持 WebAuthn");

  log(`检测：conditional=${conditional}, uvpa=${uvpa}`);

  try {
    // ========== 步骤A：请求“登录 options” ==========
    log("请求登录 options...");
    const loginOptsResp = await postJSON(`${baseUrl}/passkeys/login/options`, {
      deviceIdentifier: deviceId,
    });
    const requestOptions = loginOptsResp.options || loginOptsResp; // 兼容你的返回结构
    const publicKey = toWebAuthnRequestOptions(requestOptions);

    // 复杂：若支持条件UI，则 mediation 设为 'conditional'；否则 'required'（需用户手势）
    const mediation = conditional ? "conditional" : "required";

    // ========== 步骤B：发起 credentials.get ==========
    log(`调用 navigator.credentials.get (mediation=${mediation})...`);
    const assertion = await navigator.credentials.get({ publicKey, mediation });

    // ========== 步骤C：打包并回传后端校验 ==========
    log("提交登录 verify...");
    const verifyBody = packAssertion(assertion);
    const verifyResp = await postJSON(
      `${baseUrl}/passkeys/login/verify`,
      verifyBody
    );

    log("登录成功 ✅ " + JSON.stringify(verifyResp));
    return { mode: "login", result: verifyResp };
  } catch (err) {
    // 复杂：常见失败 1）用户取消 2）设备没有匹配凭据 3）options 过期
    console.warn("登录失败，准备转注册：", err);
    // ========== 步骤D：请求“一键注册 options” ==========
    const regOptsResp = await postJSON(
      `${baseUrl}/passkeys/register-or-login/options`,
      {
        deviceIdentifier: deviceId,
      }
    );
    const { userId, options: creationOptionsServer } = regOptsResp.userId
      ? regOptsResp
      : { userId: regOptsResp.userId, options: regOptsResp.options };

    const publicKey = toWebAuthnCreationOptions(creationOptionsServer);

    // ========== 步骤E：发起 credentials.create（注册） ==========
    log("调用 navigator.credentials.create ...");
    const attestation = await navigator.credentials.create({ publicKey });

    // ========== 步骤F：打包并回传后端，完成绑定+激活+登录 ==========
    log("提交注册 verify...");
    const verifyBody = {
      ...packAttestation(attestation),
      userId, // 复杂：JIT 返回的临时/访客 userId
      deviceIdentifier: deviceId, // 复杂：用于设备→账号唯一绑定
    };
    const verifyResp = await postJSON(
      `${baseUrl}/passkeys/register-or-login/verify`,
      verifyBody
    );

    log("注册并登录成功 ✅ " + JSON.stringify(verifyResp));
    return { mode: "register-then-login", result: verifyResp };
  }
}

// ======================= 页面挂载：按钮点击即触发 =======================
document.getElementById("btn-passkey")?.addEventListener("click", () => {
  // 复杂：这里的 baseUrl 请改为你的后端地址；同源部署可留空
  oneTapPasskey("").catch((e) => {
    const pre = document.getElementById("log");
    if (pre) pre.textContent += `❌ ${e?.message || e}\n`;
    console.error(e);
  });
});
```

---

## 与后端契约（对齐要点）

- `/passkeys/login/options`

  - **入参**：`{ deviceIdentifier?: string }`（Header 也可）
  - **返回**：`{ options: PublicKeyCredentialRequestOptions }`（`challenge`、`allowCredentials[].id` 为 **base64url** 字符串）

- `/passkeys/login/verify`

  - **入参**：上文 `packAssertion()` 的结果（所有字节字段 **base64url**）
  - **返回**：`{ verified: true, token, userId }`

- `/passkeys/register-or-login/options`

  - **入参**：`{ deviceIdentifier?: string }`
  - **返回**：`{ userId: string, options: PublicKeyCredentialCreationOptions }`（`challenge`、`user.id`、`excludeCredentials[].id` 为 **base64url**）

- `/passkeys/register-or-login/verify`

  - **入参**：`packAttestation()` + `{ userId, deviceIdentifier }`
  - **返回**：`{ verified: true, token, userId }`

> 以上与您现有的 `PasskeysService` 设计完全兼容。你也可以在“已绑定设备”场景下返回 `allowCredentials`，以提升命中率（文中已说明）。

---

## 常见问题（FAQ）

- **能不能“先看一下本地有没有凭据”，有就登录、没有就不调后端？**
  不能。浏览器不允许枚举凭据。你能做的只是能力探测与**尝试调用** `credentials.get`。而调用 `get/create` 都必须先有**服务端下发的 options（含 challenge）**。

- **什么时候用条件 UI（conditional mediation）？**
  页面加载即拿到 `login options` 后即可“无提示等候”；但为简化，这里在**按钮点击**后再调，用 `mediation='conditional'`（若可用）+ `required` 作为兜底。

- **后端 challenge 过期怎么办？**
  统一设置较短 TTL（如 300s），一旦 `get/create` 抛出 `InvalidStateError/NotAllowedError`，前端直接重拉 options 再试。

---

## 测试步骤

1. **HTTPS 环境**部署（本地可用 `localhost`）
2. **确保后端 RP_ID/ORIGIN 正确**、Redis 正常、四个路由可达
3. 首次访问：点击按钮 → 预期走注册 → 后端 verify 成功后返回 token
4. 再次访问：点击按钮 → 直接 `get()` 登录成功
5. Android/Chrome 测试条件 UI：地址栏出现通行密钥提示；Safari 需同源 HTTPS

---

## 小结

- “先判断本地是否有凭据”在浏览器上**不可行**；
- **正确做法**是**每次先拿登录 options**，用 `credentials.get` 尝试登录；
- **失败则无缝切到注册**（JIT 建号 + 可发现凭证 + 注册即登录）。
- 上文代码开箱即用，你只需要把 `baseUrl` 指向你的后端即可。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[鉴权判定“最佳实践”：别维护白名单数组，用“前缀约定 + 显式覆盖”]]></title>
        <id>https://herongdev.github.io/blog/posts/显式覆盖</id>
        <link href="https://herongdev.github.io/blog/posts/显式覆盖"/>
        <updated>2025-09-05T21:13:27.000Z</updated>
        <content type="html"><![CDATA[
## 结论（一句话）

**不要维护 `noAuthPaths` 白名单数组。**
大厂常用是**约定式路径前缀**（如 `/api/pub/**` 全部公开，其余默认鉴权）+ **显式 `auth:false` 覆盖**个别特殊接口（如登录/注册）。必要时再做**双实例**（`authHttp`/`pubHttp`）隔离。

## 你只需做的最小改动（片段）

### 1) 用“前缀约定”替换白名单数组

> 复杂逻辑：将“是否需要鉴权”收敛为**实例级默认值** + **URL 前缀** + **每次请求的显式覆盖**。

**删除：**

```ts
// 删除这行
const noAuthPaths = [
  "/login",
  "/register",
  "/public-endpoint",
  "/api/pub/get_feednews",
];
```

**在 `createAxiosHttp` 定义处新增第二个参数（不改已有调用方也能有默认值）：**

```ts
// 复杂逻辑：通过 opts 控制默认鉴权与公开前缀
function createAxiosHttp(
  config: AxiosRequestConfig,
  opts: { authDefault?: boolean; publicPrefixes?: string[] } = {},
) {
  const authDefault = opts.authDefault ?? true
  const publicPrefixes = opts.publicPrefixes ?? ['/api/pub']  // 仅维护“前缀”，而非逐个接口
  // ...
```

**在请求拦截器里替换 needAuth 判定：**

```ts
_axios.interceptors.request.use((req) => {
  // ...（保留你已有的 AbortController 代码）

  // 复杂逻辑：先按前缀判定是否公开，再由显式 req.auth 覆盖
  const url = req.url || "";
  const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));

  // 复杂逻辑：优先使用 req.auth（true/false），否则用实例默认值 + 前缀约定
  const needAuth = (req as any).auth ?? (authDefault && !isPublicByPrefix);

  const accToken = storage.get(ACCESS_TOKEN);
  const tokenType = storage.get(TOKEN_TYPE) || "Bearer";
  if (needAuth && !accToken) {
    ((req as any).__abortController as AbortController | undefined)?.abort();
    return Promise.reject(new Error("UNAUTHENTICATED"));
  }
  if (needAuth && accToken) {
    req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };
  }
  return req;
});
```

**创建实例时传入前缀约定（一次配置，全局生效）：**

```ts
// 复杂逻辑：默认需要鉴权，唯独 /api/pub/** 前缀走公开
const http = createAxiosHttp(
  {
    timeout: 10000,
    baseURL: API_BASE,
    withCredentials: true,
    xsrfCookieName: "Authorization",
    xsrfHeaderName: "Authorization",
  },
  { authDefault: true, publicPrefixes: ["/api/pub"] }
);
```

### 2) 显式覆盖个别公开接口（例如登录/注册）

> 复杂逻辑：无需继续维护数组；在调用时给 `{ auth:false }`。

```ts
// 复杂逻辑：显式声明无需鉴权
http.request("/auth/login", "POST", body, { auth: false });
http.request("/auth/register", "POST", body, { auth: false });
```

### 3) 小修 bug：统一释放键，避免内存泄露

> 你在请求里写的是 `__abortController`，但错误拦截里读取的是 `__ac`。统一成同一个键。

**在错误拦截器里替换：**

```ts
// 复杂逻辑：统一用 __abortController
const abortController = (err?.config as any)?.__abortController as
  | AbortController
  | undefined;
if (abortController) abortPool.delete(abortController);
```

---

## 为什么这是“更像大厂”的做法

- **约定 > 配置**：接口分层（`/api/pub/**` 公开，其他默认鉴权）是**稳定、低维护**的组织方式；新增公开接口只需放在该前缀下。
- **按需覆盖**：极少数“路径不在公开前缀但仍需公开”的接口，用 `auth:false` **显式声明**，可读性强。
- **可扩展**：未来要拆网关/多后端时，可用**双实例**进一步隔离（见下方“进阶”）。
- **类型友好**：`AxiosRequestConfig` 扩展 `auth?: boolean`，IDE 自动提示，避免遗漏。

---

## 进阶可选（按需采纳）

### 方案 B：双实例隔离（最常见于中大型前端）

> 公有与鉴权接口**不同实例**，互不影响，拦截器更简单。

```ts
// 复杂逻辑：一个实例默认鉴权，一个实例默认公开
export const authHttp = createAxiosHttp(config, {
  authDefault: true,
  publicPrefixes: [],
});
export const pubHttp = createAxiosHttp(config, {
  authDefault: false,
  publicPrefixes: ["/api/pub"],
});

// 使用时不再传 auth:false
pubHttp.request("/api/pub/get_feednews", "GET");
authHttp.request("/api/secure/profile", "GET");
```

### 方案 C：API 分层封装（类型安全）

> 给每个后端接口包一层函数：在函数里固定 `auth:true/false`，业务层不再关心 `auth`。

```ts
// 复杂逻辑：在 API 层固定鉴权语义
export const Api = {
  getFeedNews: () =>
    http.request<Feed[]>("/api/pub/get_feednews", "GET", undefined, {
      auth: false,
    }),
  getProfile: () => http.request<Profile>("/api/secure/profile", "GET"), // 默认为鉴权
};
```

---

## 小结

- **最佳实践**：**前缀约定 + 显式覆盖**，别再维护接口白名单数组。
- 这样新增公开接口只要放到 `/api/pub/**`，其余默认鉴权；个别例外 `auth:false` 即可。
- 若项目更复杂，进一步采用**双实例**或**API 分层**，把鉴权语义固化到“调用入口”，彻底杜绝分散判断。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AI 时代技能谱系：广而杂还是深而稳？——给在职开发者的「反替代」路线图]]></title>
        <id>https://herongdev.github.io/blog/posts/AI-协作与边界/AI 时代技能谱系：广而杂还是深而稳？——给在职开发者的「反替代」路线图</id>
        <link href="https://herongdev.github.io/blog/posts/AI-协作与边界/AI 时代技能谱系：广而杂还是深而稳？——给在职开发者的「反替代」路线图"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 摘要（直给结论）

- **要求更广，但不能“平均用力”。** 今天的工作更像“系统整合 + 业务落地 + AI 协同”。最佳形态是 **T/π 形**：一到两条深根（护城河）＋若干相邻面（会用、会集成）。
- **只会单一、可模板化的技能，确实更易被 AI 替代**——特别是输入输出可量化、历史数据充足、验收标准清晰、合规要求低的任务。
- **持续学习是必要条件，但有方法论**：以业务结果为导向，选择“相邻栈”递进式拓展；用“可验证产物”替代“学过痕迹”。
- **AI 在新技术上的回答确实更容易不准**（训练滞后、资料稀疏、概念易混），所以要建立“**四重校验**”与“**带置信度的提问模板**”。

## 1. 为什么感觉“要求更杂”？

- **边界更多**：云原生、数据与安全、AI 推理与评估、端到端观测，协作面拉长。
- **交付标准更现实**：不仅“能跑”，还要**可观测、可评测、可解释、可控成本**。
- **工具栈“可替代”，能力栈“不可替代”**：框架会换，人机协同、系统思维、需求澄清不会换。

> 判断是否该“学得更杂”的准绳：你是否经常**卡在边界**（网关/鉴权/数据质量/部署/观测/合规）？如果是，说明需要“补相邻面”。

## 2. 单一技能会被 AI 取代吗？

### “自动化风险五问”（答“是”的越多，风险越高）

1. 需求是否**高度标准化**（几乎不与人沟通）？
2. 输入输出是否**完全可量化**（像打分题）？
3. 是否有**充足历史样本**可供模型拟合？
4. 验收是否**单指标**就能定胜负（例如准确率阈值）？
5. **合规与安全要求低**（错了成本也不高）？

**高风险示例**：纯 CRUD、简单切图、常见脚手架/迁移、无上下文的“写单元测试”。
**低风险示例**：含**需求沟通与取舍**、**跨系统约束**、**性能/成本与 SLO**、**现场应急与灰度回滚**、**数据与合规治理**的工作。

> 你的“护城河”应落在**难以标准化**的环节：需求澄清、系统设计、成本/性能权衡、数据与安全、上线与可观测、口述解释与知识迁移。

## 3. 广学 ≠ 乱学：用 **T/π 形**规划相邻面

### 3×3 能力面板（示例）

- **深根（选 1–2 条）**：如前端工程化/可观测、后端高并发/数据一致性、GIS/地图与空间索引、AI 检索/RAG。
- **相邻面（选 2–4 个）**：云部署（容器/CI/CD）、数据工程（ETL/质量）、安全与合规（鉴权/审计/隐私）、AI 评测与成本治理。
- **通用底座**：网络/OS/数据库基础、系统设计沟通、度量与实验。

### 90 天“相邻栈”拓展法（按周产物驱动）

- **每 2 周**选择一个“业务化小题”：必须交付 **在线 Demo + 自动评测 + 走查视频**。
- **每次拓展只加一跳**：例如你的深根是前端 → 相邻：RAG 接入 → 再相邻：检索评测与观测 → 再相邻：低成本推理与缓存。
- **用“证据化简历”积木**：每个积木包含问题、约束、指标、权衡与结果图表。

## 4. 为什么 AI 在“新技术”上更不准？怎么避坑？

**原因**

- **训练滞后**：模型更新不及生态演进。
- **语料稀疏**：新框架/新版本案例少、歧义多。
- **官方语义易变**：参数名/默认值/兼容策略频繁改。
- **错因难察**：模型会“自洽”地补全缺失事实（幻觉）。

**四重校验法**（从低信到高信）

1. **营销/博客**（仅作线索）
2. **官方文档与 Release Notes**（版本边界为王）
3. **源码与官方示例/测试**（真相在 tests/）
4. **最小可复现实验**（容器化、锁版本、保留日志与指标）

**带置信度的提问模板**（贴给 AI，用于新技术检索）

```text
你将回答一个可能涉及新版本/新库的问题。要求：
1) 若你不确定或缺语料，请明确输出【未知】并停在这里，不要编造。
2) 给出“你确定的部分”的最小示例，并标注版本前提（库名@版本）。
3) 附上你建议的验证步骤清单（我会用最小容器验证）。
问题是：<在此粘贴我的问题>。
```

**最小可复现实验模板（MRE）**

```bash
# 1) 创建隔离环境并锁版本
mkdir mre && cd mre
# 用你常用的包管理器/容器，统一输出版本
# 2) 复制最小代码，记录命令与日志
# 3) 保存 benchmark/指标到 artifacts/ 目录（便于复查与对比）
```

## 5. 面向在职者的“反替代”清单（可直接执行）

- **每周 1 次走查**：选择一段最近改过的核心代码，用 10 分钟口述：背景 → 约束 → 方案 → 权衡 → 指标。
- **每周 1 个边界点**：在鉴权、缓存、限流、观测、灰度中选一个做“最小实验”，写下复盘。
- **每季度 1 个“业务化”作品**：必须可在线访问，有指标截图与成本分析。
- **AI 使用日志**：保留 prompt、版本、你做的修改与验证结论，形成**过程证据**。
- **技术雷达看板**（观望/试点/采用/放弃四象限），每月更新一次。

示例雷达（YAML）

```yaml
adopt:
  - "RAG 线上评测（准确率/延迟/成本/安全）"
  - "可观测三件套（日志/指标/追踪）"
trial:
  - "函数级缓存 + Token 限额联动"
  - "前端 A/B + 合成监控"
assess:
  - "Agent 工作流（以特定业务为锚）"
  - "向量数据库 X 与 Y 的冷热分层"
hold:
  - "仅换皮的脚手架替换"
```

## 6. “广度”怎么选？——三个优先级原则

1. **靠近现金流**：优先学能直接降低成本/提升转化/缩短交付的东西（如观测、评测、缓存、灰度与成本治理）。
2. **靠近你的深根**：相邻一跳最划算，跨三跳成本陡增。
3. **可证据化**：能用指标与 Demo 证明价值的学习，才会沉淀为“护城河”。

## 7. 给你的个性化建议（结合你之前的方向）

你长期做前端/全栈与地图相关工作，也在搭建 AI 相关功能。建议的 π 形组合示例：

- **深根 A**：前端工程化 + 可观测（含性能与体验指标）。
- **深根 B**：RAG 与检索评测（与地图/知识检索联动）。
- **相邻面**：数据治理（质量/去重/标注）、鉴权与审计、成本治理（缓存/批处理/降级）、GIS 空间索引与切片服务。
- **落地路线**：用你现有站点做“AI + 地图知识库”项目，从**指标化问答**（正确率/延迟/成本）入手，逐步加入**合规与安全检查**。

## 8. 一句话记忆法

- **深耕 1–2 条可度量的护城河**，再**串起 2–4 个相邻面**；
- **每两周一个“线上可验证”的小成果**；
- **让 AI 当陪练，而非代写**；
- **新技术一律“四重校验 + MRE”过闸**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AI 时代：工程师不可替代的价值与协作边界]]></title>
        <id>https://herongdev.github.io/blog/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界</id>
        <link href="https://herongdev.github.io/blog/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界"/>
        <updated>2025-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[这些是 AI 相对更弱、人类工程师显著更强的领域，以及落地的人机协作做法与质量保障。]]></summary>
        <content type="html"><![CDATA[
## 为什么要谈“边界”

AI 擅长“已知知识的重组与加速”，但在“问题定义、系统性权衡、非完备信息推理、组织沟通与落地”上存在天然短板。明确人机边界，能让 AI 负责“快且广”，工程师负责“准与稳”。

## 人类工程师显著更强的领域

### 1）需求澄清与问题定义

- 把模糊诉求变成可验证的目标/约束/验收标准
- 在成本/性能/上市时间等冲突目标之间做取舍并对齐干系人

### 2）系统设计与演进路线

- 跨模块/跨团队的架构升级、灰度与回滚策略
- 面向未来不确定性的扩展点，平衡复杂度与收益

### 3）真实生产问题定位（非完备信息）

- 偶发、不可复现故障的“信号拼图”与因果链验证
- 跨层关联日志/指标/链路，形成可复现实验和结论

### 4）领域知识与隐性约定

- 行业合规/风控/结算/对账等隐性“黑话”与规则
- 团队历史技术债与未显式表达的不变量

### 5）安全、隐私与合规（PIPL/GDPR/许可证）

- 供应链安全、最小权限、日志脱敏、审计与存证
- 在业务价值与合规要求之间做可落地的折中

### 6）分布式与性能工程

- 幂等/重试/限流/熔断等系统级设计与验证
- 基准测试设计，硬件/内核/网络抖动下的性能归因

### 7）复杂交互与可用性

- 真用户的边界输入、可访问性与可用性权衡
- 多端/多浏览器/容器内嵌环境的微妙差异处理

### 8）数据与正确性

- 事务边界、最终一致、补偿/重放的业务落地
- 数据质量/血缘/稽核与“可追责”的数据治理

### 9）产品感觉与工程品味

- API 的语义一致性与长期可维护性
- 何时“少做/不做”，把复杂度留在正确层次

### 10）组织沟通与推动落地

- 与上下游谈判、拆分排期与风险缓解、跨团队协作
- 方案说服与共识形成，真正“从纸面到生产”

### 11）实验设计与度量

- 指标选择、A/B 边界、因果与相关的区分
- 防“纸面最优”，用业务闭环指标检验技术方案

### 12）零先例创新与复盘文化

- 无公开资料时的原型验证、快速试错与知识沉淀
- 事后复盘（Postmortem）与最小可复现仓库建设

## 可落地的人机协作流程（模板化执行）

### A. 文档先行（AI 起草，人类定锚）

- 产出《问题定义/约束/验收标准》与《设计评审提纲》
- 用清单化模板：输入、假设、边界、风险、观测项

### B. 强化“验证链路”

- 最小可复现（MRE）、自动化测试、基准测试与可观测性基线
- 对高风险改动设护栏：灰度/回滚/特性开关/错误预算

### C. 产物分级与质量关卡

- AI 产物只进“开发态/草稿态”，上线前必须经 CR 与度量验证
- 引入“拒收条件”：不满足验收标准/观测项即退回补强

### D. 知识显性化与复用

- 维护《事故复盘》《设计评审》《发布流程》三套 Checklist
- 以专题/系列沉淀：生产复盘、系统权衡、行业隐性规则

## 建议的长期专题（可做成系列与课程）

- 生产问题复盘：从信号采集到因果验证的全链路
- 系统权衡与演进：灰度、回滚、演进路线与“变更即文档”
- 性能与分布式：限流/熔断/幂等等“系统级能力”的可验证实践
- 数据治理：质量/血缘/稽核与数据可追责体系
- 安全与合规：供应链安全、最小权限、合规落地与审计
- 工程化流程：评审/发布/观测/复盘的标准化与自动化

## 结语

AI 让“生成更快”，工程师让“正确落地”。边界越清晰，协作越高效。把“不可替代”的能力沉淀为流程、清单与课程，才是个人品牌与团队战斗力的复利来源。

## 延伸阅读

- 请求层与鉴权：
  - [/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线](/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线)
  - [/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）](/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）)
- Vue 性能与交互：
  - [/posts/前端/Vue/Vue 项目请求处理优化](/posts/前端/Vue/Vue项目请求处理优化)
  - [/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）](/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）)
- 实时通信与网络：
  - [/posts/前端/实时通信/web 应用开发-前端-Web-应用如何做到实时消息通知](/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知)
- 下载与文件：
  - [/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）](/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）)
- Web 推送与标识：
  - [/posts/Web-API-与推送/Web-Push/Web-Push-推送简介](/posts/Web-API-与推送/Web-Push/Web-Push-推送简介)
  - [/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取](/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取)
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[<替换为标题>]]></title>
        <id>https://herongdev.github.io/blog/posts/_templates/article</id>
        <link href="https://herongdev.github.io/blog/posts/_templates/article"/>
        <updated>2025-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<一句话摘要，便于 SEO>]]></summary>
        <content type="html"><![CDATA[
## 背景与目标

- 业务/技术背景
- 这篇文章要解决什么问题？如何验证？

## 问题分析（可复现）

- 最小复现或真实案例
- 误区与常见失败路径

## 解决方案（可验证）

- 方案对比与取舍
- 步骤/代码/配置
- 验证与指标

## 探索与延伸

- 边界条件、兼容性、性能与安全
- 与相关专题的链接

## 结论与行动项

- 关键结论
- 下一步可执行清单
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[<专题导言：描述系列价值与对象>]]></title>
        <id>https://herongdev.github.io/blog/posts/_templates/series-intro</id>
        <link href="https://herongdev.github.io/blog/posts/_templates/series-intro"/>
        <updated>2025-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<系列摘要与读者收益>]]></summary>
        <content type="html"><![CDATA[
## 系列对象与前置

- 适合谁？需要什么前置知识？

## 目录与进度

- [第 1 篇：主题 A](/posts/...) —— 进度：✅/进行中
- [第 2 篇：主题 B](/posts/...)

## 学习方式

- 推荐阅读顺序
- 配套 Demo/最小复现仓库

## 常见问题

- FAQ 1
- FAQ 2
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin + Swift 快速入门实战课程大纲（AI 驱动版）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/Kotlin + Swift 快速入门实战课程大纲（AI 驱动版）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/Kotlin + Swift 快速入门实战课程大纲（AI 驱动版）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 前言

你的思路非常正确 👍

- 不再像以前一样花几个月甚至一年去“系统化”学习，而是**以开发为目标、遇到问题即学**；
- 借助 **AI 辅助**，快速查缺补漏、解决问题；
- 在 **边学边写**的同时，把知识整理成 **系统化的精简教程（博客）**，不仅能加深理解，还能对外输出，吸引同样有需要的读者。

这种方法既能让你快速上手开发项目，又能通过博客积累个人影响力。

下面给你一个适合写成 Hexo 博客系列的**课程大纲**（即后续每篇文章的章节目录）。

---

## 课程大纲（Hexo 博客结构）

### 1. 开篇

- 为什么要学 Kotlin 和 Swift
- Android vs iOS 开发的差异
- AI + 实战驱动的学习方法介绍
- 学习环境准备（HBuilderX、Android Studio、Xcode、模拟器）

---

### 2. Kotlin 入门（Android 开发）

- Kotlin 基础语法速览（变量、函数、类、集合）
- Android 应用结构（Activity、Manifest、Gradle）
- 最常用的 Android API：Toast、日志、权限、存储
- 实战示例：写一个能显示唯一设备 ID 的小工具

---

### 3. Swift 入门（iOS 开发）

- Swift 基础语法速览（变量、函数、类、集合）
- iOS 应用结构（AppDelegate、SceneDelegate、Info.plist）
- 最常用的 iOS API：Alert、日志、权限、存储
- 实战示例：写一个能显示设备 IDFV 的小工具

---

### 4. 跨平台思维：相同功能如何用两种语言实现

- 获取设备唯一标识（Android vs iOS）
- 调用相机拍照
- 调用网络请求
- 本地持久化存储

---

### 5. 与 UTS 插件结合

- 什么是 UTS 插件
- Kotlin + Swift 混编到 UTS 插件
- 写一个“ID Kit”插件（即你正在开发的功能）
- 在 uni-app 项目中调用

---

### 6. AI 驱动的开发学习法

- 如何用 AI 查文档、解释代码
- 如何把“遇到问题 → 提问 → 得到解答 → 整理成博客”变成习惯
- 写博客的结构化模板（背景 → 问题 → 解决方案 → 示例代码）

---

### 7. 博客运营与个人影响力

- 如何把教程系统化整理到 Hexo
- 如何在掘金/知乎/公众号同步
- 如何加上 SEO 关键词（比如 “Kotlin 教程 快速上手” / “Swift 实用开发”）
- 如何在写项目的同时吸引读者

---

## 学习路线特点

- **精简**：只覆盖最常用、马上能用的语法/知识
- **实战驱动**：每一章都有小 Demo，可以直接运行
- **AI 补充**：不懂的再查，而不是被动死记硬背
- **博客沉淀**：学习成果 = 系统教程

---

👉 接下来，我们可以从 **第一篇博文**（比如《为什么要学 Kotlin 和 Swift：AI 时代的移动开发学习法》）开始写。

要不要我帮你起草 **第一篇 Hexo 博客内容**（带前言、动机、学习方法和环境准备）？
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么要学 Kotlin 和 Swift：AI 时代的移动开发学习法]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/为什么要学 Kotlin 和 Swift：AI 时代的移动开发学习法</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/为什么要学 Kotlin 和 Swift：AI 时代的移动开发学习法"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 前言

在 AI 辅助开发的今天，学习编程语言和框架的方式正在发生巨大变化。
过去，我们常常需要花费数月甚至一年的时间，去系统地学习一门语言：看书、看视频、上培训班……
但现在，**AI 就像随身携带的老师**，让我们可以随时提问、随时解决问题。

这篇文章是本系列课程的开篇，目的是带你进入 **Kotlin（Android）** 与 **Swift（iOS）** 的学习世界，
并告诉你如何用 **实用、精简、快速** 的方式掌握这两门移动开发语言。

---

## 为什么是 Kotlin 和 Swift？

- **Kotlin**：Google 官方推荐的 Android 开发语言，简洁、安全，兼容 Java。
- **Swift**：Apple 官方推荐的 iOS/macOS 开发语言，语法现代，性能接近 C++。
- **移动开发的必备技能**：
  想写原生 App，或者写跨平台插件（比如 UTS 插件），这两门语言绕不开。

---

## 为什么现在学习更容易？

### 1. 有 AI 辅助

不会的地方，可以马上问 AI：

- “Kotlin 中如何写一个单例？”
- “Swift 怎么调用系统相机？”
  得到的答案往往比去翻文档快得多。

### 2. 不用从零到一系统学习

过去要学完所有语法，才能开始写项目。
现在我们可以直接上手写项目，遇到不会的再查。
**学习和实战并行，不拖延。**

### 3. 学习+输出的闭环

我们不只是学，还要写博客：

- 今天学了 `Kotlin 的数据类` → 写一篇博文分享。
- 明天学了 `Swift 获取设备唯一 ID` → 写一篇博文总结。
  这样不仅加深记忆，还能吸引流量，打造个人品牌。

---

## 学习方法论

1. **快速扫盲**：先过一遍最常用的语法（变量、函数、类、集合）。
2. **马上动手**：写一个小 Demo，比如“获取设备唯一 ID 并打印”。
3. **遇到问题 → 提问 AI → 记录答案**。
4. **整理成博客**：一篇篇文章，最终就是一本属于你的“快速入门手册”。

---

## 环境准备

### Android 端

- 安装 **Android Studio**（官方 IDE）
- 学习使用 Kotlin 文件（.kt）
- 熟悉 Android 项目结构（`MainActivity.kt`、`AndroidManifest.xml`、Gradle）

### iOS 端

- 安装 **Xcode**（苹果官方 IDE）
- 学习使用 Swift 文件（.swift）
- 熟悉 iOS 项目结构（`AppDelegate.swift`、`Info.plist`）

### 跨平台插件（可选）

- 安装 **HBuilderX**，用于开发 uni-app / UTS 插件
- 未来我们会写一个同时支持 Android + iOS 的 **ID Kit 插件**，实践 Kotlin 与 Swift

---

## 下一步

在下一篇文章中，我们将进入 **Kotlin 入门**，快速掌握 Android 开发中最常用的语法和知识点，并用一个 Demo 展示如何获取 Android 的唯一设备 ID。

---

👉 提问：
你希望下一篇 **Kotlin 入门** 的博文风格是：

- **“语法精简速览 + Demo 实战”**（适合快速入门）
  还是
- **“从 0 开始循序渐进”**（更系统，但内容会多一些）？
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/README]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/README</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/README"/>
        <updated>2025-09-18T17:26:53.092Z</updated>
        <content type="html"><![CDATA[# Swift 第二阶段（专题进阶）目录

本套目录覆盖 iOS 开发常见的 **框架 / 并发 / 网络 / 架构 / 性能 / 安全 / 发布 / 多平台** 等主题，
作为第一阶段（语法速成）的延续。每篇将包含：
- 背景与场景
- 最小可跑示例（可复制）
- 常见坑与Checklist
- 延伸阅读与实战练习

> 使用方式：将本目录放入你的 Hexo 源仓库（如 `source/_posts/swift-advanced/`），按专题逐步完善。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 第二阶段（专题进阶）说明]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/gpt</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/gpt"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 第二阶段（专题进阶）说明

在完成 **Swift 入门快速掌握（第一阶段）** 之后，我们将进入 **第二阶段（专题进阶）**。  
这一阶段的目标是：系统深入学习 Swift 与 iOS 开发生态，涵盖实际开发中必须掌握的各类专题。

---

## 使用说明

当你准备好进入第二阶段时，只需要告诉 AI：

```

进入 Swift 第二阶段（专题进阶）模式，写第 X 篇

```

即可触发进阶教程的生成。

---

## 统一提示词（保存备用）

```

进入 Swift 第二阶段（专题进阶）模式：

* 背景：我已完成 Swift 入门快速掌握（第一阶段），现在要系统深入学习 Swift 与 iOS 开发。
* 目标：逐个专题生成完整的 Hexo 博文系列（带 YAML front-matter、分节结构、示例代码、实战要点），直到完成所有文章。
* 范围：按照 “swift-advanced-v2.zip” 提供的目录结构，覆盖 iOS 应用开发、SwiftUI、网络编程、并发与多线程、数据持久化、架构模式、测试质量、性能优化、系统能力、安全合规、发布运营、互操作、多平台扩展、视觉交互进阶、专题案例。
* 风格：每篇博文需包含：

  1. 简要背景/场景
  2. 核心概念与语法
  3. 5 分钟可跑的最简示例
  4. 实战要点与常见坑
  5. Checklist 总结
  6. 延伸阅读
* 输出形式：Hexo 博文 Markdown（带 front-matter）。

```

---

## 第二阶段目录（示例）

- iOS 应用开发（UIKit、SwiftUI）
- 网络编程（URLSession、Codable）
- 并发与多线程（GCD、async/await）
- 数据持久化（CoreData、SQLite、文件系统）
- 架构模式（MVC、MVVM、VIPER）
- 测试与质量保障
- 性能优化与调试
- 系统能力（传感器、通知、定位等）
- 安全与隐私合规
- 发布与运营（App Store、TestFlight）
- 互操作（Swift 与 C/Objective-C）
- 多平台扩展（iPad、macOS、watchOS、tvOS）
- 视觉与交互进阶（动画、手势）
- 专题案例实战

---

📌 **提示**  
第一阶段的课程已经保证你在 8 小时内快速掌握 Swift 核心语法，能读懂 AI 写的代码。  
第二阶段则是 “实战专题”，深入到各个方面，帮你从“能写”到“能做应用”。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-quickstart/0-提示词]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/0-提示词</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/0-提示词"/>
        <updated>2025-09-18T17:26:53.093Z</updated>
        <content type="html"><![CDATA[我来为你总结一些提示词，这样你以后可以快速让我以这种风格来整理和分类 Swift 知识点：

## 🎯 **提示词模板**

### **基础分类提示词**

- `"把这段代码的知识点分类到 swift-quickstart 教程中"`
- `"这段代码涉及哪些语法，放到对应的教程文件里"`
- `"解释这段代码并归类到合适的章节"`
- `"分析这个语法特性，添加到相应的教程中"`

### **具体语法提示词**

- `"这个 try? 用法，添加到可选类型教程"`
- `"这个协议实现，放到协议章节"`
- `"这个类定义语法，归类到结构体与类"`
- `"这个 import 语句，放到模块导入教程"`
- `"这个闭包写法，添加到闭包章节"`

### **实战导向提示词**

- `"以实战示例的形式，把这段代码加到教程"`
- `"用速成的方式解释这个语法，放到对应文件"`
- `"这是实际项目中的代码，分类到教程中"`
- `"把这个知识点做成速查表格式"`

## 📋 **我的回答风格特点**

### **1. 自动识别归类**

- 分析代码涉及的核心语法点
- 自动判断应该放在哪个教程文件中
- 如果涉及多个知识点，会分别归类

### **2. 结构化解释**

- 🎯 核心语法点提取
- ✅ 为什么这样写的优势分析
- 📝 逐行代码解释
- 🚀 实际应用场景举例

### **3. 实战导向**

- 提供完整可运行的代码示例
- 对比不同写法的优劣
- 展示真实项目中的使用场景
- 包含常见错误和最佳实践

### **4. 速成友好**

- 重点突出，避免冗长理论
- 用表格、列表等形式快速总结
- 提供速查手册式的内容组织
- 注重实用性而非完整性

## 🔥 **推荐的使用方式**

```
// 你只需要这样说：
"这段代码分类一下"
"把这个语法归类到教程"
"解释这段代码并分类"
"这个知识点放到对应章节"

// 我会自动：
1. 识别核心语法特性
2. 选择合适的教程文件
3. 以实战示例的形式添加
4. 提供详细的逐步解释
5. 包含最佳实践和常见错误
```

## 💡 **特殊场景提示词**

- `"这个代码涉及多个知识点，分别归类"`
- `"这是系统 API 调用，放到对应的框架介绍中"`
- `"这个错误处理模式，添加到错误处理教程"`
- `"这个性能优化技巧，归类到相应章节"`
- `"这个设计模式，放到架构相关教程"`

这样，你以后在读源码时，只需要复制代码片段 + 简单的分类指令，我就会按照这种风格来整理知识点，帮你建立系统化的学习资料！
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（1）：语法速览]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/01-语法速览</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/01-语法速览"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（1）：语法速览

> 本文属于 Swift 入门速成系列，帮助你在 **8 小时内掌握最常用的语法与特性**，快速读懂代码。  
> 本篇作为第一篇，带你 **一眼看懂 Swift 的常见语法**，相当于一个“速查表”。

## 基本语法特点

- **强类型语言**：所有变量、常量都有确定类型。
- **类型推断**：大多数时候不用显式写类型，编译器能自动推断。
- **安全性强**：默认变量必须初始化，避免空指针。
- **现代简洁**：省去了大量冗余符号，代码更接近自然语言。

## 变量与常量

```swift
let pi = 3.14159      // 常量，不能修改
var age = 18          // 变量，可以修改

age = 20              // ✅ 可以修改
// pi = 3.14          // ❌ 报错：常量不可修改
```

## 常见数据类型

```swift
let name: String = "Swift"
let score: Int = 95
let price: Double = 19.99
let passed: Bool = true
```

## 字符串插值

```swift
let name = "Alice"
let age = 20
print("Hello, my name is \(name), I am \(age) years old.")
```

## 数组与字典

```swift
// 数组
var numbers = [1, 2, 3, 4]
numbers.append(5)
print(numbers[0])  // 输出 1

// 字典
var user = ["name": "Bob", "age": "22"]
print(user["name"] ?? "Unknown") // Bob
```

## 条件语句

```swift
let score = 85
if score >= 90 {
    print("优秀")
} else if score >= 60 {
    print("及格")
} else {
    print("不及格")
}
```

## 循环

```swift
for i in 1...5 {
    print("第 \(i) 次")
}

var n = 3
while n > 0 {
    print(n)
    n -= 1
}
```

## 函数

```swift
func greet(name: String) -> String {
    return "Hello, \(name)"
}

print(greet(name: "Swift")) // Hello, Swift
```

## 可选类型（Optionals）

```swift
var nickname: String? = nil
nickname = "小明"

// 安全解包
if let nick = nickname {
    print("昵称：\(nick)")
}
```

## 小结

这一篇带你快速扫了一遍 **Swift 最常见的语法**：

- 变量与常量（`var` / `let`）
- 常见数据类型（`String`、`Int`、`Double`、`Bool`）
- 数组与字典
- 条件与循环
- 函数
- 可选类型（`?` 和 `if let`）
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（2）：变量与常量]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/02-变量与常量</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/02-变量与常量"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（2）：变量与常量

## 基本概念

- **`var`**：变量，可以修改。
- **`let`**：常量，定义后不可修改。

```swift
var age = 18
age = 20          // ✅ 可以修改

let pi = 3.14159
// pi = 3.14      // ❌ 报错：常量不可修改
```

## 类型推断与显式声明

Swift 编译器会自动推断变量的类型，但你也可以显式声明。

```swift
// 类型推断
var name = "Alice"     // 自动推断为 String
var score = 95         // 自动推断为 Int

// 显式声明
var city: String = "Beijing"
let year: Int = 2025
```

## 命名规范

- 推荐使用 **小驼峰**：`userName`、`totalScore`。
- 可以使用 Unicode：`let 😊 = "smile"`（但实际开发不推荐）。
- 避免拼音或缩写，代码更清晰。

## 多变量声明

```swift
var x = 0, y = 1, z = 2
let red = 255, green = 128, blue = 64
```

## 懒加载与延迟初始化

有些变量可能要等到第一次用时才计算，可以用 `lazy` 修饰。

```swift
lazy var data = loadData() // 第一次访问时才会调用 loadData()
```

> 注意：`lazy` 只能修饰 **var**，不能修饰 **let**。

## 可变性原则

Swift 推荐：

- **默认用 `let`**，只有需要修改时才用 `var`。
- 这样可以避免无意的修改，提高代码安全性。

## 小结

- `var` 定义变量，可变。
- `let` 定义常量，不可变。
- 默认用 `let`，这是 Swift 的最佳实践。
- 类型推断让代码更简洁，但在需要时可显式声明。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（4）：流程控制（if、switch、循环）]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/03-流程控制</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/03-流程控制"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（4）：流程控制（if、switch、循环）

> 程序的核心就是控制执行流程。Swift 提供了清晰的条件判断和循环语法，语义直观，易读易写。

## if 条件语句

```swift
let score = 85

if score >= 90 {
    print("优秀")
} else if score >= 60 {
    print("及格")
} else {
    print("不及格")
}
```

> **注意**：条件表达式必须是布尔值，不能像 C 那样用 `1` 或 `0`。

### 版本兼容性检查：#available

```swift
// iOS 版本兼容性检查
if #available(iOS 16.0, *) {
    // iOS 16+ 可用的代码
    let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: "example.com")
    // 使用 Passkeys 功能
} else {
    // iOS 16 以下的降级处理
    print("需要 iOS 16 或更高版本")
}
```

#### #available 语法详解

```swift
if #available(平台 版本号, *) {
    // 新版本可用的代码
} else {
    // 旧版本的兜底处理
}
```

**参数说明**：

- `iOS 16.0`：指定最低支持的 iOS 版本
- `*`：表示其他平台使用当前部署目标版本

#### 实际应用场景

```swift
// 1. 新 API 的兼容性处理
func setupPasskeys() {
    if #available(iOS 16.0, *) {
        // 使用 iOS 16+ 的 Passkeys API
        let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)
        let request = provider.createCredentialRegistrationRequest(
            challenge: challengeData,
            name: userName,
            userID: userIdData
        )
        performPasskeyAuthentication(request)
    } else {
        // 降级到传统密码登录
        showPasswordLogin()
    }
}

// 2. UI 组件的版本适配
func setupUI() {
    if #available(iOS 15.0, *) {
        // 使用 iOS 15+ 的新 UI 组件
        let button = UIButton(configuration: .filled())
        button.configuration?.title = "登录"
    } else {
        // 使用传统的 UIButton 设置
        let button = UIButton(type: .system)
        button.setTitle("登录", for: .normal)
        button.backgroundColor = .systemBlue
    }
}

// 3. 多平台版本检查
func setupCrossplatform() {
    if #available(iOS 14.0, macOS 11.0, watchOS 7.0, tvOS 14.0, *) {
        // 所有平台都支持的新功能
        useNewFeature()
    } else {
        // 兜底方案
        useOldFeature()
    }
}
```

#### 与 @available 的区别

```swift
// @available - 标记函数/类的可用性
@available(iOS 16.0, *)
func createPasskey() {
    // 这个函数只在 iOS 16+ 可用
}

// #available - 运行时检查版本
func someFunction() {
    if #available(iOS 16.0, *) {
        createPasskey()  // 只有在 iOS 16+ 才调用
    }
}
```

#### 常见的版本检查模式

```swift
// 模式1：功能降级
func authenticateUser() {
    if #available(iOS 16.0, *) {
        // 优先使用 Passkeys
        setupPasskeys()
    } else if #available(iOS 13.0, *) {
        // 次选使用 Face ID/Touch ID
        setupBiometrics()
    } else {
        // 最后使用密码
        setupPasswordAuth()
    }
}

// 模式2：错误提示
func checkCompatibility() {
    guard #available(iOS 16.0, *) else {
        showAlert(message: "此功能需要 iOS 16 或更高版本")
        return
    }

    // 继续执行 iOS 16+ 的代码
    enableAdvancedFeatures()
}

// 模式3：条件编译结合
#if swift(>=5.7)
    if #available(iOS 16.0, *) {
        // Swift 5.7 + iOS 16 的最新功能
    }
#endif
```

#### 实际项目中的最佳实践

```swift
class AuthenticationManager {

    func register(_ options: String, callback: @escaping (String) -> Void) {
        // 版本检查应该在功能入口处进行
        guard #available(iOS 16.0, *) else {
            callback(errorJSON("iOS 16+ required for Passkeys"))
            return
        }

        // 继续执行 Passkeys 注册逻辑
        performPasskeyRegistration(options, callback)
    }

    private func performPasskeyRegistration(_ options: String, _ callback: @escaping (String) -> Void) {
        // 这里可以安全使用 iOS 16+ API，因为已经检查过版本
        let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)
        // ...
    }

    private func errorJSON(_ message: String) -> String {
        return """
        {
            "ok": false,
            "errMsg": "\(message)"
        }
        """
    }
}
```

## switch 语句

```swift
let grade = "B"

switch grade {
case "A":
    print("非常好")
case "B":
    print("良好")
case "C":
    print("及格")
default:
    print("不及格")
}
```

特点：

- **必须覆盖所有情况**，否则要写 `default`。
- **无需写 `break`**，匹配后自动退出。

### switch 的进阶用法

```swift
let point = (1, 1)

switch point {
case (0, 0):
    print("原点")
case (let x, 0):
    print("在 X 轴上，x=\(x)")
case (0, let y):
    print("在 Y 轴上，y=\(y)")
case (-2...2, -2...2):
    print("在 (-2,2) 范围内")
default:
    print("其他位置")
}
```

> Swift 的 `switch` 很强大，支持区间、元组、条件匹配。

## while 循环

```swift
var n = 3
while n > 0 {
    print(n)
    n -= 1
}
```

## repeat-while 循环（至少执行一次）

```swift
var m = 0
repeat {
    print("执行一次：m=\(m)")
    m += 1
} while m < 3
```

## for-in 循环

```swift
for i in 1...5 {  // 闭区间，包含 5
    print(i)
}

for i in 1..<5 {  // 半开区间，不包含 5
    print(i)
}

let names = ["Alice", "Bob", "Charlie"]
for name in names {
    print("Hello, \(name)")
}
```

## 控制跳转

```swift
for i in 1...5 {
    if i == 3 {
        continue   // 跳过当前循环
    }
    if i == 4 {
        break      // 提前结束循环
    }
    print(i)
}
```

## 小结

- `if-else`：最常见的条件判断。
- `switch`：比很多语言更强大，支持模式匹配。
- 循环包括 `while`、`repeat-while`、`for-in`，最后一个最常用。
- `continue` 和 `break` 用于跳转控制。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（5）：函数与参数]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/04-函数</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/04-函数"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（5）：函数与参数

> 函数是 Swift 程序的基本组成单位，既能封装逻辑，也能复用代码。

## 基本函数

```swift
func sayHello() {
    print("Hello, Swift!")
}

sayHello()  // 调用
```

## 带参数的函数

```swift
func greet(name: String) {
    print("Hello, \(name)!")
}

greet(name: "Alice")
```

## 多个参数

```swift
func add(a: Int, b: Int) -> Int {
    return a + b
}

let result = add(a: 3, b: 5)
print(result)  // 8
```

> 使用 `->` 指定返回值类型。

## 外部参数名

Swift 默认函数参数既有 **外部名**（调用时用的）也有 **内部名**（函数体内用的）。

```swift
func multiply(x a: Int, y b: Int) -> Int {
    return a * b
}

let r = multiply(x: 2, y: 3)
print(r)  // 6
```

## 省略外部参数名

用 `_` 可以省略外部参数名，让调用更简洁：

```swift
func divide(_ a: Double, _ b: Double) -> Double {
    return a / b
}

print(divide(10, 2))  // 5.0
```

## 默认参数

```swift
func greet(name: String = "游客") {
    print("你好，\(name)！")
}

greet()            // 你好，游客！
greet(name: "小明") // 你好，小明！
```

## 可变参数

一个参数可以接收多个值：

```swift
func sum(_ numbers: Int...) -> Int {
    var total = 0
    for n in numbers {
        total += n
    }
    return total
}

print(sum(1, 2, 3, 4))  // 10
```

## 返回多个值（元组）

```swift
func minMax(_ numbers: [Int]) -> (min: Int, max: Int)? {
    if numbers.isEmpty { return nil }
    var minVal = numbers[0]
    var maxVal = numbers[0]
    for n in numbers {
        if n < minVal { minVal = n }
        if n > maxVal { maxVal = n }
    }
    return (minVal, maxVal)
}

if let result = minMax([3, 7, 2, 9]) {
    print("最小值: \(result.min), 最大值: \(result.max)")
}
```

## 小结

- `func` 定义函数。
- 参数可以有外部名，也可以用 `_` 省略。
- 支持默认参数和可变参数。
- 函数可以返回单个值，也可以返回元组。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（5）：集合类型（Array、Set、Dictionary）]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/05-集合</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/05-集合"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（5）：集合类型（Array、Set、Dictionary）

> Swift 提供了三种常用集合类型：**数组（Array）**、**集合（Set）** 和 **字典（Dictionary）**。掌握它们就能处理大部分数据存储与操作。

## 数组（Array）

数组是有序的元素集合，可以包含重复值。

```swift
var numbers: [Int] = [1, 2, 3, 4]

// 添加元素
numbers.append(5)

// 访问元素
print(numbers[0])  // 1

// 遍历
for num in numbers {
    print(num)
}
```

简写：

```swift
let fruits = ["Apple", "Banana", "Cherry"]
print(fruits.count)      // 3
print(fruits.contains("Banana"))  // true
```

## 集合（Set）

集合是 **无序且唯一** 的元素集合。

```swift
var set: Set<String> = ["A", "B", "C"]

set.insert("D")
set.insert("A")   // 已存在，不会重复

print(set.contains("C"))  // true

// 遍历（顺序不保证）
for item in set {
    print(item)
}
```

集合常用于 **去重**：

```swift
let nums = [1, 2, 2, 3, 3, 4]
let uniqueNums = Set(nums)
print(uniqueNums)  // {2, 3, 1, 4}
```

## 字典（Dictionary）

字典是 **键值对** 的集合。

```swift
var dict: [String: Int] = [
    "Alice": 25,
    "Bob": 30
]

// 访问
print(dict["Alice"])  // Optional(25)

// 修改
dict["Alice"] = 26

// 新增
dict["Charlie"] = 22

// 遍历
for (name, age) in dict {
    print("\(name): \(age)")
}
```

## 集合运算（Set 特有）

```swift
let set1: Set = [1, 2, 3]
let set2: Set = [3, 4, 5]

// 交集
print(set1.intersection(set2))  // [3]

// 并集
print(set1.union(set2))  // [1, 2, 3, 4, 5]

// 差集
print(set1.subtracting(set2))  // [1, 2]
```

## 小结

- **Array**：有序，可重复 → 适合顺序存储。
- **Set**：无序，唯一 → 适合去重、集合运算。
- **Dictionary**：键值对 → 适合映射关系。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（6）：可选类型与空安全]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/06-可选类型与空安全</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/06-可选类型与空安全"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（6）：可选类型与空安全

> Swift 语言最突出的特性之一就是 **空安全（null safety）**，它通过 **可选类型（Optional）** 来避免常见的空指针错误。

## 什么是可选类型？

在 Swift 中，变量默认必须有值。如果可能为空，就要用 `?` 声明为 **可选类型**：

```swift
var name: String? = "Alice"
name = nil   // 合法，因为是可选类型
```

普通变量不能为 `nil`：

```swift
var age: Int = 18
// age = nil   ❌ 错误
```

## 解包（Unwrapping）

### 1. 强制解包（!）

如果确定有值，可以用 `!` 取出：

```swift
let name: String? = "Bob"
print(name!)   // Bob
```

⚠️ 如果为 `nil` 会崩溃：

```swift
let n: String? = nil
print(n!)  // ❌ 崩溃
```

### 2. 可选绑定（if let）

更安全的写法：

```swift
var name: String? = "Charlie"

if let n = name {
    print("Hello, \(n)")   // Hello, Charlie
} else {
    print("No name")
}
```

### 3. 可选绑定（guard let）

常用于函数中提前退出：

```swift
func greet(_ name: String?) {
    guard let n = name else {
        print("No name")
        return
    }
    print("Hello, \(n)")
}

greet("David")  // Hello, David
greet(nil)      // No name
```

#### guard let 的实战应用：Base64URL 编码

```swift
// 实际项目中的 guard let 使用模式
private func b64url(_ data: Data?) -> String {
    guard let d = data else {
        return ""
    }
    // 继续处理 d（已确保不为 nil）
    return d.base64EncodedString()
        .replacingOccurrences(of: "+", with: "-")
        .replacingOccurrences(of: "/", with: "_")
        .replacingOccurrences(of: "=", with: "")
}

// 使用示例
let someData: Data? = "Hello".data(using: .utf8)
let result = b64url(someData)  // 返回 Base64URL 编码字符串
let nilResult = b64url(nil)    // 返回空字符串 ""
```

#### 多重 guard let 与 as? 组合

```swift
// 复杂的 JSON 数据解析与类型转换
func parsePasskeyOptions(_ data: Data, _ cb: @escaping (String) -> Void) {
    guard
        let pub = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
        let rp = pub["rp"] as? [String: Any],
        let rpId = rp["id"] as? String,
        let challengeB64 = pub["challenge"] as? String,
        let user = pub["user"] as? [String: Any],
        let userIdB64 = user["id"] as? String,
        let userName = user["name"] as? String
    else {
        cb(toJSON(["ok": false, "errMsg": "bad options"]))
        return
    }

    // 所有解析都成功，继续处理
    processPasskeyRegistration(rpId: rpId, challenge: challengeB64,
                              userId: userIdB64, userName: userName)
}
```

#### as? String else 详解

**语法结构**：

```swift
let userName = user["name"] as? String
//             ↑           ↑      ↑
//          字典取值     安全转换  目标类型
```

**执行流程**：

```swift
// 1. user["name"] 返回 Any?（字典值可能不存在）
// 2. as? String 尝试将 Any? 转换为 String?
// 3. 如果转换失败（nil 或类型不匹配），整个 guard 失败
// 4. 执行 else 块，提前退出函数
```

**可能失败的情况**：

```swift
let testCases = [
    // 情况1：字段不存在
    ["user": ["age": 25]],  // user["name"] 返回 nil

    // 情况2：类型不匹配
    ["user": ["name": 123]],  // 123 as? String 返回 nil

    // 情况3：嵌套字段缺失
    ["user": "not a dict"],  // user 不是字典类型

    // 情况4：成功情况
    ["user": ["name": "Alice"]]  // 成功转换为 "Alice"
]
```

**为什么用 guard let 而不是 if let？**

```swift
// ❌ 使用 if let 会让代码嵌套过深
private func b64urlBad(_ data: Data?) -> String {
    if let d = data {
        return d.base64EncodedString()
            .replacingOccurrences(of: "+", with: "-")
            .replacingOccurrences(of: "/", with: "_")
            .replacingOccurrences(of: "=", with: "")
    } else {
        return ""
    }
}

// ✅ guard let 让主逻辑保持在最外层，更清晰
private func b64urlGood(_ data: Data?) -> String {
    guard let d = data else {
        return ""  // 提前退出，处理异常情况
    }

    // 主要逻辑在最外层，易读易维护
    return d.base64EncodedString()
        .replacingOccurrences(of: "+", with: "-")
        .replacingOccurrences(of: "/", with: "_")
        .replacingOccurrences(of: "=", with: "")
}
```

#### 多重 guard 的优势

```swift
// ❌ 嵌套 if let（可读性差）
func badParseOptions(_ data: Data, _ cb: @escaping (String) -> Void) {
    if let pub = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
        if let rp = pub["rp"] as? [String: Any] {
            if let rpId = rp["id"] as? String {
                if let user = pub["user"] as? [String: Any] {
                    if let userName = user["name"] as? String {
                        // 主逻辑深度嵌套，难以阅读
                        processData(rpId: rpId, userName: userName)
                    } else { cb(errorJSON) }
                } else { cb(errorJSON) }
            } else { cb(errorJSON) }
        } else { cb(errorJSON) }
    } else { cb(errorJSON) }
}

// ✅ 多重 guard let（清晰简洁）
func goodParseOptions(_ data: Data, _ cb: @escaping (String) -> Void) {
    guard
        let pub = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
        let rp = pub["rp"] as? [String: Any],
        let rpId = rp["id"] as? String,
        let user = pub["user"] as? [String: Any],
        let userName = user["name"] as? String
    else {
        cb(toJSON(["ok": false, "errMsg": "bad options"]))
        return
    }

    // 主逻辑在最外层，清晰易读
    processData(rpId: rpId, userName: userName)
}
```

#### 实际应用：WebAuthn 数据解析

```swift
// 真实的 WebAuthn 选项解析
func parseWebAuthnOptions(_ optionsJson: String, _ callback: @escaping (String) -> Void) {
    guard let data = optionsJson.data(using: .utf8) else {
        callback(errorResponse("Invalid JSON string"))
        return
    }

    guard
        // 第一层：JSON 解析
        let options = try? JSONSerialization.jsonObject(with: data) as? [String: Any],

        // 第二层：必需字段提取
        let rp = options["rp"] as? [String: Any],
        let rpId = rp["id"] as? String,
        let rpName = rp["name"] as? String,

        // 第三层：用户信息提取
        let user = options["user"] as? [String: Any],
        let userIdB64 = user["id"] as? String,
        let userName = user["name"] as? String,
        let userDisplayName = user["displayName"] as? String,

        // 第四层：挑战码和其他参数
        let challengeB64 = options["challenge"] as? String,
        let pubKeyCredParams = options["pubKeyCredParams"] as? [[String: Any]]
    else {
        callback(errorResponse("Missing required fields"))
        return
    }

    // 所有必需数据都已成功提取，继续处理
    createPasskey(rpId: rpId, rpName: rpName,
                  userId: userIdB64, userName: userName,
                  challenge: challengeB64, params: pubKeyCredParams)
}
```

### 4. 默认值（?? 运算符）

```swift
let nickname: String? = nil
print(nickname ?? "Guest")   // Guest
```

## 隐式解包（!）

如果一个变量在生命周期内 **一定会有值**，可以用 `String!`：

```swift
var username: String! = "Eve"
print(username)   // 自动解包 → Eve
```

⚠️ 一般少用，容易出错。

## 可选链（Optional Chaining）

访问可能为空的属性/方法时，可以用 `?.`：

```swift
class Person {
    var pet: Pet?
}

class Pet {
    var name: String = "Dog"
}

let p = Person()
print(p.pet?.name)   // nil
```

### 可选调用操作符（?.）的实战应用

```swift
// 可选方法调用
class AuthManager {
    private var callback: ((String) -> Void)?

    func setCallback(_ cb: @escaping (String) -> Void) {
        self.callback = cb
    }

    func triggerSuccess() {
        // 使用 ?. 安全调用可选的闭包
        self.callback?("认证成功")
        // 等价于：
        // if let callback = self.callback {
        //     callback("认证成功")
        // }
    }

    func handleError(_ error: Error) {
        defer {
            self.callback = nil  // 清理回调
        }

        // 可选调用：如果 callback 不为 nil 才执行
        self.callback?(toJSON(["ok": false, "errMsg": error.localizedDescription]))
    }
}
```

#### ?. 与 ! 的对比

```swift
let manager = AuthManager()

// ❌ 强制调用 - 如果 callback 为 nil 会崩溃
// manager.callback!("消息")  // 危险！

// ✅ 可选调用 - 安全，callback 为 nil 时什么都不做
manager.callback?("消息")    // 安全
```

#### 复杂的可选链调用

```swift
class User {
    var profile: Profile?
}

class Profile {
    var settings: Settings?
}

class Settings {
    func updateTheme(_ theme: String) {
        print("主题更新为: \(theme)")
    }
}

let user = User()

// 多层可选链调用
user.profile?.settings?.updateTheme("暗黑模式")
// 只有当 user.profile 和 settings 都不为 nil 时才会执行

// 等价的完整写法：
if let profile = user.profile,
   let settings = profile.settings {
    settings.updateTheme("暗黑模式")
}
```

#### 实际应用场景

```swift
// 1. UI 更新
class ViewController {
    weak var delegate: ViewControllerDelegate?

    func viewDidAppear() {
        // 可选调用 delegate 方法
        delegate?.viewControllerDidAppear(self)
    }
}

// 2. 网络回调
class NetworkManager {
    var onComplete: ((Data?) -> Void)?
    var onError: ((Error) -> Void)?

    func performRequest() {
        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error {
                self.onError?(error)  // 可选调用错误回调
            } else {
                self.onComplete?(data)  // 可选调用成功回调
            }
        }.resume()
    }
}

// 3. 系统 API 回调（你的代码应用）
public func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
    defer {
        self.callback = nil
    }

    // 可选调用：只有当 callback 存在时才执行
    self.callback?(self.toJSON(["ok": false, "errMsg": error.localizedDescription]))

    // 如果不用 ?.，需要这样写：
    // if let callback = self.callback {
    //     callback(self.toJSON(["ok": false, "errMsg": error.localizedDescription]))
    // }
}
```

## 实战示例：JSON 处理中的空安全

### try? 与可选绑定的组合

```swift
// 将字典转换为 JSON 字符串的安全写法
func dictToJSON(_ dict: [String: Any]) -> String {
    if let data = try? JSONSerialization.data(withJSONObject: dict, options: []) {
        return String(data: data, encoding: .utf8) ?? "{}"
    }
    return "{}"
}

// 使用示例
let userInfo = ["name": "Alice", "age": 25]
let jsonString = dictToJSON(userInfo)
print(jsonString) // {"name":"Alice","age":25}
```

### try? 与 as? 的双重安全

```swift
// JSON 反序列化：Data → 字典
func parseJSON(_ data: Data) -> [String: Any]? {
    let pub = try? JSONSerialization.jsonObject(with: data) as? [String: Any]
    return pub
}

// 完整示例
let jsonData = """
{
    "name": "Alice",
    "age": 25,
    "active": true
}
""".data(using: .utf8)!

if let dict = parseJSON(jsonData) {
    print("姓名: \(dict["name"] ?? "未知")")
    print("年龄: \(dict["age"] ?? 0)")
}
```

#### 语法分解：try? as?

```swift
let pub = try? JSONSerialization.jsonObject(with: data) as? [String: Any]
//        ↑                                              ↑
//      try?                                           as?
//   错误处理                                        类型转换
```

**第一层安全：try?**

```swift
// JSONSerialization.jsonObject 可能抛出错误
// try? 将错误转换为 nil

// 等价于：
let jsonObject: Any?
do {
    jsonObject = try JSONSerialization.jsonObject(with: data)
} catch {
    jsonObject = nil
}
```

**第二层安全：as?**

```swift
// jsonObject 的类型是 Any，需要转换为 [String: Any]
// as? 安全类型转换，失败返回 nil

// 等价于：
let dict: [String: Any]?
if jsonObject is [String: Any] {
    dict = jsonObject as! [String: Any]
} else {
    dict = nil
}
```

#### 组合使用的优势

```swift
// ❌ 不安全的写法（可能崩溃）
func badParseJSON(_ data: Data) -> [String: Any] {
    let obj = try! JSONSerialization.jsonObject(with: data)  // 可能抛出异常
    return obj as! [String: Any]  // 可能类型转换失败
}

// ✅ 安全的写法（双重保护）
func safeParseJSON(_ data: Data) -> [String: Any]? {
    return try? JSONSerialization.jsonObject(with: data) as? [String: Any]
    // 1. try? 处理 JSON 解析错误
    // 2. as? 处理类型转换失败
}

// ✅ 更详细的错误处理
func detailedParseJSON(_ data: Data) -> [String: Any]? {
    guard let jsonObject = try? JSONSerialization.jsonObject(with: data) else {
        print("JSON 解析失败")
        return nil
    }

    guard let dict = jsonObject as? [String: Any] else {
        print("类型转换失败，期望字典类型")
        return nil
    }

    return dict
}
```

#### 实际应用场景

```swift
// 网络请求中的 JSON 处理
func handleAPIResponse(_ data: Data) {
    if let response = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
        // 成功解析为字典
        let status = response["status"] as? String ?? "unknown"
        let message = response["message"] as? String ?? ""
        print("状态: \(status), 消息: \(message)")
    } else {
        print("响应格式错误")
    }
}

// 配置文件解析
func loadConfig(_ data: Data) -> AppConfig? {
    guard let configDict = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
        return nil
    }

    return AppConfig(
        apiURL: configDict["apiURL"] as? String ?? "",
        timeout: configDict["timeout"] as? Double ?? 30.0,
        enableLogging: configDict["enableLogging"] as? Bool ?? false
    )
}

// WebAuthn 数据解析
func parsePasskeyOptions(_ data: Data) -> PasskeyOptions? {
    guard let optionsDict = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
          let rp = optionsDict["rp"] as? [String: Any],
          let user = optionsDict["user"] as? [String: Any] else {
        return nil
    }

    return PasskeyOptions(
        rpId: rp["id"] as? String ?? "",
        userName: user["name"] as? String ?? "",
        challenge: optionsDict["challenge"] as? String ?? ""
    )
}
```

让我们分解这段代码的每个部分：

### 1. try? 的作用

```swift
// JSONSerialization.data 可能抛出错误
// try? 将错误转换为 nil，返回 Optional<Data>
let data = try? JSONSerialization.data(withJSONObject: dict, options: [])
// data 的类型是 Data?（可选类型）
```

### 2. if let 安全解包

```swift
if let data = try? JSONSerialization.data(withJSONObject: dict, options: []) {
    // 只有 data 不为 nil 时才执行这里
    // data 在这个作用域内是 Data 类型（已解包）
}
```

### 3. 双重保险的默认值

```swift
// String(data:encoding:) 也可能返回 nil
// 第一层保险：?? "{}"
return String(data: data, encoding: .utf8) ?? "{}"

// 第二层保险：整个 if let 失败时
return "{}"
```

### 4. 完整的错误处理对比

```swift
// ❌ 不安全的写法
func badDictToJSON(_ dict: [String: Any]) -> String {
    let data = try! JSONSerialization.data(withJSONObject: dict, options: [])
    return String(data: data, encoding: .utf8)! // 可能崩溃
}

// ✅ 安全的写法
func safeDictToJSON(_ dict: [String: Any]) -> String {
    guard let data = try? JSONSerialization.data(withJSONObject: dict, options: []),
          let jsonString = String(data: data, encoding: .utf8) else {
        return "{}" // 任何步骤失败都返回默认值
    }
    return jsonString
}

// ✅ 更简洁的写法（你的代码）
func conciseDictToJSON(_ dict: [String: Any]) -> String {
    if let data = try? JSONSerialization.data(withJSONObject: dict, options: []) {
        return String(data: data, encoding: .utf8) ?? "{}"
    }
    return "{}"
}
```

### 5. 实际使用场景

```swift
// 网络请求中的 JSON 处理
class APIClient {
    func sendRequest(_ params: [String: Any]) {
        let jsonString = dictToJSON(params)
        // 即使 params 有问题，也不会崩溃，最多发送空对象 "{}"
        print("发送数据: \(jsonString)")
    }
}

// 日志记录
func logUserAction(_ action: String, data: [String: Any]) {
    let jsonData = dictToJSON(data)
    print("[\(action)] \(jsonData)")
    // 保证日志一定能记录，不会因为 JSON 转换失败而中断
}
```

## 小结

- `?` → 表示可能为空。
- `!` → 强制解包，危险。
- `if let` / `guard let` → 安全解包。
- `??` → 提供默认值。
- `?.` → 可选链，优雅避免空指针。
- `try?` → 将错误转换为可选类型，配合 `if let` 使用。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（7）：字符串与日期]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/07-字符串与日期</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/07-字符串与日期"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（7）：字符串与日期

> 字符串和日期是开发中最常用的数据类型。Swift 提供了强大且安全的操作方式。

## 字符串（String）

### 创建字符串

```swift
let s1 = "Hello"
let s2 = String("World")
```

### 拼接

```swift
let name = "Alice"
let greeting = "Hello, " + name
print(greeting)   // Hello, Alice
```

### 字符串插值

```swift
let age = 20
print("My age is \(age)")   // My age is 20
```

### 遍历字符

```swift
for ch in "Swift" {
    print(ch)
}
```

### 字符串长度

```swift
let text = "Hello"
print(text.count)   // 5
```

### 子串

```swift
let str = "Hello Swift"
let start = str.startIndex
let end = str.index(str.startIndex, offsetBy: 4)
let sub = str[start...end]
print(sub)   // Hello
```

### 常用方法

```swift
let msg = " swift "
print(msg.uppercased())   // " SWIFT "
print(msg.lowercased())   // " swift "
print(msg.trimmingCharacters(in: .whitespaces))   // "swift"
print(msg.contains("sw")) // true
```

### 字符串替换与链式调用

#### replacingOccurrences 方法

```swift
// 单个替换
let text = "Hello World"
let newText = text.replacingOccurrences(of: " ", with: "-")
print(newText)  // "Hello-World"

// 多个替换的链式调用
let original = "a+b/c=d"
let result = original
    .replacingOccurrences(of: "+", with: "-")
    .replacingOccurrences(of: "/", with: "_")
    .replacingOccurrences(of: "=", with: "")
print(result)  // "a-b_cd"
```

#### 什么是 Data 类型？

`Data` 是 Swift Foundation 框架中的核心类型，用于表示**二进制数据**。

```swift
import Foundation  // Data 来自 Foundation 框架

// Data 的本质：字节数组
let data1 = Data([0x48, 0x65, 0x6C, 0x6C, 0x6F])  // "Hello" 的字节表示
print(data1)  // 5 bytes

// 常见的 Data 创建方式
let data2 = "Hello".data(using: .utf8)!        // 字符串 → Data
let data3 = Data(count: 10)                     // 创建 10 字节的空 Data
let data4 = Data(base64Encoded: "SGVsbG8=")!    // Base64 → Data
```

#### Data 的来源和用途

| 来源        | 方法                        | 用途             |
| ----------- | --------------------------- | ---------------- |
| 字符串转换  | `"text".data(using: .utf8)` | 文本数据处理     |
| 网络请求    | `URLSession` 响应           | API 数据接收     |
| 文件读取    | `Data(contentsOf: url)`     | 文件内容读取     |
| 图片处理    | `UIImage.pngData()`         | 图片数据转换     |
| JSON 序列化 | `JSONSerialization.data()`  | 对象 → JSON 数据 |

#### 实战：Base64URL 编码转换

```swift
// 完整的 Data → Base64URL 流程
func dataToBase64URL(_ data: Data) -> String {
    // 1. Data → 标准 Base64 字符串
    var s = data.base64EncodedString()

    // 2. 标准 Base64 → Base64URL
    s = s.replacingOccurrences(of: "+", with: "-")
         .replacingOccurrences(of: "/", with: "_")
         .replacingOccurrences(of: "=", with: "")
    return s
}

// 使用示例
let textData = "Hello World".data(using: .utf8)!
let base64url = dataToBase64URL(textData)
print(base64url)  // "SGVsbG8gV29ybGQ"

// 更简洁的写法（一行完成）
return data.base64EncodedString()
    .replacingOccurrences(of: "+", with: "-")
    .replacingOccurrences(of: "/", with: "_")
    .replacingOccurrences(of: "=", with: "")
```

#### 反向转换：Base64URL → Data

```swift
// Base64URL 解码函数
func base64URLToData(_ s: String) -> Data {
    // 1. Base64URL → 标准 Base64
    var t = s.replacingOccurrences(of: "-", with: "+")  // - → +
             .replacingOccurrences(of: "_", with: "/")   // _ → /

    // 2. 计算并添加填充字符
    let pad = (4 - t.count % 4) % 4  // 计算需要多少个 = 填充
    if pad > 0 {
        t.append(String(repeating: "=", count: pad))  // 添加 = 填充
    }

    // 3. 标准 Base64 → Data
    return Data(base64Encoded: t) ?? Data()
}
```

#### 数据转换过程详解

**完整的双向转换流程：**

```swift
// 原始数据
let originalText = "Hello World!"
let originalData = originalText.data(using: .utf8)!
print("原始数据: \(originalText)")  // "Hello World!"

// 第一步：Data → Base64URL
let base64url = originalData.base64EncodedString()
    .replacingOccurrences(of: "+", with: "-")
    .replacingOccurrences(of: "/", with: "_")
    .replacingOccurrences(of: "=", with: "")
print("Base64URL: \(base64url)")  // "SGVsbG8gV29ybGQh"

// 第二步：Base64URL → Data（你的代码）
let decodedData = base64URLToData(base64url)
let decodedText = String(data: decodedData, encoding: .utf8)!
print("解码结果: \(decodedText)")  // "Hello World!"
```

#### 填充计算逻辑解析

Base64 编码要求长度是 4 的倍数，不足时用 `=` 填充：

```swift
// 填充计算公式：(4 - length % 4) % 4
let examples = [
    ("SGVsbG8", 7),   // 7 % 4 = 3, 需要 1 个 =
    ("SGVsbG8g", 8),  // 8 % 4 = 0, 不需要填充
    ("SGVsbG8gV2", 10), // 10 % 4 = 2, 需要 2 个 =
]

for (base64url, length) in examples {
    let pad = (4 - length % 4) % 4
    let padded = pad > 0 ? base64url + String(repeating: "=", count: pad) : base64url
    print("\(base64url) → \(padded) (添加 \(pad) 个 =)")
}

// 输出：
// SGVsbG8 → SGVsbG8= (添加 1 个 =)
// SGVsbG8g → SGVsbG8g (添加 0 个 =)
// SGVsbG8gV2 → SGVsbG8gV2== (添加 2 个 =)
```

#### 实际应用：JWT Token 解析

```swift
// JWT Token 通常使用 Base64URL 编码
func decodeJWTPayload(_ token: String) -> [String: Any]? {
    let parts = token.components(separatedBy: ".")
    guard parts.count == 3 else { return nil }

    // 解码 payload 部分（第二部分）
    let payloadData = base64URLToData(parts[1])

    // JSON 解析
    return try? JSONSerialization.jsonObject(with: payloadData) as? [String: Any]
}

// WebAuthn 挑战码解析
func decodeChallenge(_ challengeString: String) -> Data {
    return base64URLToData(challengeString)
}
```

#### Data 的常用方法

```swift
let data = "Hello".data(using: .utf8)!

// 基本属性
print(data.count)        // 5 (字节数)
print(data.isEmpty)      // false

// 转换方法
let string = String(data: data, encoding: .utf8)  // Data → 字符串
let base64 = data.base64EncodedString()            // Data → Base64
let array = [UInt8](data)                          // Data → 字节数组

// 操作方法
var mutableData = data
mutableData.append("!".data(using: .utf8)!)       // 追加数据
print(String(data: mutableData, encoding: .utf8)!) // "Hello!"
```

#### 方法解析表

| 方法                             | 作用                 | 示例                   |
| -------------------------------- | -------------------- | ---------------------- |
| `base64EncodedString()`          | Data → Base64 字符串 | `"SGVsbG8="`           |
| `replacingOccurrences(of:with:)` | 替换所有匹配的子串   | `"a+b" → "a-b"`        |
| 链式调用                         | 多个方法连续执行     | `.method1().method2()` |

#### Base64 vs Base64URL 对比

```swift
let data = "Hello World".data(using: .utf8)!

// 标准 Base64
let base64 = data.base64EncodedString()
print(base64)  // "SGVsbG8gV29ybGQ="

// Base64URL（URL 安全）
let base64url = data.base64EncodedString()
    .replacingOccurrences(of: "+", with: "-")  // + → -
    .replacingOccurrences(of: "/", with: "_")  // / → _
    .replacingOccurrences(of: "=", with: "")   // 移除填充
print(base64url)  // "SGVsbG8gV29ybGQ"
```

#### 为什么需要 Base64URL？

```swift
// ❌ 标准 Base64 在 URL 中会有问题
let url1 = "https://api.com/token=SGVsbG8+V29/bGQ="  // + 和 / 在 URL 中有特殊含义

// ✅ Base64URL 是 URL 安全的
let url2 = "https://api.com/token=SGVsbG8-V29_bGQ"   // - 和 _ 在 URL 中安全
```

#### 实际应用场景

```swift
// JWT Token 编码
func encodeJWTPayload(_ payload: [String: Any]) -> String {
    guard let data = try? JSONSerialization.data(withJSONObject: payload) else {
        return ""
    }
    return data.base64EncodedString()
        .replacingOccurrences(of: "+", with: "-")
        .replacingOccurrences(of: "/", with: "_")
        .replacingOccurrences(of: "=", with: "")
}

// WebAuthn 挑战码处理
func processChallenge(_ challengeData: Data) -> String {
    return challengeData.base64EncodedString()
        .replacingOccurrences(of: "+", with: "-")
        .replacingOccurrences(of: "/", with: "_")
        .trimmingCharacters(in: CharacterSet(charactersIn: "="))
}
```

## 日期（Date）

### 当前时间

```swift
let now = Date()
print(now)   // 2025-09-14 12:34:56 +0000
```

### 日期格式化

```swift
let formatter = DateFormatter()
formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"

let now = Date()
let str = formatter.string(from: now)
print(str)   // 2025-09-14 20:34:56
```

### 字符串转日期

```swift
let formatter = DateFormatter()
formatter.dateFormat = "yyyy/MM/dd"

if let date = formatter.date(from: "2025/09/14") {
    print(date)
}
```

### 日期计算

```swift
let now = Date()
let tomorrow = now.addingTimeInterval(24 * 60 * 60)
print(tomorrow)
```

## 小结

- **字符串**：拼接 `+`，插值 `\(var)`，常用方法 `uppercased`、`contains`、`trimmingCharacters`。
- **日期**：`Date()` 获取当前时间，`DateFormatter` 用于格式化和解析。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（8）：闭包]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/08-闭包</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/08-闭包"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（8）：闭包

> 闭包（Closure）是 Swift 的核心特性之一，类似匿名函数。它能捕获上下文变量，非常常用。

## 基本语法

闭包的基本形式：

```swift
{ (参数列表) -> 返回类型 in
    代码块
}
```

例如：

```swift
let add = { (a: Int, b: Int) -> Int in
    return a + b
}
print(add(2, 3))   // 5
```

## 作为函数参数

```swift
func operate(_ a: Int, _ b: Int, op: (Int, Int) -> Int) -> Int {
    return op(a, b)
}

let sum = operate(2, 3, op: { (x, y) in x + y })
print(sum)   // 5
```

## 闭包简写

Swift 提供了简写规则，使闭包更简洁：

1. **省略参数类型和返回值**
2. **省略 return**
3. **使用参数占位符 `$0`, `$1`**

```swift
let nums = [3, 1, 5, 2]
let sorted = nums.sorted(by: { $0 < $1 })
print(sorted)   // [1, 2, 3, 5]
```

## 尾随闭包

当闭包是函数最后一个参数时，可以写在括号外：

```swift
let doubled = nums.map { $0 * 2 }
print(doubled)   // [6, 2, 10, 4]
```

## 捕获变量

闭包会捕获外部变量：

```swift
func makeCounter() -> () -> Int {
    var count = 0
    return {
        count += 1
        return count
    }
}

let counter = makeCounter()
print(counter())   // 1
print(counter())   // 2
```

## 常见应用场景

1. **数组操作（map/filter/reduce）**
2. **回调（网络请求完成后执行）**
3. **延迟执行**

## 实战：first(where:) 方法

### 基础用法

```swift
let numbers = [1, 3, 5, 7, 8, 9]

// 完整闭包语法
let firstEven = numbers.first(where: { (number) -> Bool in
    return number % 2 == 0
})
print(firstEven)  // Optional(8)

// 简化语法
let firstOdd = numbers.first { $0 % 2 == 1 }
print(firstOdd)   // Optional(1)
```

### 实际项目中的应用：寻找活跃窗口

```swift
// 在 iOS 应用中寻找当前活跃的窗口
public func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return UIApplication.shared.windows.first {
        $0.isKeyWindow  // 尾随闭包：寻找 isKeyWindow 为 true 的窗口
    } ?? ASPresentationAnchor()
}
```

#### 语法分解

```swift
// 1. 完整写法
UIApplication.shared.windows.first(where: { window in
    return window.isKeyWindow
})

// 2. 省略参数类型和 return
UIApplication.shared.windows.first(where: { window in
    window.isKeyWindow
})

// 3. 使用参数占位符
UIApplication.shared.windows.first(where: { $0.isKeyWindow })

// 4. 尾随闭包语法（最简洁）
UIApplication.shared.windows.first { $0.isKeyWindow }
```

#### 更多 first(where:) 实战示例

```swift
// 寻找特定用户
let users = [
    User(name: "Alice", age: 25),
    User(name: "Bob", age: 30),
    User(name: "Charlie", age: 35)
]

let adult = users.first { $0.age >= 18 }
let alice = users.first { $0.name == "Alice" }

// 寻找特定视图控制器
let viewControllers = navigationController?.viewControllers ?? []
let targetVC = viewControllers.first { $0 is SettingsViewController }

// 寻找有效的网络配置
let configs = [config1, config2, config3]
let validConfig = configs.first { $0.isValid && $0.isEnabled }
```

### 与其他高阶函数的对比

```swift
let data = [1, 2, 3, 4, 5]

// first(where:) - 找到第一个符合条件的元素
let firstEven = data.first { $0 % 2 == 0 }  // Optional(2)

// filter - 找到所有符合条件的元素
let allEvens = data.filter { $0 % 2 == 0 }  // [2, 4]

// contains(where:) - 判断是否存在符合条件的元素
let hasEven = data.contains { $0 % 2 == 0 }  // true

// firstIndex(where:) - 找到第一个符合条件的元素的索引
let index = data.firstIndex { $0 % 2 == 0 }  // Optional(1)
```

## @escaping 闭包详解

### 什么是 @escaping？

```swift
// 非逃逸闭包（默认）- 函数返回前必须执行
func processData(_ data: String, completion: (String) -> Void) {
    let result = data.uppercased()
    completion(result)  // 在函数返回前执行
}

// 逃逸闭包 - 可能在函数返回后执行
func processDataAsync(_ data: String, completion: @escaping (String) -> Void) {
    DispatchQueue.global().async {
        let result = data.uppercased()
        completion(result)  // 在函数返回后执行
    }
}
```

### 实战：@objc 方法中的回调

```swift
@objc public func register(_ optionsJson: String, _ cb: @escaping (String) -> Void) {
    // 这个回调会在异步操作完成后执行，所以需要 @escaping
}
```

#### 语法分解

```swift
// 1. @objc - 使方法可被 Objective-C 调用
// 2. public - 外部模块可访问
// 3. _ optionsJson: String - 无标签参数
// 4. _ cb: @escaping (String) -> Void - 逃逸闭包回调

@objc public func register(_ optionsJson: String, _ cb: @escaping (String) -> Void) {
    // 参数解析
    guard let options = parseOptions(optionsJson) else {
        cb("{\"ok\": false, \"errMsg\": \"Invalid options\"}")
        return
    }

    // 异步认证操作
    performAuthentication(options: options) { result in
        // 这个回调在异步操作完成后执行
        cb(result)  // 需要 @escaping 才能在这里调用
    }
}
```

### 为什么需要 @escaping？

```swift
class AuthManager {
    private var callback: ((String) -> Void)?  // 存储回调

    // ❌ 编译错误：非逃逸闭包不能赋值给属性
    func badExample(_ completion: (String) -> Void) {
        self.callback = completion  // 错误！
    }

    // ✅ 正确：使用 @escaping
    func goodExample(_ completion: @escaping (String) -> Void) {
        self.callback = completion  // 正确！
    }

    func triggerCallback() {
        callback?("操作完成")
    }
}
```

### 实际应用场景

#### 1. 网络请求回调

```swift
@objc public func fetchUserData(_ userId: String, _ callback: @escaping (String) -> Void) {
    URLSession.shared.dataTask(with: url) { data, response, error in
        // 网络请求是异步的，回调在请求完成后执行
        if let data = data {
            callback(String(data: data, encoding: .utf8) ?? "")
        } else {
            callback("{\"error\": \"Network failed\"}")
        }
    }.resume()
}
```

#### 2. 系统认证回调

```swift
@objc public func authenticate(_ options: String, _ callback: @escaping (String) -> Void) {
    let authController = ASAuthorizationController(authorizationRequests: requests)

    // 存储回调，在认证完成后调用
    self.completionCallback = callback

    authController.delegate = self
    authController.performRequests()  // 异步操作
}

// 在协议方法中调用存储的回调
func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
    completionCallback?("{\"ok\": true, \"data\": \"...\"}")
    completionCallback = nil
}
```

#### 3. 延迟执行

```swift
@objc public func delayedOperation(_ seconds: Double, _ callback: @escaping (String) -> Void) {
    DispatchQueue.main.asyncAfter(deadline: .now() + seconds) {
        callback("延迟操作完成")  // 在未来某个时间点执行
    }
}
```

### 闭包类型语法详解

```swift
// (String) -> Void 的含义：
// ↓
// 接收一个 String 参数，无返回值的闭包类型

// 其他常见闭包类型
let closure1: () -> Void = { print("无参数无返回值") }
let closure2: (Int) -> String = { "\($0)" }
let closure3: (String, Int) -> Bool = { $0.count > $1 }

// 在函数参数中使用
func process(_ data: String, success: @escaping (String) -> Void, failure: @escaping (Error) -> Void) {
    // 成功和失败的不同回调
}
```

### @escaping vs 非逃逸对比

| 特性         | 非逃逸闭包（默认） | @escaping 闭包       |
| ------------ | ------------------ | -------------------- |
| **执行时机** | 函数返回前必须执行 | 可在函数返回后执行   |
| **存储**     | 不能赋值给属性     | 可以赋值给属性       |
| **异步操作** | 不支持             | 支持                 |
| **性能**     | 更好（编译器优化） | 稍差（需要内存管理） |
| **使用场景** | 同步操作、集合遍历 | 异步操作、回调存储   |

### 实际使用建议

```swift
// ✅ 同步操作用非逃逸闭包
func transform<T>(_ items: [T], _ transform: (T) -> T) -> [T] {
    return items.map(transform)  // 立即执行
}

// ✅ 异步操作用 @escaping
func loadData(_ completion: @escaping (Data?) -> Void) {
    DispatchQueue.global().async {
        // 异步加载数据
        completion(data)
    }
}

// ✅ 需要存储回调用 @escaping
class APIClient {
    private var onComplete: ((String) -> Void)?

    func request(_ callback: @escaping (String) -> Void) {
        self.onComplete = callback  // 存储以备后用
    }
}
```

## 小结

- 闭包 = 匿名函数，可以捕获外部变量。
- 语法简洁，支持尾随闭包。
- `@escaping` 用于可能在函数返回后执行的闭包。
- 异步操作、回调存储都需要 `@escaping`。
- 常用于集合操作、网络请求和系统 API 回调。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（9）：结构体与类]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/09-结构体与类</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/09-结构体与类"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（9）：结构体与类

> Swift 中既有 **结构体（struct）**，也有 **类（class）**。两者非常相似，但也有重要区别。

## 定义结构体

```swift
struct Point {
    var x: Int
    var y: Int
}

var p1 = Point(x: 3, y: 5)
p1.x = 10
print(p1)   // Point(x: 10, y: 5)
```

结构体自动拥有一个 **成员初始化器**，不需要手动写构造函数。

## 定义类

```swift
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

let p = Person(name: "Tom", age: 20)
print(p.name)   // Tom
```

类需要写 `init` 构造函数来初始化属性。

## 值类型 vs 引用类型

这是两者最大的区别：

- **结构体** 是 **值类型**，赋值时会复制一份。
- **类** 是 **引用类型**，赋值时多个变量指向同一个对象。

```swift
var a = Point(x: 1, y: 2)
var b = a
b.x = 100
print(a.x)   // 1（不受影响）

let p2 = p
p2.name = "Jerry"
print(p.name)   // Jerry（引用同一个对象）
```

## 选择结构体还是类？

- **结构体**：推荐默认使用，轻量、安全，常用于数据模型。
- **类**：当需要继承、引用语义时使用（如视图控制器）。

## 类的高级用法

### 继承与协议实现

```swift
// 继承系统类并实现协议的语法
class PasskeysNative: NSObject, ASAuthorizationControllerDelegate {
    // 类的内容
}
```

语法结构：`class 类名: 父类, 协议1, 协议2, ...`

### 为什么继承 NSObject？

```swift
// ✅ 继承 NSObject 的好处
class MyClass: NSObject {
    // 1. 与 Objective-C 兼容
    // 2. 支持 @objc 标记的方法
    // 3. 可以被跨语言框架调用
    // 4. 支持 KVO、KVC 等特性
}

// ❌ 纯 Swift 类的限制
class PureSwiftClass {
    // 无法直接与 Objective-C 交互
}
```

### 实现协议方法

```swift
class AuthHandler: NSObject, SomeProtocol {
    // 实现协议要求的方法
    func requiredMethod() {
        print("实现协议方法")
    }
}
```

## 小结

- `struct` = 值类型，复制独立。
- `class` = 引用类型，共享同一对象。
- 类可以继承父类并实现多个协议。
- 继承 `NSObject` 提供 Objective-C 兼容性。
- Swift 鼓励多用结构体，少用类，除非需要继承。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（10）：属性与方法]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/10-属性与方法</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/10-属性与方法"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（10）：属性与方法

> Swift 中，结构体和类可以有 **属性（properties）** 和 **方法（methods）**，这是面向对象编程的核心。

## 存储属性

直接存储值在实例里的属性。

```swift
struct User {
    var name: String
    var age: Int
}

var u = User(name: "Tom", age: 20)
u.age = 21
print(u.age)   // 21
```

## 计算属性

不会直接存储值，而是通过 getter/setter 计算得到。

```swift
struct Rectangle {
    var width: Double
    var height: Double

    var area: Double {
        return width * height
    }
}

let r = Rectangle(width: 5, height: 3)
print(r.area)   // 15.0
```

## 属性观察器

在属性变化时触发 `willSet` / `didSet`。

```swift
class Counter {
    var count: Int = 0 {
        willSet {
            print("即将设置为 \(newValue)")
        }
        didSet {
            print("已从 \(oldValue) 改为 \(count)")
        }
    }
}

let c = Counter()
c.count = 5
// 即将设置为 5
// 已从 0 改为 5
```

## 方法

方法就是定义在类/结构体中的函数。

```swift
struct Circle {
    var radius: Double

    func area() -> Double {
        return 3.14 * radius * radius
    }
}

let c1 = Circle(radius: 10)
print(c1.area())   // 314.0
```

## mutating 方法

结构体是 **值类型**，默认方法不能修改属性。需要 `mutating` 关键字。

```swift
struct Counter {
    var value = 0

    mutating func increment() {
        value += 1
    }
}

var ct = Counter()
ct.increment()
print(ct.value)   // 1
```

## 静态属性和方法

属于类型本身，而不是某个实例。

```swift
struct Math {
    static let pi = 3.14159
    static func square(_ x: Int) -> Int {
        return x * x
    }
}

print(Math.pi)        // 3.14159
print(Math.square(5)) // 25
```

## 小结

- **存储属性**：保存值。
- **计算属性**：动态计算。
- **属性观察器**：监听变化。
- **实例方法**：作用于实例。
- **mutating 方法**：修改结构体/枚举。
- **静态属性/方法**：属于类型。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（11）：枚举]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/11-枚举</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/11-枚举"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（11）：枚举

> 枚举（`enum`）是 Swift 中非常常见的语法结构，用来表示一组有限的、相关的值。  
> 它比许多其他语言中的枚举更强大，支持关联值、原始值，还能扩展方法。

## 1. 基本用法

```swift
enum Direction {
    case north
    case south
    case east
    case west
}

let d = Direction.north
print(d)   // north
```

你也可以写在一行：

```swift
enum Direction { case north, south, east, west }
```

## 2. 搭配 switch 使用

```swift
func move(_ dir: Direction) {
    switch dir {
    case .north:
        print("向北走")
    case .south:
        print("向南走")
    case .east:
        print("向东走")
    case .west:
        print("向西走")
    }
}

move(.east)  // 向东走
```

> `switch` 必须覆盖所有枚举的情况，否则编译报错。

## 3. 枚举的原始值

枚举的每个 case 可以绑定一个 **原始值**（Raw Value），常见于数字或字符串。

```swift
enum Weekday: Int {
    case monday = 1, tuesday, wednesday, thursday, friday, saturday, sunday
}

print(Weekday.friday.rawValue) // 5

if let day = Weekday(rawValue: 7) {
    print(day) // sunday
}
```

## 4. 枚举的关联值

有时 case 需要携带不同的数据，这时可以用 **关联值**。

```swift
enum LoginState {
    case success(user: String)
    case failure(error: String)
}

let result = LoginState.success(user: "Alice")

switch result {
case .success(let user):
    print("登录成功：\(user)")
case .failure(let error):
    print("失败：\(error)")
}
```

## 5. 枚举的方法

枚举可以像类和结构体一样添加方法。

```swift
enum TrafficLight {
    case red, yellow, green

    func action() -> String {
        switch self {
        case .red: return "停"
        case .yellow: return "等"
        case .green: return "走"
        }
    }
}

print(TrafficLight.green.action()) // 走
```

## 总结

- `enum` 用来表示有限集合。
- 搭配 `switch` 使用非常常见。
- 可以有 **原始值** 和 **关联值**。
- 可以定义 **方法**，功能接近类和结构体。

Swift 的枚举很灵活，不只是常量集合，更像“轻量的数据类型”。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（12）：协议]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/12-协议</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/12-协议"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（12）：协议

> 协议（`protocol`）就像“契约”，规定了 **必须具备的属性和方法**。  
> 类、结构体、枚举都可以遵循协议。

## 1. 定义协议

```swift
protocol Drawable {
    func draw()
}
```

## 2. 遵循协议

```swift
struct Circle: Drawable {
    func draw() {
        print("画一个圆")
    }
}

let c = Circle()
c.draw()  // 画一个圆
```

## 3. 属性要求

协议可以要求属性，但只规定 **读/写权限**，不实现。

```swift
protocol Named {
    var name: String { get set }
    var description: String { get }
}

struct Person: Named {
    var name: String
    var description: String {
        "我的名字是 \(name)"
    }
}

let p = Person(name: "Alice")
print(p.description) // 我的名字是 Alice
```

## 4. 多协议

一个类型可以同时遵循多个协议。

```swift
protocol Flyable { func fly() }
protocol Swimmable { func swim() }

struct Duck: Flyable, Swimmable {
    func fly() { print("鸭子会飞") }
    func swim() { print("鸭子会游泳") }
}
```

## 5. 协议作为类型

协议不仅是规范，也能作为类型使用。

```swift
func test(d: Drawable) {
    d.draw()
}

test(d: Circle()) // 画一个圆
```

## 6. 协议继承

协议可以继承其它协议。

```swift
protocol Animal {
    func eat()
}

protocol Pet: Animal {
    func play()
}

struct Dog: Pet {
    func eat() { print("狗在吃") }
    func play() { print("狗在玩") }
}
```

## 7. 实战：系统协议实现

### AuthenticationServices 协议示例

````swift
import AuthenticationServices

class PasskeysManager: NSObject {
    // 私有属性存储回调
    private var callback: ((String) -> Void)?
}

// 使用 extension 分组实现协议
extension PasskeysManager: ASAuthorizationControllerDelegate {

    // 认证成功回调
    func authorizationController(controller: ASAuthorizationController,
                               didCompleteWithAuthorization authorization: ASAuthorization) {
        callback?("认证成功")
        callback = nil
    }

    // 认证失败回调
    func authorizationController(controller: ASAuthorizationController,
                               didCompleteWithError error: Error) {
        callback?("认证失败: \(error.localizedDescription)")
        callback = nil
    }
}

extension PasskeysManager: ASAuthorizationControllerPresentationContextProviding {

    // 提供展示认证界面的窗口
    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
        return UIApplication.shared.windows.first { $0.isKeyWindow } ?? UIWindow()
    }
}

#### 协议方法详解：presentationAnchor

```swift
public func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return UIApplication.shared.windows.first {
        $0.isKeyWindow
    } ?? ASPresentationAnchor()
}
````

**这个方法在做什么？**

- 为 AuthenticationServices 提供一个"锚点窗口"
- 系统会在这个窗口上显示 Face ID/Touch ID 认证界面

#### 语法分解

**1. 方法签名**

```swift
// 协议要求的方法签名
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor
```

**2. 核心逻辑：寻找活跃窗口**

```swift
UIApplication.shared.windows.first {
    $0.isKeyWindow  // 尾随闭包语法
}
```

等价于：

```swift
UIApplication.shared.windows.first(where: { window in
    return window.isKeyWindow
})
```

**3. 类型别名**

```swift
// ASPresentationAnchor 实际上就是 UIWindow
typealias ASPresentationAnchor = UIWindow
```

#### 不同的实现方式对比

```swift
// ✅ 你的实现：安全的空窗口降级
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return UIApplication.shared.windows.first { $0.isKeyWindow } ?? ASPresentationAnchor()
}

// ✅ 常见实现：返回空 UIWindow
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return UIApplication.shared.windows.first { $0.isKeyWindow } ?? UIWindow()
}

// ✅ iOS 13+ 现代写法
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return view.window ?? UIWindow()
}

// ❌ 不安全的写法（可能崩溃）
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return UIApplication.shared.windows.first { $0.isKeyWindow }!  // 强制解包危险
}
```

#### 实际应用场景

```swift
class PasskeysViewController: UIViewController {
    private let passkeysManager = PasskeysManager()

    override func viewDidLoad() {
        super.viewDidLoad()

        // 当用户点击认证按钮时
        let authController = ASAuthorizationController(authorizationRequests: [/* ... */])
        authController.delegate = passkeysManager
        authController.presentationContextProvider = passkeysManager  // 👈 会调用 presentationAnchor
        authController.performRequests()
    }
}
```

#### 为什么需要这个方法？

1. **系统需要知道在哪个窗口显示认证界面**
2. **确保认证界面显示在正确的屏幕上**（多屏设备）
3. **处理应用的窗口层级关系**

#### 常见问题和解决方案

```swift
// 问题：iOS 13+ 中 windows 数组可能为空
// 解决：使用 scene-based 方法
@available(iOS 13.0, *)
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
        return windowScene.windows.first { $0.isKeyWindow } ?? UIWindow()
    }
    return UIWindow()
}

// 问题：SwiftUI 环境中的处理
func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
    return UIApplication.shared.windows.first { $0.isKeyWindow } ??
           UIApplication.shared.windows.first ??
           UIWindow()
}
```

````

### @objc 协议兼容

```swift
// 跨语言调用的协议设计
@objc public protocol AuthenticationAPI {
    func register(_ options: String, callback: @escaping (String) -> Void)
    func authenticate(_ options: String, callback: @escaping (String) -> Void)
}

@objc public class AuthManager: NSObject, AuthenticationAPI {
    @objc public func register(_ options: String, callback: @escaping (String) -> Void) {
        // 实现注册逻辑
        callback("注册成功")
    }

    @objc public func authenticate(_ options: String, callback: @escaping (String) -> Void) {
        // 实现认证逻辑
        callback("认证成功")
    }
}
````

### 协议实现的最佳实践

```swift
// ✅ 使用 extension 分组组织协议实现
extension MyClass: ProtocolA {
    // ProtocolA 的方法
}

extension MyClass: ProtocolB {
    // ProtocolB 的方法
}

// ✅ 使用 MARK 注释分组
class MyClass {
    // MARK: - ProtocolA Implementation

    // MARK: - ProtocolB Implementation
}
```

## 总结

- `protocol` 用来定义 **方法和属性的规范**。
- 类/结构体/枚举都可以遵循协议。
- 协议也可以 **继承** 和 **组合**。
- 使用 `extension` 分组实现协议方法，代码更清晰。
- `@objc` 协议支持跨语言调用。
- 协议能作为类型使用，是 Swift 面向协议编程的基础。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（13）：扩展]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/13-扩展</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/13-扩展"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（13）：扩展

> **扩展（`extension`）** 可以给已有的类、结构体、枚举、协议 **添加新功能**，而无需修改原有代码。  
> 这在实际开发中非常常用。

## 1. 给已有类型添加方法

```swift
extension Int {
    func squared() -> Int {
        return self * self
    }
}

print(5.squared()) // 25
```

## 2. 添加计算属性

```swift
extension Double {
    var km: Double { self * 1000 }
    var cm: Double { self / 100 }
}

print(5.0.km) // 5000.0
print(120.0.cm) // 1.2
```

## 3. 初始化器扩展

扩展也能添加新的初始化方法。

```swift
struct Point {
    var x = 0.0, y = 0.0
}

extension Point {
    init(value: Double) {
        self.x = value
        self.y = value
    }
}

let p = Point(value: 3.0)
print(p) // Point(x: 3.0, y: 3.0)
```

## 4. 协议 + 扩展

扩展能给协议提供 **默认实现**。

```swift
protocol Greetable {
    func greet()
}

extension Greetable {
    func greet() {
        print("你好，欢迎学习 Swift!")
    }
}

struct Student: Greetable {}

let s = Student()
s.greet() // 你好，欢迎学习 Swift!
```

## 5. 限制扩展

可以通过 `where` 限制扩展只对特定类型生效。

```swift
extension Collection where Element: Comparable {
    func isSorted() -> Bool {
        return self == self.sorted()
    }
}

print([1, 2, 3].isSorted()) // true
print([3, 1, 2].isSorted()) // false
```

## 总结

- **扩展** 可以给已有类型添加 **方法、属性、初始化器**。
- **协议扩展** 能写默认实现，非常常用。
- 可以用 **`where` 限制扩展范围**。
- 扩展不会覆盖原有实现，但能让代码更简洁。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（14）：错误处理]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/14-错误处理</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/14-错误处理"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（14）：错误处理

> 在 Swift 中，错误处理主要通过 **`throw` / `try` / `catch`** 来实现。  
> 和异常不同，Swift 错误必须显式声明和处理，更安全。

## 1. 定义错误类型

Swift 的错误必须遵循 `Error` 协议。

```swift
enum FileError: Error {
    case notFound
    case noPermission
}
```

## 2. 抛出错误

```swift
func readFile(name: String) throws -> String {
    if name == "secret.txt" {
        throw FileError.noPermission
    }
    return "文件内容"
}
```

## 3. 捕获错误

```swift
do {
    let content = try readFile(name: "secret.txt")
    print(content)
} catch FileError.notFound {
    print("❌ 文件未找到")
} catch FileError.noPermission {
    print("⛔ 没有权限")
} catch {
    print("⚠️ 其它错误：\(error)")
}
```

## 4. try? 和 try!

- **`try?`**：错误时返回 `nil`。
- **`try!`**：确定不会出错时使用，出错会崩溃。

```swift
let result1 = try? readFile(name: "a.txt")  // Optional("文件内容")
let result2 = try? readFile(name: "secret.txt")  // nil

let result3 = try! readFile(name: "a.txt") // 强制执行
```

## 5. defer（清理资源）

`defer` 块中的代码在函数结束时执行，常用于释放资源。

```swift
func processFile() throws {
    print("开始处理文件")
    defer {
        print("关闭文件")
    }
    throw FileError.notFound
}

try? processFile()
// 输出：
// 开始处理文件
// 关闭文件
```

### defer 的实战应用：回调清理

```swift
// 系统 API 回调中的资源清理
public func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
    defer {
        self.callback = nil  // 确保函数退出前清理回调
    }
    self.callback?(self.toJSON(["ok": false, "errMsg": error.localizedDescription]))
}
```

#### defer 的执行时机

```swift
func demonstrateDefer() {
    print("1. 函数开始")

    defer {
        print("4. defer 块执行")
    }

    print("2. 中间逻辑")

    if someCondition {
        print("3a. 提前返回")
        return  // defer 仍会执行
    }

    print("3b. 正常结束")
    // defer 在这里执行
}

// 输出（提前返回情况）：
// 1. 函数开始
// 2. 中间逻辑
// 3a. 提前返回
// 4. defer 块执行
```

#### 多个 defer 的执行顺序

```swift
func multipleDefer() {
    defer { print("第一个 defer") }
    defer { print("第二个 defer") }
    defer { print("第三个 defer") }

    print("函数主体")
}

multipleDefer()
// 输出（后进先出 LIFO）：
// 函数主体
// 第三个 defer
// 第二个 defer
// 第一个 defer
```

#### defer 的实际应用场景

```swift
// 1. 文件操作清理
func readFileWithCleanup(_ path: String) -> String? {
    let file = openFile(path)
    defer {
        closeFile(file)  // 确保文件被关闭
    }

    guard file.isValid else { return nil }
    return file.readContent()
}

// 2. 网络请求状态管理
func performNetworkRequest() {
    isLoading = true
    defer {
        isLoading = false  // 确保加载状态被重置
    }

    // 网络请求逻辑
    if requestFailed {
        return  // defer 仍会执行，isLoading 会被设为 false
    }

    processResponse()
}

// 3. 数据库事务管理
func updateDatabase() throws {
    let transaction = database.beginTransaction()
    defer {
        if transaction.isActive {
            transaction.rollback()  // 确保事务被回滚或提交
        }
    }

    try database.insert(record1)
    try database.insert(record2)

    transaction.commit()
}

// 4. 认证回调清理（你的代码）
class AuthManager {
    private var callback: ((String) -> Void)?

    func authenticate(_ options: String, _ cb: @escaping (String) -> Void) {
        self.callback = cb
        // 执行认证...
    }

    // 成功回调
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        defer {
            self.callback = nil  // 确保回调被清理
        }

        // 处理成功结果
        let result = processAuthorization(authorization)
        self.callback?(result)
    }

    // 失败回调（你的代码）
    public func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
        defer {
            self.callback = nil  // 无论如何都清理回调
        }
        self.callback?(self.toJSON(["ok": false, "errMsg": error.localizedDescription]))
    }
}
```

#### defer vs 普通清理的对比

```swift
// ❌ 容易遗漏清理的写法
func badCleanupExample() {
    self.callback = someCallback

    if condition1 {
        self.callback = nil  // 需要手动清理
        return
    }

    if condition2 {
        // 忘记清理 callback！
        return
    }

    doSomething()
    self.callback = nil  // 需要手动清理
}

// ✅ 使用 defer 确保清理
func goodCleanupExample() {
    defer {
        self.callback = nil  // 自动清理，不会遗漏
    }

    self.callback = someCallback

    if condition1 {
        return  // defer 自动执行
    }

    if condition2 {
        return  // defer 自动执行
    }

    doSomething()
    // defer 自动执行
}
```

## 总结

- 用 `enum` + `Error` 定义错误类型。
- 用 `throw` 抛出，用 `try` + `catch` 捕获。
- `try?` 返回可选，`try!` 强制执行。
- `defer` 用于清理收尾。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（15）：泛型]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/15-泛型</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/15-泛型"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（15）：泛型

> 泛型（Generics）让你编写 **可复用、灵活、安全** 的代码。  
> 通过占位符 `T` 表示任意类型，避免重复写同样的函数或类。

## 1. 泛型函数

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temp = a
    a = b
    b = temp
}

var x = 5, y = 10
swapTwoValues(&x, &y)
print(x, y) // 10 5

var s1 = "hello", s2 = "world"
swapTwoValues(&s1, &s2)
print(s1, s2) // world hello
```

## 2. 泛型类型（结构体 / 类）

```swift
struct Stack<T> {
    private var items: [T] = []

    mutating func push(_ item: T) {
        items.append(item)
    }

    mutating func pop() -> T? {
        return items.popLast()
    }
}

var intStack = Stack<Int>()
intStack.push(1)
intStack.push(2)
print(intStack.pop()!) // 2
```

## 3. 类型约束

有时需要限定泛型类型必须遵循某个协议。

```swift
func findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {
    for (index, item) in array.enumerated() {
        if item == value { return index }
    }
    return nil
}

print(findIndex(of: "b", in: ["a", "b", "c"])) // 1
```

## 4. 关联类型（协议里的泛型）

```swift
protocol Container {
    associatedtype Item
    mutating func add(_ item: Item)
    var count: Int { get }
}

struct IntContainer: Container {
    var items: [Int] = []
    mutating func add(_ item: Int) { items.append(item) }
    var count: Int { items.count }
}
```

## 总结

- 泛型函数：`func foo<T>(...) {}`
- 泛型类型：`struct Stack<T> {...}`
- 类型约束：`<T: Equatable>`
- 协议可用 `associatedtype` 声明泛型。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（16）：访问控制]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/16-访问控制</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/16-访问控制"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（16）：访问控制

> Swift 提供访问控制（Access Control）来保护代码的内部实现。  
> 通过 `open`、`public`、`internal`、`fileprivate`、`private` 关键字控制作用范围。

## 1. 五种访问级别

1. **open**
   - 最宽松，允许模块外使用，并且可以继承 / 重写。
   - 主要用于 **框架对外 API**。
2. **public**
   - 模块外可以使用，但不能继承或重写。
   - 适合对外只读的接口。
3. **internal**（默认）
   - 只能在 **同一模块** 内使用。
   - 一般项目中大部分代码都是 `internal`。
4. **fileprivate**
   - 限制在 **同一个文件** 内访问。
5. **private**
   - 最严格，限制在 **同一个作用域**（类 / 结构体）内使用。

## 2. 使用示例

```swift
open class OpenClass {
  open func openMethod() {}
  public func publicMethod() {}
  internal func internalMethod() {}
  fileprivate func filePrivateMethod() {}
  private func privateMethod() {}
}

let obj = OpenClass()
obj.publicMethod()   // ✅ 可访问
obj.internalMethod() // ✅ 同模块可访问
// obj.filePrivateMethod() ❌ 其他文件不可访问
// obj.privateMethod() ❌ 作用域外不可访问
```

## 3. 常见使用场景

- **open**：SDK / Framework 提供可继承的基类。
- **public**：模块对外公开的常量或函数。
- **internal**：默认级别，适合大部分业务代码。
- **fileprivate**：隐藏某些工具函数。
- **private**：保护类内部细节。

## 4. 注意事项

- 属性、方法、初始化器、扩展都可以设置访问级别。
- 子类的访问级别不能高于父类。
- 协议的访问级别会影响其实现。

## 总结

- Swift 默认访问级别是 `internal`。
- 最常用的是 `internal` + `private`，只在需要开放 API 时用 `public` 或 `open`。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（17）：继承与多态]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/17-继承与多态</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/17-继承与多态"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（17）：继承与多态

> Swift 是面向对象语言，支持 **继承** 与 **多态**，但比起某些语言更强调组合。

## 1. 基本继承

```swift
class Animal {
  var name: String
  init(name: String) {
    self.name = name
  }
  func makeSound() {
      print("...")
  }
}

class Dog: Animal {
  func fetch() {
    print("\(name) is fetching!")
  }

  // 重写父类方法
  override func makeSound() {
    print("Woof!")
  }
}

let dog = Dog(name: "Buddy")
dog.makeSound()   // Woof!
dog.fetch()       // Buddy is fetching!
```

## 2. 多态

父类引用可以指向子类对象：

```swift
let a: Animal = Dog(name: "Max")
a.makeSound()   // 调用的是 Dog 的实现 -> "Woof!"
```

这就是 **多态**：相同的接口，表现不同的行为。

## 3. `final` 关键字

如果不希望类被继承，可以用 `final`：

```swift
final class Cat: Animal {
  override func makeSound() {
      print("Meow!")
  }
}

// ❌ 下面代码会报错：不能继承 final 类
// class Kitten: Cat {}
```

## 4. 构造器的继承与重写

子类如果没有写构造器，会自动继承父类的构造器。

```swift
class Bird: Animal {
  override func makeSound() {
      print("Chirp!")
  }
}

let b = Bird(name: "Tweety") // ✅ 直接用父类 init
```

如果写了自己的 `init`，可能需要 `super.init`：

```swift
class Parrot: Animal {
  var color: String
  init(name: String, color: String) {
    self.color = color
    super.init(name: name) // 必须调用父类构造器
  }
}
```

## 5. 多态与协议的对比

- **继承**：类与类之间的关系，强调 "is-a"。
- **协议**：行为的抽象，强调 "can-do"。
- 在 Swift 开发中，协议比继承更常用。

## 总结

- 继承允许子类扩展和重写父类功能。
- 多态通过父类引用调用子类实现。
- 使用 `final` 可以禁止继承。
- Swift 提倡 **少用继承，多用协议与组合**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（18）：协议进阶]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/18-协议进阶</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/18-协议进阶"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（18）：协议进阶

> 协议（`protocol`）是 Swift 的核心特性之一。它不仅能定义行为接口，还能与扩展、泛型、面向协议编程结合，形成比继承更强大的抽象。

## 1. 协议继承

协议可以继承其他协议：

```swift
protocol Named {
  var name: String { get }
}

protocol Aged {
  var age: Int { get }
}

protocol Person: Named, Aged {}

struct Student: Person {
  var name: String
  var age: Int
}
```

## 2. 协议中的构造器

协议可以要求实现某些构造器：

```swift
protocol Initializable {
  init(value: Int)
}

class NumberBox: Initializable {
  var value: Int
  required init(value: Int) { // required 表示所有子类必须实现
      self.value = value
  }
}
```

## 3. 协议扩展（默认实现）

协议扩展可以提供默认实现，让协议更像“接口 + 实现”：

```swift
protocol Drawable {
    func draw()
}

extension Drawable {
    func draw() {
        print("Default drawing...")
    }
}

struct Circle: Drawable {} // 没实现 draw()，会用默认实现

Circle().draw() // Default drawing...
```

也可以在扩展里添加新的方法：

```swift
extension Drawable {
    func debug() {
        print("Debugging drawable object")
    }
}

Circle().debug() // Debugging drawable object
```

---

## 4. 协议与泛型

协议常与泛型结合，用 `where` 约束类型：

```swift
protocol Summable {
    static func +(lhs: Self, rhs: Self) -> Self
}

func add<T: Summable>(_ a: T, _ b: T) -> T {
    return a + b
}

extension Int: Summable {}
extension Double: Summable {}

print(add(3, 5))      // 8
print(add(2.5, 7.1))  // 9.6
```

---

## 5. 面向协议编程（POP）

Swift 鼓励 **Protocol-Oriented Programming**（POP），比继承更灵活：

- 协议定义能力（能做什么）。
- 结构体/类采用协议，组合出需要的行为。
- 协议扩展提供默认实现，减少重复代码。

示例：

```swift
protocol Flyable {
    func fly()
}

extension Flyable {
    func fly() { print("Flying...") }
}

struct Bird: Flyable {}
struct Airplane: Flyable {}

Bird().fly()      // Flying...
Airplane().fly()  // Flying...
```

---

## 总结

- 协议支持继承、构造器要求。
- 协议扩展提供默认实现，提升代码复用。
- 协议与泛型结合更强大。
- 面向协议编程是 Swift 的核心思想。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（19）：内存管理]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/19-内存管理</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/19-内存管理"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（19）：内存管理

> Swift 使用 **ARC（Automatic Reference Counting）** 自动管理内存，大多数情况下不需要手动释放对象。但理解其工作原理非常重要，尤其是避免循环引用。

## 1. ARC 的基本原理

- 每个类实例都有一个 **引用计数**。
- 当引用 +1 时，实例保留。
- 当引用变为 0 时，实例被销毁。

```swift
class Person {
  let name: String
  init(name: String) { self.name = name }
  deinit { print("\(name) 被销毁") }
}

var p1: Person? = Person(name: "Tom")
p1 = nil // 引用计数归零，触发 deinit
```

## 2. 强引用（Strong Reference）

默认情况下，变量保存对象时会创建一个 **强引用**。

```swift
class Dog {}
var d1: Dog? = Dog()
var d2 = d1 // d1, d2 都是强引用
```

## 3. 循环引用问题

如果两个对象相互持有强引用，会导致 **循环引用**，对象无法释放。

```swift
class Teacher {
  var student: Student?
  deinit { print("Teacher deinit") }
}

class Student {
  var teacher: Teacher?
  deinit { print("Student deinit") }
}

var t: Teacher? = Teacher()
var s: Student? = Student()

t?.student = s
s?.teacher = t

t = nil
s = nil
// ❌ Teacher 和 Student 都不会释放
```

## 4. 解决循环引用

### 4.1 弱引用（weak）

- 用 `weak` 修饰，引用不会增加计数。
- 常用于 **可选类型**，引用对象销毁后会自动设为 `nil`。

```swift
class Teacher {
  var student: Student?
  deinit { print("Teacher deinit") }
}

class Student {
  weak var teacher: Teacher? // 🔑 解决循环引用
  deinit { print("Student deinit") }
}
```

### 4.2 无主引用（unowned）

- 用 `unowned` 修饰，不会增加计数。
- **不会自动置 nil**，适合生命周期一致的对象。

```swift
class CreditCard {
  unowned let customer: Customer // 永远存在
  init(customer: Customer) { self.customer = customer }
  deinit { print("Card deinit") }
}

class Customer {
  var card: CreditCard?
  deinit { print("Customer deinit") }
}

var c: Customer? = Customer()
c?.card = CreditCard(customer: c!)
c = nil // 两个对象都释放
```

## 5. 闭包捕获列表

闭包也可能导致循环引用，需要用 `[weak self]` 或 `[unowned self]`。

```swift
class ViewController {
  var name = "VC"
  var callback: (() -> Void)?

  func setup() {
      callback = { [weak self] in
          print(self?.name ?? "nil")
      }
  }

  deinit { print("VC deinit") }
}
```

## 总结

- Swift 使用 ARC 自动管理内存。
- 循环引用是主要问题，需要 `weak` 或 `unowned` 解决。
- 闭包中捕获 `self` 时，注意使用捕获列表。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（20）：并发与异步]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/20-并发与异步</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/20-并发与异步"/>
        <updated>2025-09-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（20）：并发与异步

> Swift 从 5.5 开始引入了现代化的 **并发模型**，主要包括 `async/await`、`Task`、以及 `Actor`。它让异步代码更直观，也避免了回调地狱。

## 1. async/await 基础

用 `async` 标记异步函数，用 `await` 调用它。

```swift
func fetchData() async -> String {
    return "数据结果"
}

Task {
    let result = await fetchData()
    print(result)
}
```

## 2. 异步任务 Task

`Task {}` 可以在任何地方开启一个并发任务。

```swift
Task {
    print("开始下载")
    let data = await fetchData()
    print("下载完成: \(data)")
}
```

## 3. 并发执行

多个异步任务可以 **并发执行**。

```swift
func task1() async -> String {
    try? await Task.sleep(nanoseconds: 1_000_000_000)
    return "任务1完成"
}

func task2() async -> String {
    return "任务2完成"
}

Task {
    async let r1 = task1()
    async let r2 = task2()
    print(await r1, await r2)
}
```

## 4. 异步序列

异步版本的 `for-in`，用于流式数据。

```swift
func numbers() -> AsyncStream<Int> {
    AsyncStream { continuation in
        for i in 1...3 {
            continuation.yield(i)
        }
        continuation.finish()
    }
}

Task {
    for await num in numbers() {
        print(num)
    }
}
```

## 5. Actor（解决共享数据并发问题）

`Actor` 用来保证数据的 **线程安全**。

```swift
actor Counter {
    var value = 0
    func increment() { value += 1 }
}

let counter = Counter()

Task {
    await counter.increment()
    print(await counter.value)
}
```

## 6. 与传统回调互操作

老的 **回调 API** 可以通过 `withCheckedContinuation` 转成 `async`。

```swift
func loadData(completion: @escaping (String) -> Void) {
    DispatchQueue.global().async {
        completion("旧API数据")
    }
}

func loadDataAsync() async -> String {
    await withCheckedContinuation { cont in
        loadData { result in cont.resume(returning: result) }
    }
}

Task {
    print(await loadDataAsync())
}
```

---

## 总结

- `async/await` 让异步代码像同步一样易读。
- `Task` 开启并发任务，`async let` 并发执行多个任务。
- `Actor` 提供线程安全的数据访问。
- 旧回调 API 可以用 `Continuation` 封装成异步。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 模块化编程速成：以 PasskeysNative 为例]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/21-Swift 模块化编程速成：以 PasskeysNative 为例</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/21-Swift 模块化编程速成：以 PasskeysNative 为例"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# 你将收获

- 如何为 iOS 代码划清**模块边界**，只暴露稳定的 **Public API**。
- 选择 **Swift Package** / **XCFramework** 输出形态，以及最小可行的集成步骤。
- 设计**输入输出契约**（JSON 入参与回调），稳定错误模型与平台兼容策略。
- 进阶：协议抽象、依赖倒置、可测试性、并发模型、二进制分发与文档化。

---

# 场景设定：把 `PasskeysNative` 做成可复用模块

你的类大致长这样（节选，便于说明；不复述完整代码）：

```swift
@objc public class PasskeysNative: NSObject, ASAuthorizationControllerDelegate, ASAuthorizationControllerPresentationContextProviding {
    // ... JSON / Base64url 工具方法（internal/private）
    // ... @objc public func register(_ optionsJson: String, _ cb: @escaping (String) -> Void)
    // ... @objc public func authenticate(_ optionsJson: String, _ cb: @escaping (String) -> Void)
    // ... ASAuthorizationControllerDelegate 回调
}
```

> 目标：把它抽为 **独立模块**，对外只暴露 `register(optionsJson, cb)` 与 `authenticate(optionsJson, cb)`，内部细节（Base64 工具、iOS 16+ 适配、系统回调）全部**隐藏**。

# 第一部分 · 最常用最重要（先用起来）

## 1. 划定模块边界与对外 API

**原则**：

- 仅把**稳定能力**标注为 `public` / `@objc` 暴露给上层（UTS/JS 桥）。
- 细节工具与策略（Base64url、JSON 解析、错误组装）一律 `internal`/`private`。
- **输入**：`optionsJson`（WebAuthn 标准字段，经由前端/服务器下发）。
- **输出**：统一的回调 JSON：`{"ok": true, "data": {...}} | {"ok": false, "errMsg": "..."}`。

**建议 API（示意）**：

```swift
@objc public protocol PasskeysAPI {
    // 复杂：跨语言回调形态与线程切换
    // ↑ 在复杂逻辑上一行加注释
    func register(_ optionsJson: String, _ cb: @escaping (String) -> Void)
    func authenticate(_ optionsJson: String, _ cb: @escaping (String) -> Void)
}
```

> 说明：把协议放在模块 `Public` 目录，类 `PasskeysNative` 作为默认实现，后续可无痛替换（比如接入外部安全 Key 的实现）。

## 2. 产物类型：Swift Package vs XCFramework（怎么交付）

**Swift Package（首选）**

- 优点：源码分发、版本化清晰、集成简单（Xcode/SwiftPM 原生支持）。
- 适合团队内部与持续演进。

**XCFramework（二进制）**

- 优点：隐藏源码、冷启动更快、适合跨项目/商业分发。
- 用法：`xcodebuild -create-xcframework -framework ... -output Passkeys.xcframework`。

> 推荐：**先 SwiftPM，后期有保密/性能诉求再补二进制 XCFramework**。

## 3. 输入输出契约（最易踩坑的地方）

- **输入**：`PublicKeyCredentialCreationOptions` / `RequestOptions` 的**对象本体**（不是 `{ publicKey: {} }` 外包一层）。
- **字段**：`rp.id`、`challenge`、`user.id`/`user.name`、`rpId` 等必须存在。
- **编码**：二进制字段（`challenge`、`user.id`、`rawId`等）统一 **Base64URL**。
- **输出**：遵循 WebAuthn 前端预期形态（`id/rawId/type/response/...`）。
- **错误**：固定 `ok/errMsg` 键，便于前端/UTS 无分支解析。

> 小贴士：JSON 序列化失败、必填字段缺失、平台版本不符，**都走同一错误模型**，前端体验最稳定。

## 4. 平台/版本兼容策略（iOS 16+）

- `ASAuthorizationPlatformPublicKeyCredential*` 需要 **iOS 16+**。
- 在 API 内部用 `#available(iOS 16.0, *)` **短路返回**统一错误（`"iOS 16+ required"`）。
- 不把平台细节泄露到 API 边界之外（对外只看 `ok/errMsg`）。

## 第二部分 · 深入与难点（架构/工程化）

### A. 面向协议的抽象与依赖倒置

- **问题**：未来可能接入 FIDO 外置 Key、模拟器桩件或切换到不同系统 API。
- **做法**：抽象协议并**依赖接口**而非具体类。

```swift
// 复杂：抽象系统提供者，便于注入 mock 与多实现
// ↑ 在复杂逻辑上一行加注释
protocol CredentialProvider {
    func makeRegistrationRequest(rpId: String, challenge: Data, userName: String, userId: Data) -> ASAuthorizationRequest
    func makeAssertionRequest(rpId: String, challenge: Data) -> ASAuthorizationRequest
}
```

> `PasskeysNative` 通过构造函数接收 `CredentialProvider`，测试时注入 **FakeProvider**。

### B. 并发模型：从回调到 async/await（可选）

- 门面层保留回调（兼容跨语言），**内部**可封装为 `async`：

  - 回调转 `CheckedContinuation`。
  - 上层 Swift 调用者可获得 `let result = try await client.register(options:)` 的良好体验。
  - 对外仍只暴露回调方法，保持跨语言稳定。

### C. 错误域与分类

- 自定义 `PasskeysError: Error`，内部归类：

  - `.invalidOptions(field: String)`、`.platformUnsupported(min: "iOS16")`、`.system(Error)`、`.encoding`。

- **统一映射**到 `errMsg` 字符串，**不上抛内部类型**到跨语言边界。

### D. 跨语言边界与可见性

- 需要 `@objc` + `NSObject` + `public` 才能被 UTS/JS 调用。
- 注意 `nullability` 与 Swift/ObjC 桥接（`String?` / `Data?`）。
- `JSONSerialization` 用 `try?` + 可控的默认值**收口错误**。

## E. 测试策略

- **单测**：

  - Base64URL 编解码（空输入、无填充、多填充）。
  - JSON 契约（必填字段缺失 → 错误）。
  - iOS16 可用性分支。

- **组件测试**：

  - 用 Fake `CredentialProvider` 模拟成功/失败/取消回调。

- **UI/集成**：

  - 最小 Demo App 调通真实设备的注册/登录流程。

## F. 工程化：版本与分发

- **语义化版本**：`MAJOR.MINOR.PATCH`。

  - 修改 JSON 字段 →**MAJOR**。
  - 新增字段（向后兼容）→**MINOR**。
  - 修复/优化 →**PATCH**。

- **二进制分发**（可选）：出 `*.xcframework` + 校验脚本（`codesign --verify`）。

## G. 文档化与可发现性

- 用 **DocC** 为 `PasskeysAPI` 生成文档；
- 在包内提供 `Examples/`，含最小调用样例与 JSON 模版。

---

# 目录结构建议（可直接照搬）

```
PasskeysKit/
├─ Package.swift
├─ Sources/
│  └─ PasskeysKit/
│     ├─ Public/
│     │  ├─ PasskeysAPI.swift
│     │  └─ PasskeysErrors.swift
│     └─ Internal/
│        ├─ PasskeysNative.swift
│        ├─ CredentialProvider.swift
│        ├─ Base64URL.swift
│        └─ JSONCoder.swift
└─ Tests/
   └─ PasskeysKitTests/
      ├─ Base64URLTests.swift
      ├─ OptionsParsingTests.swift
      └─ PlatformAvailabilityTests.swift
```

---

# 模块化落地清单（Checklist）

- [ ] Public API **最小化**，仅暴露 `register/authenticate`。
- [ ] 输入/输出 JSON 契约文档齐全，错误模型统一。
- [ ] `#available(iOS 16, *)` 在内部**短路**，不外泄平台细节。
- [ ] SwiftPM 集成通过；必要时补 XCFramework。
- [ ] 协议抽象 + 依赖注入，测试可控。
- [ ] 版本语义化与变更日志。
- [ ] DocC 文档与 `Examples/` 示例齐备。

---

# 常见坑位与规避

- **Base64URL** 填充处理：注意 `=` 去/补；空字符串与非法字符要兜底为空 `Data()`。
- **回调置空**：一次请求结束后 `callback = nil`，避免多次触发或悬挂引用。
- **线程语义**：系统回调不保证在主线程；UI 更新前**切主线程**。
- **`presentationAnchor`**：确保返回 **keyWindow**；多场景时注意窗口切换。
- **版本分支**：把 `iOS 16+` 检查放在**最前**，尽早失败、错误可预期。
- **跨语言兼容**：`@objc public` 与 `NSObject` 继承别漏；字符串编码用 UTF-8。

---

# 结语

把功能做成**小而稳的模块**，先对外统一契约，再在内部迭代实现，是 Swift/iOS 项目长期可维护的关键。你现在的 `PasskeysNative` 已经很接近理想门面：**只需把工具与系统细节收入 Internal，把 API 抽到 Public 协议里**，就能在不破坏上层调用的前提下，持续演进到更专业的工程形态。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（22）：模块导入与导出]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/22-模块导入与导出</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/22-模块导入与导出"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（22）：模块导入与导出

> 如何导入系统框架、第三方库，以及如何设计自己的模块对外接口。

## 什么是模块（Module）

在 Swift 中，**模块**是代码分发的基本单位。每个模块都有自己的命名空间，可以包含类、结构体、协议、函数等。

常见的模块类型：

- **系统框架**：`Foundation`、`UIKit`、`SwiftUI` 等
- **第三方库**：通过 CocoaPods、Swift Package Manager 安装的库
- **自定义模块**：你自己创建的 Swift Package 或 Framework

## import 语法详解

### 1. 基础导入语法

```swift
// 导入整个模块
import Foundation
import UIKit
import AuthenticationServices

// 导入后就可以使用模块中的公开类型
let date = Date()                    // Foundation.Date
let label = UILabel()               // UIKit.UILabel
```

### 2. 选择性导入

```swift
// 只导入模块中的特定类型
import class UIKit.UIViewController
import struct Foundation.URL
import enum Foundation.ComparisonResult

// 导入特定函数
import func Darwin.sqrt
```

### 3. 重命名导入

```swift
// 避免命名冲突
import UIKit
import class MyFramework.UIView as MyUIView

// 使用时区分
let systemView = UIView()    // UIKit.UIView
let customView = MyUIView()  // MyFramework.UIView
```

### 4. 测试专用导入

```swift
// 仅在测试环境导入
#if DEBUG
import TestingFramework
#endif

@testable import MyApp  // 可以访问 internal 级别的内容
```

## 你提到的三个框架详解

### Foundation

```swift
import Foundation

// Foundation 提供基础数据类型和系统服务
let string = "Hello"
let date = Date()
let url = URL(string: "https://example.com")
let data = Data()
let userDefaults = UserDefaults.standard
```

**常用场景**：字符串处理、日期时间、网络请求、数据存储、JSON 解析

### UIKit

```swift
import UIKit

// UIKit 提供 iOS 用户界面组件
let viewController = UIViewController()
let label = UILabel()
let button = UIButton(type: .system)
let imageView = UIImageView()
```

**常用场景**：构建传统 iOS 界面、处理触摸事件、导航控制、动画

### AuthenticationServices

```swift
import AuthenticationServices

// 提供生物识别、Passkeys 等认证服务
let context = ASAuthorizationController()
let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: "example.com")
```

**常用场景**：Face ID/Touch ID 认证、Passkeys 登录、Safari 密码自动填充

## 模块的访问控制

### 访问级别从高到低

```swift
// 1. open - 最开放，可被其他模块继承和重写
open class BaseViewController: UIViewController {
    open func setup() { }
}

// 2. public - 可被其他模块访问，但不能继承
public class APIClient {
    public func request() { }
}

// 3. internal - 模块内部可访问（默认级别）
internal class NetworkManager {
    func sendRequest() { }
}

// 4. fileprivate - 同一文件内可访问
fileprivate class FileHelper {
    func process() { }
}

// 5. private - 最严格，只有当前作用域可访问
private class Secret {
    private func encrypt() { }
}
```

## 如何设计可导出的模块

### 1. 创建 Swift Package

```bash
# 创建新的 Swift Package
mkdir MyAwesomeKit
cd MyAwesomeKit
swift package init --type library
```

生成的 `Package.swift`：

```swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "MyAwesomeKit",
    products: [
        .library(
            name: "MyAwesomeKit",
            targets: ["MyAwesomeKit"]),
    ],
    targets: [
        .target(
            name: "MyAwesomeKit",
            dependencies: []),
        .testTarget(
            name: "MyAwesomeKitTests",
            dependencies: ["MyAwesomeKit"]),
    ]
)
```

### 2. 设计公开 API

```swift
// Sources/MyAwesomeKit/MyAwesomeKit.swift

import Foundation

// 对外暴露的主要接口
public class NetworkClient {
    public init() {}

    public func get(url: String) async throws -> Data {
        // 实现网络请求
        return Data()
    }
}

// 对外暴露的协议
public protocol DataProcessor {
    func process(_ data: Data) -> String
}

// 内部实现，不对外暴露
internal class InternalHelper {
    static func format(_ data: Data) -> String {
        return String(data: data, encoding: .utf8) ?? ""
    }
}

// 私有实现
private extension NetworkClient {
    func buildRequest(url: String) -> URLRequest? {
        guard let url = URL(string: url) else { return nil }
        return URLRequest(url: url)
    }
}
```

### 3. 使用你的模块

```swift
// 在其他项目中使用
import MyAwesomeKit

class ViewController: UIViewController {
    let client = NetworkClient()

    override func viewDidLoad() {
        super.viewDidLoad()

        Task {
            do {
                let data = try await client.get(url: "https://api.example.com")
                print("获取到数据：\(data.count) bytes")
            } catch {
                print("请求失败：\(error)")
            }
        }
    }
}
```

## 实际开发中的最佳实践

### 1. 按功能模块化导入

```swift
// 好的做法：按需导入
import Foundation          // 基础类型
import UIKit              // UI 组件
import AuthenticationServices  // 认证相关

class LoginViewController: UIViewController {
    // 使用各个模块的功能
}
```

### 2. 避免循环依赖

```swift
// ❌ 避免这样的循环依赖
// ModuleA 导入 ModuleB
// ModuleB 导入 ModuleA

// ✅ 正确做法：提取公共协议到独立模块
// ModuleA 和 ModuleB 都依赖 CommonProtocols
```

### 3. 合理设计访问级别

```swift
public class UserManager {
    // 对外接口
    public func login(username: String, password: String) async -> Bool {
        return await performLogin(username, password)
    }

    // 内部实现
    private func performLogin(_ username: String, _ password: String) async -> Bool {
        // 具体登录逻辑
        return true
    }

    // 内部状态
    private var isLoggedIn = false
}
```

## 常见问题与解决方案

### 问题 1：模块找不到

```swift
// 错误信息：No such module 'SomeFramework'
// 解决方案：
// 1. 检查 import 语句拼写
// 2. 确认已在 Package.swift 或 Podfile 中添加依赖
// 3. 清理构建缓存：Product → Clean Build Folder
```

### 问题 2：访问级别错误

```swift
// 错误信息：'SomeClass' is inaccessible due to 'internal' protection level
// 解决方案：确保要访问的类型标记为 public 或 open

// 模块内部
public class SomeClass {  // 添加 public 关键字
    public init() {}      // 构造函数也需要 public
}
```

### 问题 3：命名冲突

```swift
// 两个模块都有同名类型
import ModuleA
import ModuleB

// 使用完整名称区分
let a = ModuleA.SomeClass()
let b = ModuleB.SomeClass()

// 或者使用重命名导入
import struct ModuleB.SomeClass as ModuleBClass
```

## 小结

这一篇我们学习了 Swift 的模块系统：

- **import 语法**：基础导入、选择性导入、重命名导入
- **系统框架**：Foundation、UIKit、AuthenticationServices 的用途
- **访问控制**：open、public、internal、fileprivate、private 五个级别
- **模块设计**：如何创建可复用的 Swift Package
- **最佳实践**：避免循环依赖、合理设计 API、处理常见问题

下一篇我们将学习 Swift 的包管理器和依赖管理，让你能够更好地使用和分发 Swift 模块。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 入门（23）：系统API调用与数据流]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-quickstart/23-系统API调用与数据流</id>
        <link href="https://herongdev.github.io/blog/posts/swift-quickstart/23-系统API调用与数据流"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Swift 入门（23）：系统 API 调用与数据流

> 本文专门讲解如何调用 iOS 系统 API，以 AuthenticationServices 框架的 Passkeys 实现为例，展示完整的数据流转和方法调用过程。

## 系统 API 调用的基本模式

### 典型的调用流程

```swift
// 1. 创建提供者（Provider）
let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)

// 2. 创建请求（Request）
let request = provider.createCredentialRegistrationRequest(
    challenge: fromB64url(challengeB64),
    name: userName,
    userID: fromB64url(userIdB64)
)

// 3. 创建控制器（Controller）
let controller = ASAuthorizationController(authorizationRequests: [request])

// 4. 配置控制器
controller.delegate = self
controller.presentationContextProvider = self

// 5. 存储回调
self.callback = cb

// 6. 执行请求
controller.performRequests()
```

## 逐步分解：类与方法详解

### 1. ASAuthorizationPlatformPublicKeyCredentialProvider

```swift
let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)
```

**类的作用**：

- 这是 Apple 提供的 **Passkeys 凭证提供者**
- 负责与系统的 Passkeys 存储进行交互
- `relyingPartyIdentifier` 是网站/应用的唯一标识符（如 "example.com"）

**初始化参数**：

```swift
// rpId 通常是域名，用于标识这个 Passkey 属于哪个网站
let rpId = "example.com"
let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)

// 实际数据示例
let rpId = "webauthn.example.com"  // 从服务器传来的 rp.id 字段
```

### 2. createCredentialRegistrationRequest 方法

```swift
let request = provider.createCredentialRegistrationRequest(
    challenge: fromB64url(challengeB64),  // Data 类型
    name: userName,                       // String 类型
    userID: fromB64url(userIdB64)        // Data 类型
)
```

**方法作用**：

- 创建一个 **注册请求**，用于生成新的 Passkey
- 将后端服务器提供的参数转换为系统可识别的格式

**参数详解**：

| 参数        | 类型     | 作用                     | 数据转换         |
| ----------- | -------- | ------------------------ | ---------------- |
| `challenge` | `Data`   | 防重放攻击的随机挑战码   | Base64URL → Data |
| `name`      | `String` | 用户标识符（通常是邮箱） | 直接使用         |
| `userID`    | `Data`   | 用户的唯一 ID            | Base64URL → Data |

#### 数据转换过程详解

```swift
// 服务器发送的原始数据（JSON）
let serverData = """
{
    "rp": {"id": "example.com"},
    "user": {
        "id": "dXNlcjEyMw==",           // Base64URL 编码的用户 ID
        "name": "alice@example.com",    // 用户邮箱
        "displayName": "Alice Smith"
    },
    "challenge": "Y2hhbGxlbmdl"         // Base64URL 编码的挑战码
}
"""

// 数据转换函数
func fromB64url(_ base64url: String) -> Data {
    // Base64URL → 标准 Base64 → Data
    var base64 = base64url
        .replacingOccurrences(of: "-", with: "+")
        .replacingOccurrences(of: "_", with: "/")

    // 添加填充
    let padding = (4 - base64.count % 4) % 4
    if padding > 0 {
        base64.append(String(repeating: "=", count: padding))
    }

    return Data(base64Encoded: base64) ?? Data()
}

// 实际转换过程
let challengeB64 = "Y2hhbGxlbmdl"              // 来自服务器
let challengeData = fromB64url(challengeB64)    // 转换为 Data
// challengeData = <63686161 6c6c656e 6765>     // "challenge" 的字节表示

let userIdB64 = "dXNlcjEyMw=="                 // 来自服务器
let userIdData = fromB64url(userIdB64)         // 转换为 Data
// userIdData = <75736572 313233>               // "user123" 的字节表示
```

### 3. ASAuthorizationController

```swift
let controller = ASAuthorizationController(authorizationRequests: [request])
```

**类的作用**：

- 这是 Apple 的 **授权控制器**
- 负责协调整个认证流程
- 管理用户界面的显示和用户交互

**初始化参数**：

```swift
// authorizationRequests 是一个数组，可以包含多个请求
let requests: [ASAuthorizationRequest] = [request]
let controller = ASAuthorizationController(authorizationRequests: requests)

// 也可以同时支持多种认证方式
let passkeyRequest = provider.createCredentialRegistrationRequest(...)
let passwordRequest = ASPasswordCredentialIdentity.init(...)
let allRequests = [passkeyRequest, passwordRequest]
let controller = ASAuthorizationController(authorizationRequests: allRequests)
```

### 4. 控制器配置

```swift
controller.delegate = self                      // 处理认证结果
controller.presentationContextProvider = self  // 提供显示窗口
self.callback = cb                             // 存储回调函数
```

#### delegate 的作用

```swift
// 当前类需要实现 ASAuthorizationControllerDelegate 协议
extension PasskeysManager: ASAuthorizationControllerDelegate {

    // 认证成功时调用 - 完整实现
    public func authorizationController(controller: ASAuthorizationController,
                                      didCompleteWithAuthorization authorization: ASAuthorization) {
        defer {
            self.callback = nil  // 确保回调被清理
        }

        if #available(iOS 16.0, *) {
            // 注册结果 → WebAuthn Create 格式
            if let reg = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialRegistration {
                let id = b64url(reg.credentialID)
                let data: [String: Any] = [
                    "id": id,
                    "rawId": id,
                    "type": "public-key",
                    "response": [
                        "attestationObject": b64url(reg.rawAttestationObject),
                        "clientDataJSON": b64url(reg.rawClientDataJSON)
                    ],
                    "transports": ["internal"]
                ]
                self.callback?(self.toJSON(["ok": true, "data": data]))
                return
            }

            // 登录结果 → WebAuthn Get 格式
            if let asr = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialAssertion {
                let id = b64url(asr.credentialID)
                let data: [String: Any] = [
                    "id": id,
                    "rawId": id,
                    "type": "public-key",
                    "response": [
                        "authenticatorData": b64url(asr.rawAuthenticatorData),
                        "clientDataJSON": b64url(asr.rawClientDataJSON),
                        "signature": b64url(asr.signature),
                        "userHandle": b64url(asr.userID)
                    ]
                ]
                self.callback?(self.toJSON(["ok": true, "data": data]))
                return
            }

            // 未知的凭证类型
            self.callback?(self.toJSON(["ok": false, "errMsg": "unsupported credential type"]))
        } else {
            // iOS 版本不支持
            self.callback?(self.toJSON(["ok": false, "errMsg": "iOS 16+ required"]))
        }
    }

    // 认证失败时调用
    func authorizationController(controller: ASAuthorizationController,
                               didCompleteWithError error: Error) {
        let result = ["ok": false, "errMsg": error.localizedDescription]
        callback?(toJSON(result))
        callback = nil
    }
}
```

#### 成功回调的详细分析

**1. 双重类型检查模式**

```swift
// 第一层：版本检查
if #available(iOS 16.0, *) {

    // 第二层：凭证类型检查
    if let reg = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialRegistration {
        // 处理注册结果
    } else if let asr = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialAssertion {
        // 处理登录结果
    } else {
        // 未知类型
    }

} else {
    // 版本不支持
}
```

**2. 数据转换流程**

```swift
// iOS 系统对象 → WebAuthn 标准格式

// 注册场景的数据转换
let reg = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialRegistration

// 系统数据
reg.credentialID           // Data 类型
reg.rawAttestationObject   // Data? 类型
reg.rawClientDataJSON      // Data 类型

// 转换为前端期望格式
let data = [
    "id": b64url(reg.credentialID),                    // Data → Base64URL
    "rawId": b64url(reg.credentialID),                 // Data → Base64URL
    "type": "public-key",                              // 固定值
    "response": [
        "attestationObject": b64url(reg.rawAttestationObject),  // Data? → Base64URL
        "clientDataJSON": b64url(reg.rawClientDataJSON)         // Data → Base64URL
    ],
    "transports": ["internal"]                         // 固定值，表示平台内置
]
```

**3. 两种认证场景的区别**

| 场景     | 系统类型                                                 | 关键数据                         | 用途             |
| -------- | -------------------------------------------------------- | -------------------------------- | ---------------- |
| **注册** | `ASAuthorizationPlatformPublicKeyCredentialRegistration` | `attestationObject`              | 创建新的 Passkey |
| **登录** | `ASAuthorizationPlatformPublicKeyCredentialAssertion`    | `signature`, `authenticatorData` | 验证已有 Passkey |

```swift
// 注册场景 - 创建新凭证
if let reg = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialRegistration {
    // 包含证明对象，用于服务器验证设备的合法性
    "attestationObject": b64url(reg.rawAttestationObject)
}

// 登录场景 - 验证已有凭证
if let asr = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialAssertion {
    // 包含签名数据，用于服务器验证用户身份
    "signature": b64url(asr.signature),
    "authenticatorData": b64url(asr.rawAuthenticatorData),
    "userHandle": b64url(asr.userID)
}
```

**4. b64url 函数的作用**

```swift
// 将 iOS 系统的 Data 对象转换为 WebAuthn 标准的 Base64URL 格式
func b64url(_ data: Data?) -> String {
    guard let data = data else { return "" }

    return data.base64EncodedString()
        .replacingOccurrences(of: "+", with: "-")
        .replacingOccurrences(of: "/", with: "_")
        .replacingOccurrences(of: "=", with: "")
}

// 使用示例
let credentialId = reg.credentialID                    // Data
let base64urlId = b64url(credentialId)                // Base64URL String
// "dXNlcjEyMw" （URL 安全的编码格式）
```

**5. 错误处理的层次**

```swift
// 层次1：版本兼容性错误
if #available(iOS 16.0, *) {
    // 支持的版本
} else {
    callback?(toJSON(["ok": false, "errMsg": "iOS 16+ required"]))
}

// 层次2：凭证类型错误
if let reg = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialRegistration {
    // 已知类型
} else {
    callback?(toJSON(["ok": false, "errMsg": "unsupported credential type"]))
}

// 层次3：系统级错误（在 didCompleteWithError 中处理）
func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
    callback?(toJSON(["ok": false, "errMsg": error.localizedDescription]))
}
```

#### presentationContextProvider 的作用

```swift
// 提供显示认证界面的窗口
extension PasskeysManager: ASAuthorizationControllerPresentationContextProviding {

    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
        // 返回当前活跃的窗口
        return UIApplication.shared.windows.first { $0.isKeyWindow } ?? UIWindow()
    }
}
```

### 5. performRequests() 执行

```swift
controller.performRequests()
```

**方法作用**：

- 启动整个认证流程
- 这是一个 **异步方法**，会立即返回
- 实际的认证结果通过 delegate 方法返回

## 完整的数据流转过程

### 输入数据（来自前端/服务器）

```swift
// 1. 前端发送 JSON 字符串
let optionsJson = """
{
    "rp": {
        "id": "example.com",
        "name": "Example Corp"
    },
    "user": {
        "id": "dXNlcjEyMw==",
        "name": "alice@example.com",
        "displayName": "Alice Smith"
    },
    "challenge": "Y2hhbGxlbmdl",
    "pubKeyCredParams": [
        {"type": "public-key", "alg": -7}
    ]
}
"""
```

### 数据解析与转换

```swift
// 2. 解析 JSON
guard let data = optionsJson.data(using: .utf8),
      let options = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
      let rp = options["rp"] as? [String: Any],
      let rpId = rp["id"] as? String,
      let user = options["user"] as? [String: Any],
      let userIdB64 = user["id"] as? String,
      let userName = user["name"] as? String,
      let challengeB64 = options["challenge"] as? String else {
    return
}

// 3. Base64URL 解码
let challengeData = fromB64url(challengeB64)  // "Y2hhbGxlbmdl" → <challenge bytes>
let userIdData = fromB64url(userIdB64)        // "dXNlcjEyMw==" → <user123 bytes>
```

### 系统 API 调用

```swift
// 4. 创建系统对象
let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)
let request = provider.createCredentialRegistrationRequest(
    challenge: challengeData,    // Data 类型
    name: userName,              // "alice@example.com"
    userID: userIdData          // Data 类型
)

// 5. 配置并执行
let controller = ASAuthorizationController(authorizationRequests: [request])
controller.delegate = self
controller.presentationContextProvider = self
controller.performRequests()  // 异步执行
```

### 输出数据（返回给前端）

```swift
// 6. 在 delegate 方法中处理结果
func authorizationController(controller: ASAuthorizationController,
                           didCompleteWithAuthorization authorization: ASAuthorization) {

    if let credential = authorization.credential as? ASAuthorizationPlatformPublicKeyCredentialRegistration {

        // 提取系统返回的数据
        let credentialId = credential.credentialID                    // Data
        let attestationObject = credential.rawAttestationObject       // Data?
        let clientDataJSON = credential.rawClientDataJSON            // Data

        // 转换为前端期望的格式
        let response = [
            "ok": true,
            "id": credentialId.base64EncodedString(),                           // Data → Base64
            "rawId": credentialId.base64EncodedString(),                        // Data → Base64
            "type": "public-key",
            "response": [
                "attestationObject": attestationObject?.base64EncodedString() ?? "",  // Data → Base64
                "clientDataJSON": clientDataJSON.base64EncodedString()                // Data → Base64
            ]
        ]

        // 返回 JSON 字符串
        callback?(toJSON(response))
    }
}
```

## 常见问题与注意事项

### 1. iOS 版本兼容性

```swift
// Passkeys 需要 iOS 16+
@available(iOS 16.0, *)
func createPasskey() {
    let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(relyingPartyIdentifier: rpId)
    // ...
}

// 版本检查
if #available(iOS 16.0, *) {
    createPasskey()
} else {
    callback?(toJSON(["ok": false, "errMsg": "iOS 16+ required"]))
}
```

### 2. 错误处理

```swift
// 常见错误类型
func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
    let errorMessage: String

    if let authError = error as? ASAuthorizationError {
        switch authError.code {
        case .canceled:
            errorMessage = "用户取消了认证"
        case .invalidResponse:
            errorMessage = "无效的响应"
        case .notHandled:
            errorMessage = "认证未处理"
        case .failed:
            errorMessage = "认证失败"
        default:
            errorMessage = "未知错误: \(error.localizedDescription)"
        }
    } else {
        errorMessage = error.localizedDescription
    }

    callback?(toJSON(["ok": false, "errMsg": errorMessage]))
}
```

### 3. 内存管理

```swift
// 避免循环引用
class PasskeysManager {
    private var callback: ((String) -> Void)?

    func register(_ options: String, _ cb: @escaping (String) -> Void) {
        self.callback = cb
        // ... 执行认证
    }

    // 在 delegate 方法中清理回调
    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
        // 处理结果
        callback?(result)
        callback = nil  // 重要：清理引用
    }
}
```

## 小结

- **系统 API 调用**遵循：Provider → Request → Controller → Execute 的模式
- **数据转换**是关键：Base64URL ↔ Data ↔ 系统对象
- **异步处理**：通过 delegate 模式处理结果
- **错误处理**：统一的错误模型和版本兼容性检查
- **内存管理**：及时清理回调引用，避免内存泄漏

这种模式在 iOS 开发中极其常见，掌握了这个流程，你就能轻松调用其他系统 API！
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文多发怎么做？我帮你把坑都踩完了（VitePress 博客 → CSDN/知乎/掘金…）]]></title>
        <id>https://herongdev.github.io/blog/posts/平台与博客/一文多发怎么做？我帮你把坑都踩完了（VitePress 博客 → CSDN-知乎-掘金…）</id>
        <link href="https://herongdev.github.io/blog/posts/平台与博客/一文多发怎么做？我帮你把坑都踩完了（VitePress 博客 → CSDN-知乎-掘金…）"/>
        <updated>2025-09-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## TL;DR

- 想省时：用 **OpenWrite** 这类一键分发平台，Markdown 写一次，多平台同步（含 CSDN/知乎/掘金/公众号等）。([openwrite.cn][1])
- 想更可控、可私有：用 **ArtiPub**（开源）本地/服务器跑，提供 CLI 与 API，自动把文章发到多平台。([artipub.github.io][2])
- 只想解决「格式兼容」：用 **mdnice** 一键把 Markdown 转成各平台友好排版，再手动/半自动粘贴。([product.mdnice.com][3])
- 浏览器侧"抓取 → 同步"：用 **Wechatsync**（文章同步助手）把现有页面/Markdown 互转并同步到多平台。([GitHub][4])

> 合规提醒：部分平台对自动化发布有限制（如公众号 API 面向企业认证；CSDN 禁止滥用自动化发布），务必遵守各站规则。([CSDN 博客][5])

---

## 适合你的三种路线

### 1) SaaS 省心路线（最低心智负担）

**OpenWrite**：多平台文章发布工具，支持 Markdown 编辑，一键分发到 CSDN、知乎、掘金、公众号等。

- 特点：一次配置账号与渠道，后续可批量分发；适合你当前的"把 VitePress 的文章同步出去"的诉求。([openwrite.cn][1])
- 常见搭配：本地用 VSCode/Typora 写作 → OpenWrite 分发；图片用图床（Gitee/GitHub/七牛等）避免各站重复上传。([博客园][6])
- 注意：不同平台的栏目/话题需在渠道配置里预设好，偶尔会遇到"专栏不匹配需调整"的体验问题。([CSDN 博客][7])

可替/补充方案：市面也有"蚁小二/融媒宝/易媒助手"等分发工具，定位偏自媒体矩阵，功能更重（团队/数据/审核），做技术内容也能用。([CSDN 博客][8])

---

### 2) 自建可控路线（更灵活、可脚本化）

**ArtiPub（开源）**：支持"一文多发"，有 **CLI/SDK**，能发往 CSDN/SegmentFault/简书/知乎/掘金/开源中国等技术平台；适合放到你的构建流程或服务器上自动跑。([CSDN 博客][9])

- 场景：你用 VitePress 管理 Markdown；Git 提交后触发脚本，按平台差异做少量转换，然后调用 ArtiPub CLI 一次性发布。([artipub.github.io][2])
- 好处：可版本化、可审计、可与你的"发版流水线/定时任务"衔接；不开外部 SaaS 也能跑。
- 参考生态：还有一些自动发文工具/仓库可借鉴实现（支持 CSDN/知乎/头条/掘金/公众号等）。([GitHub][10])

> 风险与合规：对**没有公开接口**或风控严格的平台（如知乎、公众号个人主体），往往要走"浏览器自动化/扩展注入"思路，需谨慎以免触犯平台规则。([CSDN 博客][5])

---

### 3) 半自动排版路线（最稳妥、兼容最好）

**mdnice（墨滴）**：Markdown → 多平台友好排版，一键复制到 **公众号/知乎/掘金/博客园/CSDN** 等。

- 你仍然写一次 Markdown，但发布时只需：打开 mdnice → 选择平台模板 → 复制粘贴过去。适合对"排版一致性"和"所见即所得"有要求的技术博客。([product.mdnice.com][3])
- 可与 Wechatsync 组合：mdnice 解决格式，Wechatsync 负责把整理好的文稿推到多个站点。([微信公众号同步助手][11])

---

## 平台差异与发布要点清单

- **CSDN**：良好支持 Markdown，但注意代码高亮与图片尺寸；遵守其自动化使用规范。([CSDN 博客][5])
- **知乎专栏**：不提供公开发布 API，最稳的是"格式转换后人工或扩展半自动发布"。([GitHub][4])
- **微信公众号**：官方 API 基本面向**企业认证**账号；个人号走第三方/自动化风险较高。([CSDN 博客][5])
- **图片与图床**：建议统一托管（如 Gitee/GitHub/云存储），写作时即生成 CDN 链接，减少"每个平台重新传图"的成本。([博客园][6])

---

## 针对你用 VitePress 的落地流程（推荐）

1. **仓库组织**：在 `docs/` 下维护 Markdown 与 Front-matter（保留 `title/description/tags/date`）。
2. **图片策略**：接入 PicGo → Gitee/GitHub/云存储图床，确保全平台可直接引用。([博客园][6])
3. **格式适配**：

   - 代码块使用三引号并标注语言（便于 CSDN/掘金高亮）。
   - 文章尾部添加**"首发于…，本篇为同步"**与**原文链接**，避免 SEO 重复内容问题（各平台也更尊重"首发+同步"表述）。

4. **分发工具**（三选一或组合）：

   - **OpenWrite**：最省事，账号渠道配置好后，一键分发。([openwrite.cn][1])
   - **ArtiPub**：把 CLI 接到你的 CI（push 到 `main` 分支触发），自动发到技术社区平台。([artipub.github.io][2])
   - **mdnice +（可选）Wechatsync**：先一键排版，再半自动分发到知乎/公众号等。([product.mdnice.com][3])

5. **灰度发布**：先同步到 1–2 个站点校验排版/代码高亮/图片，再全量发。
6. **数据回收**：优先使用分发平台自带的数据面板；若无，可在各站设置"统一 UTM 参数"（例如 `?utm_source=csdn`）来区分流量来源（CSDN/知乎等都支持外链参数）。

---

## 你可能会关心的问题（FAQ）

**Q1：知乎、公众号为什么总是最麻烦？**
A：它们没有稳定面向个人的开放发布 API，且风控严格；因此**格式转换 + 半自动发布**是更稳的实践。([CSDN 博客][5])

**Q2：完全免费的方案？**
A：**ArtiPub（开源）** + 你自己的 CI/脚本；或 **mdnice（免费版）** + 手动/半自动粘贴。功能全面的一键分发 SaaS 往往会有会员功能，但能显著省时。([artipub.github.io][2])

**Q3：有没有现成的"从公众号/网页 → 多平台"的工具？**
A：**Wechatsync** 支持"任意网页提取正文并同步"，也支持 Markdown 同步到多平台，用起来比较灵活。([微信公众号同步助手][11])

---

## 快速对比（给你选型）

| 方案               | 上手成本 | 自动化程度           | 适配平台广度                    | 风险与限制                                                    |
| ------------------ | -------- | -------------------- | ------------------------------- | ------------------------------------------------------------- |
| OpenWrite（SaaS）  | 低       | 高                   | 广（含 CSDN/知乎/掘金/公众号…） | 需信任第三方；个别平台配置较"死板"需手调。([openwrite.cn][1]) |
| ArtiPub（开源）    | 中       | 高（接 CI）          | 技术社区平台覆盖好              | 个别平台无 API 需回退到半自动。([artipub.github.io][2])       |
| mdnice（排版）     | 很低     | 低（复制粘贴）       | 多平台排版模板                  | 需要手动提交；但排版最稳。([product.mdnice.com][3])           |
| Wechatsync（扩展） | 低       | 中（浏览器内半自动） | 多平台"互同步"                  | 依赖浏览器/登录态；注意合规。([GitHub][4])                    |

---

## 给你的"最省时"推荐

- **首选**：OpenWrite 做主分发；VitePress 里保持 Markdown 规范与统一图床，周更/日更直接一键发。([openwrite.cn][1])
- **补充**：碰到"格式挑剔"的平台（知乎/公众号）时，用 mdnice 套模板后再发，保证观感统一。([product.mdnice.com][3])
- **升级**：如果你想把它**完全并入工程化流水线**（比如 commit 后自动发），就接 **ArtiPub CLI** 到 CI。([artipub.github.io][2])

---

如果你愿意，我可以基于你当前的 VitePress 目录结构，给出一份**"最小自动化脚本 + 发布说明模板"**（遵循你"只提供必要改动代码、复杂逻辑行上加注释"的规范），把这套流程直接落到仓库里。

[1]: https://openwrite.cn/?utm_source=chatgpt.com "OpenWrite: 多平台文章发布工具"
[2]: https://artipub.github.io/artipub/?utm_source=chatgpt.com "artipub | VitePress"
[3]: https://product.mdnice.com/?utm_source=chatgpt.com "墨滴软件-mdnice"
[4]: https://github.com/wechatsync/Wechatsync?utm_source=chatgpt.com "wechatsync/Wechatsync: 一键同步文章到多个内容平台 ..."
[5]: https://blog.csdn.net/Fx_demon/article/details/145961214?utm_source=chatgpt.com "如何将文章一键发布到CSDN、 微信公众号等博客的详细方案"
[6]: https://www.cnblogs.com/leovany/p/17691019.html?utm_source=chatgpt.com "一键发布多平台方案- Leovany"
[7]: https://blog.csdn.net/qq_45495857/article/details/106206239?utm_source=chatgpt.com "OpenWrite(博客群发平台)到底好不好用，有什么缺点？ 原创"
[8]: https://blog.csdn.net/qq_43664361/article/details/142516870?utm_source=chatgpt.com "推荐一个一键多平台发布文章的工具_小明来客"
[9]: https://blog.csdn.net/juemuren444/article/details/104717386?utm_source=chatgpt.com "一文多发神器--ArtiPub&OpenWrite 原创"
[10]: https://github.com/ddean2009/blog-auto-publishing-tools?utm_source=chatgpt.com "ddean2009/blog-auto-publishing-tools: 博客自动发布工具"
[11]: https://www.wechatsync.com/?utm_source=chatgpt.com "微信公众号同步助手- 公众号文章多平台同步Typora Markdown ..."
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web Push 推送简介]]></title>
        <id>https://herongdev.github.io/blog/posts/Web-API-与推送/Web-Push/Web-Push-推送简介</id>
        <link href="https://herongdev.github.io/blog/posts/Web-API-与推送/Web-Push/Web-Push-推送简介"/>
        <updated>2025-09-05T14:10:59.000Z</updated>
        <content type="html"><![CDATA[
---

title: Web Push 推送简介
date: 2025-09-05
categories: \[Web 实时通讯, 浏览器推送]
tags: \[Web Push, Service Worker, PWA, VAPID, 离线通知, 实时消息]
description: 全面介绍 Web Push 技术的原理、特点、实现步骤和典型应用场景，帮助前端/全栈开发者理解并快速落地。

---

# 什么是 Web Push？

**Web Push** 是浏览器层面的 **推送通知机制**。与 WebSocket 或 SSE 不同，它不依赖页面是否处于前台，甚至用户没有打开网页也能收到通知。核心依赖：

- **Service Worker**：浏览器的后台脚本，常驻运行。
- **Push API**：浏览器与推送服务（FCM、APNs 等）之间的推送通道。
- **Notification API**：展示系统级通知。

特点：

- **跨平台**：Chrome、Firefox、Edge、Safari（部分版本）均支持。
- **后台可达**：即使网页未激活或浏览器最小化也能收到。
- **需用户授权**：必须 HTTPS，且用户点击“允许通知”。
- **带有身份机制**：通过 VAPID（Voluntary Application Server Identification for Web Push）实现应用级认证。

---

# 工作流程

```mermaid
sequenceDiagram
  participant User as 用户浏览器
  participant SW as Service Worker
  participant PushSrv as 浏览器厂商推送服务(FCM等)
  participant Server as 应用服务端

  User->>Server: 注册并获取 VAPID 公钥
  User->>SW: 注册 Service Worker
  User->>PushSrv: 订阅推送 (PushSubscription)
  User->>Server: 上报订阅信息 (endpoint+keys)

  Server->>PushSrv: 使用 VAPID 私钥加密并发送消息
  PushSrv->>SW: 转发推送
  SW->>User: Notification API 展示通知
```

---

# 核心实现步骤

## 1. 生成 VAPID 密钥对

```bash
npx web-push generate-vapid-keys
```

会得到 **公钥 / 私钥**，公钥发给前端，私钥保存在服务端。

---

## 2. 前端注册 Service Worker

```js
const reg = await navigator.serviceWorker.register("/sw.js");

// 申请通知权限
const permission = await Notification.requestPermission();
if (permission === "granted") {
  // 订阅推送
  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: "<VAPID_PUBLIC_KEY_BASE64URL>",
  });
  // 上报给服务端保存
  await fetch("/push/subscribe", { method: "POST", body: JSON.stringify(sub) });
}
```

---

## 3. Service Worker 处理推送

```js
// sw.js
self.addEventListener("push", (event) => {
  const data = event.data?.json() ?? {};
  event.waitUntil(
    self.registration.showNotification(data.title || "通知", {
      body: data.body,
      icon: "/icon.png",
    })
  );
});
```

---

## 4. 服务端发送推送

以 Node.js 为例：

```js
import webpush from "web-push";

// 设置 VAPID
webpush.setVapidDetails(
  "mailto:admin@example.com",
  process.env.VAPID_PUBLIC,
  process.env.VAPID_PRIVATE
);

// subs 存储用户的 PushSubscription
export async function sendPush(sub, payload) {
  await webpush.sendNotification(sub, JSON.stringify(payload));
}
```

---

# 典型应用场景

- **消息提醒**：聊天应用收到新消息。
- **电商营销**：用户未登录页面也能收到促销信息。
- **系统告警**：后台监控推送紧急故障。
- **PWA（渐进式 Web 应用）**：接近原生 App 的体验。

---

# 优缺点对比

✅ 优点：

- 浏览器级支持，后台可达。
- 无需页面常驻，适合通知类消息。
- 跨浏览器标准（W3C Push API）。

⚠️ 缺点：

- 依赖用户同意，存在拒绝率。
- Safari 支持有限制（macOS 较晚才全面支持）。
- 消息大小有限制（通常 4KB）。
- 不适合大流量/高频推送（需 WebSocket/SSE）。

---

# 小结

**Web Push** = **Service Worker + Push API + Notification API**
适合“提醒/通知”类场景，不适合实时高频通信。生产实践里常和 **WebSocket/SSE** 组合：

- **WebSocket**：前台实时互动。
- **Web Push**：后台/离线通知兜底。

---

要不要我帮你写一个 **完整的最小 Web Push DEMO 项目（前端+后端）**，可以直接跑通并测试浏览器推送？
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OAID 库的初始化与获取]]></title>
        <id>https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取</id>
        <link href="https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/OAID-库的初始化与获取"/>
        <updated>2025-09-07T15:44:21.000Z</updated>
        <content type="html"><![CDATA[
# 一、国内主流 OAID 获取的两条路线

1. **MSA 官方 SDK（闭源）**

- 由“移动安全联盟/CAICT”提供。接入要放 `oaid_sdk_x.x.x.aar`（或早期 `miit_mdid_x.x.x.aar`）、`supplierconfig.json`、证书（`xxx.cert.pem`），并**先加载安全库**再 `MdidSdkHelper.InitSdk(...)` 获取 OAID。常见混淆与加载问题官方 FAQ 也有说明。([百度移动统计][1], [网站名称][2])

2. **开源聚合库（Android_CN_OAID）**

- 由 gzu-liyujiang 提供，统一封装**各厂商 OAID + 海外 AAID + 多种替代 ID**（AndroidID/WidevineID/GUID 等），API 友好。常用入口：`DeviceIdentifier.register(app)` 预取，或者 `DeviceID.getOAID(context, IGetter)` 异步获取。([李宇江的个人网站][3])

> 额外：**华为设备**可直接通过 **HMS Ads Identifier** 获取 OAID（`AdvertisingIdClient.getAdvertisingIdInfo(context).getId()`），不依赖 MSA（很多三方 SDK 文档也这样说明）。([华为开发者][4], [Adjust][5])

---

# 二、你的两个 UTS 插件实际做法（我已解包查看）

- **`android-deviceid`**（UTS for Android）

  - 直接 `import com.github.gzuliyujiang.oaid.*`，调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!)` 进行预取；随后通过接口把结果回调出去。
  - 插件内还自带 **华为 HMS ads-identifier AAR**（`ads-identifier-*.aar`），作为获取 OAID 的华为路径支撑。
  - 这是一个\*\*标准的“开源聚合库 + （可选）HMS”\*\*实现范式。

  片段（来自 `utssdk/app-android/index.uts`）：

  ```ts
  import DeviceIdentifier from "com.github.gzuliyujiang.oaid.DeviceIdentifier";
  export const register = function () {
    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);
  };
  ```

  （随后通过自定义 `MyListener implements IDManger.OnIOAIDListener` 回传 JSON 结果）

- **`zws-uniqueid`**

  - 不取 OAID，仅根据 `android.os.Build` 若干字段计算 `MD5` 作为**伪标识**（PseudoID），没有广告/合规可重置特性，仅能用于弱追踪/灰度分配等**非广告**用途。

---

# 三、初始化 & 获取：可直接抄的代码片段库

## 方案 A：开源 Android_CN_OAID（推荐起步用）

**初始化（建议在用户同意隐私后再调用）**

```kotlin
// Application.onCreate 或隐私同意后
DeviceIdentifier.register(application)  // 预取 clientId/OAID
```

**获取 OAID（两种）**

- 同步拿预取结果（需先 register）：

  ```kotlin
  val oaid = DeviceID.getOAID()  // 若未预取会为空
  ```

- 异步获取（不需要 register）：

  ```kotlin
  DeviceID.getOAID(context, object : IGetter {
      override fun onOAIDGetComplete(result: String) { /* result 即 OAID */ }
      override fun onOAIDGetError(error: Exception) { /* 失败或不支持 */ }
  })
  ```

这些方法签名、时机说明都在官方 javadoc 文档中有清晰描述：`register(...)` 预取、`getOAID(...)` 异步、`supportedOAID(context)` 判断支持性、以及 `getGUID`、`getAndroidID` 等替代项。([李宇江的个人网站][6])

> **优点**：开源、快速落地；**缺点**：在个别厂商/系统组合上获取率可能不如官方 MSA；不过开源库会优先尝试 HMS、厂商通道，整体覆盖度已较好。([李宇江的个人网站][3])

## 方案 B：MSA 官方 SDK（企业/上量后建议切换或并行）

**准备**

- `oaid_sdk_x.x.x.aar` 放 `libs/`
- `supplierconfig.json`、`<package>.cert.pem` 放 `assets/`
- Proguard：`-keep class com.bun.miitmdid.core.** { *; }`
- **在 Init 前加载安全库**（不同版本库名可能不同，如 `msaoaidsec` 或文档示例里的 nllvm 加固库名），否则会出现 `No implementation found for ... InitCert` 之类错误。([百度移动统计][1], [网站名称][2])

**初始化 & 获取**

```java
// 1) （可选但推荐）在 Application.onCreate 尝试加载安全库
try { System.loadLibrary("msaoaidsec"); } catch(Throwable ignore) {}

// 2) 在合适时机发起初始化与获取（不要在主线程里做耗时 I/O）
MdidSdkHelper.InitSdk(
  context.getApplicationContext(),
  /* isCert = */ true,
  new IIdentifierListener() {
    @Override public void onSupport(IdSupplier supplier) {
      if (supplier != null) {
        String oaid = supplier.getOAID();
        // supplier.isSupported() / isLimited() 等也可读
      }
    }
  }
);
```

上面这段 init 与回调写法，在各家第三方接入文档里都是类似范式（百度统计、Adjust、AppsFlyer 等均说明“MSA 或 HMS”两路径），并给出了混淆、AAR、`supplierconfig.json` 的标准放置方法。([百度移动统计][1], [Adjust][5], [AppsFlyer 支持中心][7])

## 方案 C：华为设备走 HMS（若接入了 HMS Core）

```java
// 不依赖 MSA，在华为设备上直接拿 OAID
AdvertisingIdClient.Info info =
    com.huawei.hms.ads.identifier.AdvertisingIdClient.getAdvertisingIdInfo(context);
String oaid = info.getId();
// info.isLimitAdTrackingEnabled() 可读 “限制个性化广告” 状态
```

HMS 文档对 OAID / Identifier Service 的 API 有明确说明。([华为开发者][4])

---

# 四、UTS（uni-app x）里的**最佳实践**总方案

> 目标：**一个 API 跨 H5 / Android**，Android 侧**优先 MSA/HMS**，没有则回退到 **Android_CN_OAID**，最后再降级 **AndroidID / GUID**；且**必须在取得隐私同意后**再初始化与获取。

### 1) API 设计（简洁且可扩展）

```ts
// /uni_modules/uaid-kit/utssdk/index.uts
export type UaidInfo = {
  oaid: string | null;
  source: "MSA" | "HMS" | "GZU" | "NONE";
  limitAdTracking?: boolean | null;
  aaid?: string | null; // 海外广告标识，未来可补
  androidId?: string | null; // 回退项
  guid?: string | null; // 本地持久 GUID（Web/低版本回退）
};

export function initAfterConsent(): void;
export function getUaid(callback: (info: UaidInfo) => void): void;
```

### 2) UTS 源码（**可直接用**；Android + Web 双端）

> 说明：
>
> - **MSA** 部分需要你把 `oaid_sdk_x.x.x.aar` 放到 `utssdk/app-android/libs/`，并在 `manifest.json` 勾选 UTS 插件；否则请把 `// MSA 可选块` 注释掉再编译。
> - **HMS** 部分需要 `ads-identifier` 依赖；没有就留开源库/回退路径。
> - Web 端只能**生成/持久化 GUID**，OAID 是 Android 概念。

```ts
// /uni_modules/uaid-kit/utssdk/app-android/index.uts
// #ifdef APP-ANDROID
import Context from "android.content.Context";
import Application from "android.app.Application";
import System from "java.lang.System";

// 开源库（gzu-liyujiang）
import DeviceIdentifier from "com.github.gzuliyujiang.oaid.DeviceIdentifier";
import DeviceID from "com.github.gzuliyujiang.oaid.DeviceID";
import IGetter from "com.github.gzuliyujiang.oaid.IGetter";

// HMS（若集成）
import AdvertisingIdClient from "com.huawei.hms.ads.identifier.AdvertisingIdClient";

// MSA（若集成了 AAR，否则请注释下一行两行以及使用处）
import MdidSdkHelper from "com.bun.miitmdid.core.MdidSdkHelper";
import IIdentifierListener from "com.bun.miitmdid.interfaces.IIdentifierListener";
import IdSupplier from "com.bun.miitmdid.interfaces.IdSupplier";
// #endif

// #ifdef H5
import { ref } from "vue";
// #endif

export type UaidInfo = {
  oaid: string | null;
  source: "MSA" | "HMS" | "GZU" | "NONE";
  limitAdTracking?: boolean | null;
  aaid?: string | null;
  androidId?: string | null;
  guid?: string | null;
};

export function initAfterConsent(): void {
  // #ifdef APP-ANDROID
  try {
    // 优先预取开源库的 clientId/OAID
    DeviceIdentifier.register(
      UTSAndroid.getUniActivity()!!.getApplication()!! as Application
    );
  } catch (e) {}

  // （可选）若你计划走 MSA，尽早加载安全库，避免 InitCert 报错
  try {
    System.loadLibrary("msaoaidsec");
  } catch (e) {}
  // #endif
  // #ifdef H5
  // nothing
  // #endif
}

function buildGuid(): string {
  // 128bit GUID，H5/Android 均可用，H5 存 localStorage 即可
  const s = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  return s.replace(/[xy]/g, (c) => {
    const r = (Math.floor(Math.random() * 16) as number) & 0xf;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

export function getUaid(cb: (info: UaidInfo) => void): void {
  // #ifdef APP-ANDROID
  const ctx = UTSAndroid.getUniActivity()!! as Context;

  // 1) 尝试 HMS（若集成）
  try {
    const info = AdvertisingIdClient.getAdvertisingIdInfo(ctx);
    const id = info.getId();
    if (id) {
      cb({
        oaid: id,
        source: "HMS",
        limitAdTracking: info.isLimitAdTrackingEnabled(),
      });
      return;
    }
  } catch (e) {
    /* ignore */
  }

  // 2) 尝试 MSA 官方（若集成了 AAR）
  try {
    MdidSdkHelper.InitSdk(
      ctx,
      true,
      new (class implements IIdentifierListener {
        override onSupport(supplier: IdSupplier | null) {
          if (supplier != null && supplier.getOAID() != null) {
            cb({ oaid: supplier.getOAID(), source: "MSA" });
          } else {
            // 3) 回退：开源库异步
            DeviceID.getOAID(
              ctx,
              new (class implements IGetter {
                override onOAIDGetComplete(result: string) {
                  cb({ oaid: result, source: "GZU" });
                }
                override onOAIDGetError(err: any) {
                  const androidId = DeviceID.getAndroidID(ctx);
                  cb({ oaid: null, source: "NONE", androidId });
                }
              })()
            );
          }
        }
      })()
    );
    return;
  } catch (e) {
    // 没集成 MSA 或运行异常，继续走开源库回退
  }

  // 3) 开源库异步（无预取也能用）
  DeviceID.getOAID(
    ctx,
    new (class implements IGetter {
      override onOAIDGetComplete(result: string) {
        cb({ oaid: result, source: "GZU" });
      }
      override onOAIDGetError(err: any) {
        const androidId = DeviceID.getAndroidID(ctx);
        cb({ oaid: null, source: "NONE", androidId });
      }
    })()
  );
  // #endif

  // #ifdef H5
  try {
    let guid = uni.getStorageSync("UAID_GUID") as string;
    if (!guid) {
      guid = buildGuid();
      uni.setStorageSync("UAID_GUID", guid);
    }
    cb({ oaid: null, source: "NONE", guid });
  } catch (e) {
    cb({ oaid: null, source: "NONE", guid: buildGuid() });
  }
  // #endif
}
```

**混淆/配置建议（Android）**

- 若启用 **MSA**：

  ```
  -keep class com.bun.miitmdid.core.** { *; }
  ```

  同时把 `oaid_sdk_x.x.x.aar`、`supplierconfig.json`、`<pkg>.cert.pem` 放到对应目录（AAR: `libs/`，其余在 `assets/`）。初始化前加载安全库，避免 `InitCert` 报错。([百度移动统计][1], [网站名称][2])

- 若启用 **HMS**：确保引入 `com.huawei.hms:ads-identifier`（你现有 `android-deviceid` 插件已内置两个 ads-identifier AAR）。华为 OAID API 文档参考。([华为开发者][4])
- 若只用**开源库**：不需要证书，按上面 `DeviceID` / `DeviceIdentifier` 的调用即可（方法签名见官方 javadoc）。([李宇江的个人网站][6])

**隐私合规关键点**

- **必须在用户同意隐私政策后**再 `initAfterConsent()`；开源库文档也特别提示 register/获取前需获同意。([李宇江的个人网站][6])

---

# 五、再回答你“原来的插件中如何实现”的要点

- 你的 **`android-deviceid`** 正是采用**开源库（Android_CN_OAID）+（可选）HMS**的组合：

  - 预取：`DeviceIdentifier.register(...)`
  - 异步获取：`DeviceID.getOAID(context, IGetter)`
  - 附带 ad-identifier AAR，完善华为路径

  > 这与文档推荐用法一致（register 预取、或异步获取；支持 `supportedOAID` 检查）。([李宇江的个人网站][6])

- 你的 **`zws-uniqueid`** 只是**伪 ID**（基于 `Build.*` 拼接+MD5），**不属于 OAID**，适合作兜底标识，不可用于广告归因。

---

# 六、为什么推荐“先开源库 → 再视需要加 MSA/HMS”

- **落地速度**：开源库无证书/厂商注册门槛，上线快；API 稳定，文档完整（还有 `GUID/AndroidID` 兜底）。([李宇江的个人网站][3])
- **兼容与获取率**：有华为设备时可直接走 **HMS OAID**；大盘上量/商业化合规要求更高时，再**并行接入 MSA** 提升部分机型覆盖率。([华为开发者][4], [Adjust][5])
- **合规**：始终把 OAID 获取放在**隐私同意之后**。([李宇江的个人网站][6])

---

## 附：权威/一手资料（便于你对照）

- Android_CN_OAID 文档（`DeviceID.register/getOAID/supportedOAID/...` 方法签名）([李宇江的个人网站][6])
- Android_CN_OAID 项目主页/文档导航（含包结构/实现原理）([李宇江的个人网站][3])
- MSA 官方接入说明（AAR、`supplierconfig.json`、混淆、加载安全库/InitCert 问题）([百度移动统计][1], [网站名称][2])
- Adjust / AppsFlyer 对 OAID 的总述与“MSA 或 HMS”两条路径的明确表述（帮助理解生态）([Adjust][5], [AppsFlyer 支持中心][7])
- 华为 HMS Ads Identifier OAID 能力文档（API 参考）([华为开发者][4])

---

如果你同意这套方案，我可以把上面的 **UTS 插件源码**按你项目结构打包成 `uni_modules/uaid-kit`（含 `package.json`、`utssdk/app-android/config.json`、`README.md`、示例页），并给出在 **uni-app x** 项目里如何调用的示例页（含隐私弹窗 → 同意后初始化 → 展示结果）的完整代码。

[1]: https://mtj.baidu.com/static/userguide/book/android/oaid.html?utm_source=chatgpt.com "Android OAID 接入"
[2]: https://16054554.s21i.faiusr.com/61/ABUIABA9GAAgx5iGjgYo2_j-1AE.pdf?utm_source=chatgpt.com "常见问题问答F&Q - 信息资源系统"
[3]: https://gzu-liyujiang.github.io/Android_CN_OAID/?utm_source=chatgpt.com ":library"
[4]: https://developer.huawei.com/consumer/en/doc/hmscore-references/overview-0000001050066887?utm_source=chatgpt.com "Overview-com.huawei.hms.ads.identifier-Android-Java- ..."
[5]: https://dev.adjust.com/zh/sdk/android/plugins/oaid-plugin/?utm_source=chatgpt.com "OAID"
[6]: https://gzu-liyujiang.github.io/Android_CN_OAID/com/github/gzuliyujiang/oaid/DeviceID.html "DeviceID "
[7]: https://support.appsflyer.com/hc/en-us/articles/360006278797-Android-OAID-implementation-in-the-SDK?utm_source=chatgpt.com "Android OAID implementation in the SDK"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[id-kit]]></title>
        <id>https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit</id>
        <link href="https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit"/>
        <updated>2025-09-07T12:35:03.000Z</updated>
        <content type="html"><![CDATA[
棒～这个方向很实用。按你的节奏来：**先取名 → 再讲实现思路 → 之后我们再一步步落地**。

---

## 先取个名字（我给你几个风格不同的备选）

**强推：`UniIdKit`（中文：一体设备 ID 工具包）**

- 简洁、易记、和 uni-app 生态贴合（Uni 前缀）。
- “Kit” 体现工具集合的定位（OAID/AAID/AndroidID/GUID…聚合）。

其它好选项（任选其一也行）：

- `UniDeviceID`（直白、上手即懂）
- `IdFusion` / 中文：ID 融合（强调多源融合）
- `OmniIdKit` / 中文：全域 ID 工具包（强调覆盖广泛）
- `SignalID` / 中文：设备信标（更“概念化”，偏品牌感）

> 没有特别诉求的话，我后续以 **`UniIdKit`** 为默认名继续讲实现与代码。

---

## 实现思路（先把“大图”画清楚）

### 1) 目标与边界

- **平台覆盖**：Android（App-Plus 原生）、iOS（可选：IDFV）、H5（本地持久 GUID）。
- **能力聚合**：OAID、AAID、AndroidID、（可选）IMEI/MEID、WidevineID、PseudoID、GUID。
- **合规优先**：

  - 默认**不采集强隐私**（如 IMEI），需**显式同意**与**动态权限**才允许。
  - 提供**哈希化输出**（SHA-256）选项，避免直传原始标识。
  - 尊重系统/用户“广告追踪限制”（AAID/OAID 可能返回空或受限标志）。

### 2) 能力分层（便于维护与扩展）

```
UniIdKit（JS/TS 封装与 API ）
 ├─ ConsentManager（隐私同意、选项管理、状态缓存）
 ├─ CacheLayer（本地缓存：uni.storage / iOS Keychain / Android MMKV）
 ├─ Aggregator（聚合各 Adapter 的结果、去重、优先级策略、哈希化）
 └─ Adapters
     ├─ Android:
     │   ├─ OAIDAdapter（MSA SDK）
     │   ├─ AAIDAdapter（Google Play 服务）
     │   ├─ AndroidIdAdapter（SSAID）
     │   ├─ WidevineIdAdapter（DRM ID，有些机型/ROM可能不可用）
     │   ├─ PseudoIdAdapter（Build 信息拼接的伪 ID，稳定性一般）
     │   └─ IMEI/MEIDAdapter（需权限；默认关闭）
     ├─ iOS:
     │   └─ IDFVAdapter（IdentifierForVendor）
     └─ H5:
         └─ GuidAdapter（首访生成 UUID，localStorage/IndexedDB/Cookie 持久化）
```

### 3) API 设计（兼容回调，也提供 Promise 风格）

与 Ba-IdCode 的 API 兼容，但**统一返回结构**、并补充 Promise 版本：

- `register(options?)`：完成 SDK 初始化/权限请求/合规弹窗接入（**只有用户同意后才能继续**）。
- `getIdCodes(options?)`：一次性返回所有可用标识（含哈希/明文二选一），并标出可用性/限制信息。
- `getOAID()` / `getAAID()` / `getAndroidId()` / `getGuid()`：单项拉取。
- `getBestId(options?)`：按优先级策略返回“一个最合适的设备标识”（例如：`OAID > AAID > AndroidID > IDFV > GUID`）。
- `setSalt(salt: string)`：设置服务端协商的哈希盐（建议）；前端仅输出 hash 以降低风险。

**统一返回结构（示例）**：

```ts
type IdValue = {
  value?: string; // 原始值（默认可关闭）
  hash?: string; // SHA-256(value + salt) 的十六进制
  available: boolean; // 是否成功获取
  limited?: boolean; // 是否受限制（如关闭广告标识、受 ROM 策略限制）
  source?: string; // 具体来源：oaid/aaid/androidId/idfv/guid/...
  message?: string; // 失败/限制说明
};

type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue; // iOS
  widevineId?: IdValue;
  pseudoId?: IdValue;
  imei?: IdValue; // 默认不返回，需开启 & 权限通过
  guid?: IdValue; // H5/兜底
  ts: number; // 时间戳
  consent: boolean; // 是否已取得用户隐私同意
};
```

**调用风格**：

```ts
// 回调
idKit.getIdCodes((res) => {
  /* ... */
});

// Promise（推荐）
const res = await UniIdKit.getIdCodes({
  hashOnly: true,
  include: ["oaid", "aaid", "androidId", "guid"],
});
```

### 4) 平台实现要点

- **Android**：

  - OAID：集成 **MSA (移动安全联盟) SDK** 或厂商合规通道（插件市场常用做法）。
  - AAID：Google Play 服务 `AdvertisingIdClient`（需处理“限制广告跟踪”返回）。
  - AndroidID：`Settings.Secure.ANDROID_ID`。
  - IMEI/MEID：`READ_PHONE_STATE` 动态权限 + Play 政策；**默认关闭**、强提醒不建议依赖。
  - 缓存：优先使用 MMKV/SharedPreferences，配合有效期（如 24 小时）避免频繁拉取。

- **iOS**：

  - IDFV：`UIDevice.current.identifierForVendor`；卸载所有同一 Vendor 应用后可能变。
  - 不建议用 IDFA（需要 ATT 授权且涉广告用途，与你目标不匹配）。

- **H5**：

  - 生成 `uuid`，持久化在 `localStorage` + `cookie` 双存；被清理会变，属于“弱设备 ID”。
  - 返回 `guid` 字段；可选加“服务端长 Cookie dvc=xxx”作为辅助。

### 5) 合规与配置

- 插件默认只返回 **hash**；要返回原值需显式 `exposeRaw: true`。
- 提供 `register()` 用于展示你的隐私弹窗（或与现有弹窗 SDK 对接），**未同意**则所有采集接口返回 `available=false`。
- 允许配置 `include/exclude` 字段（避免不必要的请求/权限）。
- 提供 `fallback: 'guid' | 'none'` 选项控制 H5 的兜底行为。

---

## 3) 先给你一份可直接用的 JS 封装（跨端 & 可渐进增强）

> 先从 JS 层开始（不依赖原生插件也可工作），App 端等你绑定好原生插件后，再把 `native` 分支接上即可。

```ts
// src/utils/uni-id-kit.ts  —— 先做纯JS壳子，后续接原生
function uuid4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function sha256Hex(msg: string): Promise<string> {
  if (typeof window !== "undefined" && window.crypto?.subtle) {
    const enc = new TextEncoder().encode(msg);
    const buf = await window.crypto.subtle.digest("SHA-256", enc);
    return Array.from(new Uint8Array(buf))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  // 非 H5（App 小程序）用简易实现或交给原生
  // 这里先用最简单的占位：直接返回 msg（上线前请接真 SHA-256，如 plus.crypto / 原生）
  return msg;
}

type GetIdOptions = {
  include?: Array<
    | "oaid"
    | "aaid"
    | "androidId"
    | "idfv"
    | "widevineId"
    | "pseudoId"
    | "imei"
    | "guid"
  >;
  exposeRaw?: boolean; // 默认 false，默认仅返回 hash
  salt?: string; // 建议传服务端下发的盐
  fallback?: "guid" | "none";
  ttlMs?: number; // 缓存有效期，默认 1 天
};

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: any } | null = null;

export const UniIdKit = {
  setSalt(salt: string) {
    _salt = salt || "";
  },

  async register(): Promise<{ consent: boolean }> {
    // TODO: 这里接你的隐私弹窗或第三方隐私 SDK
    _consent = true; // 演示先直接同意
    return { consent: _consent };
  },

  async getIdCodes(opts: GetIdOptions = {}) {
    const include = opts.include || [
      "oaid",
      "aaid",
      "androidId",
      "idfv",
      "guid",
    ]; // 先常用
    const ttl = opts.ttlMs ?? 24 * 3600 * 1000;

    // 简单缓存
    if (_cache && Date.now() - _cache.ts < ttl) {
      return _cache.data;
    }

    const data: any = { ts: Date.now(), consent: _consent };

    // App 原生插件（占位），后续把 requireNativePlugin 接上
    let native: any = null;
    try {
      // @ts-ignore
      native = uni.requireNativePlugin && uni.requireNativePlugin("Uni-IdKit");
    } catch {}

    // 工具：组装返回（含 hash）
    const build = async (
      source: string,
      value?: string,
      limited?: boolean,
      msg?: string
    ) => {
      const available = !!value;
      const raw = opts.exposeRaw ? value : undefined;
      const hash = value ? await sha256Hex(value + (_salt || "")) : undefined;
      return { value: raw, hash, available, limited, source, message: msg };
    };

    // Android / iOS / H5 分支（先写 H5 + 纯 JS 兜底，原生等你接上）
    const isH5 =
      typeof window !== "undefined" && typeof document !== "undefined";

    // OAID / AAID / AndroidID / IDFV —— 占位：若未接原生，返回不可用
    if (include.includes("oaid"))
      data.oaid = await build(
        "oaid",
        native?.getOAID ? await native.getOAID() : undefined
      );
    if (include.includes("aaid"))
      data.aaid = await build(
        "aaid",
        native?.getAAID ? await native.getAAID() : undefined
      );
    if (include.includes("androidId"))
      data.androidId = await build(
        "androidId",
        native?.getAndroidID ? await native.getAndroidID() : undefined
      );
    if (include.includes("idfv"))
      data.idfv = await build(
        "idfv",
        native?.getIDFV ? await native.getIDFV() : undefined
      );
    if (include.includes("widevineId"))
      data.widevineId = await build(
        "widevineId",
        native?.getWidevineID ? await native.getWidevineID() : undefined
      );
    if (include.includes("pseudoId"))
      data.pseudoId = await build(
        "pseudoId",
        native?.getPseudoID ? await native.getPseudoID() : undefined
      );
    if (include.includes("imei"))
      data.imei = await build(
        "imei",
        native?.getIMEI ? await native.getIMEI() : undefined
      );

    // H5 / 兜底 GUID
    if (include.includes("guid")) {
      let guid = uni.getStorageSync("UNI_ID_KIT_GUID");
      if (!guid) {
        guid = `web:${uuid4()}`;
        uni.setStorageSync("UNI_ID_KIT_GUID", guid);
      }
      data.guid = await build("guid", guid);
    }

    // 如果要求有“最佳 ID”
    data.best = (() => {
      const order = ["oaid", "aaid", "androidId", "idfv", "guid"];
      for (const k of order) {
        if (data[k]?.available) return k;
      }
      return null;
    })();

    _cache = { ts: Date.now(), data };
    return data;
  },

  async getBestId(opts: GetIdOptions = {}) {
    const res = await this.getIdCodes(opts);
    const key = res.best;
    return key ? res[key] : { available: false, source: "none" };
  },
};
```

> 这份 JS 壳子**现在就能在 H5 返回一个稳定的 GUID**；等你把 Android/iOS 原生侧接上 `Uni-IdKit` 插件，就能自动获得 OAID/AAID/AndroidID/IDFV 等真实值，API 不变。

---

## 下一步怎么干？

1. **确定名字**（默认我用 `UniIdKit` 继续）。
2. 我给你 **Android 原生插件最小实现骨架（Kotlin）**：

   - 暴露 `getOAID/getAAID/getAndroidID/...` 方法；
   - 可先不接 MSA/AAID，返回占位，跑通桥接；
   - 再逐个接入 MSA SDK、Google Play Advertising ID。

3. 同步给 **iOS 原生插件（Swift）** 获取 IDFV；
4. 最后在你的登录流程里，把 `const dvc = await UniIdKit.getBestId({ hashOnly: true })` 接上，作为 `x-device-id` 传后端。

要不要我直接开始贴 **Android 插件骨架（可云打包）**？你点个头我就开写。

太好了，我们就按 **UTS 插件**来落地。下面我先给出**项目结构 & API 设计（最佳实践版）**，然后直接给你**可运行的首版代码骨架**（先支持 Web；Android 提供可运行的基础实现 + OAID/AAID 预留点），后续你把 MSA/GP 的 SDK 接上即可。

---

# 一、插件命名 & 目录结构

**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）

- 英文：**UniIdKit**
- 中文：**一体设备 ID 工具包**

**目录（uni_modules 标准）**：

```
uni_modules/
  uni-id-kit/
    package.json
    module.json
    utssdk/
      index.uts              # 聚合导出（按平台分发）
      common/
        types.uts            # 类型与常量定义（复用）
        hash.uts             # SHA-256 工具（Web/Android 均可）
        storage.uts          # 本地缓存工具（uni.storage封装）
      web/
        index.uts            # Web 实现（GUID、hash、缓存）
      app-android/
        index.uts            # Android 实现（AndroidID，OAID/AAID占位）
        adapters/
          android_id.uts     # ANDROID_ID
          aaid.uts           # Google AAID（待接SDK）
          oaid.uts           # MSA OAID  （待接SDK）
          pseudo_id.uts      # 伪ID（可选）
```

> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。
> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。

---

# 二、API 设计（Promise + 回调兼容）

> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。

## 公开方法

```ts
// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）
export function register(options?: {
  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗
}): Promise<{ consent: boolean }>;

// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash
export function setSalt(salt: string): void;

// 3) 一次性获取所有可用的 ID（聚合）
export function getIdCodes(options?: {
  include?: Array<
    | "oaid"
    | "aaid"
    | "androidId"
    | "idfv"
    | "widevineId"
    | "pseudoId"
    | "imei"
    | "guid"
  >;
  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value
  ttlMs?: number; // 缓存有效期，默认 24h
}): Promise<IdCodesResult>;

// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）
export function getBestId(options?: {
  prefer?: Array<"oaid" | "aaid" | "androidId" | "idfv" | "guid">; // 可自定义优先级
  exposeRaw?: boolean;
  ttlMs?: number;
}): Promise<IdValue>;

// 5) 单项拉取（必要时）
export function getOAID(): Promise<IdValue>;
export function getAAID(): Promise<IdValue>;
export function getAndroidId(): Promise<IdValue>;
export function getGuid(): Promise<IdValue>;
```

## 返回类型（最佳实践）

```ts
// utssdk/common/types.uts
export type IdValue = {
  value?: string; // 原始值（exposeRaw=true 才返回）
  hash?: string; // SHA-256(value + salt) 十六进制
  available: boolean; // 是否获取成功
  limited?: boolean; // 是否受限（系统关闭广告跟踪等）
  source: string; // oaid/aaid/androidId/idfv/guid/...
  message?: string; // 失败或说明
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue; // 预留给 iOS
  widevineId?: IdValue; // 可选
  pseudoId?: IdValue; // 可选
  imei?: IdValue; // 不建议默认启用
  guid?: IdValue; // H5/兜底
  best?: string | null; // 最佳项的 key
  consent: boolean;
  ts: number; // 生成时间戳
};
```

---

# 三、首版代码（可直接放进项目）

> **说明**：以下代码为 **可运行骨架**。
>
> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。
> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。
> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。

## 1）`uni_modules/uni-id-kit/module.json`

```json
{
  "id": "uni-id-kit",
  "displayName": "UniIdKit - 一体设备ID工具包",
  "version": "0.1.0",
  "description": "聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出",
  "keywords": ["deviceid", "oaid", "aaid", "androidid", "guid", "uts"],
  "repository": "",
  "engines": {
    "HBuilderX": "^3.8.0"
  },
  "uni_modules": {
    "platforms": {
      "app-android": {
        "utssdk": {
          "kotlin": ">=1.7.0"
        }
      },
      "web": {
        "utssdk": {}
      }
    }
  }
}
```

## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`

```ts
export type IdValue = {
  value?: string;
  hash?: string;
  available: boolean;
  limited?: boolean;
  source: string;
  message?: string;
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue;
  widevineId?: IdValue;
  pseudoId?: IdValue;
  imei?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`

```ts
// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）
export async function sha256Hex(input: string): Promise<string> {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const enc = new TextEncoder().encode(input);
    const buf = await g.crypto.subtle.digest("SHA-256", enc);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现
  return input;
}
```

## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`

```ts
export function get(key: string): string | null {
  try {
    // @ts-ignore
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}

export function set(key: string, val: string) {
  try {
    // @ts-ignore
    uni.setStorageSync(key, val);
  } catch {}
}
```

## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";

let _consent = false;
let _salt = "";

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getAndroidId(): Promise<IdValue> {
  // Web 没有 AndroidID
  return await build(
    "androidId",
    undefined,
    false,
    false,
    "Not supported on Web"
  );
}

export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Not supported on Web");
}

export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Not supported on Web");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;

  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("androidId") >= 0) res.androidId = await getAndroidId();
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();

  // 国内默认优先级
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }

  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`

```ts
// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）
export function getAndroidIdRaw(): string | null {
  try {
    // @ts-ignore
    const ctx = plus.android.runtimeMainActivity();
    // @ts-ignore
    const SettingsSecure = plus.android.importClass(
      "android.provider.Settings$Secure"
    );
    // @ts-ignore
    const contentResolver = ctx.getContentResolver();
    // @ts-ignore
    const id = SettingsSecure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch (e) {
    return null;
  }
}
```

## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";

let _consent = false;
let _salt = "";

// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：
// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现
async function sha256Hex(input: string): Promise<string> {
  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256
}

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 这里接入你的合规弹窗/SDK；同意前建议不采集
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  const v = getAndroidIdRaw();
  return await build("androidId", v || undefined, exposeRaw);
}

// 预留：接入 Google Advertising ID（AAID）
export async function getAAID(): Promise<IdValue> {
  // TODO：集成 com.google.android.gms:play-services-ads-identifier
  return await build("aaid", undefined, false, true, "AAID not integrated");
}

// 预留：接入 MSA OAID（国内主流）
export async function getOAID(): Promise<IdValue> {
  // TODO：接入 MSA/OAID SDK
  return await build("oaid", undefined, false, true, "OAID not integrated");
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  // 国内优先级：oaid > androidId > guid
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）

```ts
// 平台分发：同名导出，业务方 import 一处即可
// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif
```

---

# 四、在页面中使用（uni-app x）

```ts
// pages/login/index.uvue (示例)
import {
  register,
  setSalt,
  getBestId,
  getIdCodes,
} from "@/uni_modules/uni-id-kit/utssdk/index.uts";

onMounted(async () => {
  await register(); // 视需求弹你的隐私协议
  setSalt("server-salt-xxx"); // 建议从服务端下发

  const best = await getBestId({ exposeRaw: false });
  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）
  const dvc = best.hash || best.value || "unknown";

  await uni.request({
    url: `${baseUrl}/passkeys/login/options`,
    method: "POST",
    header: { "x-device-id": dvc },
    data: {},
  });
});
```

---

# 五、后续接入指引（Android OAID/AAID）

- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。
- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。
- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。
- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。
- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。

---

如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[id-kit开发]]></title>
        <id>https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit开发</id>
        <link href="https://herongdev.github.io/blog/posts/Web-API-与推送/标识-ID/id-kit开发"/>
        <updated>2025-09-07T12:57:14.000Z</updated>
        <content type="html"><![CDATA[
# 一、插件命名 & 目录结构

**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）

- 英文：**UniIdKit**
- 中文：**一体设备 ID 工具包**

**目录（uni_modules 标准）**：

```
uni_modules/
  uni-id-kit/
    package.json
    module.json
    utssdk/
      index.uts              # 聚合导出（按平台分发）
      common/
        types.uts            # 类型与常量定义（复用）
        hash.uts             # SHA-256 工具（Web/Android 均可）
        storage.uts          # 本地缓存工具（uni.storage封装）
      web/
        index.uts            # Web 实现（GUID、hash、缓存）
      app-android/
        index.uts            # Android 实现（AndroidID，OAID/AAID占位）
        adapters/
          android_id.uts     # ANDROID_ID
          aaid.uts           # Google AAID（待接SDK）
          oaid.uts           # MSA OAID  （待接SDK）
          pseudo_id.uts      # 伪ID（可选）
```

> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。
> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。

---

# 二、API 设计（Promise + 回调兼容）

> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。

## 公开方法

```ts
// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）
export function register(options?: {
  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗
}): Promise<{ consent: boolean }>;

// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash
export function setSalt(salt: string): void;

// 3) 一次性获取所有可用的 ID（聚合）
export function getIdCodes(options?: {
  include?: Array<
    | "oaid"
    | "aaid"
    | "androidId"
    | "idfv"
    | "widevineId"
    | "pseudoId"
    | "imei"
    | "guid"
  >;
  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value
  ttlMs?: number; // 缓存有效期，默认 24h
}): Promise<IdCodesResult>;

// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）
export function getBestId(options?: {
  prefer?: Array<"oaid" | "aaid" | "androidId" | "idfv" | "guid">; // 可自定义优先级
  exposeRaw?: boolean;
  ttlMs?: number;
}): Promise<IdValue>;

// 5) 单项拉取（必要时）
export function getOAID(): Promise<IdValue>;
export function getAAID(): Promise<IdValue>;
export function getAndroidId(): Promise<IdValue>;
export function getGuid(): Promise<IdValue>;
```

## 返回类型（最佳实践）

```ts
// utssdk/common/types.uts
export type IdValue = {
  value?: string; // 原始值（exposeRaw=true 才返回）
  hash?: string; // SHA-256(value + salt) 十六进制
  available: boolean; // 是否获取成功
  limited?: boolean; // 是否受限（系统关闭广告跟踪等）
  source: string; // oaid/aaid/androidId/idfv/guid/...
  message?: string; // 失败或说明
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue; // 预留给 iOS
  widevineId?: IdValue; // 可选
  pseudoId?: IdValue; // 可选
  imei?: IdValue; // 不建议默认启用
  guid?: IdValue; // H5/兜底
  best?: string | null; // 最佳项的 key
  consent: boolean;
  ts: number; // 生成时间戳
};
```

---

# 三、首版代码（可直接放进项目）

> **说明**：以下代码为 **可运行骨架**。
>
> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。
> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。
> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。

## 1）`uni_modules/uni-id-kit/module.json`

```json
{
  "id": "uni-id-kit",
  "displayName": "UniIdKit - 一体设备ID工具包",
  "version": "0.1.0",
  "description": "聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出",
  "keywords": ["deviceid", "oaid", "aaid", "androidid", "guid", "uts"],
  "repository": "",
  "engines": {
    "HBuilderX": "^3.8.0"
  },
  "uni_modules": {
    "platforms": {
      "app-android": {
        "utssdk": {
          "kotlin": ">=1.7.0"
        }
      },
      "web": {
        "utssdk": {}
      }
    }
  }
}
```

## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`

```ts
export type IdValue = {
  value?: string;
  hash?: string;
  available: boolean;
  limited?: boolean;
  source: string;
  message?: string;
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue;
  widevineId?: IdValue;
  pseudoId?: IdValue;
  imei?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`

```ts
// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）
export async function sha256Hex(input: string): Promise<string> {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const enc = new TextEncoder().encode(input);
    const buf = await g.crypto.subtle.digest("SHA-256", enc);
    const arr = Array.from(new Uint8Array(buf));
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现
  return input;
}
```

## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`

```ts
export function get(key: string): string | null {
  try {
    // @ts-ignore
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}

export function set(key: string, val: string) {
  try {
    // @ts-ignore
    uni.setStorageSync(key, val);
  } catch {}
}
```

## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";

let _consent = false;
let _salt = "";

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getAndroidId(): Promise<IdValue> {
  // Web 没有 AndroidID
  return await build(
    "androidId",
    undefined,
    false,
    false,
    "Not supported on Web"
  );
}

export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Not supported on Web");
}

export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Not supported on Web");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;

  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("androidId") >= 0) res.androidId = await getAndroidId();
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();

  // 国内默认优先级
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }

  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`

```ts
// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）
export function getAndroidIdRaw(): string | null {
  try {
    // @ts-ignore
    const ctx = plus.android.runtimeMainActivity();
    // @ts-ignore
    const SettingsSecure = plus.android.importClass(
      "android.provider.Settings$Secure"
    );
    // @ts-ignore
    const contentResolver = ctx.getContentResolver();
    // @ts-ignore
    const id = SettingsSecure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch (e) {
    return null;
  }
}
```

## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";

let _consent = false;
let _salt = "";

// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：
// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现
async function sha256Hex(input: string): Promise<string> {
  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256
}

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 这里接入你的合规弹窗/SDK；同意前建议不采集
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  const v = getAndroidIdRaw();
  return await build("androidId", v || undefined, exposeRaw);
}

// 预留：接入 Google Advertising ID（AAID）
export async function getAAID(): Promise<IdValue> {
  // TODO：集成 com.google.android.gms:play-services-ads-identifier
  return await build("aaid", undefined, false, true, "AAID not integrated");
}

// 预留：接入 MSA OAID（国内主流）
export async function getOAID(): Promise<IdValue> {
  // TODO：接入 MSA/OAID SDK
  return await build("oaid", undefined, false, true, "OAID not integrated");
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "aaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  // 国内优先级：oaid > androidId > guid
  const order = ["oaid", "androidId", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const arr = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);
  if (r.best) {
    // @ts-ignore
    return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）

```ts
// 平台分发：同名导出，业务方 import 一处即可
// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif
```

---

# 四、在页面中使用（uni-app x）

```ts
// pages/login/index.uvue (示例)
import {
  register,
  setSalt,
  getBestId,
  getIdCodes,
} from "@/uni_modules/uni-id-kit/utssdk/index.uts";

onMounted(async () => {
  await register(); // 视需求弹你的隐私协议
  setSalt("server-salt-xxx"); // 建议从服务端下发

  const best = await getBestId({ exposeRaw: false });
  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）
  const dvc = best.hash || best.value || "unknown";

  await uni.request({
    url: `${baseUrl}/passkeys/login/options`,
    method: "POST",
    header: { "x-device-id": dvc },
    data: {},
  });
});
```

---

# 五、后续接入指引（Android OAID/AAID）

- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。
- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。
- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。
- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。
- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。

---

如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。

# 参考实现

太好了，我把你这两个现成插件解包看过了，简单总结下各自实现，然后给一套“最佳实践”的统一 API 和落地改造方案（含可以直接替换的 UTS 代码片段）。

---

## 现有两个插件的实现差异（速览）

### 1) `android-deviceid`（UTS，App-Android）

- **用到的库**：`com.github.gzuliyujiang.oaid`（常用 OAID SDK 聚合库），还打包了 3 个 AAR（`ads-identifier-*.aar`、`IDlibrary-release.aar`）。
- **关键点**：

  - 在 `register()` 里调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity().getApplication())` 完成 **OAID 初始化**。
  - 暴露了一个 **监听器**（`IDManger.OnIOAIDListener`），把厂商返回的 JSON 结果转成你定义的 `Device` 对象回调出去。

- **优点**：能拿到 **OAID**，并且是较为标准的做法；兼容多厂商。
- **需要补强**：

  - **统一 Promise API**（目前是回调），方便在页面里用 `await`。
  - **AAID（Google 广告 ID）**、**AndroidID** 的兜底与优先级策略。
  - **隐私合规**（register 同意前不采集）、**hash-only** 输出（默认只回传哈希，原值可开关）。
  - **缓存**（ttl），防止频繁拉取。
  - 错误/受限标记（例如用户关闭了广告跟踪）。

### 2) `zws-uniqueid`（UTS，App-Android）

- **实现**：拼接 `Build.*` 信息做一段文本，MD5 后作为“唯一 ID”。
- **优点**：无需权限/SDK，易用。
- **问题**：这是典型 **PseudoID**，**同型号/同批次设备可能相同**，也可能因 ROM/版本变更；不适合用来做**设备唯一绑定**或风控。
- **建议**：可以作为 `pseudoId` 字段的**最末位兜底**，不要当主标识。

---

## 建议的统一方案（名字可用你之前认可的：**`uni-id-kit`**）

**目标**：同一份 UTS 插件，覆盖 Web/H5 与 App-Android；API 一致、返回结构一致、默认合规（hash-only），国内优先级 `OAID > AndroidID > GUID > PseudoID`，海外可加 `AAID`。

### 统一 API（Promise 风格）

```ts
// 注册/合规：未同意前一律 available=false
export function register(options?: {
  showPrivacyDialog?: boolean;
}): Promise<{ consent: boolean }>;

// 配置哈希盐（建议服务端下发）
export function setSalt(salt: string): void;

// 一次性获取所有（含可用性、受限说明、hash）
export function getIdCodes(options?: {
  include?: Array<"oaid" | "aaid" | "androidId" | "pseudoId" | "guid">;
  exposeRaw?: boolean; // 默认 false
  ttlMs?: number; // 默认 24h
}): Promise<IdCodesResult>;

// 返回“最合适”的一个（按优先级，可定制）
export function getBestId(options?: {
  prefer?: Array<"oaid" | "androidId" | "guid" | "pseudoId" | "aaid">;
  exposeRaw?: boolean;
  ttlMs?: number;
}): Promise<IdValue>;

// 单项
export function getOAID(): Promise<IdValue>;
export function getAAID(): Promise<IdValue>;
export function getAndroidId(): Promise<IdValue>;
export function getGuid(): Promise<IdValue>;
```

**统一返回结构**

```ts
type IdValue = {
  value?: string; // exposeRaw=true 才返回
  hash?: string; // SHA-256(value + salt)
  available: boolean;
  limited?: boolean; // 例如系统关闭广告跟踪
  source: string; // oaid/aaid/androidId/pseudoId/guid
  message?: string;
};

type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  pseudoId?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

---

## 如何改造你现有的两个插件

> 下面给的都是 **直接能塞进工程** 的 UTS 代码。你可以新建一个 `uni_modules/uni-id-kit`，把这两个插件的“能力”合在一起；或者在你现有 `android-deviceid` 里重构导出，效果一致。

### 1) 公共类型与工具（`common/types.uts`、`common/storage.uts`、`common/hash.uts`）

```ts
// common/types.uts
export type IdValue = {
  value?: string;
  hash?: string;
  available: boolean;
  limited?: boolean;
  source: string;
  message?: string;
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  pseudoId?: IdValue;
  guid?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

```ts
// common/storage.uts
export function get(key: string): string | null {
  try {
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}
export function set(key: string, val: string) {
  try {
    uni.setStorageSync(key, val);
  } catch {}
}
```

```ts
// common/hash.uts（Web 有 crypto.subtle；Android 建议换成 MessageDigest）
export async function sha256Hex(input: string): Promise<string> {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const enc = new TextEncoder().encode(input);
    const buf = await g.crypto.subtle.digest("SHA-256", enc);
    return Array.from(new Uint8Array(buf))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  return input; // Android 再换成原生 MessageDigest（见下）
}
```

### 2) Web 实现（先把 H5 跑起来：GUID + hash + 缓存）

```ts
// web/index.uts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";

let _consent = false;
let _salt = "";

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  _consent = true; // 你可在这里弹你的隐私协议
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}

export async function getAndroidId(): Promise<IdValue> {
  return await build(
    "androidId",
    undefined,
    false,
    false,
    "Not supported on Web"
  );
}
export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Not supported on Web");
}
export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Not supported on Web");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  res.best = res.guid?.available ? "guid" : null;
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const r = await getIdCodes(options);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

### 3) Android 实现（融合你两个插件思路，Promise 化 + 兜底 + 可拓展）

- **AndroidID**：直接取 `Settings.Secure.ANDROID_ID`（不需要权限）。
- **OAID**：沿用你 `android-deviceid` 的库，包装为 Promise；初始化要在 `register()` 里做。
- **AAID**：先留占位，后续加 `play-services-ads-identifier`。
- **PseudoID**：把 `zws-uniqueid` 的思路做成可选兜底，不当主标识。
- **SHA-256**：建议在 Android 侧用 `java.security.MessageDigest`，比 web 占位靠谱。

```ts
// app-android/adapters/android_id.uts
export function getAndroidIdRaw(): string | null {
  try {
    // @ts-ignore
    const ctx = plus.android.runtimeMainActivity();
    // @ts-ignore
    const SettingsSecure = plus.android.importClass(
      "android.provider.Settings$Secure"
    );
    // @ts-ignore
    const contentResolver = ctx.getContentResolver();
    // @ts-ignore
    const id = SettingsSecure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch (e) {
    return null;
  }
}
```

```ts
// app-android/adapters/pseudo_id.uts（把 zws 的实现收编为兜底项）
import Build from "android.os.Build";
import MessageDigest from "java.security.MessageDigest";
import BigInteger from "java.math.BigInteger";

export function getPseudoIdRaw(): string | null {
  try {
    const text =
      Build.BOARD +
      Build.BRAND +
      Build.DEVICE +
      Build.DISPLAY +
      Build.FINGERPRINT +
      "uni-id-kit";
    const md5s = MessageDigest.getInstance("MD5").digest(
      (text as any).toString().toByteArray()
    );
    return new BigInteger(1, md5s).toString(16);
  } catch {
    return null;
  }
}
```

```ts
// app-android/index.uts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";
import { getPseudoIdRaw } from "./adapters/pseudo_id.uts";

// ==== 引入你 android-deviceid 插件用到的 OAID 库 ====
import DeviceIdentifier from "com.github.gzuliyujiang.oaid.DeviceIdentifier";
// 你现有的监听器写法是 IDManger.OnIOAIDListener + JSON 回调，这里改 Promise 风格：
// 如果库支持 IGetter 回调也可以（取决于版本），我这里按你包内的风格保留 register 初始化。

let _consent = false;
let _salt = "";

// 使用 Android 的 MessageDigest 实现 SHA-256（优于 web 占位）
function sha256HexSync(input: string): string {
  try {
    // @ts-ignore
    const MessageDigest = plus.android.importClass(
      "java.security.MessageDigest"
    );
    // @ts-ignore
    const md = MessageDigest.getInstance("SHA-256");
    // @ts-ignore
    const bytes = (input as any).toString().getBytes();
    const out = md.digest(bytes);
    let hex = "";
    for (let i = 0; i < out.length; i++) {
      const b = (out[i] as number) & 0xff;
      hex += (b < 16 ? "0" : "") + b.toString(16);
    }
    return hex;
  } catch {
    return input;
  }
}

function uuid4(): string {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = ((Math.random() * 16) as number) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

function buildSync(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): IdValue {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? sha256HexSync(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  try {
    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);
  } catch {}
  _consent = true; // 这里接你的隐私弹窗
  return { consent: _consent } as UTSJSONObject;
}

export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  const v = getAndroidIdRaw();
  return buildSync("androidId", v || undefined, exposeRaw);
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return buildSync("guid", guid as string, exposeRaw);
}

// OAID：基于你现有库封装为 Promise（示例：如果库是同步 API 换成同步返回即可）
export async function getOAID(): Promise<IdValue> {
  try {
    // 你包里是通过监听器把结果 JSON 回调出来的；
    // 这里建议写一个同步/异步包装（示意）：
    // 假设库提供 DeviceIdentifier.getOAID(ctx) 或者 DeviceID.getOAID(...)
    // 如果仅有回调形式，就 new Promise 包一下。
    // 先占位为“未集成”，避免误用：
    return buildSync(
      "oaid",
      undefined,
      false,
      true,
      "OAID not integrated to Promise wrapper"
    );
  } catch (e) {
    return buildSync("oaid", undefined, false, false, (e as any).toString());
  }
}

// AAID：等你接 play-services-ads-identifier，这里先占位
export async function getAAID(): Promise<IdValue> {
  return buildSync("aaid", undefined, false, true, "AAID not integrated");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;

  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("pseudoId") >= 0)
    res.pseudoId = buildSync(
      "pseudoId",
      getPseudoIdRaw() || undefined,
      exposeRaw
    );

  // 国内默认优先级：oaid > androidId > guid > pseudoId
  const order = ["oaid", "androidId", "guid", "pseudoId"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    // @ts-ignore
    const v: IdValue | null = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const prefer = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

### 4) 平台聚合导出（`utssdk/index.uts`）

```ts
// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif
```

---

## 要不要“调整现在的代码”？

**要的**，但改动并不大，主要集中在 4 点：

1. **Promise 化**：把回调/监听器的导出改为 Promise，页面里可以 `await`。
2. **统一返回结构**：所有方法都返回 `IdValue/IdCodesResult`，好串联与埋点。
3. **合规默认 & hash-only**：提供 `register()` 和 `setSalt()`，未同意前不采集；默认只回 `hash`。
4. **兜底与优先级**：在拿不到 OAID 时，**自动回退**到 `AndroidID`、`GUID`、`pseudoId`，并清晰标出 `limited`/`message`。

> 你的 `android-deviceid` 插件可以直接把库继续用；我在上面的安卓实现里已经把“桥接位”留好了。
> `zws-uniqueid` 的算法我收编到 `pseudoId`，作为兜底，不再当主标识使用。

---

## 下一步

- 你确认用 **`uni-id-kit`** 的方案我就把 **OAID Promise 包装**（基于你现有 `DeviceIdentifier` 监听回调）也给你写上，并且给出 **AAID 接入**（`play-services-ads-identifier`）的 `gradle` 依赖与 UTS 调用示例。
- 如果需要，我也可以给 **iOS（IDFV）** 的 UTS 版本，一起并到这个套件里。

没问题。我把你给的两个 UTS 插件（`android-deviceid` / `zws-uniqueid`）的可取之处吸收，做成一套\*\*“最佳实践版”统一插件\*\*：**`uni-id-kit`**。它满足：

- 跨端（H5 / App-Android / App-iOS），统一 Promise API；
- 默认合规：需先 `register()` 才采集；默认只回 **hash**（可开 `exposeRaw` 返回原值）；
- 国内优先级（可自定义）：**OAID > AndroidID > GUID > PseudoID**，海外可加 **AAID**；
- 安全版 UUID：多端用系统级安全随机（`crypto.getRandomValues` / `SecureRandom` / `SecRandomCopyBytes`），兜底 `Math.random`；
- 缓存、错误与受限标记（如“限制广告跟踪”）；
- 兼容你现有后端（请求头携带 `x-device-id` 即可）。

> 下方给出**可直接落地**的文件结构与代码（可直接新建 `uni_modules/uni-id-kit`），Android 的 OAID/AAID 留好“可用的占位与接入点”；如果你确认要接哪套 SDK（MSA 官方/聚合库），我再把桥接也补全为可跑版本。

---

# 目录结构（放到项目的 `uni_modules/uni-id-kit`）

```
uni_modules/
  uni-id-kit/
    module.json
    package.json
    utssdk/
      index.uts
      common/
        types.uts
        uuid.uts
        hash.uts
        storage.uts
      web/
        index.uts
      app-android/
        index.uts
        adapters/
          android_id.uts
          oaid.uts
          aaid.uts
          pseudo_id.uts
      app-ios/
        index.uts
```

---

# 1) module.json

```json
{
  "id": "uni-id-kit",
  "displayName": "UniIdKit - 一体设备ID工具包",
  "version": "0.2.0",
  "description": "聚合 OAID/AAID/AndroidID/GUID/IDFV 等设备标识，合规 & 哈希化输出，UTS 插件",
  "keywords": ["deviceid", "oaid", "aaid", "androidid", "idfv", "guid", "uts"],
  "engines": { "HBuilderX": ">=3.8.0" },
  "uni_modules": {
    "platforms": {
      "web": { "utssdk": {} },
      "app-android": { "utssdk": { "kotlin": ">=1.7.0" } },
      "app-ios": { "utssdk": {} }
    }
  }
}
```

---

# 2) 公共类型/工具

## `utssdk/common/types.uts`

```ts
export type IdValue = {
  value?: string; // exposeRaw=true 才返回
  hash?: string; // SHA-256(value + salt)
  available: boolean; // 是否成功获取
  limited?: boolean; // 广告跟踪受限/ROM限制
  source: string; // oaid/aaid/androidId/idfv/guid/pseudoId
  message?: string; // 说明/错误
};

export type IdCodesResult = {
  oaid?: IdValue;
  aaid?: IdValue;
  androidId?: IdValue;
  idfv?: IdValue;
  guid?: IdValue;
  pseudoId?: IdValue;
  best?: string | null;
  consent: boolean;
  ts: number;
};
```

## `utssdk/common/hash.uts`

```ts
// Web 有 crypto.subtle；原生侧建议用平台 API（Android 代码里换成 MessageDigest；iOS 侧可换 CommonCrypto）
export async function sha256Hex(input: string): Promise<string> {
  // #ifdef H5
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.subtle) {
    const buf = await g.crypto.subtle.digest(
      "SHA-256",
      new TextEncoder().encode(input)
    );
    return Array.from(new Uint8Array(buf))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
  // #endif
  return input; // 非H5先返回原文；Android/iOS在各自实现中用系统哈希
}
```

## `utssdk/common/storage.uts`

```ts
export function get(key: string): string | null {
  try {
    return uni.getStorageSync(key) || null;
  } catch {
    return null;
  }
}
export function set(key: string, val: string) {
  try {
    uni.setStorageSync(key, val);
  } catch {}
}
```

## `utssdk/common/uuid.uts`（跨端安全 UUIDv4）

```ts
function toHex(): string[] {
  const h: string[] = [];
  for (let i = 0; i < 256; i++) h[i] = (i + 0x100).toString(16).substring(1);
  return h;
}
function formatUuid(b: Uint8Array): string {
  b[6] = (b[6] & 0x0f) | 0x40; // version=4
  b[8] = (b[8] & 0x3f) | 0x80; // variant=10
  const H = toHex();
  return (
    H[b[0]] +
    H[b[1]] +
    H[b[2]] +
    H[b[3]] +
    "-" +
    H[b[4]] +
    H[b[5]] +
    "-" +
    H[b[6]] +
    H[b[7]] +
    "-" +
    H[b[8]] +
    H[b[9]] +
    "-" +
    H[b[10]] +
    H[b[11]] +
    H[b[12]] +
    H[b[13]] +
    H[b[14]] +
    H[b[15]]
  );
}

// #ifdef H5
function getRandom16(): Uint8Array {
  // @ts-ignore
  const g: any = globalThis;
  if (g && g.crypto && g.crypto.getRandomValues)
    return g.crypto.getRandomValues(new Uint8Array(16));
  const a = new Uint8Array(16);
  for (let i = 0; i < 16; i++) a[i] = Math.floor(Math.random() * 256);
  return a;
}
// #endif

// #ifdef APP-ANDROID
function getRandom16(): Uint8Array {
  const sr = new java.security.SecureRandom(); // UTS 原生：直接 Java 类
  const arr: number[] = new Array<number>(16);
  for (let i = 0; i < 16; i++) arr[i] = sr.nextInt(256);
  return new Uint8Array(arr);
}
// #endif

// #ifdef APP-IOS
// 使用 Security 的 SecRandomCopyBytes（UTS 映射到 Swift）
function getRandom16(): Uint8Array {
  const bytes = new Uint8Array(16);
  // @ts-ignore
  const ok = SecRandomCopyBytes(kSecRandomDefault, 16, bytes);
  if (ok === 0) return bytes;
  // 兜底 arc4random_buf
  // @ts-ignore
  arc4random_buf(bytes, 16);
  return bytes;
}
// #endif

export function uuid4(): string {
  return formatUuid(getRandom16());
}
```

---

# 3) H5 实现

## `utssdk/web/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { sha256Hex } from "../common/hash.uts";
import { get, set } from "../common/storage.uts";
import { uuid4 } from "../common/uuid.uts";

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: IdCodesResult } | null = null;

async function build(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): Promise<IdValue> {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? await sha256Hex(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 这里接你的隐私弹窗；Demo 直接视为同意
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `web:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return await build("guid", guid as string, exposeRaw);
}
export async function getAndroidId(): Promise<IdValue> {
  return await build("androidId", undefined, false, false, "Web unsupported");
}
export async function getOAID(): Promise<IdValue> {
  return await build("oaid", undefined, false, false, "Web unsupported");
}
export async function getAAID(): Promise<IdValue> {
  return await build("aaid", undefined, false, false, "Web unsupported");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const ttl = (options?.getNumber("ttlMs") || 24 * 3600 * 1000) as number;

  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  res.best = res.guid?.available ? "guid" : null;
  _cache = { ts: Date.now(), data: res };
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const r = await getIdCodes(options);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

---

# 4) Android 实现（融合两插件思路）

- **参考自** `android-deviceid`：OAID 初始化/拉取（此处给出 Promise 版接口占位，方便你把已购库接上）；
- **参考自** `zws-uniqueid`：PseudoID 作为**兜底**而非主标识；
- **AndroidID**：不需权限，稳定性较好；
- **AAID**：留占位（接入 `play-services-ads-identifier` 后即可实现）；
- **哈希**：用 `java.security.MessageDigest`（强于 H5 占位）。

## `utssdk/app-android/adapters/android_id.uts`

```ts
export function getAndroidIdRaw(): string | null {
  try {
    const contentResolver = uni.getContext().getContentResolver();
    const id = android.provider.Settings$Secure.getString(
      contentResolver,
      "android_id"
    ) as string;
    return id ? `android:${id}` : null;
  } catch {
    return null;
  }
}
```

## `utssdk/app-android/adapters/pseudo_id.uts`

```ts
export function getPseudoIdRaw(): string | null {
  try {
    const text =
      android.os.Build.BOARD +
      android.os.Build.BRAND +
      android.os.Build.DEVICE +
      android.os.Build.DISPLAY +
      android.os.Build.FINGERPRINT +
      "uni-id-kit";
    const md = java.security.MessageDigest.getInstance("MD5");
    md.update((text as any).toString().getBytes("UTF-8"));
    const out = md.digest();
    let hex = "";
    for (let i = 0; i < out.length; i++) {
      const b = (out[i] as number) & 0xff;
      hex += (b < 16 ? "0" : "") + b.toString(16);
    }
    return hex;
  } catch {
    return null;
  }
}
```

## `utssdk/app-android/adapters/oaid.uts`（接入点）

```ts
// 这里封装你现有的 OAID 库调用（例如使用 com.github.gzuliyujiang.oaid）
// 由于每家库的接口不完全一致，这里给 Promise 化占位；你把实际调用贴进来即可。
export async function getOAIDRaw(): Promise<{
  value?: string;
  limited?: boolean;
  message?: string;
}> {
  try {
    // TODO: 用你的库实际实现（初始化 register 在 index.uts 的 register() 里做）
    // 例如：DeviceIdentifier.getOAID(context, callback) -> 在 callback 里 resolve
    return {
      value: undefined,
      limited: true,
      message: "OAID not integrated yet",
    };
  } catch (e) {
    return { value: undefined, limited: false, message: (e as any).toString() };
  }
}
```

## `utssdk/app-android/adapters/aaid.uts`（接入点）

```ts
export async function getAAIDRaw(): Promise<{
  value?: string;
  limited?: boolean;
  message?: string;
}> {
  try {
    // TODO: 接入 play-services-ads-identifier：
    // AdvertisingIdClient.getAdvertisingIdInfo(context).getId()
    return {
      value: undefined,
      limited: true,
      message: "AAID not integrated yet",
    };
  } catch (e) {
    return { value: undefined, limited: false, message: (e as any).toString() };
  }
}
```

## `utssdk/app-android/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { uuid4 } from "../common/uuid.uts";
import { getAndroidIdRaw } from "./adapters/android_id.uts";
import { getOAIDRaw } from "./adapters/oaid.uts";
import { getAAIDRaw } from "./adapters/aaid.uts";
import { getPseudoIdRaw } from "./adapters/pseudo_id.uts";

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: IdCodesResult } | null = null;

function sha256HexSync(input: string): string {
  try {
    const md = java.security.MessageDigest.getInstance("SHA-256");
    md.update((input as any).toString().getBytes("UTF-8"));
    const out = md.digest();
    let hex = "";
    for (let i = 0; i < out.length; i++) {
      const b = (out[i] as number) & 0xff;
      hex += (b < 16 ? "0" : "") + b.toString(16);
    }
    return hex;
  } catch {
    return input;
  }
}

function buildSync(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): IdValue {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? sha256HexSync(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  // 1) OAID 库初始化（把你 android-deviceid 的 register 放到这里）
  //    例：DeviceIdentifier.register(uni.getContext().getApplicationContext())
  try {
    // TODO: 调你的 OAID 库 register
  } catch {}

  // 2) 你的隐私弹窗/合规流程
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

export async function getAndroidId(
  exposeRaw: boolean = false
): Promise<IdValue> {
  return buildSync("androidId", getAndroidIdRaw() || undefined, exposeRaw);
}
export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `app:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return buildSync("guid", guid as string, exposeRaw);
}
export async function getOAID(): Promise<IdValue> {
  const r = await getOAIDRaw();
  return buildSync("oaid", r.value, false, r.limited, r.message);
}
export async function getAAID(): Promise<IdValue> {
  const r = await getAAIDRaw();
  return buildSync("aaid", r.value, false, r.limited, r.message);
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
    "aaid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const ttl = (options?.getNumber("ttlMs") || 24 * 3600 * 1000) as number;

  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("oaid") >= 0) res.oaid = await getOAID();
  if (include.indexOf("androidId") >= 0)
    res.androidId = await getAndroidId(exposeRaw);
  if (include.indexOf("aaid") >= 0) res.aaid = await getAAID();
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);
  if (include.indexOf("pseudoId") >= 0)
    res.pseudoId = buildSync(
      "pseudoId",
      getPseudoIdRaw() || undefined,
      exposeRaw
    );

  // 国内默认优先级（可通过 getBestId 覆盖）
  const order = ["oaid", "androidId", "guid", "pseudoId", "aaid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  _cache = { ts: Date.now(), data: res };
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const prefer = (options?.getArray<string>("prefer") || [
    "oaid",
    "androidId",
    "guid",
    "pseudoId",
    "aaid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

---

# 5) iOS 实现（IDFV）

> 你说先国内为主；这里把 **IDFV** 实现好，方便未来开 iOS 端复用。

## `utssdk/app-ios/index.uts`

```ts
import { IdCodesResult, IdValue } from "../common/types.uts";
import { get, set } from "../common/storage.uts";
import { uuid4 } from "../common/uuid.uts";

let _consent = false;
let _salt = "";
let _cache: { ts: number; data: IdCodesResult } | null = null;

function sha256HexSync(input: string): string {
  // TODO: 可换成 CommonCrypto(CC_SHA256)；演示先返回原文
  return input;
}
function buildSync(
  source: string,
  value?: string,
  exposeRaw?: boolean,
  limited?: boolean,
  msg?: string
): IdValue {
  const available = !!value;
  const raw = exposeRaw ? value : undefined;
  const hash = value ? sha256HexSync(value + _salt) : undefined;
  return { value: raw, hash, available, limited, source, message: msg };
}

export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  _consent = true;
  return { consent: _consent } as UTSJSONObject;
}
export function setSalt(salt: string): void {
  _salt = salt || "";
}

function getIDFVRaw(): string | null {
  try {
    const idfv = UIDevice.currentDevice.identifierForVendor?.UUIDString;
    return idfv ? `idfv:${idfv}` : null;
  } catch {
    return null;
  }
}
export async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {
  let guid = get("UNIIDKIT_GUID");
  if (!guid) {
    guid = `ios:${uuid4()}`;
    set("UNIIDKIT_GUID", guid);
  }
  return buildSync("guid", guid as string, exposeRaw);
}
export async function getAndroidId(): Promise<IdValue> {
  return buildSync("androidId", undefined, false, false, "iOS unsupported");
}
export async function getOAID(): Promise<IdValue> {
  return buildSync("oaid", undefined, false, false, "iOS unsupported");
}
export async function getAAID(): Promise<IdValue> {
  return buildSync("aaid", undefined, false, false, "iOS unsupported");
}

export async function getIdCodes(
  options?: UTSJSONObject | null
): Promise<IdCodesResult> {
  const include = (options?.getArray<string>("include") || [
    "idfv",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const ttl = (options?.getNumber("ttlMs") || 24 * 3600 * 1000) as number;

  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;

  const res: IdCodesResult = {
    consent: _consent,
    ts: Date.now(),
  } as IdCodesResult;
  if (!_consent) {
    res.guid = { available: false, source: "guid", message: "consent=false" };
    return res;
  }

  if (include.indexOf("idfv") >= 0)
    res.idfv = buildSync("idfv", getIDFVRaw() || undefined, exposeRaw);
  if (include.indexOf("guid") >= 0) res.guid = await getGuid(exposeRaw);

  const order = ["idfv", "guid"];
  res.best = null;
  for (let i = 0; i < order.length; i++) {
    const k = order[i];
    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;
    if (v && v.available) {
      res.best = k;
      break;
    }
  }
  _cache = { ts: Date.now(), data: res };
  return res;
}

export async function getBestId(
  options?: UTSJSONObject | null
): Promise<IdValue> {
  const prefer = (options?.getArray<string>("prefer") || [
    "idfv",
    "guid",
  ]) as string[];
  const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);
  if (r.best) {
    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;
  }
  return { available: false, source: "none", message: "no id available" };
}
```

---

# 6) 平台聚合导出

## `utssdk/index.uts`

```ts
// #ifdef H5
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./web/index.uts";
// #endif

// #ifdef APP-ANDROID
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-android/index.uts";
// #endif

// #ifdef APP-IOS
export {
  register,
  setSalt,
  getIdCodes,
  getBestId,
  getOAID,
  getAAID,
  getAndroidId,
  getGuid,
} from "./app-ios/index.uts";
// #endif
```

---

# 7) 使用示例（在你的登录页中）

```ts
import {
  register,
  setSalt,
  getBestId,
} from "@/uni_modules/uni-id-kit/utssdk/index.uts";

onMounted(async () => {
  await register({}); // 你的隐私弹窗/合规逻辑
  setSalt("server-salt-xyz"); // 建议服务端下发；默认只回 hash

  const best = await getBestId({
    prefer: ["oaid", "androidId", "guid"],
    exposeRaw: false,
  });
  const dvc = best.hash || best.value || "unknown";

  await uni.request({
    url: `${baseUrl}/passkeys/login/options`,
    method: "POST",
    header: { "x-device-id": dvc },
    data: {},
  });
});
```

---

# 8) 和你两个插件的关系（怎么“融合/替换”）

- `android-deviceid`：

  - **保留其 OAID 能力**，把初始化 `register()` 与获取流程**Promise 化**放到 `adapters/oaid.uts`；
  - 如果你用的是 **gzu 的聚合库**（`com.github.gzuliyujiang.oaid`），我可按它的 IGetter/Client 回调写成可跑代码；你只需告诉我当前项目里的依赖坐标/使用方式即可（或把现有 `register/getOAID` 调用片段贴我）。

- `zws-uniqueid`：

  - 仅作为 **PseudoID 兜底**（`adapters/pseudo_id.uts` 已收编）；
  - 不再把它当“设备唯一标识”，它稳定性不够（但当兜底是有意义的）。

---

# 9) 你可能需要的依赖与打包说明（Android）

**OAID**

- 如果用 **MSA 官方 SDK**：按其文档接入（添加 AAR、初始化、回调）。
- 如果用 **gzu 聚合库**：在 `module.json` 的 `app-android -> utssdk` 里加配置，或在 HBuilderX 的原生配置里勾选对应依赖；随后把 `adapters/oaid.uts` 里按该库接口实现 `getOAIDRaw()` 即可。

**AAID**（Google 广告 ID）

- `com.google.android.gms:play-services-ads-identifier`（需要科学上网/可用镜像）；
- 通过 `AdvertisingIdClient.getAdvertisingIdInfo(context).id` 获取；若用户限制广告跟踪，返回 limited=true。

> 我可以根据你环境（国内私服/镜像）给出具体 Gradle 依赖配置方式。

---

## 总结

- 这套 **`uni-id-kit`** 是把你两个 UTS 插件做了**统一封装、Promise 化、合规默认与安全加强（哈希/安全随机）**，并提供**清晰可扩展**的适配层。
- 你现在就可以把上述文件落地，H5 和 Android 的 **AndroidID/GUID/PseudoID** 已可用；**OAID/AAID** 只需在 `adapters/*.uts` 里按你现有库补上调用即可（导出接口已经定好）。
- 一旦接上 OAID，你就能在国内端得到优先使用的稳定设备标识；其余平台自动回退到 AndroidID/IDFV/GUID。

需要的话，你把你现在 OAID 库的 **初始化 & 获取代码片段**贴我，我直接把 `adapters/oaid.uts` 写成可用实现版（不再占位）。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（1）：Hello World 与变量常量]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（1）：Hello World 与变量常量</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（1）：Hello World 与变量常量"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（1）：Hello World 与变量常量

在 AI 时代，我们学习 Kotlin 的目标不是背诵语法，而是 **快速能看懂 AI 生成的代码**，并能写出简单功能。本篇文章带你用最短的路径跑通第一个 Kotlin 程序，并掌握「变量与常量」的写法。

## 1. 第一个 Kotlin 程序

Kotlin 的入口和其它语言类似，一个 `main` 函数就能跑起来。

```kotlin
fun main() {
    println("Hello, Kotlin!")
}
```

运行后输出：

```
Hello, Kotlin!
```

- `fun` 表示函数
- `main` 是程序入口
- `println` 用来打印内容到控制台

## 2. 变量与常量

在 Kotlin 中，声明变量有两种方式：

### 可变变量：`var`

```kotlin
fun main() {
    var age = 18
    println(age)   // 输出 18

    age = 20
    println(age)   // 输出 20
}
```

- `var` 声明的变量可以修改
- Kotlin 会自动推断类型（这里 `age` 是 `Int` 类型）

### 不可变变量：`val`

```kotlin
fun main() {
    val name = "Alice"
    println(name)  // 输出 Alice

    // name = "Bob"  // ❌ 报错：val 不能重新赋值
}
```

- `val` 相当于常量，只能赋值一次
- 推荐 **能用 `val` 就用 `val`**，保证安全性

## 3. 指定类型

Kotlin 通常能自动推断类型，但你也可以显式声明：

```kotlin
val score: Int = 100
val pi: Double = 3.14
val username: String = "admin"
```

常见类型有：

- `Int`：整数
- `Double`：小数
- `Boolean`：布尔值
- `String`：字符串
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（2）：语法速览（数据类型、字符串模板、空安全）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（2）：语法速览（数据类型、字符串模板、空安全）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（2）：语法速览（数据类型、字符串模板、空安全）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（2）：语法速览（数据类型、字符串模板、空安全）

## 1. 常见数据类型

Kotlin 是强类型语言，常见数据类型包括：

```kotlin
val age: Int = 20        // 整数
val price: Double = 9.99 // 小数
val isVip: Boolean = true // 布尔
val name: String = "Tom" // 字符串
```

Kotlin 会自动推断类型，所以一般不用写类型：

```kotlin
val age = 20
val price = 9.99
val isVip = true
val name = "Tom"
```

## 2. 字符串模板

Kotlin 内置了「字符串模板」功能，用 `$变量名` 或 `${表达式}` 嵌入变量：

```kotlin
fun main() {
    val name = "Alice"
    val age = 18
    println("名字: $name, 年龄: $age")

    // 表达式要加 {}
    println("明年年龄: ${age + 1}")
}
```

输出：

```
名字: Alice, 年龄: 18
明年年龄: 19
```

非常常用！比拼接字符串 `+` 更直观。

## 3. 空安全（Null Safety）

Kotlin 最大的特点之一就是「空安全」，尽量避免空指针错误。

### 普通变量（不能为 null）

```kotlin
val name: String = "Alice"
// name = null // ❌ 报错，普通变量不能赋值为 null
```

### 可空变量（可以为 null）

```kotlin
var nickname: String? = null
nickname = "小明"
```

- 加 `?` 表示这个变量可以为 null
- 读取时要小心

### 安全调用：`?.`

```kotlin
val length = nickname?.length
```

如果 `nickname` 为 null，结果就是 `null`，不会报错。

### Elvis 操作符：`?:`

```kotlin
val length = nickname?.length ?: 0
```

如果 `nickname` 为 null，就返回 `0`。

### 强制非空：`!!`

```kotlin
val length = nickname!!.length
```

如果 `nickname` 是 `null`，会抛出异常。⚠️ 一般少用。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（3）：流程控制（if、when、循环）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（3）：流程控制（if、when、循环）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（3）：流程控制（if、when、循环）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（3）：流程控制（if、when、循环）

程序离不开 **条件判断** 和 **循环**。

## 1. if 表达式

Kotlin 的 `if` 不仅能做判断，还能当表达式返回值。

```kotlin
val age = 20

if (age >= 18) {
    println("成年人")
} else {
    println("未成年人")
}
```

也可以直接赋值：

```kotlin
val category = if (age >= 18) "成年人" else "未成年人"
println(category) // 成年人
```

## 2. when 表达式

`when` 是 Kotlin 里的「多分支选择」，比 `switch` 更强大。

### 基本用法

```kotlin
val score = 85

when {
    score >= 90 -> println("优秀")
    score >= 60 -> println("及格")
    else -> println("不及格")
}
```

### 匹配具体值

```kotlin
val day = 3
val weekday = when (day) {
    1 -> "周一"
    2 -> "周二"
    3 -> "周三"
    else -> "未知"
}
println(weekday) // 周三
```

### 多个条件合并

```kotlin
when (day) {
    1, 7 -> println("周末")
    in 2..6 -> println("工作日")
    else -> println("未知")
}
```

## 3. 循环

### for 循环（区间）

```kotlin
for (i in 1..5) {
    println(i) // 1,2,3,4,5
}
```

### 递减循环

```kotlin
for (i in 5 downTo 1) {
    println(i) // 5,4,3,2,1
}
```

### 指定步长

```kotlin
for (i in 0..10 step 2) {
    println(i) // 0,2,4,6,8,10
}
```

### 遍历数组/集合

```kotlin
val list = listOf("A", "B", "C")
for (item in list) {
    println(item)
}
```

## 4. while 循环

```kotlin
var n = 3
while (n > 0) {
    println(n)
    n--
}
```

## 5. 小结

- `if` 可以做条件判断，也能当表达式返回值
- `when` 是 Kotlin 的多分支选择，功能比 `switch` 强大
- `for` 支持区间、步长、集合遍历
- `while` 和其他语言差不多，适合条件循环
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（4）：函数进阶（默认参数、命名参数、内联函数）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（4）：函数必备（默认参数、命名参数、可变参数）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（4）：函数必备（默认参数、命名参数、可变参数）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（4）：函数进阶（默认参数、命名参数、内联函数）

Kotlin 的函数非常灵活，尤其是 **默认参数、命名参数、内联函数**。

## 1. 默认参数

函数可以为参数提供默认值，调用时就可以省略。

```kotlin
fun greet(name: String = "游客") {
    println("你好, $name")
}

fun main() {
    greet()          // 输出: 你好, 游客
    greet("Alice")   // 输出: 你好, Alice
}
```

👉 好处：比方法重载更简洁。

## 2. 命名参数

调用函数时，可以按「参数名」指定值，避免记混顺序。

```kotlin
fun showUser(name: String, age: Int) {
    println("名字: $name, 年龄: $age")
}

fun main() {
    showUser(age = 20, name = "Bob") // 顺序可变
}
```

👉 在参数多时特别清晰。

## 3. 结合使用：默认参数 + 命名参数

```kotlin
fun connect(host: String = "localhost", port: Int = 3306) {
    println("连接到 $host:$port")
}

fun main() {
    connect()                   // localhost:3306
    connect("192.168.1.1")      // 192.168.1.1:3306
    connect(port = 8080)        // localhost:8080
}
```

## 4. 内联函数（inline）

在高阶函数中，**内联函数**能避免额外开销，提高性能。
常见于 **lambda 回调**。

```kotlin
inline fun measureTime(block: () -> Unit) {
    val start = System.currentTimeMillis()
    block()
    val end = System.currentTimeMillis()
    println("耗时: ${end - start}ms")
}

fun main() {
    measureTime {
        Thread.sleep(500)
    }
}
```

👉 `inline` 的作用：调用时把函数体「内联展开」，避免函数调用栈的开销。
👉 在 Android/多层回调中用得很多。

## 5. 小结

- **默认参数**：减少重载，让函数调用更灵活
- **命名参数**：让调用更清晰，不怕顺序错乱
- **内联函数**：提升高阶函数性能，常见于回调/工具函数
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（8）：集合与泛型（List、Set、Map、泛型函数）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（5）：集合操作（List、Set、Map + 常用方法）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（5）：集合操作（List、Set、Map + 常用方法）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（8）：集合与泛型（List、Set、Map、泛型函数）

在实际开发中，数据通常不是一个一个单独存在，而是成组的。  
Kotlin 提供了功能强大的 **集合 API**，加上 **泛型**，能让代码更安全、更灵活。

## 1. List（有序集合）

```kotlin
fun main() {
    // 不可变 List
    val fruits = listOf("Apple", "Banana", "Orange")
    println(fruits[0]) // Apple

    // 可变 List
    val nums = mutableListOf(1, 2, 3)
    nums.add(4)
    println(nums) // [1, 2, 3, 4]

    // 常用操作
    println(nums.first()) // 1
    println(nums.last())  // 4
    println(nums.filter { it % 2 == 0 }) // [2, 4]
    println(nums.map { it * it }) // [1, 4, 9, 16]
}
```

## 2. Set（无序且不重复）

```kotlin
fun main() {
    val set = mutableSetOf("A", "B", "C", "A")
    println(set) // [A, B, C] 自动去重

    println(set.contains("B")) // true

    set.remove("C")
    println(set) // [A, B]
}
```

## 3. Map（键值对）

```kotlin
fun main() {
    // 不可变 Map
    val map = mapOf("name" to "Alice", "age" to 20)
    println(map["name"]) // Alice

    // 可变 Map
    val scores = mutableMapOf("Tom" to 90, "Jerry" to 85)
    scores["Lucy"] = 95
    println(scores) // {Tom=90, Jerry=85, Lucy=95}

    // 遍历
    for ((k, v) in scores) {
        println("$k -> $v")
    }
}
```

## 4. 泛型（Generics）

泛型让函数/类支持多种类型，写一次，通用多处。

### 泛型函数

```kotlin
fun <T> printList(items: List<T>) {
    for (item in items) {
        println(item)
    }
}

fun main() {
    printList(listOf(1, 2, 3))        // 打印数字
    printList(listOf("a", "b", "c"))  // 打印字符串
}
```

### 泛型类

```kotlin
class Box<T>(val value: T)

fun main() {
    val intBox = Box(123)
    val strBox = Box("Hello")
    println(intBox.value) // 123
    println(strBox.value) // Hello
}
```

## 5. 常用集合操作

Kotlin 集合有大量便捷函数：

```kotlin
fun main() {
    val nums = listOf(5, 2, 8, 1)

    println(nums.sorted())       // [1, 2, 5, 8]
    println(nums.sortedDescending()) // [8, 5, 2, 1]
    println(nums.sum())          // 16
    println(nums.average())      // 4.0
    println(nums.maxOrNull())    // 8
}
```

## 6. 小结

- **List**：有序，可重复
- **Set**：无序，不重复
- **Map**：键值对存储
- **泛型**：提高代码复用性和类型安全
- **集合 API**：`filter`、`map`、`sorted` 等非常常用
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（5）：类与对象（构造函数、属性、方法）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（6）：类与对象（属性、方法、构造函数）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/Kotlin 入门（6）：类与对象（属性、方法、构造函数）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（5）：类与对象（构造函数、属性、方法）

Kotlin 是面向对象语言，几乎所有功能都依赖 **类与对象**。  
这一篇我们快速掌握 **构造函数、属性、方法** —— 写应用必备。

## 1. 定义类

```kotlin
class User(val name: String, var age: Int) {
    fun sayHello() {
        println("大家好，我是 $name，今年 $age 岁")
    }
}
```

- `val` → 只读属性
- `var` → 可变属性
- 构造函数可以直接写在类名后面。

## 2. 创建对象

```kotlin
fun main() {
    val u1 = User("Alice", 20)
    u1.sayHello()
}
```

输出：

```
大家好，我是 Alice，今年 20 岁
```

## 3. 主构造函数

上例里的 `(val name: String, var age: Int)` 就是 **主构造函数**。

也可以加 `init` 代码块做初始化逻辑：

```kotlin
class Person(val name: String, var age: Int) {
    init {
        println("创建 Person: $name, $age 岁")
    }
}
```

## 4. 次构造函数

如果需要多个不同的构造方式，可以写 **次构造函数**。

```kotlin
class Book(val title: String, val price: Double) {
    constructor(title: String) : this(title, 0.0)
}
```

调用：

```kotlin
val b1 = Book("Kotlin 入门", 39.9)
val b2 = Book("免费电子书")
```

## 5. 属性

属性本质上是 **字段 + getter/setter**。
Kotlin 可以自定义逻辑：

```kotlin
class Account(var balance: Double) {
    var isRich: Boolean
        get() = balance > 1_000_000
        set(value) {
            println("忽略设置，isRich 根据余额计算")
        }
}
```

## 6. 方法

类里定义的函数就是 **方法**。

```kotlin
class Calculator {
    fun add(a: Int, b: Int): Int = a + b
}
```

调用：

```kotlin
val calc = Calculator()
println(calc.add(3, 5)) // 8
```

## 7. 小结

- **主构造函数**：最常用，属性可直接写进去
- **次构造函数**：提供额外初始化方式
- **属性**：默认带 getter/setter，可自定义
- **方法**：就是类中的函数
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 入门（7）：常见工具类（String、Date、正则、异常处理）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/otlin 入门（7）：常见工具类（String、Date、正则、异常处理）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第一部分：基础必备/otlin 入门（7）：常见工具类（String、Date、正则、异常处理）"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# Kotlin 入门（7）：常见工具类（String、Date、正则、异常处理）

写应用时，常用到 **字符串、日期、正则、异常处理**。

## 1. String（字符串）

Kotlin 的字符串功能非常强大。

```kotlin
fun main() {
    val name = "Alice"
    val age = 20

    // 模板字符串
    println("我是 $name，今年 $age 岁")

    // 多行字符串
    val msg = """
        第一行
        第二行
    """.trimIndent()
    println(msg)

    // 常用方法
    val text = "Hello Kotlin"
    println(text.lowercase())  // hello kotlin
    println(text.uppercase())  // HELLO KOTLIN
    println(text.contains("Kot")) // true
    println(text.replace("Kotlin", "World")) // Hello World
}
```

## 2. 日期与时间

Kotlin 推荐使用 **Java 8+ 的 java.time API**。

```kotlin
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

fun main() {
    val now = LocalDateTime.now()
    println(now) // 2025-09-12T10:15:30

    // 格式化
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    println(now.format(formatter)) // 2025-09-12 10:15:30

    // 加减时间
    val tomorrow = now.plusDays(1)
    println("明天: ${tomorrow.format(formatter)}")
}
```

## 3. 正则表达式

```kotlin
fun main() {
    val regex = Regex("\\d{3}-\\d{4}")
    val input = "我的电话是 123-4567"

    // 匹配
    println(regex.containsMatchIn(input)) // true

    // 查找
    val match = regex.find(input)
    println(match?.value) // 123-4567

    // 替换
    val masked = regex.replace(input, "***-****")
    println(masked) // 我的电话是 ***-****
}
```

## 4. 异常处理

Kotlin 的异常和 Java 类似，用 `try...catch...finally`。

```kotlin
fun main() {
    try {
        val x = 10 / 0
    } catch (e: ArithmeticException) {
        println("错误: ${e.message}")
    } finally {
        println("无论是否出错都会执行")
    }
}
```

### 自定义异常

```kotlin
class InvalidInputException(msg: String) : Exception(msg)

fun checkAge(age: Int) {
    if (age < 0) throw InvalidInputException("年龄不能为负数")
}

fun main() {
    try {
        checkAge(-1)
    } catch (e: InvalidInputException) {
        println("捕获异常: ${e.message}")
    }
}
```

## 5. 小结

- **String**：支持模板、常用方法丰富
- **Date/Time**：推荐用 `java.time.*` API
- **正则**：`Regex` 类自带匹配/替换
- **异常处理**：`try-catch-finally`，支持自定义异常
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（1）：Android 开发中的 Kotlin 基础用法]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（1）：Android 开发中的 Kotlin 基础用法</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（1）：Android 开发中的 Kotlin 基础用法"/>
        <updated>2025-09-18T17:26:53.105Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（2）：Swift 与 Kotlin 写法对比（跨平台开发准备）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（2）：Swift 与 Kotlin 写法对比（跨平台开发准备）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（2）：Swift 与 Kotlin 写法对比（跨平台开发准备）"/>
        <updated>2025-09-18T17:26:53.105Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（3）：常用库实践（JSON、HTTP、数据库操作）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（3）：常用库实践（JSON、HTTP、数据库操作）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第三部分：实用场景/Kotlin 实战（3）：常用库实践（JSON、HTTP、数据库操作）"/>
        <updated>2025-09-18T17:26:53.105Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（1）：高阶函数与 Lambda 表达式]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（1）：高阶函数与 Lambda 表达式</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（1）：高阶函数与 Lambda 表达式"/>
        <updated>2025-09-18T17:26:53.105Z</updated>
        <content type="html"><![CDATA[好的 ✅ 我来帮你写 **进阶系列第 1 篇**，保持 Hexo 博客风格，主题是 **高阶函数与 Lambda 表达式**。

---

````markdown
---
title: Kotlin 进阶（1）：高阶函数与 Lambda 表达式
date: 2025-09-12
categories: [Kotlin 进阶学习]
tags: [Kotlin, 函数式编程, Lambda, 高阶函数]
---

# Kotlin 进阶（1）：高阶函数与 Lambda 表达式

Kotlin 支持 **函数式编程**，最核心的就是 **高阶函数** 和 **Lambda 表达式**。  
掌握它们后，你会发现很多标准库函数（`map`、`filter`、`let`、`apply` 等）原来都在用这些特性。

---

## 1. 什么是高阶函数？

👉 **高阶函数**：把函数当作参数或返回值的函数。

```kotlin
// 高阶函数：接收一个函数作为参数
fun operate(x: Int, y: Int, op: (Int, Int) -> Int): Int {
    return op(x, y)
}

fun main() {
    val sum = operate(3, 4) { a, b -> a + b }
    println(sum) // 7
}
```
````

这里 `op: (Int, Int) -> Int` 就是一个函数类型参数。

---

## 2. Lambda 表达式基础

Lambda 是 **匿名函数**，语法更简洁。

```kotlin
val add: (Int, Int) -> Int = { a, b -> a + b }
println(add(2, 3)) // 5
```

简写规则：

- 参数类型可省略（由上下文推断）
- 单参数时可用 `it`
- 最后一行就是返回值

```kotlin
val square: (Int) -> Int = { it * it }
println(square(5)) // 25
```

---

## 3. 常见标准库函数

高阶函数+Lambda 在集合操作里用得最多。

```kotlin
val nums = listOf(1, 2, 3, 4, 5)

println(nums.filter { it % 2 == 0 }) // [2, 4]
println(nums.map { it * it })        // [1, 4, 9, 16, 25]
println(nums.any { it > 3 })         // true
println(nums.all { it > 0 })         // true
```

---

## 4. 函数作为返回值

函数也能“生成函数”。

```kotlin
fun multiplier(factor: Int): (Int) -> Int {
    return { x -> x * factor }
}

fun main() {
    val double = multiplier(2)
    println(double(5)) // 10
}
```

---

## 5. 内联函数（inline）

高阶函数会带来额外的函数对象开销。
用 `inline` 可以避免多余的对象创建和调用成本。

```kotlin
inline fun measureTime(block: () -> Unit) {
    val start = System.currentTimeMillis()
    block()
    val end = System.currentTimeMillis()
    println("耗时: ${end - start} ms")
}

fun main() {
    measureTime {
        Thread.sleep(500)
    }
}
```

---

## 6. 小结

- **高阶函数**：函数可当参数或返回值
- **Lambda**：简洁的匿名函数
- **集合操作**：`filter`、`map`、`any`、`all` 等大量使用 Lambda
- **内联函数**：优化高阶函数性能

---

下一篇我们学习 👉 **《Kotlin 进阶（2）：作用域函数（let、apply、run、also、with）》**，写出更优雅的链式代码。

```

---

要不要我接着帮你写 **《Kotlin 进阶（2）：作用域函数》**？
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（2）：扩展函数（给类添加新功能）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（2）：扩展函数（给类添加新功能）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（2）：扩展函数（给类添加新功能）"/>
        <updated>2025-09-18T17:26:53.105Z</updated>
        <content type="html"><![CDATA[好的 ✅ 我来帮你写 **进阶系列第 2 篇**，保持 Hexo 博客风格，主题是 **扩展函数**。

---

````markdown
---
title: Kotlin 进阶（2）：扩展函数（给类添加新功能）
date: 2025-09-12
categories: [Kotlin 进阶学习]
tags: [Kotlin, 扩展函数, 面向对象, 语法糖]
---

# Kotlin 进阶（2）：扩展函数（给类添加新功能）

在 Kotlin 里，**扩展函数**让你不用继承或修改源码，就能给现有的类加新功能。  
这非常适合 **库的增强**、**工具方法封装**、**简化代码**。

---

## 1. 基础语法

扩展函数的定义形式：

```kotlin
fun 类型名.函数名(参数...): 返回类型 {
    // this 代表调用对象
}
```
````

示例：

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Hello".lastChar()) // o
}
```

---

## 2. 常用场景示例

### (1) 数字工具函数

```kotlin
fun Int.isEven(): Boolean = this % 2 == 0
fun Int.isOdd(): Boolean = this % 2 != 0

println(10.isEven()) // true
println(3.isOdd())   // true
```

### (2) 集合扩展

```kotlin
fun <T> List<T>.secondOrNull(): T? =
    if (this.size >= 2) this[1] else null

println(listOf(1, 2, 3).secondOrNull()) // 2
println(emptyList<Int>().secondOrNull()) // null
```

### (3) 日期格式化（依赖 `java.time`）

```kotlin
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

fun LocalDateTime.format(pattern: String = "yyyy-MM-dd HH:mm:ss"): String {
    return this.format(DateTimeFormatter.ofPattern(pattern))
}

fun main() {
    println(LocalDateTime.now().format()) // 2025-09-12 15:30:00
}
```

---

## 3. 扩展属性

不仅可以写函数，还能写属性。

```kotlin
val String.wordCount: Int
    get() = this.trim().split("\\s+".toRegex()).size

println("Hello Kotlin Extension".wordCount) // 3
```

---

## 4. 伴生对象扩展

可以给类的伴生对象（类似静态方法）添加扩展。

```kotlin
class Utils {
    companion object {}
}

fun Utils.Companion.now(): Long = System.currentTimeMillis()

println(Utils.now()) // 1694500000000
```

---

## 5. 注意事项

- 扩展函数 **不会修改原类**，只是 **语法糖**
- 调用时根据 **静态类型** 决定，不支持多态覆盖
- 适合用在 **工具类**、**增强库功能**

---

## 6. 小结

- 用 `fun 类型.函数名()` 定义扩展函数
- 可以扩展 **普通函数**、**属性**、**伴生对象**
- 常用于 **工具方法封装** 和 **代码简化**

---

下一篇我们学习 👉 **《Kotlin 进阶（3）：协程基础（挂起函数、launch、async）》**，进入并发编程的核心。

```

---

要不要我接着帮你写 **《Kotlin 进阶（3）：协程基础》**？
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（3）：空安全进阶]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（3）：空安全进阶</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（3）：空安全进阶"/>
        <updated>2025-09-18T17:26:53.106Z</updated>
        <content type="html"><![CDATA[好的 ✅ 我来帮你写 **进阶系列第 3 篇**，保持 Hexo 博客风格，主题是 **空安全进阶**。

---

````markdown
---
title: Kotlin 进阶（3）：空安全进阶
date: 2025-09-12
categories: [Kotlin 进阶学习]
tags: [Kotlin, 空安全, NullPointerException, Elvis, 安全调用]
---

# Kotlin 进阶（3）：空安全进阶

在 Java 里，`NullPointerException`（简称 NPE）几乎是最常见的运行时错误。  
而 Kotlin 的设计目标之一就是 **彻底减少空指针错误**。  
今天我们深入学习 Kotlin 的 **空安全语法** 和 **最佳实践**。

---

## 1. 可空类型与非空类型

Kotlin 把类型分为两种：

- **非空类型**：默认不能为 `null`
- **可空类型**：在类型后加 `?` 表示

```kotlin
val a: String = "Hello"
// a = null ❌ 编译报错

val b: String? = "Hi"
val c: String? = null
```
````

---

## 2. 安全调用（?.）

如果对象可能为 `null`，用 `?.` 来安全调用。

```kotlin
val name: String? = null
println(name?.length) // null，而不是抛异常
```

---

## 3. Elvis 操作符（?:）

如果左边是 `null`，就用右边的值。

```kotlin
val name: String? = null
val length = name?.length ?: 0
println(length) // 0
```

---

## 4. 非空断言（!!）

把可空类型强制转为非空，如果是 `null` 就抛 NPE。
⚠️ **慎用！** 一般只在“绝对保证非空”的地方使用。

```kotlin
val s: String? = "Kotlin"
println(s!!.length) // 6

val t: String? = null
println(t!!.length) // ❌ NPE
```

---

## 5. `let` 与空安全链式调用

`let` 常和 `?.` 一起用，只有非空时才会执行。

```kotlin
val name: String? = "Kotlin"
name?.let {
    println("长度是 ${it.length}") // 6
}
```

还能写成链式调用：

```kotlin
val result = name?.takeIf { it.length > 3 }?.uppercase()
println(result) // KOTLIN
```

---

## 6. `lateinit` 与 `by lazy`

如果一个变量在稍后初始化，可以用：

- **`lateinit var`**：必须是 `var`，常用于依赖注入、Android View
- **`by lazy`**：必须是 `val`，第一次访问时才会初始化

```kotlin
lateinit var username: String

val config: String by lazy {
    println("初始化中…")
    "配置加载完成"
}
```

---

## 7. 平台类型与 Java 互操作

从 Java 代码调用来的对象可能是 `null` 也可能不是，Kotlin 把它称为 **平台类型**（不带 `?` 也不带 `!!`）。
所以在和 Java 互操作时，要特别小心空指针问题。

```java
// Java
public String getName() { return null; }
```

```kotlin
val name = javaObj.name // 平台类型，不安全
println(name.length)    // 可能直接 NPE
```

---

## 8. 小结

- Kotlin 通过 **可空类型** 和 **空安全操作符**，最大限度避免 NPE
- 常用语法：`?.`、`?:`、`!!`、`let`
- 初始化场景：`lateinit` 和 `by lazy`
- 注意 Java 平台类型的潜在风险

---

下一篇我们学习 👉 **《Kotlin 进阶（4）：集合操作进阶（map/filter/flatMap/reduce）》**，写出更简洁优雅的数据处理代码。

```

---

要不要我接着帮你写 **《Kotlin 进阶（4）：集合操作进阶》**？
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（4）：数据类、枚举类、密封类]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（4）：数据类、枚举类、密封类</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（4）：数据类、枚举类、密封类"/>
        <updated>2025-09-18T17:26:53.106Z</updated>
        <content type="html"><![CDATA[好的 ✅ 我来帮你写 **进阶系列第 4 篇**，主题是 **数据类、枚举类、密封类**，保持 Hexo 博客风格。

---

````markdown
---
title: Kotlin 进阶（4）：数据类、枚举类、密封类
date: 2025-09-12
categories: [Kotlin 进阶学习]
tags: [Kotlin, 数据类, 枚举类, 密封类, 面向对象]
---

# Kotlin 进阶（4）：数据类、枚举类、密封类

在 Kotlin 中，除了普通的 `class`，还有三类非常常用的特殊类：

- **数据类（data class）**：用来存放数据，自动生成常用方法
- **枚举类（enum class）**：表示有限个固定常量
- **密封类（sealed class）**：用于表示有限但可扩展的类型层次结构

---

## 1. 数据类（Data Class）

数据类的主要用途是存放数据，Kotlin 会自动为你生成：

- `toString()`
- `equals()`
- `hashCode()`
- `copy()`
- `componentN()`（解构用）

### 示例

```kotlin
data class User(val id: Int, val name: String)

fun main() {
    val u1 = User(1, "Alice")
    val u2 = User(1, "Alice")
    val u3 = u1.copy(name = "Bob")

    println(u1)         // User(id=1, name=Alice)
    println(u1 == u2)   // true
    println(u3)         // User(id=1, name=Bob)

    val (id, name) = u1 // 解构
    println("id=$id, name=$name")
}
```
````

非常适合用在 **模型类 / DTO**。

---

## 2. 枚举类（Enum Class）

枚举表示固定的一组常量。
每个枚举成员本质上是一个对象。

### 示例

```kotlin
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}

fun main() {
    val dir = Direction.NORTH
    println(dir)            // NORTH
    println(dir.name)       // NORTH
    println(dir.ordinal)    // 0
}
```

---

### 枚举类也能有属性和方法

```kotlin
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF);

    fun hex() = "#${rgb.toString(16)}"
}

fun main() {
    println(Color.RED.hex()) // #ff0000
}
```

---

## 3. 密封类（Sealed Class）

密封类用来表示 **受限的类层次结构**。
它的子类必须在 **同一个文件** 中声明，因此编译器能知道所有子类。

常用于 **状态机**、**结果类型**。

### 示例：表达式求值

```kotlin
sealed class Expr

data class Const(val value: Int) : Expr()
data class Sum(val left: Expr, val right: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Int = when(expr) {
    is Const -> expr.value
    is Sum -> eval(expr.left) + eval(expr.right)
    NotANumber -> 0
}
```

优势：`when` 表达式会 **强制检查所有分支**，防止遗漏。

---

## 4. 小结

- **数据类**：快速建模数据对象，自动生成常用方法
- **枚举类**：固定集合常量，可带属性与方法
- **密封类**：有限层次结构，常用于状态或结果建模

---

下一篇我们学习 👉 **《Kotlin 进阶（5）：协程入门（suspend、launch、async）》**，带你进入 Kotlin 最强大的异步编程世界。

```

---

要不要我继续帮你写 **《Kotlin 进阶（5）：协程入门》**？
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（5）：协程入门（异步代码最常用写法）]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（5）：协程入门（异步代码最常用写法）</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（5）：协程入门（异步代码最常用写法）"/>
        <updated>2025-09-18T17:26:53.106Z</updated>
        <content type="html"><![CDATA[好的 ✅ 我来帮你写 **进阶系列第 5 篇**，主题是 **协程入门（异步代码最常用写法）**，保持 Hexo 博客风格，简明实用。

---

````markdown
---
title: Kotlin 进阶（5）：协程入门（异步代码最常用写法）
date: 2025-09-12
categories: [Kotlin 进阶学习]
tags: [Kotlin, 协程, 异步, 并发, Coroutine]
---

# Kotlin 进阶（5）：协程入门（异步代码最常用写法）

协程（Coroutine）是 Kotlin 最强大的特性之一，用于 **异步任务** 和 **并发编程**。  
相比传统的线程，协程更轻量，写法像同步代码一样清晰。

---

## 1. 最小示例

要使用协程，需要引入 `kotlinx.coroutines` 库：

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        delay(1000L)
        println("协程任务完成")
    }
    println("主线程继续执行")
}
```
````

👉 输出：

```
主线程继续执行
协程任务完成
```

- `runBlocking`：阻塞主线程，直到协程执行完毕（通常用在 `main` 或测试）。
- `launch`：启动一个协程（不会阻塞当前线程）。
- `delay`：挂起，不阻塞线程。

---

## 2. 并发执行

多个任务可以并行运行：

```kotlin
fun main() = runBlocking {
    val job1 = launch {
        delay(1000)
        println("任务1完成")
    }
    val job2 = launch {
        delay(500)
        println("任务2完成")
    }
    println("等待子任务完成")
    joinAll(job1, job2)
    println("全部完成")
}
```

👉 输出顺序：

```
等待子任务完成
任务2完成
任务1完成
全部完成
```

---

## 3. async 并发返回结果

`async` 启动协程并返回结果，用 `await()` 获取。

```kotlin
fun main() = runBlocking {
    val a = async {
        delay(1000)
        10
    }
    val b = async {
        delay(1500)
        20
    }
    println("结果: ${a.await() + b.await()}")
}
```

👉 输出：

```
结果: 30
```

---

## 4. suspend 挂起函数

`suspend` 关键字表示函数可以挂起，用于协程里。

```kotlin
suspend fun fetchData(): String {
    delay(1000)
    return "网络数据"
}

fun main() = runBlocking {
    println("请求中…")
    val data = fetchData()
    println("结果: $data")
}
```

---

## 5. 协程作用域（scope）

在 Android 中，常用作用域有：

- `GlobalScope.launch {}`：全局协程（不推荐，容易泄露）
- `lifecycleScope.launch {}`：Activity/Fragment 生命周期范围
- `viewModelScope.launch {}`：ViewModel 范围

---

## 6. 小结

- `launch`：启动协程（无返回值）
- `async/await`：并发执行并返回结果
- `suspend`：挂起函数，用于协程内
- `delay`：非阻塞延迟

---

下一篇我们学习 👉 **《Kotlin 进阶（6）：协程进阶（异常、取消、作用域）》**，掌握协程的高级用法。

```

---

要不要我现在接着帮你写 **《Kotlin 进阶（6）：协程进阶》**？
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（6）：内联函数与性能优化]]></title>
        <id>https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（6）：内联函数与性能优化</id>
        <link href="https://herongdev.github.io/blog/posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（6）：内联函数与性能优化"/>
        <updated>2025-09-18T17:26:53.106Z</updated>
        <content type="html"><![CDATA[好的 ✅ 我来帮你写 **进阶系列第 6 篇**，主题是 **内联函数与性能优化**，继续保持 Hexo 博客风格，实用精简。

---

````markdown
---
title: Kotlin 进阶（6）：内联函数与性能优化
date: 2025-09-12
categories: [Kotlin 进阶学习]
tags: [Kotlin, 内联函数, inline, 性能优化]
---

# Kotlin 进阶（6）：内联函数与性能优化

Kotlin 的 **内联函数（inline function）** 主要用于 **性能优化**，尤其是高阶函数中，减少不必要的对象创建和函数调用开销。

---

## 1. 什么是内联函数？

一般高阶函数（接受 Lambda 参数的函数）在运行时会生成额外的对象和调用层级。  
加上 `inline` 关键字后，编译器会 **把函数体直接拷贝到调用处**，减少开销。

```kotlin
inline fun logTime(block: () -> Unit) {
    val start = System.currentTimeMillis()
    block()
    val end = System.currentTimeMillis()
    println("耗时: ${end - start}ms")
}

fun main() {
    logTime {
        Thread.sleep(500)
    }
}
```
````

👉 输出：

```
耗时: 500ms
```

这里 `block()` 会被编译成 **直接调用**，而不是额外的函数对象。

---

## 2. noinline 关键字

如果函数有多个 Lambda 参数，但并不是所有都需要内联，可以用 `noinline` 标记。

```kotlin
inline fun doSomething(
    block1: () -> Unit,
    noinline block2: () -> Unit
) {
    block1()
    block2()
}
```

这样 `block1` 会被内联，而 `block2` 仍然是普通对象。

---

## 3. crossinline 关键字

有些 Lambda 要求不能使用 `return` 直接跳出外层函数，可以用 `crossinline` 解决。

```kotlin
inline fun runTask(crossinline block: () -> Unit) {
    Thread {
        block() // 允许调用，但禁止直接 return 外层函数
    }.start()
}
```

---

## 4. reified（具体化类型参数）

通常泛型在运行时会被擦除，用 `reified` 可以让 **内联函数** 保留类型信息。

```kotlin
inline fun <reified T> printType() {
    println(T::class.simpleName)
}

fun main() {
    printType<String>() // 输出 String
    printType<Int>()    // 输出 Int
}
```

这在写工具函数时非常常用，比如 `startActivity<T>()`。

---

## 5. 使用场景

- **性能优化**：减少 Lambda 对象创建（常见于集合操作、DSL）
- **泛型工具函数**：结合 `reified`，写更优雅的 API
- **Android 开发**：`inline fun <reified T : Activity> Context.startActivity()`

---

## 6. 小结

- `inline`：把函数体复制到调用处，减少开销
- `noinline`：某些参数不内联
- `crossinline`：禁止 Lambda 非局部返回
- `reified`：泛型具体化，保留类型信息

---

下一篇我们学习 👉 **《Kotlin 进阶（7）：泛型与约束》**，掌握写通用代码的核心技能。

```

---

要不要我接着帮你写 **《Kotlin 进阶（7）：泛型与约束》**？
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/01-UIKit基础]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/01-UIKit基础</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/01-UIKit基础"/>
        <updated>2025-09-18T17:26:53.106Z</updated>
        <content type="html"><![CDATA[# 01-UIKit基础

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/02-AutoLayout与约束]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/02-AutoLayout与约束</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/02-AutoLayout与约束"/>
        <updated>2025-09-18T17:26:53.107Z</updated>
        <content type="html"><![CDATA[# 02-AutoLayout与约束

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/03-UI事件与手势]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/03-UI事件与手势</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/03-UI事件与手势"/>
        <updated>2025-09-18T17:26:53.107Z</updated>
        <content type="html"><![CDATA[# 03-UI事件与手势

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/04-导航与页面跳转]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/04-导航与页面跳转</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/04-导航与页面跳转"/>
        <updated>2025-09-18T17:26:53.107Z</updated>
        <content type="html"><![CDATA[# 04-导航与页面跳转

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/05-表格与集合视图(UITableView,UICollectionView)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/05-表格与集合视图(UITableView,UICollectionView)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/05-表格与集合视图(UITableView,UICollectionView)"/>
        <updated>2025-09-18T17:26:53.107Z</updated>
        <content type="html"><![CDATA[# 05-表格与集合视图(UITableView,UICollectionView)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/06-动画(CoreAnimation与UIViewPropertyAnimator)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/06-动画(CoreAnimation与UIViewPropertyAnimator)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/06-动画(CoreAnimation与UIViewPropertyAnimator)"/>
        <updated>2025-09-18T17:26:53.107Z</updated>
        <content type="html"><![CDATA[# 06-动画(CoreAnimation与UIViewPropertyAnimator)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/07-本地化与国际化]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/07-本地化与国际化</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/07-本地化与国际化"/>
        <updated>2025-09-18T17:26:53.108Z</updated>
        <content type="html"><![CDATA[# 07-本地化与国际化

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/08-无障碍(Accessibility)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/08-无障碍(Accessibility)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/08-无障碍(Accessibility)"/>
        <updated>2025-09-18T17:26:53.108Z</updated>
        <content type="html"><![CDATA[# 08-无障碍(Accessibility)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/09-应用生命周期与场景(UIApplication,UIScene)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/09-应用生命周期与场景(UIApplication,UIScene)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/09-应用生命周期与场景(UIApplication,UIScene)"/>
        <updated>2025-09-18T17:26:53.108Z</updated>
        <content type="html"><![CDATA[# 09-应用生命周期与场景(UIApplication,UIScene)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/10-资源与资产管理(Assets,SF Symbols)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/10-资源与资产管理(Assets,SF Symbols)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/01-iOS应用开发/10-资源与资产管理(Assets,SF Symbols)"/>
        <updated>2025-09-18T17:26:53.108Z</updated>
        <content type="html"><![CDATA[# 10-资源与资产管理(Assets,SF Symbols)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/01-视图与状态(State,Binding,ObservedObject)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/01-视图与状态(State,Binding,ObservedObject)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/01-视图与状态(State,Binding,ObservedObject)"/>
        <updated>2025-09-18T17:26:53.108Z</updated>
        <content type="html"><![CDATA[# 01-视图与状态(State,Binding,ObservedObject)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/02-NavigationStack与路由]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/02-NavigationStack与路由</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/02-NavigationStack与路由"/>
        <updated>2025-09-18T17:26:53.108Z</updated>
        <content type="html"><![CDATA[# 02-NavigationStack与路由

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/03-布局(Stack,Grid,GeometryReader)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/03-布局(Stack,Grid,GeometryReader)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/03-布局(Stack,Grid,GeometryReader)"/>
        <updated>2025-09-18T17:26:53.109Z</updated>
        <content type="html"><![CDATA[# 03-布局(Stack,Grid,GeometryReader)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/04-列表与表单(List,Form)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/04-列表与表单(List,Form)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/04-列表与表单(List,Form)"/>
        <updated>2025-09-18T17:26:53.109Z</updated>
        <content type="html"><![CDATA[# 04-列表与表单(List,Form)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/05-动画与过渡]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/05-动画与过渡</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/05-动画与过渡"/>
        <updated>2025-09-18T17:26:53.109Z</updated>
        <content type="html"><![CDATA[# 05-动画与过渡

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/06-数据流与架构(MVVM,TCA概览)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/06-数据流与架构(MVVM,TCA概览)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/06-数据流与架构(MVVM,TCA概览)"/>
        <updated>2025-09-18T17:26:53.109Z</updated>
        <content type="html"><![CDATA[# 06-数据流与架构(MVVM,TCA概览)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/07-与UIKit互操作(UIViewRepresentable)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/07-与UIKit互操作(UIViewRepresentable)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/07-与UIKit互操作(UIViewRepresentable)"/>
        <updated>2025-09-18T17:26:53.109Z</updated>
        <content type="html"><![CDATA[# 07-与UIKit互操作(UIViewRepresentable)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/08-多平台与Widget]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/08-多平台与Widget</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/02-SwiftUI/08-多平台与Widget"/>
        <updated>2025-09-18T17:26:53.109Z</updated>
        <content type="html"><![CDATA[# 08-多平台与Widget

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/01-URLSession基础]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/01-URLSession基础</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/01-URLSession基础"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 01-URLSession基础

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/02-请求构建与拦截器]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/02-请求构建与拦截器</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/02-请求构建与拦截器"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 02-请求构建与拦截器

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/03-Codable与JSON解析]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/03-Codable与JSON解析</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/03-Codable与JSON解析"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 03-Codable与JSON解析

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/04-并发请求与TaskGroup]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/04-并发请求与TaskGroup</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/04-并发请求与TaskGroup"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 04-并发请求与TaskGroup

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/05-上传下载与后台传输]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/05-上传下载与后台传输</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/05-上传下载与后台传输"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 05-上传下载与后台传输

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/06-缓存与离线(HTTP缓存,持久化)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/06-缓存与离线(HTTP缓存,持久化)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/06-缓存与离线(HTTP缓存,持久化)"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 06-缓存与离线(HTTP缓存,持久化)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/07-WebSocket与实时通信]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/07-WebSocket与实时通信</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/07-WebSocket与实时通信"/>
        <updated>2025-09-18T17:26:53.110Z</updated>
        <content type="html"><![CDATA[# 07-WebSocket与实时通信

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/08-网络错误与重试策略]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/08-网络错误与重试策略</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/08-网络错误与重试策略"/>
        <updated>2025-09-18T17:26:53.111Z</updated>
        <content type="html"><![CDATA[# 08-网络错误与重试策略

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/09-安全(ATS,HSTS,证书绑定)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/09-安全(ATS,HSTS,证书绑定)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/03-网络编程/09-安全(ATS,HSTS,证书绑定)"/>
        <updated>2025-09-18T17:26:53.111Z</updated>
        <content type="html"><![CDATA[# 09-安全(ATS,HSTS,证书绑定)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/01-GCD基础]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/01-GCD基础</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/01-GCD基础"/>
        <updated>2025-09-18T17:26:53.111Z</updated>
        <content type="html"><![CDATA[# 01-GCD基础

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/02-OperationQueue与依赖]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/02-OperationQueue与依赖</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/02-OperationQueue与依赖"/>
        <updated>2025-09-18T17:26:53.111Z</updated>
        <content type="html"><![CDATA[# 02-OperationQueue与依赖

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/03-async-await进阶(结构化并发)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/03-async-await进阶(结构化并发)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/03-async-await进阶(结构化并发)"/>
        <updated>2025-09-18T17:26:53.111Z</updated>
        <content type="html"><![CDATA[# 03-async-await进阶(结构化并发)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/04-Actor与Sendable]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/04-Actor与Sendable</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/04-Actor与Sendable"/>
        <updated>2025-09-18T17:26:53.112Z</updated>
        <content type="html"><![CDATA[# 04-Actor与Sendable

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/05-MainActor与UI线程]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/05-MainActor与UI线程</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/05-MainActor与UI线程"/>
        <updated>2025-09-18T17:26:53.112Z</updated>
        <content type="html"><![CDATA[# 05-MainActor与UI线程

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/06-取消,超时与重试]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/06-取消,超时与重试</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/06-取消,超时与重试"/>
        <updated>2025-09-18T17:26:53.112Z</updated>
        <content type="html"><![CDATA[# 06-取消,超时与重试

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/07-Combine与async_await桥接]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/07-Combine与async_await桥接</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/04-并发与多线程/07-Combine与async_await桥接"/>
        <updated>2025-09-18T17:26:53.112Z</updated>
        <content type="html"><![CDATA[# 07-Combine与async_await桥接

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/01-UserDefaults与Keychain]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/01-UserDefaults与Keychain</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/01-UserDefaults与Keychain"/>
        <updated>2025-09-18T17:26:53.112Z</updated>
        <content type="html"><![CDATA[# 01-UserDefaults与Keychain

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/02-文件系统与Sandbox]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/02-文件系统与Sandbox</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/02-文件系统与Sandbox"/>
        <updated>2025-09-18T17:26:53.112Z</updated>
        <content type="html"><![CDATA[# 02-文件系统与Sandbox

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/03-CoreData入门]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/03-CoreData入门</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/03-CoreData入门"/>
        <updated>2025-09-18T17:26:53.113Z</updated>
        <content type="html"><![CDATA[# 03-CoreData入门

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/04-CoreData高级(并发,批量,NSFetchedResultsController)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/04-CoreData高级(并发,批量,NSFetchedResultsController)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/04-CoreData高级(并发,批量,NSFetchedResultsController)"/>
        <updated>2025-09-18T17:26:53.113Z</updated>
        <content type="html"><![CDATA[# 04-CoreData高级(并发,批量,NSFetchedResultsController)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/05-Realm入门(可选)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/05-Realm入门(可选)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/05-Realm入门(可选)"/>
        <updated>2025-09-18T17:26:53.113Z</updated>
        <content type="html"><![CDATA[# 05-Realm入门(可选)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/06-CloudKit与iCloud同步]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/06-CloudKit与iCloud同步</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/05-数据持久化/06-CloudKit与iCloud同步"/>
        <updated>2025-09-18T17:26:53.113Z</updated>
        <content type="html"><![CDATA[# 06-CloudKit与iCloud同步

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/01-MVC,MVVM,VIPER,Clean对比]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/01-MVC,MVVM,VIPER,Clean对比</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/01-MVC,MVVM,VIPER,Clean对比"/>
        <updated>2025-09-18T17:26:53.113Z</updated>
        <content type="html"><![CDATA[# 01-MVC,MVVM,VIPER,Clean对比

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/02-依赖注入与模块化]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/02-依赖注入与模块化</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/02-依赖注入与模块化"/>
        <updated>2025-09-18T17:26:53.113Z</updated>
        <content type="html"><![CDATA[# 02-依赖注入与模块化

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/03-路由与模块通信]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/03-路由与模块通信</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/03-路由与模块通信"/>
        <updated>2025-09-18T17:26:53.114Z</updated>
        <content type="html"><![CDATA[# 03-路由与模块通信

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/04-领域建模与不可变数据]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/04-领域建模与不可变数据</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/04-领域建模与不可变数据"/>
        <updated>2025-09-18T17:26:53.114Z</updated>
        <content type="html"><![CDATA[# 04-领域建模与不可变数据

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/05-The Composable Architecture(TCA)入门]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/05-The Composable Architecture(TCA)入门</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/06-架构与模式/05-The Composable Architecture(TCA)入门"/>
        <updated>2025-09-18T17:26:53.114Z</updated>
        <content type="html"><![CDATA[# 05-The Composable Architecture(TCA)入门

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/01-XCTest单元测试]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/01-XCTest单元测试</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/01-XCTest单元测试"/>
        <updated>2025-09-18T17:26:53.114Z</updated>
        <content type="html"><![CDATA[# 01-XCTest单元测试

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/02-UI测试(XCUITest)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/02-UI测试(XCUITest)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/02-UI测试(XCUITest)"/>
        <updated>2025-09-18T17:26:53.114Z</updated>
        <content type="html"><![CDATA[# 02-UI测试(XCUITest)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/03-快照测试]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/03-快照测试</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/03-快照测试"/>
        <updated>2025-09-18T17:26:53.114Z</updated>
        <content type="html"><![CDATA[# 03-快照测试

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/04-测试金字塔,Mock与依赖倒置]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/04-测试金字塔,Mock与依赖倒置</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/04-测试金字塔,Mock与依赖倒置"/>
        <updated>2025-09-18T17:26:53.115Z</updated>
        <content type="html"><![CDATA[# 04-测试金字塔,Mock与依赖倒置

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/05-CI_CD(Xcode Cloud,fastlane)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/05-CI_CD(Xcode Cloud,fastlane)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/05-CI_CD(Xcode Cloud,fastlane)"/>
        <updated>2025-09-18T17:26:53.115Z</updated>
        <content type="html"><![CDATA[# 05-CI_CD(Xcode Cloud,fastlane)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/06-代码规范(swiftlint,swiftformat)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/06-代码规范(swiftlint,swiftformat)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/07-测试与质量/06-代码规范(swiftlint,swiftformat)"/>
        <updated>2025-09-18T17:26:53.115Z</updated>
        <content type="html"><![CDATA[# 06-代码规范(swiftlint,swiftformat)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/01-ARC与循环引用深入]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/01-ARC与循环引用深入</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/01-ARC与循环引用深入"/>
        <updated>2025-09-18T17:26:53.115Z</updated>
        <content type="html"><![CDATA[# 01-ARC与循环引用深入

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/02-闭包,定时器与泄漏案例]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/02-闭包,定时器与泄漏案例</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/02-闭包,定时器与泄漏案例"/>
        <updated>2025-09-18T17:26:53.115Z</updated>
        <content type="html"><![CDATA[# 02-闭包,定时器与泄漏案例

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/03-Instruments(Leaks,Allocations,TimeProfiler)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/03-Instruments(Leaks,Allocations,TimeProfiler)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/03-Instruments(Leaks,Allocations,TimeProfiler)"/>
        <updated>2025-09-18T17:26:53.115Z</updated>
        <content type="html"><![CDATA[# 03-Instruments(Leaks,Allocations,TimeProfiler)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/04-App启动优化]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/04-App启动优化</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/04-App启动优化"/>
        <updated>2025-09-18T17:26:53.116Z</updated>
        <content type="html"><![CDATA[# 04-App启动优化

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/05-列表与图片性能优化]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/05-列表与图片性能优化</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/05-列表与图片性能优化"/>
        <updated>2025-09-18T17:26:53.116Z</updated>
        <content type="html"><![CDATA[# 05-列表与图片性能优化

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/06-电量与网络流量优化]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/06-电量与网络流量优化</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/08-性能与内存/06-电量与网络流量优化"/>
        <updated>2025-09-18T17:26:53.116Z</updated>
        <content type="html"><![CDATA[# 06-电量与网络流量优化

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/01-定位与MapKit]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/01-定位与MapKit</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/01-定位与MapKit"/>
        <updated>2025-09-18T17:26:53.116Z</updated>
        <content type="html"><![CDATA[# 01-定位与MapKit

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/02-相机与相册(AVFoundation,Photos)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/02-相机与相册(AVFoundation,Photos)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/02-相机与相册(AVFoundation,Photos)"/>
        <updated>2025-09-18T17:26:53.116Z</updated>
        <content type="html"><![CDATA[# 02-相机与相册(AVFoundation,Photos)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/03-推送与通知(APNs,UNUserNotificationCenter)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/03-推送与通知(APNs,UNUserNotificationCenter)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/03-推送与通知(APNs,UNUserNotificationCenter)"/>
        <updated>2025-09-18T17:26:53.117Z</updated>
        <content type="html"><![CDATA[# 03-推送与通知(APNs,UNUserNotificationCenter)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/04-后台模式与BackgroundTasks]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/04-后台模式与BackgroundTasks</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/04-后台模式与BackgroundTasks"/>
        <updated>2025-09-18T17:26:53.117Z</updated>
        <content type="html"><![CDATA[# 04-后台模式与BackgroundTasks

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/05-蓝牙(CoreBluetooth)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/05-蓝牙(CoreBluetooth)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/05-蓝牙(CoreBluetooth)"/>
        <updated>2025-09-18T17:26:53.117Z</updated>
        <content type="html"><![CDATA[# 05-蓝牙(CoreBluetooth)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/06-健康(HealthKit)与运动(CoreMotion)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/06-健康(HealthKit)与运动(CoreMotion)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/06-健康(HealthKit)与运动(CoreMotion)"/>
        <updated>2025-09-18T17:26:53.117Z</updated>
        <content type="html"><![CDATA[# 06-健康(HealthKit)与运动(CoreMotion)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/07-近场通信(NFC)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/07-近场通信(NFC)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/09-系统能力与硬件/07-近场通信(NFC)"/>
        <updated>2025-09-18T17:26:53.118Z</updated>
        <content type="html"><![CDATA[# 07-近场通信(NFC)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/01-隐私权限与InfoPlist说明]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/01-隐私权限与InfoPlist说明</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/01-隐私权限与InfoPlist说明"/>
        <updated>2025-09-18T17:26:53.118Z</updated>
        <content type="html"><![CDATA[# 01-隐私权限与InfoPlist说明

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/02-本地认证与生物识别(LocalAuthentication)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/02-本地认证与生物识别(LocalAuthentication)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/02-本地认证与生物识别(LocalAuthentication)"/>
        <updated>2025-09-18T17:26:53.118Z</updated>
        <content type="html"><![CDATA[# 02-本地认证与生物识别(LocalAuthentication)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/03-数据加密与Keychain最佳实践]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/03-数据加密与Keychain最佳实践</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/03-数据加密与Keychain最佳实践"/>
        <updated>2025-09-18T17:26:53.118Z</updated>
        <content type="html"><![CDATA[# 03-数据加密与Keychain最佳实践

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/04-反调试与完整性保护]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/04-反调试与完整性保护</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/04-反调试与完整性保护"/>
        <updated>2025-09-18T17:26:53.119Z</updated>
        <content type="html"><![CDATA[# 04-反调试与完整性保护

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/05-合规(GDPR,CCPA,国内合规)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/05-合规(GDPR,CCPA,国内合规)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/10-安全与合规/05-合规(GDPR,CCPA,国内合规)"/>
        <updated>2025-09-18T17:26:53.119Z</updated>
        <content type="html"><![CDATA[# 05-合规(GDPR,CCPA,国内合规)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/01-证书签名与Provisioning]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/01-证书签名与Provisioning</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/01-证书签名与Provisioning"/>
        <updated>2025-09-18T17:26:53.119Z</updated>
        <content type="html"><![CDATA[# 01-证书签名与Provisioning

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/02-多环境与构建配置]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/02-多环境与构建配置</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/02-多环境与构建配置"/>
        <updated>2025-09-18T17:26:53.119Z</updated>
        <content type="html"><![CDATA[# 02-多环境与构建配置

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/03-App Store提审流程与元数据]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/03-App Store提审流程与元数据</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/03-App Store提审流程与元数据"/>
        <updated>2025-09-18T17:26:53.119Z</updated>
        <content type="html"><![CDATA[# 03-App Store提审流程与元数据

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/04-内购(StoreKit)与订阅]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/04-内购(StoreKit)与订阅</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/04-内购(StoreKit)与订阅"/>
        <updated>2025-09-18T17:26:53.119Z</updated>
        <content type="html"><![CDATA[# 04-内购(StoreKit)与订阅

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/05-崩溃与日志(Firebase Crashlytics等)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/05-崩溃与日志(Firebase Crashlytics等)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/11-发布与运营/05-崩溃与日志(Firebase Crashlytics等)"/>
        <updated>2025-09-18T17:26:53.120Z</updated>
        <content type="html"><![CDATA[# 05-崩溃与日志(Firebase Crashlytics等)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/01-Swift与Objective-C互操作]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/01-Swift与Objective-C互操作</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/01-Swift与Objective-C互操作"/>
        <updated>2025-09-18T17:26:53.120Z</updated>
        <content type="html"><![CDATA[# 01-Swift与Objective-C互操作

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/02-包管理(Swift Package Manager)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/02-包管理(Swift Package Manager)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/02-包管理(Swift Package Manager)"/>
        <updated>2025-09-18T17:26:53.120Z</updated>
        <content type="html"><![CDATA[# 02-包管理(Swift Package Manager)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/03-第三方库与CocoaPods迁移]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/03-第三方库与CocoaPods迁移</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/03-第三方库与CocoaPods迁移"/>
        <updated>2025-09-18T17:26:53.120Z</updated>
        <content type="html"><![CDATA[# 03-第三方库与CocoaPods迁移

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/04-KVC_KVO与现代化替代方案]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/04-KVC_KVO与现代化替代方案</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/12-互操作与迁移/04-KVC_KVO与现代化替代方案"/>
        <updated>2025-09-18T17:26:53.120Z</updated>
        <content type="html"><![CDATA[# 04-KVC_KVO与现代化替代方案

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/01-CoreAnimation基础]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/01-CoreAnimation基础</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/01-CoreAnimation基础"/>
        <updated>2025-09-18T17:26:53.120Z</updated>
        <content type="html"><![CDATA[# 01-CoreAnimation基础

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/02-CoreGraphics绘制]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/02-CoreGraphics绘制</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/02-CoreGraphics绘制"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 02-CoreGraphics绘制

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/03-自定义转场与交互动画]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/03-自定义转场与交互动画</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/03-自定义转场与交互动画"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 03-自定义转场与交互动画

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/04-Metal简述(可选)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/04-Metal简述(可选)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/13-视觉交互进阶/04-Metal简述(可选)"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 04-Metal简述(可选)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/01-watchOS入门]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/01-watchOS入门</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/01-watchOS入门"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 01-watchOS入门

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/02-tvOS入门]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/02-tvOS入门</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/02-tvOS入门"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 02-tvOS入门

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/03-visionOS与RealityKit入门]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/03-visionOS与RealityKit入门</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/03-visionOS与RealityKit入门"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 03-visionOS与RealityKit入门

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/04-Mac Catalyst移植]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/04-Mac Catalyst移植</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/14-多平台扩展/04-Mac Catalyst移植"/>
        <updated>2025-09-18T17:26:53.121Z</updated>
        <content type="html"><![CDATA[# 04-Mac Catalyst移植

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/01-新闻客户端(网络+缓存+SwiftUI)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/01-新闻客户端(网络+缓存+SwiftUI)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/01-新闻客户端(网络+缓存+SwiftUI)"/>
        <updated>2025-09-18T17:26:53.122Z</updated>
        <content type="html"><![CDATA[# 01-新闻客户端(网络+缓存+SwiftUI)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/02-IM聊天(实时通信+本地存储)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/02-IM聊天(实时通信+本地存储)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/02-IM聊天(实时通信+本地存储)"/>
        <updated>2025-09-18T17:26:53.122Z</updated>
        <content type="html"><![CDATA[# 02-IM聊天(实时通信+本地存储)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/03-离线优先记事本(CoreData+iCloud)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/03-离线优先记事本(CoreData+iCloud)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/03-离线优先记事本(CoreData+iCloud)"/>
        <updated>2025-09-18T17:26:53.122Z</updated>
        <content type="html"><![CDATA[# 03-离线优先记事本(CoreData+iCloud)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/04-音视频小工具(AVFoundation)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/04-音视频小工具(AVFoundation)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/04-音视频小工具(AVFoundation)"/>
        <updated>2025-09-18T17:26:53.122Z</updated>
        <content type="html"><![CDATA[# 04-音视频小工具(AVFoundation)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/05-地图打卡(MapKit+地理围栏)]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/05-地图打卡(MapKit+地理围栏)</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/15-专题案例/05-地图打卡(MapKit+地理围栏)"/>
        <updated>2025-09-18T17:26:53.122Z</updated>
        <content type="html"><![CDATA[# 05-地图打卡(MapKit+地理围栏)

> 待补充：
- 背景与常见场景
- 5分钟最小可跑示例
- 实战要点与常见坑
- Checklist
- 延伸阅读
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/@objc]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/@objc</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/@objc"/>
        <updated>2025-09-18T17:26:53.122Z</updated>
        <content type="html"><![CDATA[`@objc` 是 Swift 中的一个属性（attribute），用于将 Swift 代码暴露给 Objective-C 运行时。让我详细解释一下：

## `@objc` 的作用

1. **Objective-C 互操作性**：使 Swift 类、方法、属性能够被 Objective-C 代码调用
2. **运行时访问**：允许在运行时通过字符串名称访问方法和属性
3. **动态特性**：支持一些需要 Objective-C 运行时的功能，如 KVO、选择器等

## 在你的代码中的使用

从你的 `DeviceIdNative.swift` 文件中可以看到几种使用场景：

### 1. 类级别的 `@objc`
```swift
@objc public class DeviceIdNative: NSObject {
```
- 将整个类暴露给 Objective-C
- 继承自 `NSObject` 是为了获得 Objective-C 的基础功能

### 2. 方法级别的 `@objc`
```swift
@objc public static func setConsent(_ v: Bool) {
    consent = v
}

@objc public static func getIDFAOrNull(_ requestATT: Bool) -> String? {
    // ...
}
```
- 将特定方法暴露给 Objective-C
- 这些方法可以被其他语言（如 JavaScript、Java 等）通过桥接调用

## 为什么需要 `@objc`？

在你的项目中，这是一个 **uni-app 的 UTS 插件**：

1. **跨平台调用**：UTS (uni-app TypeScript) 需要调用原生 iOS 代码
2. **桥接机制**：`@objc` 使得 TypeScript/JavaScript 可以通过 uni-app 的桥接机制调用这些 Swift 方法
3. **统一接口**：确保 iOS 和 Android 平台提供一致的 API 接口

## 语法特点

- **可选参数**：Swift 的参数标签在 Objective-C 中会变成方法名的一部分
- **类型映射**：Swift 类型会自动映射到对应的 Objective-C 类型
- **返回值**：可选类型 `String?` 在 Objective-C 中变成可为 nil 的对象

总的来说，`@objc` 是 Swift 与 Objective-C 互操作的关键机制，在你的项目中主要用于让 uni-app 的跨平台框架能够调用原生 iOS 功能。]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点"/>
        <updated>2025-09-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 什么是尾随闭包？

**尾随闭包**是 Swift 提供的语法糖：当**函数的最后一个参数是闭包**时，可以把这个闭包**写在圆括号 `()` 外面**，让调用更简洁、更像“DSL”。

对比（同义写法）：

```swift
// 普通写法（闭包写在括号里）
someFunc(arg1: 42, completion: { value in
    print(value)
})

// 尾随闭包（把最后一个闭包挪到括号外）
someFunc(arg1: 42) { value in
    print(value)
}
```

## 语法细节（逐条讲清）

### 1) 闭包基本形态

```swift
{ (参数列表) -> 返回类型 in
    // 闭包体
}
```

- `in`：分隔**参数/返回类型声明**与**闭包体**。
- 未用到的参数可用 `_` 忽略；也可用**参数速记** `$0`、`$1`：

```swift
{ value in print(value) }
{ print($0) }         // 等价
{ _ in print("done") }
```

### 2) 尾随闭包的触发条件

- **函数的最后一个参数**必须是闭包；否则不能使用尾随闭包语法（Swift 5.3 起有“多尾随闭包”，见下一条）。
- 若函数**只有一个参数且是闭包**，可以**省略空括号**：

```swift
// 只有闭包一个参数
doSomething { print("hi") }   // 等价于 doSomething(closure: { ... })
```

### 3) 多尾随闭包（Swift 5.3+）

当函数有**多个闭包参数**时，可以把**第一个**闭包写成**无标签**的尾随闭包，**后面的闭包**放在后面、**带标签**：

```swift
UIView.animate(withDuration: 0.25) {
    // animations（第一个尾随闭包，无标签）
} completion: { finished in
    // completion（第二个尾随闭包，有标签）
}
```

规则小抄：

- 第一个尾随闭包**不写标签**。
- 后续尾随闭包**必须写出参数标签**（如 `completion:`、`onError:`）。

### 4) 与 GCD/回调常见组合

你的 ATT 例子里就用了尾随闭包：

```swift
DispatchQueue.global().async {
    ATTrackingManager.requestTrackingAuthorization { _ in   // 尾随闭包
        sem.signal()
    }
}
```

- `async { ... }` 的 `{ ... }` 是**把任务提交到队列执行**的闭包。
- `requestTrackingAuthorization { _ in ... }` 是**授权结果回调**闭包；参数（授权状态）被 `_` 忽略。

### 5) 捕获列表与内存管理（避免循环引用）

尾随闭包一样可以写**捕获列表**：

```swift
someAsyncWork { [weak self] result in
    self?.handle(result)
}
```

- 闭包默认**强引用**捕获 `self`，在异步/长期存活的闭包里用 `[weak self]` 更安全。
- 与是否“尾随”无关；是**闭包语法**的一部分。

### 6) `@escaping` 与是否能“逃出当前作用域”

- 如果函数**把闭包存起来稍后再调用**（如异步回调），参数要标注 `@escaping`，这与是否尾随无关：

```swift
func doAsync(_ completion: @escaping (Int) -> Void) { ... }
doAsync { value in print(value) }   // 尾随闭包照常使用
```

---

## 何时该用/不该用？

**更该用的时候**

- 闭包体**较长**或**是调用的主体**（例如布局 DSL、动画、网络回调）。
- 读起来像自然语言，**减少括号层级**。

**不该用的时候**

- 函数还有**闭包后面的非闭包参数**（顺序不允许）。
- 读者难以分辨哪个是参数、哪个是闭包（**可回退**到普通写法提升可读性）。

---

## 常见坑

1. **闭包不是最后一个参数**
   不能用尾随闭包（或调整函数签名/调用顺序；或使用多尾随闭包语法）。

2. **主线程阻塞**
   尾随闭包只是写法变了，**线程/阻塞行为不变**。例如你那段代码里 `wait` 会阻塞当前线程，因此**不要在主线程**调用包着 `wait` 的函数。

3. **参数标签忘写（多尾随闭包）**
   第二个及之后的尾随闭包**必须写标签**，否则不通过。

---

## 一段对照练习（从普通到尾随）

```swift
// 普通
fetch(url: url, success: { data in
    print(data)
}, failure: { error in
    print(error)
})

// 多尾随闭包（Swift 5.3+）
fetch(url: url) { data in
    print(data)
} failure: { error in
    print(error)
}
```

---

## 小结

- **尾随闭包 = “把最后一个闭包参数挪到括号外”** 的写法，核心是**让调用更好读**。
- 掌握三件事：**基本闭包语法（参数/返回/in）**、**多尾随闭包规则**、**与并发内存管理的配合（`[weak self]`、`@escaping`）**。
- 记住：**语法糖不改变语义**；是否阻塞、在哪个线程、何时执行，取决于**函数实现与你怎么调**，不是“尾随”本身。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是闭包？——从直觉到 Swift 实战（顺带和 JS 对比）]]></title>
        <id>https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/闭包</id>
        <link href="https://herongdev.github.io/blog/posts/swift-advanced-v2/指令/闭包"/>
        <updated>2025-09-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 一句话定义

**闭包（Closure）**就是**能“记住”其创建时所在环境的函数值**。它不仅有代码，还**捕获**了周围用到的变量，因此即使这些变量所在的作用域已经结束，闭包仍能访问它们。

> 换句话说：闭包 = 函数 + 被它用到的“外部变量的快照/引用”（捕获环境）。

## Swift 中闭包的基本语法

```swift
// 完整形态
{ (参数列表) -> 返回类型 in
    // 闭包体
}

// 简写（可省类型、返回、参数名）：
{ value in value * 2 }
{ $0 * 2 }
```

> Swift 把**函数也是一等公民**，所以“函数”与“闭包表达式”本质上都是**可以存到变量里、当参数传递、作为返回值**的“可调用值”。

## 闭包做了什么：**捕获（Capture）**

```swift
func makeCounter() -> () -> Int {
    var n = 0        // 将被捕获的“自由变量”
    return {
        n += 1       // 闭包持有对 n 的访问权
        return n
    }
}

let next = makeCounter()
next() // 1
next() // 2  （即使 makeCounter 已经返回，n 仍然存在于闭包的捕获环境里）
```

- **自由变量**：在闭包体内使用、但不在闭包参数或局部定义的变量（上例中的 `n`）。
- **生命周期延长**：被捕获的变量会跟着闭包一起活得更久。

## 与 JavaScript 的快速对比

- JS 里 `function`/箭头函数天然是闭包，**捕获的是词法作用域**。
- Swift 也一样是**词法闭包**，但有**强类型系统**和**值/引用类型**的区别：

  - 捕获 `struct` 值时拷贝语义更明确；
  - 捕获 `class` 实例默认**强引用**，需要注意循环引用。

## Swift 的捕获细节与内存管理

### 强/弱/无主引用（防循环引用）

```swift
class A {
    var handler: (() -> Void)?
    func setup() {
        // 复杂逻辑：异步闭包可能长期存活，这里用 weak 打破强引用环
        handler = { [weak self] in
            self?.doWork()
        }
    }
    func doWork() {}
}
```

- 默认**强捕获** `self` → 容易产生 `A -> handler -> 闭包 -> A` 的**环**。
- 用 `[weak self]` 或 `[unowned self]`（更激进，要求生命周期保证）打破环。

### 值捕获 vs 引用捕获

```swift
var x = 0
let c1 = { print(x) }    // 捕获对 x 的访问（变量本身的存储位置）
let c2 = { [x] in print(x) } // 捕获当时的“值快照”，后续外部修改不影响
x = 42
c1() // 42
c2() // 0
```

## `@escaping` 与非逃逸闭包

- **非逃逸（默认）**：闭包在函数调用结束前就会执行完，不会被存起来。
- **逃逸 `@escaping`**：闭包可能被**异步保存并在稍后执行**，如网络回调、GCD。

```swift
func fetch(_ done: @escaping (Data?) -> Void) {
    DispatchQueue.global().async { done(nil) }
}
```

> 是否尾随闭包**与逃逸无关**；`@escaping` 取决于**函数如何使用**闭包。

## 尾随闭包只是“写法糖”，语义不变

```swift
// 普通写法
animate(duration: 0.25, animations: { ... }, completion: { _ in ... })

// 多尾随闭包（Swift 5.3+）
animate(duration: 0.25) {
    // animations
} completion: { finished in
    // completion
}
```

> **尾随闭包**只是把“最后一个闭包参数”移出 `()`，代码更好读；并不改变执行时机与线程模型。

## 典型用法

- **回调/异步**：网络请求、磁盘 IO、GCD。
- **函数式链式处理**：`map/filter/reduce`。
- **资源管理**：把“前后处理”打包成闭包式 API。
- **构建 DSL**：如 Auto Layout/动画/配置器风格。

```swift
let doubled = [1,2,3].map { $0 * 2 }   // 函数式闭包
```

---

## 性能与可读性建议

- **能用简写就简写**（类型推断、`$0`）但别过度；长逻辑请起**具名参数**提升可读性。
- **热点路径**避免创建过多短生命周期闭包（尤其是捕获大对象时）。
- 异步长期存活的闭包**总是考虑捕获列表**（`[weak self]`）。
- 如需同步等待闭包回调（不推荐），务必**不要在主线程**执行等待。

---

## 小结

- 闭包是**能带着上下文变量一起走的函数值**；这使得**回调、异步、函数式**成为可能。
- Swift 中闭包**默认强捕获**，要用**捕获列表**避免循环引用。
- `@escaping` 描述的是**生命周期**，尾随闭包只是**语法糖**。
- 理解“捕获”的本质，就能写出既**优雅**又**安全**的闭包代码。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[passkeys 通行密钥 登录+注册一体化方案]]></title>
        <id>https://herongdev.github.io/blog/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案</id>
        <link href="https://herongdev.github.io/blog/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案"/>
        <updated>2025-09-04T23:29:49.000Z</updated>
        <content type="html"><![CDATA[
结论先说：**可以把“登录+注册”做成一体化体验**。

主流做法是 **“先尝试登录（可发现凭证）→ 如果用户或设备上没有可用通行密钥，再走 JIT 注册并在验证成功后直接登录”**。

原因是 WebAuthn 天生是“**两步握手**”：
**options**（服务端签发挑战）→ **客户端做凭证仪式** → **verify**（服务端校验）。
所以无论登录还是注册，都至少要走这一来一回；想“完全无交互”是不可能的。但你可以把 **登录与注册的分支逻辑** 封装好，让前端只调用 1\~2 次 API 就完成。

你的代码里已经有这个形态了：

- `/passkeys/login/options|verify`：**无用户名直登**（allowCredentials 留空 → 可发现凭证）
- `/passkeys/register-or-login/options|verify`：**JIT 建号 + 设备唯一 + 注册即登录**

这就是一体化的正确方向。下面给你**微调点**，让体验更顺滑，并回答“是否必须先绑定”的顾虑。

## 推荐落地流程（与大厂一致的用户体验）

1. **进入应用 → 前端先调用** `/passkeys/login/options`（不传 allowCredentials）。

   - Android/iOS 原生会列出与 **RP ID** 匹配的“可发现凭证”(resident key)。
   - 若用户设备上已有你的 RP 的通行密钥 → 用户点一下即返回 **assertion** → 你后端 `verifyAuthentication` → **直接登录**。

2. **若返回“没有可用凭证/用户取消/NotFound”**：前端**立即**调用 `/passkeys/register-or-login/options`（带上 `deviceIdentifier`）。

   - 后端 **JIT 建号**（或使用你已有的访客/待激活账号策略），签发 **registration options**（residentKey=required）。
   - 前端发起注册仪式 → 拿到 **attestation** 回 `/register-or-login/verify`。
   - 服务端 **校验 + 入库 + 绑定设备(可选) + 激活账号 + 签发 JWT** → **注册即登录**。

> 是否必须先“绑定再登录”？
> **不必须。**对已存在通行密钥的用户，第一步就能登录；对新设备/新用户，第二步完成**注册+登录**。
> “设备唯一绑定”是**风控策略**（特别适合你的“仅内部员工”场景），不是通行密钥的强制要求。

## 只给需要修改/新增的代码（复杂逻辑上一行有注释）

### A) `PasskeysService.issueAuthenticationOptions`：若发现设备已绑定账号，则**定向登录**（加速成功率）

```ts
// 复杂逻辑：若 deviceIdentifier 已绑定 userId，则定向下发 allowCredentials（命中率更高，更快）
async issueAuthenticationOptions({ deviceIdentifier }: { deviceIdentifier?: string }) {
  const relyingPartyId = this.configService.get<string>('RP_ID');

  // 可选的速率限制（60s/5次）
  if (deviceIdentifier) {
    const rlKey = `rl:authpub:${deviceIdentifier}`;
    const c = await this.redisService.incrementKey(rlKey);
    if (c === 1) await this.redisService.expireKey(rlKey, 60);
    if (c > 5) throw new BadRequestException('请求过于频繁，请稍后重试');
  }

  let allowCredentials: { id: Buffer; type: 'public-key' }[] | undefined;
  let preferUserId: string | null = null;

  if (deviceIdentifier) {
    // 复杂逻辑：如果该设备已绑定过账号，优先走“定向登录”
    preferUserId = await this.redisService.getValue(`dvc:owner:${deviceIdentifier}`);
    if (preferUserId) {
      // 复杂逻辑：查询该用户的所有凭证，拼出 allowCredentials（按你的持久层接口调整）
      const creds = await this.staffService.findManyCredentialsByUserId(preferUserId);
      allowCredentials = (creds || []).map((c: any) => ({
        id: Buffer.from(c.credentialId, 'base64url'),
        type: 'public-key' as const,
      }));
    }
  }

  const opts = await generateAuthenticationOptions({
    rpID: relyingPartyId,
    userVerification: 'preferred',
    // 复杂逻辑：存在 allowCredentials → 定向登录；否则留空 = 可发现凭证
    allowCredentials,
  });

  // 复杂逻辑：挑战转为 base64url，分别按“userId”或“challenge”做校验键
  const ch = typeof opts.challenge === 'string'
    ? opts.challenge
    : Buffer.from(opts.challenge).toString('base64url');

  if (preferUserId) {
    // 定向登录：按 userId 存
    await this.redisService.setWithTimeToLive(`webauthn:auth:${preferUserId}`, ch, 300);
  } else {
    // 无用户名直登：按 challenge 存
    await this.redisService.setWithTimeToLive(`webauthn:auth:ch:${ch}`, '1', 300);
  }

  // 兼容前端：无需改协议，仍返回纯 AuthenticationOptions
  return { options: opts };
}
```

> 说明：
>
> - 这段逻辑**不改变你的路由与前端协议**，仅在“已绑定设备”的情况下给出 `allowCredentials`，成功率会更高，且仍保留“可发现凭证”的默认路径。
> - `findManyCredentialsByUserId` 请在你的 `AdminStaffService` 或凭据仓库里补一个简单查询（只要返回 `credentialId` 列表即可）。

---

### B) 前端（你刚写的 `<script setup>` 页面）**登录按钮**增加“失败回退到注册”的兜底（只给改动段）

```ts
// 复杂逻辑：登录失败时自动回退到 JIT 注册（注册成功即登录）
async function onLogin() {
  try {
    appendLog("请求登录 options...");
    const { options } = await post("/passkeys/login/options", {
      deviceIdentifier: deviceId.value,
    });
    const requestOptionsJson = JSON.stringify(options);

    // 复杂逻辑：先尝试登录（Android 支持 conditional UI；iOS 忽略该参数）
    const authRespJson = await passkeys.getPasskey(requestOptionsJson, {
      conditional: true,
    });

    appendLog("登录响应返回，提交后端 verify...");
    const verify = await post(
      "/passkeys/login/verify",
      JSON.parse(authRespJson)
    );
    appendLog("登录完成：" + JSON.stringify(verify));
    uni.showToast({ title: "登录成功", icon: "success" });
  } catch (e: any) {
    appendLog("未找到可用通行密钥或用户取消，转入一键注册...");
    // ===== 回退到 JIT 注册 =====
    const { userId, options } = await post(
      "/passkeys/register-or-login/options",
      deviceId.value ? { deviceIdentifier: deviceId.value } : {}
    );
    const creationOptionsJson = JSON.stringify(options);
    const regRespJson = await passkeys.createPasskey(creationOptionsJson);

    appendLog("注册响应返回，提交后端 verify...");
    const verify = await post("/passkeys/register-or-login/verify", {
      ...JSON.parse(regRespJson),
      userId,
      deviceIdentifier: deviceId.value,
    });
    appendLog("注册并登录完成：" + JSON.stringify(verify));
    uni.showToast({ title: "已注册并登录", icon: "success" });
  }
}
```

---

### C) 小修小补（可选但建议）

```ts
// ✅ 注册 options：建议同时允许 ES256 与 RS256，兼容性更好
supportedAlgorithmIDs: [-7, -257],  // ES256 + RS256

// ✅ 注册时强制 residentKey=required 已很好；登录时建议 UV 至少 preferred（你已这么做）
// 可对内网/高敏环境将 requireUserVerification 提升为 true
requireUserVerification: true, // 在 verify* 中按需要切换
```

---

## 关键答疑

- **“能不能只请求一次后端就完成登录？”**
  不行。WebAuthn 必须由服务器先发“带签名挑战”的 **options**，客户端拿到后**本地安全硬件**完成签名/生成数据，再发给服务器 **verify**。这是设计使然，无法省略。

- **“新用户是否必须先走‘绑定’页面？”**
  不必须。你现在的 JIT 路线就是“**注册即登录**”。首次访问：登录失败 → 自动发起注册 → 验证成功后立刻签发会话即可。后续访问就直接“可发现凭证”一键登录了。

- **“设备唯一绑定是必须的吗？”**
  不是 WebAuthn 的硬性要求，但对**内部员工场景非常有用**（合规+风控）。你已经在 JIT 验证里写了 `dvc:owner:*` 的校验与写入，这就够了。

---

如果你愿意，我可以**补一个 `findManyCredentialsByUserId` 的最小实现**（Prisma/TypeORM 任一版）或把你的 `PasskeysController` 的“登录按钮”分支写成更干净的状态机。你说一声，我按你的“只给改动段”规范继续补。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Next.js/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Next.js/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）"/>
        <updated>2025-09-06T14:41:39.000Z</updated>
        <content type="html"><![CDATA[
---

title: 最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）
date: 2025-09-06
tags:

- TanStack Query
- React Query
- Next.js 14
- TypeScript

---

## 目标

在**不改动你现有 http 封装**（`http.call` + `api/modules/price.ts`）前提下，最小成本接入 TanStack Query，用于价格趋势这类“读多写少”的数据获取与缓存。

---

## 步骤总览

1. 安装依赖
2. 新增 `QueryProvider` 并在 `app/layout.tsx` 注入
3. 写一个最小的 `usePriceTrend` 查询 Hook
4. 在一个客户端组件里调用展示

> 说明：只给**新增/变更**的文件内容；复杂逻辑在上一行加注释。

---

## 1) 安装

```bash
pnpm add @tanstack/react-query
# 可选：开发工具
pnpm add -D @tanstack/react-query-devtools
```

---

## 2) Provider：在全局注入 QueryClient

**新增：`src/lib/query/QueryProvider.tsx`**

```tsx
"use client";

import { PropsWithChildren, useState } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
// 可选：开发时打开
// import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

export default function QueryProvider({ children }: PropsWithChildren) {
  // 复杂逻辑上一行注释：用 useState 确保在客户端持久化一个 QueryClient 单例
  const [client] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // 复杂逻辑上一行注释：避免频繁重复请求，数据 5 分钟内视为新鲜
            staleTime: 5 * 60 * 1000,
            // 复杂逻辑上一行注释：失败最多重试 2 次，指数退避
            retry: 2,
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={client}>
      {children}
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
}
```

**修改：`src/app/layout.tsx`（只贴需要插入的代码）**

```tsx
// ➊ 新增这一行
import QueryProvider from "@/lib/query/QueryProvider";

// ... 省略你的现有代码
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="zh-CN">
      <body>
        {/* ➋ 用 Provider 包裹全局 */}
        <QueryProvider>{children}</QueryProvider>
      </body>
    </html>
  );
}
```

---

## 3) 查询 Hook：封装价格趋势获取

**新增：`src/features/price-trend/queries.ts`**

```ts
"use client";

import { useQuery } from "@tanstack/react-query";
import { priceApi } from "@/api/modules/price";

// 复杂逻辑上一行注释：以业务语义定义查询 Hook，统一 queryKey 与调用的 API 函数
export function usePriceTrend(gameId: string, stores: string[]) {
  return useQuery({
    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参
    queryKey: ["priceTrend", gameId, stores],
    // 复杂逻辑上一行注释：交给领域 API，返回 Promise<any>
    queryFn: () => priceApi.getTrend({ gameId, stores }),
    // 复杂逻辑上一行注释：没有必要参数时不发起请求
    enabled: Boolean(gameId) && stores.length > 0,
    // 可选：覆盖全局默认值
    staleTime: 5 * 60 * 1000,
    gcTime: 60 * 60 * 1000,
  });
}
```

> 你之前已经有 `priceApi.getTrend`，这里直接复用即可。

---

## 4) 页面示例：客户端组件中使用

**新增：`src/app/price-trend-demo/page.tsx`（最小可跑 Demo 页）**

```tsx
"use client";

import { useState } from "react";
import { usePriceTrend } from "@/features/price-trend/queries";

export default function PriceTrendDemoPage() {
  const [gameId, setGameId] = useState("wukong");
  const [stores, setStores] = useState<string[]>(["Steam", "Epic"]);

  const { data, isLoading, error, refetch } = usePriceTrend(gameId, stores);

  return (
    <div className="p-4 space-y-3">
      <div className="flex gap-2 items-center">
        <input
          value={gameId}
          onChange={(e) => setGameId(e.target.value)}
          placeholder="gameId"
          className="border px-2 py-1 rounded"
        />
        <button
          // 复杂逻辑上一行注释：演示手动刷新（一般可不需要，TanStack 会按策略自动刷新）
          onClick={() => refetch()}
          className="px-3 py-1 rounded border"
        >
          Refresh
        </button>
      </div>

      {isLoading && <div>加载中...</div>}
      {error && (
        <div className="text-red-600">出错了：{(error as any)?.message}</div>
      )}

      <pre className="bg-gray-100 p-3 rounded text-sm overflow-auto">
        {JSON.stringify(data, null, 2)}
      </pre>
    </div>
  );
}
```

> 想接上图表时，把 `data` 交给你的图表组件即可；后续可以把 `stores` 做成可搜索多选，与你主页筛选一致。

---

## 可选：SSR 预取（以后再加）

最小集成里我们**不做 SSR**，直接用客户端渲染即可；若将来需要 SSR/Hydration，可用 `@tanstack/react-query` 的 `dehydrate/hydrate` 在 Server Component 里预取数据、在 Client 端复水。等你需要时我再给“最小 SSR 版本”的差异补丁即可。

下面给你**Vue 3 最小可用示例**（基于 `@tanstack/vue-query`，不改你的 http 封装与 `priceApi`）。只包含**必要的新文件/改动**；复杂逻辑已在上一行加注释。

---

### 1) 安装

```bash
pnpm add @tanstack/vue-query
# 可选：开发工具
pnpm add -D @tanstack/vue-query-devtools
```

---

### 2) 全局注册 Vue Query 插件

**新增：`src/plugins/vue-query.ts`**

```ts
// 复杂逻辑上一行注释：创建全局 QueryClient，设定默认缓存/重试策略
import {
  QueryClient,
  VueQueryPlugin,
  type VueQueryPluginOptions,
} from "@tanstack/vue-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 复杂逻辑上一行注释：5 分钟内视为新鲜，避免频繁请求
      staleTime: 5 * 60 * 1000,
      // 复杂逻辑上一行注释：失败自动重试 2 次，指数退避
      retry: 2,
      // 聚焦窗口时不强制刷新（按需可改为 true）
      refetchOnWindowFocus: false,
    },
  },
});

export function installVueQuery(app: import("vue").App) {
  const options: VueQueryPluginOptions = { queryClient };
  app.use(VueQueryPlugin, options);
  // 可选：开发工具
  // if (import.meta.env.DEV) {
  //   const { VueQueryDevtools } = await import('@tanstack/vue-query-devtools')
  //   app.use(VueQueryDevtools, { initialIsOpen: false })
  // }
}
```

**修改：`src/main.ts`（只贴需要新增的行）**

```ts
import { createApp } from "vue";
import App from "./App.vue";

// + 新增：注册 Vue Query 插件
import { installVueQuery } from "@/plugins/vue-query";

const app = createApp(App);
installVueQuery(app);
app.mount("#app");
```

---

### 3) 查询 Hook（Composable）

**新增：`src/features/price-trend/usePriceTrend.ts`**

```ts
// 复杂逻辑上一行注释：以业务语义封装 useQuery，统一 queryKey 与调用的 API
import { useQuery } from "@tanstack/vue-query";
import { priceApi } from "@/api/modules/price";

export function usePriceTrend(gameId: string, stores: string[]) {
  return useQuery({
    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参
    queryKey: ["priceTrend", gameId, stores],
    // 复杂逻辑上一行注释：交给领域 API，返回 Promise
    queryFn: () => priceApi.getTrend({ gameId, stores }),
    // 复杂逻辑上一行注释：参数不全时不发起请求
    enabled: Boolean(gameId) && stores.length > 0,
    // 可选：覆盖默认策略
    staleTime: 5 * 60 * 1000,
    gcTime: 60 * 60 * 1000,
  });
}
```

> 这里直接复用你已有的 `priceApi.getTrend`（基于 `http.call`）。

---

### 4) 最小页面示例（组件中使用）

**新增：`src/views/PriceTrendDemo.vue`**

```vue
<script setup lang="ts">
import { ref } from "vue";
import { usePriceTrend } from "@/features/price-trend/usePriceTrend";

const gameId = ref("wukong");
const stores = ref<string[]>(["Steam", "Epic"]);

const { data, isLoading, error, refetch } = usePriceTrend(
  gameId.value,
  stores.value
);
</script>

<template>
  <div class="p-4 space-y-3">
    <div class="flex gap-2 items-center">
      <input
        v-model="gameId"
        placeholder="gameId"
        class="border px-2 py-1 rounded"
      />
      <button class="px-3 py-1 rounded border" @click="refetch()">
        Refresh
      </button>
    </div>

    <div v-if="isLoading">加载中...</div>
    <div v-else-if="error" class="text-red-600">
      出错了：{{ (error as any)?.message }}
    </div>

    <pre class="bg-gray-100 p-3 rounded text-sm overflow-auto"
      >{{ JSON.stringify(data ?? null, null, 2) }}
    </pre>
  </div>
</template>
```

> 路由按你的项目来：例如在 `vue-router` 里把该组件挂到 `/price-trend-demo`。

---

#### 可选：当 `gameId/stores` 在页面中会变更时

把 `usePriceTrend(gameId.value, stores.value)` 改成**侦听式**：

```ts
const { data, isLoading, error, refetch } = usePriceTrend(
  // 复杂逻辑上一行注释：传入原始值即可；依赖变化时 useQuery 会按 key 缓存/重取
  gameId.value,
  stores.value
);
```

若你希望**自动**随着 `gameId/stores` 的变更而刷新，可在外层 `watch([gameId, stores], refetch)`；不过通常让 `queryKey` 变化即可自动生效（会根据 key 命中缓存或重新请求）。

---

### 5) 与你现有封装的关系

- **无需修改** `http.call` / `client.ts` / `cancel.ts`；Vue Query 只是把“请求何时发起、如何缓存/重试/并发合并”的**状态机**托管出去。
- 其他简单页面仍可直接用 `http.get/post` 或 `http.call`。把 **“读多写少、复用度高”的接口**（比如价格趋势、列表）逐步迁到 Vue Query 即可，**按需引入**、零破坏。

如果你需要 **SSR（Nuxt 3）** 的最小示例或 **分页/无限滚动** 的 Query 示例，我也可以在此基础上给出只含必要代码的增量补丁。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）"/>
        <updated>2025-09-05T16:25:03.000Z</updated>
        <content type="html"><![CDATA[
---

title: GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）
date: 2025-09-05
tags: \[Vue3, Ant Design Vue, 组件封装, v-model]

---

## 思路概述

- 用 `defineModel` 直接驱动 `a-checkbox-group` / `a-radio-group`，去掉中间层 `innerValue` 与 `watch`，减少响应式开销与同步复杂度。
- 加上 `defineOptions({ inheritAttrs: false })`，避免 attrs 同时落在根节点与 `a-*group` 上导致副作用。
- `Checkbox` 明确 `value` 为 **数组**，默认 `[]`；`Radio` 的 `value` 为任意，默认 `null`。

---

## 最简实现步骤

1. 删除 `innerValue` 与所有 `watch`。
2. 用 `const value = defineModel<...>('value', { default: ... })`，模板直接 `v-model:value="value"`。
3. 设置 `inheritAttrs: false`，并将 `attrs` 仅透传给 `a-*group`。

---

## 完整代码（Checkbox）

```vue
<template>
  <div
    class="gtc-checkbox"
    :class="[`gtc-checkbox-${size}`, disabled ? 'is-disabled' : '']"
  >
    <a-checkbox-group v-model:value="value" :disabled="disabled" v-bind="attrs">
      <slot />
    </a-checkbox-group>
  </div>
</template>

<script setup lang="ts">
import { useAttrs } from "vue";

// 复杂：避免 attrs 同时落到根节点与 a-checkbox-group
defineOptions({ inheritAttrs: false });

const attrs = useAttrs();

const props = defineProps({
  size: { type: String, default: "md" },
  disabled: { type: Boolean, default: false },
});

// 复杂：CheckboxGroup 期望数组；默认应为 []
const value = defineModel<any[]>("value", { default: [] });
</script>

<style lang="less" scoped>
.gtc-checkbox {
  .ant-checkbox-wrapper {
    color: var(--ink-950);
  }
  .ant-checkbox {
    &-inner {
      border-color: var(--rim-300);
      background: none;
      box-shadow: none;
    }
    &-checked .ant-checkbox-inner {
      background-color: var(--blue-primary);
      border-color: var(--blue-primary);
    }
    &:hover .ant-checkbox-inner {
      border-color: var(--ink-400);
    }
  }
}

.gtc-checkbox-sm .ant-checkbox-inner {
  width: 14px;
  height: 14px;
}
.gtc-checkbox-md .ant-checkbox-inner {
  width: 16px;
  height: 16px;
}
.gtc-checkbox-lg .ant-checkbox-inner {
  width: 18px;
  height: 18px;
}

.is-disabled {
  .ant-checkbox-inner {
    background: var(--ground-50);
    border-color: var(--rim-300);
  }
}
</style>
```

---

## 完整代码（Radio）

```vue
<template>
  <div
    class="gtc-radio"
    :class="[`gtc-radio-${size}`, disabled ? 'is-disabled' : '']"
  >
    <a-radio-group v-model:value="value" :disabled="disabled" v-bind="attrs">
      <slot />
    </a-radio-group>
  </div>
</template>

<script setup lang="ts">
import { useAttrs } from "vue";

// 复杂：避免 attrs 同时落到根节点与 a-radio-group
defineOptions({ inheritAttrs: false });

const attrs = useAttrs();

const props = defineProps({
  size: { type: String, default: "md" },
  disabled: { type: Boolean, default: false },
});

// 复杂：RadioGroup 接收单值；默认 null
const value = defineModel<any>("value", { default: null });
</script>

<style lang="less" scoped>
.gtc-radio {
  .ant-radio-wrapper {
    color: var(--ink-950);
  }
  .ant-radio-inner {
    border-color: var(--rim-300);
    background: none;
    box-shadow: none;
  }
  .ant-radio-checked .ant-radio-inner {
    border-color: var(--blue-primary);
  }
  .ant-radio-checked .ant-radio-inner::after {
    background-color: var(--blue-primary);
  }
  .ant-radio:hover .ant-radio-inner {
    border-color: var(--ink-400);
  }
}

.gtc-radio-sm .ant-radio-inner {
  width: 14px;
  height: 14px;
}
.gtc-radio-md .ant-radio-inner {
  width: 16px;
  height: 16px;
}
.gtc-radio-lg .ant-radio-inner {
  width: 18px;
  height: 18px;
}

.is-disabled {
  .ant-radio-inner {
    background: var(--ground-50);
    border-color: var(--rim-300);
  }
}
</style>
```

---

## 备注

- 现在两个组件都是\*\*“零 watch、零中间层”\*\*：父表单直接通过 `v-model:value` 与 antd 组件对齐；
- 与你表单规则的“复选框至少选一项”自定义校验配合使用即可（在 `getValidationRules` 里对 `checkbox` 做长度判断）。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 3 中的 `key`：强制重建、列表 Diff 与它为什么“换 key 就换生命”]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/Vue 3 中的 key：强制重建、列表 Diff 与它为什么“换 key 就换生命”</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/Vue 3 中的 key：强制重建、列表 Diff 与它为什么“换 key 就换生命”"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 摘要

`key` 在 Vue 3 里不仅仅用于 `v-for`。当我们在**同一个位置**渲染**同一种类型的节点/组件**时，只要 `key` 改变，Vue 会把它当作**全新的节点**处理：旧的被卸载（unmount），新的被创建并挂载（mount）。

## 一、核心用法速记

- **列表 Diff 标识**：`v-for` 时用 `:key` 唯一标识每一项，避免错误复用。
- **强制重建组件**：同一位置渲染相同组件，切换 `key` 会触发卸载+新建，从而清空内部状态与副作用。
- **配合 `Transition`/动画**：不同 `key` 驱动进入/离场。
- **避免状态串味**：表单、第三方控件、复杂内部 state 场景尤佳。

**示例（强制重置 `SLTPField`）：**

```vue
<!-- 复杂逻辑：用 tradeSide 作为 key，切换买/卖将卸载旧实例并创建新实例 -->
<SLTPField
  :key="`tp-${state.tradeSide}`"
  v-model="state.tpValue"
  :config="sltpConfig"
/>
```

## 二、为什么“换 key 就换生命”——框架底层怎么做的？

### 2.1 Diff 的入口与“同/不同节点”判定

- Vue 3 渲染更新的核心在 `patch(oldVNode, newVNode, container, …)`。
- **是否可复用**的第一步检查：**类型 + `key`**。

  - **类型相同且 `key` 相同** ⇒ 视为“同一个节点”，执行**就地更新**（props/children/patch）。
  - **类型不同或 `key` 不同** ⇒ 视为“不同节点”，**卸载旧的 → 挂载新的**。

- 组件也是节点（`type` 为组件选项/函数），因此**组件 `key` 变了 = 不是同一个组件实例**。

> 直观理解：Vue 用 `(type, key)` 这对“身份证”给每个 VNode 编号。身份证换了，就不是同一个人了；必须办离职（unmount）+新入职（mount）。

### 2.2 列表场景的“带 Key Diff”

- 子节点为数组时，Vue 3 进入 **`patchKeyedChildren`** 分支（带 Key 的比较）。
- 主要步骤（高层次）：

  1. **头尾双指针**：从两端向中间跳过相同 `type+key` 的项（O(n)）。
  2. **中段映射**：为新列表的剩余部分建立 `key → 索引` 映射，定位旧项在新列表中的位置。
  3. **构建“新索引数组”**：按旧列表顺序映射到新列表索引。
  4. **最长递增子序列（LIS）**：在“新索引数组”上求 LIS，**LIS 之外的需要移动或新建**，最少 DOM 移动。
  5. **卸载不存在于新列表的旧项**，**挂载新出现的项**。

- **结论**：`key` 是列表最小变更的锚点。缺失或错误的 `key` 会导致不必要的卸载/复用，出现“错位更新”“状态串味”。

### 2.3 单节点/同位置的“换 Key 强制重建”

- 不在列表、而是**同一个占位位置**渲染**相同类型**的组件/元素时：

  - `key` 不同 ⇒ `patch` 直接**判定不同节点** ⇒ 走**完全卸载**（销毁副作用、移除 DOM、触发生命周期/指令解绑）⇒ 再**创建新实例并挂载**（重新跑 `setup`/`onMounted` 等）。

- **副作用**：表单状态、内部 `ref`、watchers、计时器、第三方实例等全部被清空重来——这正是“重置”的本质。

---

## 三、这对我们有什么实际影响？

### 3.1 想“重置”子组件，就给它一个会变的 `key`

- 例如方向切换时，`SLTPField` 的默认区间、步长、校验逻辑可能随 `side` 不同。
- 用 `:key="state.tradeSide"` 最简单，**无需在子组件里写一堆重置逻辑**。

### 3.2 避免错误复用 & 状态污染

- `v-for` 场景必须用**稳定且唯一**的 `key`（如业务唯一 ID），不要用索引。
- 表单行交换、拖拽排序、切页缓存等，`key` 错了，会出现“值跟着 DOM 走”的诡异问题。

### 3.3 性能与正确性的权衡

- **频繁更换 `key` = 频繁销毁/重建**，有成本。
- 若只是 props 变化且**希望保留内部状态**，就不要改 `key`，让组件**就地更新**。

---

## 四、典型模式与反模式

### ✅ 推荐

- 列表：`v-for="item in list" :key="item.id"`
- 强制重建：`<Widget :key="mode" :config="cfg" />`
- 动画过渡：`<Transition> <Comp :key="step" /> </Transition>`

### ❌ 避免

- 用数组索引当 `key`（除非纯静态列表且不会重排）。
- 在需要保留内部状态的组件上滥用变更 `key`。

---

## 五、最小示例

```vue
<template>
  <div>
    <button @click="side = side === 'buy' ? 'sell' : 'buy'">
      切换方向：{{ side }}
    </button>

    <!-- 复杂逻辑：key 绑定 side，触发强制重建以重置内部状态 -->
    <PriceEditor :key="side" :side="side" />
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";
const side = ref<"buy" | "sell">("buy");
</script>
```

- `PriceEditor` 内部可能在 `onMounted` 里读取 `side` 计算初始值、建立订阅等。
- 当 `side` 改变时，`PriceEditor` 被**卸载**并**以新 props 新状态重建**。

---

## 六、和“响应式就地更新”有什么区别？

- **就地更新（同 key）**：组件实例 **不变**，只触发 `props`、`render`、`watch` 等更新，**内部状态保留**。
- **重建（换 key）**：旧实例 **销毁**，新实例 **创建**，生命周期完整走一遍，**内部状态重置**。

> 选择标准：**你是要“换皮”还是要“换命”**？
> 换皮 ⇒ 不改 `key`；换命 ⇒ 改 `key`。

---

## 七、与生态配合的注意点

- 第三方控件（图表、编辑器、地图）常有复杂内部状态，**改 key** 往往是最稳妥的“清场重来”。
- 但在**高频切换**或**大体量控件**场景，优先评估是否可以**参数化就地更新**以节流开销。

---

## 结论

- `key` 是 Vue 3 Diff 的**身份标签**。
- **类型一致 + `key` 一致** ⇒ 就地更新；**类型或 `key` 不一致** ⇒ 卸载重建。
- 正确使用 `key` 能避免列表错位、消除状态串味；在需要“重置组件”的场景，**改变 `key` 是最简单且可靠的办法**。

如需把上面的强制重建模式落到你的交易面板，只需保证：

```vue
<SLTPField :key="`tp-${state.tradeSide}`" ... />
<SLTPField :key="`sl-${state.tradeSide}`" ... />
```

即可在切换买/卖时，让两个子组件**以新方向的配置完全初始化**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理"/>
        <updated>2025-09-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 前言

在 Vue 3 项目中使用 Vue I18n 时，经常会遇到两种调用方式：`useI18n()` 和 `i18n.global.t`。  
它们在大多数场景下可以互换，但在涉及 **Portal 渲染**（如 `Modal.confirm`）时，行为却有明显差异。  
本文将精炼梳理其核心区别与原理，并给出解决方案。

## useI18n 与 i18n.global.t 的区别

### useI18n()

- 基于 **组合式 API**，通过 `provide/inject` 获取 i18n 实例。
- 默认是 **组件作用域**，依赖于组件树的注入链。
- 如果组件渲染在 **脱离应用上下文的 Portal** 中（如 `Modal.confirm`），注入链会断开，导致报错：**VUE_I18N_SYMBOL** 为 null

### useI18n({ useScope: 'global' })

- 强制取 **全局 i18n 实例**，等价于 `i18n.global`。
- 不依赖 `provide/inject`，在 Portal 场景下依然安全可用。
- 类型提示完整，开发体验较佳。

### i18n.global.t

- 直接调用全局实例上的 `t` 方法。
- 天然不受 Portal 的注入链影响，不会报错。
- 但在 TypeScript 中，由于 `i18n.global` 类型是 `Composer | VueI18n` 的联合类型，`.t` 方法签名不唯一，可能会报：This expression is not callable

- 需要通过 **类型断言** 或 **any** 绕过。

## 为什么有的报错，有的不报

- **报错场景**：
  使用 `useI18n()`（默认作用域）时，Portal 中的组件拿不到注入实例 → 报错。

- **不报错场景**：
- 使用 `useI18n({ useScope: 'global' })` → 绕过注入链。
- 或直接调用 `i18n.global.t` → 使用全局实例。

## TypeScript 报错原因与解决

### 原因

- `i18n.global` 的类型是 **联合类型**（`Composer | VueI18n`）。
- `.t` 方法在两者中定义不一致，TS 无法推断出唯一签名。

### 解决方式

1. **推荐**：使用 `useI18n({ useScope: 'global' })` → `t` 方法类型清晰。
2. **备选**：在 `i18n.global` 上加断言：

```ts
(i18n.global as any).t("key");
```

## 该如何选择

- **组件内部调用（推荐）**：
  使用 `useI18n({ useScope: 'global' })`，类型安全，语义清晰。

- **全局或工具函数调用**：
  直接用 `i18n.global.t`，搭配类型断言解决 TS 报错。

## 一句话总结

报错的根源在于 **Portal 渲染导致注入链断开**。
解决方法是 **改用全局 i18n**，从机制上绕过 `provide/inject` 的限制。
因此，最佳实践是：**组件内用 `useI18n({ useScope: 'global' })`，工具层用 `i18n.global.t`**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）"/>
        <updated>2025-09-06T14:49:38.000Z</updated>
        <content type="html"><![CDATA[
---

title: Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）
date: 2025-09-06
tags:

- Vue3
- TanStack Vue Query
- 分页
- 无限滚动

---

## 前提

已安装并在 `main.ts` 里注册了 `@tanstack/vue-query`（你之前那步已经完成）。下面示例直接复用你的 `http.call` 封装。

---

## 一、页码分页（page/pageSize）

### 1) 组合式函数：`usePagedItems.ts`

```ts
// src/features/demo/usePagedItems.ts
"use client";

import { ref } from "vue";
import { useQuery } from "@tanstack/vue-query";
import { http } from "@/lib/http";

// 复杂逻辑上一行注释：后端返回 PageResp 结构（list/total/page/pageSize）
type Item = { id: string; title: string };
type PageResp<T> = { list: T[]; total: number; page: number; pageSize: number };

// 复杂逻辑上一行注释：拉取某页数据的纯函数，便于测试与复用
async function fetchPage(
  page: number,
  pageSize: number
): Promise<PageResp<Item>> {
  return http.call<PageResp<Item>>({
    url: "/api/items",
    method: "GET",
    params: { page, pageSize },
  });
}

export function usePagedItems(initialPageSize = 20) {
  const page = ref(1);
  const pageSize = ref(initialPageSize);

  const query = useQuery({
    // 复杂逻辑上一行注释：将页码作为 queryKey 的一部分，命中不同页的缓存
    queryKey: () => ["items", page.value, pageSize.value],
    // 复杂逻辑上一行注释：当 page 或 pageSize 改变时，自动按新 key 请求/复用缓存
    queryFn: () => fetchPage(page.value, pageSize.value),
    staleTime: 60_000,
    keepPreviousData: true, // 复杂逻辑上一行注释：翻页时保留上一页数据，避免闪烁
  });

  // 复杂逻辑上一行注释：对外暴露翻页方法
  const next = () => {
    page.value += 1;
  };
  const prev = () => {
    page.value = Math.max(1, page.value - 1);
  };
  const setPage = (p: number) => {
    page.value = Math.max(1, p);
  };

  return { page, pageSize, ...query, next, prev, setPage };
}
```

### 2) 组件示例：`PagedList.vue`

```vue
<!-- src/views/PagedList.vue -->
<script setup lang="ts">
import { usePagedItems } from "@/features/demo/usePagedItems";

const { data, isFetching, error, page, next, prev } = usePagedItems(10);
</script>

<template>
  <div class="p-4 space-y-3">
    <div class="flex items-center gap-2">
      <button class="border px-3 py-1 rounded" @click="prev">上一页</button>
      <span>第 {{ page }} 页</span>
      <button class="border px-3 py-1 rounded" @click="next">下一页</button>
    </div>

    <div v-if="isFetching">加载中...</div>
    <div v-else-if="error" class="text-red-600">
      出错：{{ (error as any)?.message }}
    </div>

    <ul v-else class="list-disc pl-5">
      <li v-for="it in data?.list ?? []" :key="it.id">{{ it.title }}</li>
    </ul>
  </div>
</template>
```

---

## 二、无限滚动（cursor/nextCursor）

### 1) 组合式函数：`useInfiniteItems.ts`

```ts
// src/features/demo/useInfiniteItems.ts
"use client";

import { computed } from "vue";
import { useInfiniteQuery } from "@tanstack/vue-query";
import { http } from "@/lib/http";

type Item = { id: string; title: string };
// 复杂逻辑上一行注释：后端返回游标结构（items + nextCursor），没有更多时 nextCursor 为空/undefined
type CursorResp<T> = { items: T[]; nextCursor?: string | null };

async function fetchByCursor(
  cursor: string | null,
  limit: number
): Promise<CursorResp<Item>> {
  // 复杂逻辑上一行注释：第一页用 null/空串，后续带上 nextCursor
  return http.call<CursorResp<Item>>({
    url: "/api/items/cursor",
    method: "GET",
    params: { cursor, limit },
  });
}

export function useInfiniteItems(limit = 20) {
  const q = useInfiniteQuery({
    queryKey: ["items-infinite", limit],
    // 复杂逻辑上一行注释：pageParam 是上一次 getNextPageParam 返回的值；第一页由 initialPageParam 提供
    queryFn: ({ pageParam }) => fetchByCursor(pageParam ?? null, limit),
    initialPageParam: null as string | null,
    // 复杂逻辑上一行注释：从返回值中取下一页的游标；无则表示到底
    getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,
    staleTime: 60_000,
  });

  // 复杂逻辑上一行注释：将多页的 items 扁平合并，便于组件直接渲染
  const flatItems = computed(
    () => q.data.value?.pages.flatMap((p) => p.items) ?? []
  );

  return { ...q, flatItems };
}
```

### 2) 组件示例（IntersectionObserver 自动触底加载）：`InfiniteList.vue`

```vue
<!-- src/views/InfiniteList.vue -->
<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from "vue";
import { useInfiniteItems } from "@/features/demo/useInfiniteItems";

const { flatItems, isFetchingNextPage, hasNextPage, fetchNextPage, error } =
  useInfiniteItems(15);

const sentinel = ref<HTMLDivElement | null>(null);
let observer: IntersectionObserver | null = null;

onMounted(() => {
  // 复杂逻辑上一行注释：使用 IntersectionObserver 观察“页尾哨兵”，进入视口即加载下一页
  observer = new IntersectionObserver(
    (entries) => {
      const e = entries[0];
      if (e.isIntersecting && hasNextPage.value && !isFetchingNextPage.value) {
        fetchNextPage();
      }
    },
    { root: null, rootMargin: "0px", threshold: 0.1 }
  );

  if (sentinel.value) observer.observe(sentinel.value);
});

onBeforeUnmount(() => {
  if (observer && sentinel.value) observer.unobserve(sentinel.value);
  observer = null;
});
</script>

<template>
  <div class="p-4 space-y-3">
    <div v-if="error" class="text-red-600">
      出错：{{ (error as any)?.message }}
    </div>

    <ul class="space-y-2">
      <li v-for="it in flatItems" :key="it.id" class="border rounded p-2">
        {{ it.title }}
      </li>
    </ul>

    <!-- 复杂逻辑上一行注释：页尾“哨兵”元素，用于触发下一页加载 -->
    <div
      ref="sentinel"
      class="h-8 flex items-center justify-center text-gray-500"
    >
      <span v-if="isFetchingNextPage">加载更多...</span>
      <span v-else-if="!hasNextPage">没有更多了</span>
      <span v-else>下拉加载</span>
    </div>

    <!-- 兜底：手动加载更多按钮（可选） -->
    <div class="text-center">
      <button
        class="mt-2 border px-3 py-1 rounded"
        :disabled="!hasNextPage || isFetchingNextPage"
        @click="fetchNextPage()"
      >
        {{
          isFetchingNextPage
            ? "加载中…"
            : hasNextPage
            ? "加载更多"
            : "没有更多了"
        }}
      </button>
    </div>
  </div>
</template>
```

---

## 关键点与小贴士

- **keepPreviousData**：页码分页时避免闪屏；无限滚动用 `useInfiniteQuery` 不需要它。
- **queryKey 设计**：把影响结果的入参（如 `page/pageSize`、`limit/filters`）放进 key，缓存才可命中。
- **getNextPageParam**：返回 `undefined` 代表“没有下一页”；返回游标字符串（或对象）将作为下一次 `pageParam` 传入。
- **触底加载**：`IntersectionObserver` 比 `scroll` 事件更稳、成本更低；确保有合理的 `rootMargin/threshold`。
- **错误重试**：默认会自动重试 2 次（取决于你的全局设置）。对幂等读接口通常是安全的。

需要我把这两个 Demo 接到你现有的某个真实接口（比如你“价格趋势”或“攻略列表”）上，我可以直接给**最小改动的代码片段**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/Vue/Vue3 计算属性的依赖收集（以 selectedAccount 为例，超细颗粒度）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/Vue3 计算属性的依赖收集（以 selectedAccount 为例，超细颗粒度）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/Vue3 计算属性的依赖收集（以 selectedAccount 为例，超细颗粒度）"/>
        <updated>2025-09-18T17:26:53.125Z</updated>
        <content type="html"><![CDATA[````markdown
---
title: Vue3 计算属性的依赖收集（以 selectedAccount 为例，超细颗粒度）
date: 2025-09-11
tags: [Vue3, reactivity, computed, ref, reactive, 数组依赖, 对象依赖]
---

## 1. 目标场景回顾

我们有一个计算属性：

```ts
const selectedAccount = computed(
  () =>
    (accountList.value ?? []).find(
      (a) => a.loginid === selectedLoginid.value
    ) ?? null
);
```
````

问题：当**只修改选中行的其它字段**（如 `equity/balance/...`）时，为什么 **UI 会更新**，但 `computed` **不一定重新求值**？

---

## 2. Vue3 依赖收集是“所读即所依”

计算属性在**执行 getter 的那一刻**，会对**被读取的响应式源**建立依赖；**只有这些依赖发生变化**时，计算属性才会被标记为脏，从而在下次读取时重新求值。

### 2.1 常见响应式源与依赖粒度

- **`ref`**：访问 `.value` 建立依赖（例如 `selectedLoginid.value`）。
- **`reactive`/`ref` 包裹的对象**：访问 **某个属性** 时，以“对象 + 属性键”为依赖（例如读取 `row.loginid`）。
- **数组（`reactive`/`ref` 的数组）**：

  - 访问 **`length`** 会对 `length` 建依赖（影响 push/pop 等修改）。
  - **按索引读取**（`arr[i]`）会对该 **索引键** 建依赖。
  - **遍历/查找类方法**（如 `for...of`、`map`、`find` 等）通常会对**迭代键**和**相关索引**建依赖；在遍历过程中，若读取了元素对象的某些属性，也会对这些**属性键**建立依赖（见 2.3）。

- **Map/Set 等集合**：遍历时依赖“迭代键”（内部用 `ITERATE_KEY` 追踪）。

> 要点：**只对“读取过”的键建立依赖**；没读到的字段**不会**成为依赖。

### 2.2 `selectedAccount` 的依赖具体有哪些？

执行 `find()` 的过程中，会读取：

1. `selectedLoginid.value` —— 对这个 `ref` 的 `.value` 建依赖；
2. `accountList.value` —— 对 **数组引用/长度/迭代** 建依赖；
3. `a.loginid` —— 对**参与比较的那些元素**的 `loginid` 属性建依赖（直到找到命中的那一个或遍历结束）。

> 注意：此 getter **没有读取** `a.equity/balance/...`，所以**不会**对这些字段建依赖。

### 2.3 “读取时才变成响应式”的懒代理

当 `accountList.value` 是一个响应式数组，**访问数组元素 `a = arr[i]` 时**，Vue 会对该元素对象做**懒代理**（即在 `get` 拦截时把它包装为响应式代理）。此后读取 `a.loginid` 就会被**精确追踪**为“元素对象的 `loginid` 属性依赖”。

---

## 3. 为什么只改 `equity` 也能让 UI 更新？

- 模板或其它计算/侦听，在渲染时**单独读取**了 `selectedAccount.value?.equity`，因而对“**选中行对象的 `equity` 属性**”建立了依赖。
- 当你执行：

  ```ts
  // 原地修改选中行的对象字段
  selectedRow.equity = newEquity;
  ```

  由于这是 **被依赖的属性本身**，视图会**立即更新**。

- 但 `selectedAccount` 这个 **computed** 的 getter **并没有读取 `equity`**，所以它**不需要**重新求值；返回值（选中行对象的**同一引用**）保持不变，模板依旧能看到它的内部字段变化。

> 结论：**UI 更新**是因为模板对 `equity` 建立了依赖；**computed 不重算**是因为 getter 没依赖 `equity`。

---

## 4. 哪些变更会让 `selectedAccount` 重新求值？

- ✅ `selectedLoginid.value` 改变（切换了要找的 id）。
- ✅ `accountList.value` **换了新引用**（例如 `accountList.value = [...accountList.value]`）。
- ✅ 数组结构变化影响到依赖（如 `length` 变化、迭代相关变更）。
- ✅ 参与比较的元素的 **`loginid` 字段**改变，或该元素对象被**整体替换为新对象**。
- ❌ 只改**匹配元素的其它字段**（`equity/balance/...`），且**不换数组引用** —— **不会**触发 `selectedAccount` 重算，但模板会更新相应单元格。

---

## 5. 最简代码验证（逐步演示）

### 5.1 基础：只改其它字段，computed 不重算但 UI 会变

```ts
const selectedLoginid = ref("a1");
const accountList = ref([
  { loginid: "a1", equity: 100 },
  { loginid: "a2", equity: 200 },
]);

const selectedAccount = computed(
  () =>
    accountList.value.find((a) => a.loginid === selectedLoginid.value) ?? null
);

// ✅ 模板读取 selectedAccount?.equity → 对 “a1.equity” 建依赖
// 改 equity（不换数组引用），UI 会更新；computed 不一定重算（引用不变）
accountList.value[0].equity = 120;
```

### 5.2 换数组引用触发表格类重算（排序/分组等）

```ts
// 在复杂逻辑上一行加注释：原地改字段后，若还需触发表格模型重算，再“换数组引用”
accountList.value[0].equity = 130;
accountList.value = accountList.value.slice();
```

### 5.3 替换对象会让 computed 重算（因为命中的那一项换了引用）

```ts
// 在复杂逻辑上一行加注释：替换命中元素对象 → getter 要重新 .find()，computed 重算
const idx = accountList.value.findIndex((a) => a.loginid === "a1");
accountList.value.splice(idx, 1, { loginid: "a1", equity: 999 });
```

### 5.4 仅切换 loginid，一定重算

```ts
// 在复杂逻辑上一行加注释：selectedLoginid 变化是显式依赖，computed 一定重算
selectedLoginid.value = "a2";
```

---

## 6. 数组与对象的依赖“表格”

| 读取操作（在 getter 内）                    | 建立的依赖键                       | 哪些更新会触发重算                      |
| ------------------------------------------- | ---------------------------------- | --------------------------------------- |
| `selectedLoginid.value`                     | 该 `ref` 的 `value`                | 任何对 `selectedLoginid.value` 的修改   |
| `accountList.value`（拿到数组引用）         | 数组 `value` 引用、`length`/迭代键 | 换数组引用、`push/pop/splice`、长度变更 |
| `accountList.value[i]`                      | 数组索引 `i`                       | 替换该索引处元素、数组结构影响该索引    |
| `a.loginid`（查找时访问的元素属性）         | **元素对象的 `loginid` 属性**      | 改变该属性、或把该元素整体替换为新对象  |
| 未读取的字段（如 `a.equity` / `a.balance`） | **不会**建立依赖                   | 改这些字段**不会**让 computed 重算      |

> 模板/其它 computed/侦听如果单独读取了 `a.equity`，它们**会**对 `equity` 建依赖，从而在你改 `equity` 时更新 UI。

---

## 7. 实战建议（与表格场景结合）

1. **selectedAccount 只做“指向哪一行”**：通过 `loginid + accountList` 定位对象引用即可，不要在 getter 里读取无关字段，避免不必要重算。
2. **更新选中行的业务字段**（如盈亏、净值）：

   - 只需 **原地改对象字段**，UI 就会变。
   - 若还需要**触发表格模型重算**（排序/分组/聚合），在修改后**再换一次数组引用**：

     ```ts
     // 在复杂逻辑上一行加注释：需要触发表格重算时再换数组引用
     Object.assign(accountList.value[idx], patch);
     accountList.value = accountList.value.slice();
     ```

3. **避免错误写法**：不要让 `selectedAccount` 变成可写的 `ref` 并随行情去 `Object.assign(selectedAccount.value, ...)`；保持它是**纯派生**，杜绝引用抖动。
4. **高频更新时合批**：把多次行情更新合并到一帧内，再一次性换数组引用，减小重算与渲染负担。

---

## 8. 一句话总结

- computed **只会**对 getter **读到的键**建立依赖；
- 模板单独读取的字段，会建立**它自己的依赖**；
- **只改选中行的其它字段** ⇒ UI 更新，但 `selectedAccount` 不一定重算；
- **需要表格重排/聚合** ⇒ 修改后再“**换数组引用**”。

如果你愿意，把你当前的 `selectedAccount` 与“盈亏更新”两段代码贴上来；我只改**必要的几行**，并在复杂逻辑上一行加注释，帮你做到“UI 跟随变、computed 不抖动、表格按需重算”。

```
::contentReference[oaicite:0]{index=0}
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue项目pinia中的Store中的请求时机管理]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/Vue项目请求处理优化</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/Vue项目请求处理优化"/>
        <updated>2025-09-05T18:07:15.000Z</updated>
        <content type="html"><![CDATA[
现在的我的 vue+vite+pinia 项目有个问题，我的有些请求，我在 store 中就直接调用，但 store 的执行时机很早，这时用户可能没有登录，发出这些需要 token 的请求是不合适的，但如果我们把请求放到具体页面中，那每个页面都要请求，违背了我们放入 store 中的初衷，如何处理？

**核心结论**：

> **把“请求放在 Store”与“何时触发请求”解耦**。
> 数据仍由 Pinia Store 管，但所有“首次加载/刷新”的触发统一由**受保护布局(ProtectedLayout)**或**集中启动钩子**在“已登录且当前路由需要鉴权”时一次性触发。
> 请求层（Axios 封装）负责：自动带 Token、401 统一刷新/重试、（可选）对标记 `auth` 的请求在无 Token 时直接拒绝。

## 路由：只给受保护页面打上 `requiresAuth`

**修改位置：`src/router/index.ts`**

```ts
// 在需要登录的路由上增加 meta.requiresAuth
{
  path: '/dashboard',
  name: 'dashboard',
  component: () => import('@/pages/dashboard/index.vue'),
  meta: { requiresAuth: true }
}
```

## 受保护布局：只在“已登录 && 受保护路由”时触发各 Store 的初始化

**新增文件：`src/composables/useAppBootstrap.ts`**

```ts
import { watch } from "vue";
import { useRouter } from "vue-router";
import { useAuthStore } from "@/stores/auth";
import { useUserStore } from "@/stores/user";
import { useXStore } from "@/stores/x"; // 你的其他数据模块按需引入

export function useAppBootstrap() {
  const router = useRouter();
  const auth = useAuthStore();
  const user = useUserStore();
  const x = useXStore();

  // 复杂逻辑：仅在“已登录 && 当前路由需要鉴权”时做一次性初始化（可幂等）
  watch(
    [
      () => auth.isAuthenticated,
      () => router.currentRoute.value.meta.requiresAuth,
    ],
    async ([ok, need]) => {
      if (ok && need) {
        // 复杂逻辑：各 store 的 init() 必须“幂等”，重复调用不重复发请求
        await Promise.all([user.init(), x.init()]);
      }
    },
    { immediate: true }
  );
}
```

**在你的受保护布局/根布局里调用（例如 `src/layouts/ProtectedLayout.vue`）**：

```ts
// <script setup>
// 复杂逻辑：在受保护布局挂载时调用集中引导
import { useAppBootstrap } from "@/composables/useAppBootstrap";
useAppBootstrap();
// </script>
```

> 如果你没有单独的布局文件，可以在 `App.vue` 里根据 `route.meta.requiresAuth` 切出一个“受保护区域”再调用 `useAppBootstrap()`。

---

## Store：移除“定义即请求”的副作用，提供幂等 `init()`

**修改位置：`src/stores/user.ts`（示例）**

```ts
// 删除：顶层的立即请求（例如 defineStore 里一创建就 fetch 的代码）

// 新增：幂等 init()
let _initPromise: Promise<void> | null = null;

export const useUserStore = defineStore("user", () => {
  const profile = ref<User | null>(null);

  // 复杂逻辑：单例 Promise，保证多处调用只触发一次真实请求
  async function init() {
    if (_initPromise) return _initPromise;
    _initPromise = (async () => {
      if (profile.value) return;
      const { data } = await http.get("/me", { meta: { auth: true } });
      profile.value = data;
    })();
    return _initPromise;
  }

  // 可选：在登出时清理，便于下次重新 init
  function reset() {
    profile.value = null;
    _initPromise = null;
  }

  return { profile, init, reset };
});
```

> 你的其他 Store（如 `x.ts`、`projects.ts` 等）都按这个\*\*“删除副作用 + 提供幂等 init()”\*\*的模式改一遍。

---

## 请求层：自动带 Token、401 统一刷新并队列重试、无 Token 阻断受保护请求

**修改位置：`src/http/axios.ts`（或你的请求封装文件）**

**（1）扩展 Axios 类型，支持 `meta.auth` 与 `_retry`**

```ts
// 复杂逻辑：为请求增加自定义元信息与重试标记
declare module "axios" {
  export interface AxiosRequestConfig {
    meta?: { auth?: boolean };
    _retry?: boolean;
  }
}
```

**（2）请求拦截：自动加 Authorization；无 Token 且需要鉴权时直接拒绝**

```ts
import axios from "axios";
import { useAuthStore } from "@/stores/auth";
import router from "@/router";

export const http = axios.create({ baseURL: import.meta.env.VITE_API_BASE });

http.interceptors.request.use((config) => {
  const auth = useAuthStore();

  // 复杂逻辑：仅对标记了 meta.auth 的请求自动带 token
  if (config.meta?.auth) {
    if (!auth.token) {
      // 复杂逻辑：阻断未登录时的鉴权请求（避免在 /user/login 等页面误发）
      return Promise.reject(new Error("AUTH_REQUIRED"));
    }
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${auth.token}`,
    };
  }
  return config;
});
```

**（3）响应拦截：统一处理 401，带刷新队列（避免并发多次刷新）**

```ts
let refreshing = false;
let waitQueue: Array<() => void> = [];

http.interceptors.response.use(
  (r) => r,
  async (error) => {
    const auth = useAuthStore();
    const { response, config } = error || {};
    if (response?.status === 401 && config && !config._retry) {
      // 复杂逻辑：给当前请求打 _retry，防止递归
      config._retry = true;

      if (!refreshing) {
        refreshing = true;
        try {
          await auth.refreshToken(); // 你在 auth store 中实现这个方法
          refreshing = false;
          // 复杂逻辑：刷新成功后，放行所有队列中的请求
          waitQueue.splice(0).forEach((fn) => fn());
          return http(config);
        } catch (e) {
          refreshing = false;
          // 复杂逻辑：刷新失败，清空队列并跳转登录
          waitQueue.splice(0).forEach((fn) => fn());
          auth.logout();
          router.replace({
            name: "login",
            query: { redirect: router.currentRoute.value.fullPath },
          });
          return Promise.reject(e);
        }
      }

      // 复杂逻辑：如果正在刷新，把当前请求加入队列，等待刷新完成后重试
      return new Promise((resolve, reject) => {
        waitQueue.push(() => http(config).then(resolve).catch(reject));
      });
    }
    return Promise.reject(error);
  }
);
```

---

## Auth Store：提供 `isAuthenticated`、`refreshToken()`、`logout()`

**修改位置：`src/stores/auth.ts`**

```ts
export const useAuthStore = defineStore("auth", () => {
  const token = ref<string | null>(null);
  const refresh = ref<string | null>(null);

  // 复杂逻辑：派生登录态，集中判断是否有有效 token
  const isAuthenticated = computed(() => !!token.value);

  async function setToken(t: string, r?: string) {
    token.value = t;
    if (r) refresh.value = r;
  }

  async function refreshToken() {
    // 复杂逻辑：用 refresh_token 换新 token，失败则抛错
    const { data } = await axios.post("/auth/refresh", {
      refresh_token: refresh.value,
    });
    token.value = data.access_token;
    refresh.value = data.refresh_token ?? refresh.value;
  }

  function logout() {
    token.value = null;
    refresh.value = null;
    // 复杂逻辑：通知其他 store 清空并重置 init()
    useUserStore().reset();
    // 其他 store 同理按需 reset()
  }

  return { token, isAuthenticated, setToken, refreshToken, logout };
});
```

---

## 登录成功后：只需设置 token 并跳转，初始化会自动发生

**修改位置：`/user/login` 提交成功回调处**

```ts
// 复杂逻辑：写入 token 并跳到受保护路由；受保护布局会自动触发所有 store.init()
await authStore.setToken(res.access_token, res.refresh_token);
router.replace((route.query.redirect as string) || "/");
```

---

## 为什么这是“最佳做法”

1. **单一职责清晰**：Store 只做“状态与方法”，不在定义期发请求；“什么时候发”交给受保护布局的引导钩子统一触发。
2. **避免重复请求**：`init()` 使用**单例 Promise**，多次调用只会发一次请求。
3. **页面无侵入**：页面无需关心是否登录、是否首发，页面只消费 Store 的 state。
4. **错误集中处理**：401 统一刷新与队列重试，避免因并发导致多次刷新或脏状态。
5. **登录页零干扰**：登录页不再误发需要 Token 的请求；即使误调，Axios 层也会拦截并拒绝。
6. **易扩展**：新增数据域时，只需在受保护引导中 `store.init()` 一行接入。

---

如果你愿意，我可以基于你当前的目录结构，把上述“幂等 init + 受保护布局引导 + Axios 刷新队列”的改动**逐个落到你的具体文件**（只贴需要改的片段）。你把相关文件名和关键片段贴给我就行。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[<专题导言：描述系列价值与对象>]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/vue-系列导言</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/vue-系列导言"/>
        <updated>2025-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<系列摘要与读者收益>]]></summary>
        <content type="html"><![CDATA[
## 系列对象与前置

- 适合谁？需要什么前置知识？

## 目录与进度

- [第 1 篇：主题 A](/posts/...) —— 进度：✅/进行中
- [第 2 篇：主题 B](/posts/...)

## 学习方式

- 推荐阅读顺序
- 配套 Demo/最小复现仓库

## 常见问题

- FAQ 1
- FAQ 2
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/Vue/为什么“动态导入模块”用 import()，而“异步组件”用 defineAsyncComponent]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/为什么“动态导入模块”用 import()，而“异步组件”用 defineAsyncComponent</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/为什么“动态导入模块”用 import()，而“异步组件”用 defineAsyncComponent"/>
        <updated>2025-09-18T17:26:53.126Z</updated>
        <content type="html"><![CDATA[# 为什么“动态导入模块”用 `import()`，而“异步组件”用 `defineAsyncComponent(() => import(...))`

> `import()` 是 **ES 模块层** 的动态加载原语，返回的是“**模块对象的 Promise**”；
> `defineAsyncComponent` 是 **Vue 运行时** 的“组件包装器”，把“**模块 Promise**”包装成“**可挂载的组件**”，并内建了 **加载占位、错误重试、超时、Suspense 协作** 等逻辑。

## 1. 两种写法长什么样？

- 动态导入任意模块（业务逻辑、工具库等）：

  ```ts
  const mod = await import("./math");
  mod.add(1, 2);
  ```

- 动态导入一个 **Vue 组件** 并让它参与渲染：

  ```ts
  import { defineAsyncComponent } from "vue";
  const UserCard = defineAsyncComponent(() => import("./UserCard.vue"));
  // 在模板中：<UserCard />
  ```

为什么渲染组件不能直接写 `component: () => import('./UserCard.vue')` 呢？
因为渲染器需要一个“**同步的组件定义**”（或一个可被渲染器识别的 **异步组件包装**），而不是“裸的 Promise”。`defineAsyncComponent` 就是把 **Promise → 组件** 的这层桥梁补上了。

## 2. `import()` 做了什么？（模块层）

- 语义：**运行时** 才决定要不要加载某个 ESM 模块。
- 返回：`Promise<ModuleNamespace>`（一个模块命名空间对象，通常使用 `m.default` 拿到默认导出）。
- 构建：Vite/rollup 会把 `import('./Foo.vue')` **自动代码分割**成一个独立的 chunk（按需网络请求）。
- 缓存：同一个模块只会真正加载一次；后续调用拿到的是已解析模块的 **同一个实例**。
- 作用域：**只负责拉取模块**，并不能告诉 Vue “这东西是组件、怎么渲染、加载失败怎么办”。

## 3. `defineAsyncComponent` 做了什么？（Vue 运行时）

把“**模块 Promise**”包装成“**可渲染的组件**”，它提供：

1. **组件识别**：返回一个“组件定义对象”（内部实现上相当于一个特殊的组件），能被渲染器识别并挂载。
2. **生命周期钩子**：在首次渲染时才触发 `loader()`（也就是 `import()`），**首屏更小**。
3. **占位/错误/超时**：

   - `loadingComponent`：加载时展示的骨架/占位 UI；
   - `errorComponent`：加载失败时展示的兜底 UI；
   - `delay`：延时后再显示 loading，避免闪一下；
   - `timeout`：超时抛错；
   - `onError(retry, fail, retries)`：自定义重试策略（如指数退避）。

4. **Suspense 协作**（Vue 3）：

   - 在 `<Suspense>` 容器中，异步组件会 **挂起**，直到加载完成再统一展示。

5. **并发去重与缓存**：

   - 同一异步组件在多个地方同时首次渲染，只会触发 **一次 loader**；
   - 卸载后不会卸载 chunk，后续再次渲染是 **同步命中缓存**，不再闪 loading。

6. **SSR 支持**：

   - 服务器端渲染会预解析异步组件，客户端 hydration 不会二次请求。

**核心结论**：`defineAsyncComponent` 是 **Vue 层的能力补全**，用来把“**模块加载**”转成“**组件渲染**”这件事做完整（状态、占位、错误、Suspense、SSR 一条龙）。

---

## 4. 底层过程对比：从“写代码”到“浏览器运行”

### 4.1 代码分割与网络请求（Vite/rollup 层）

- 出现 `import('./X.vue')` 时，构建器会：

  - 为 `X.vue` 产出一个 **独立 chunk**（比如 `X-xxxx.js`）；
  - 主包在运行到这行时，会发出 **一次网络请求**去拉这个 chunk；
  - 拉到后执行该 chunk，得到模块对象（含 `default` 导出的组件选项对象）。

### 4.2 Vue 渲染调度（运行时层）

- 组件树首次渲染到 `defineAsyncComponent(loader)` 节点：

  - 调用 `loader()`（就是你的 `import()`）；
  - 若有 `<Suspense>`，会“挂起”，直到 Promise 成功；
  - 若配置了 `loadingComponent`，在 `delay` 毫秒后展示它；
  - 加载失败 → `errorComponent` 或触发 `onError`，可决定是否重试；
  - 成功后把 `m.default` 当作 **真正的子组件** 去渲染，**后续渲染都是同步**。

---

## 5. 为什么不能直接把 `() => import('./Comp.vue')` 当组件用？

技术上，Vue 2 曾支持“工厂函数式异步组件”（`resolve => require(['./Comp'], resolve)`）。
Vue 3 统一了异步组件入口，**标准方式就是 `defineAsyncComponent`**。
直接把 `() => import()` 当组件传入时，Vue 无法得知：

- 这是组件还是普通模块？
- 加载未完成期间该显示什么？
- 错误如何处理与重试？
- 如何与 Suspense 协作？
- SSR/水合如何对齐？

`defineAsyncComponent` 把这一切补齐并稳定下来。

---

## 6. 结合你的 MFA 场景：该怎么选？

你的场景里既有 **服务层的验证器模块**（逻辑），也有 **UI 层的验证器组件**（展示与交互）：

- **服务层（verifier 逻辑）**
  用 **裸 `import()`** 即可（或 `import.meta.glob` 批量映射）。
  例：

  ```ts
  registerVerifier("biometric_validate", () =>
    import("./verifiers/webauthn").then((m) => m.default ?? m)
  );
  ```

  好处：

  - 纯逻辑模块，不牵涉渲染；
  - 更灵活的并发/预热策略（按需、条件触发、预测性预加载）。

- **UI 层（每种验证器对应一个 Vue 组件）**
  用 **`defineAsyncComponent(() => import('./ui-verifiers/Xxx.vue'))`**。
  例：

  ```ts
  const SmsVerifier = defineAsyncComponent(
    () => import("./ui-verifiers/SmsVerifier.vue")
  );
  ```

  好处：

  - 有 loading/error 占位（用户体验友好）；
  - 与 `<Suspense>`、SSR 配合；
  - 多处同时渲染时只触发一次加载。

- **可选的预热（提前拉 chunk）**
  当你从后端拿到 `steps` 后，可以“预热”可能要用到的 **逻辑模块** 和 **UI 组件**：

  ```ts
  // 预热逻辑模块
  await import("./verifiers/webauthn");
  // 预热 UI 组件
  const Biometric = defineAsyncComponent(
    () => import("./ui-verifiers/Biometric.vue")
  );
  // 或通过 Router 的路由懒加载预取
  ```

---

## 7. 常见问题（FAQ）

### Q1：异步组件会不会每次显示都重新请求？

不会。`import()` 由浏览器与模块系统缓存，一旦加载过，后续复用。同一进程内**只拉一次**。

### Q2：我能不用 `defineAsyncComponent` 吗？

- 要把“模块”渲染成“组件”，建议始终用它。
- 仅在非常简单、完全无占位/错误控制的场景，且你能确保只在已加载后才渲染，才可能绕过。但不推荐。

### Q3：SSR 怎么办？

- 服务器端会先把异步组件解析出来，客户端 hydration 不会再拉网络；
- Vite SSR 内部会为异步 chunk 注入 preload 链接，避免闪烁。

### Q4：`import()` 与路由懒加载的关系？

- `component: () => import('./Foo.vue')` 是路由层面懒加载写法（Vue Router 会识别并包装成异步组件）；
- 直接在模板里用组件，推荐 `defineAsyncComponent`。

---

## 8. 结论

- **逻辑模块**：用 `import()`（动态导入，代码分割，按需加载）。
- **可渲染组件**：用 `defineAsyncComponent(() => import(...))`（包装为组件，内建加载/错误/超时/Suspense/SSR 处理）。
- 你的 **MFA** 最佳实践：

  - 验证器 **逻辑**用 `import()` 注册到 `registry`；
  - 验证器 **UI**用 `defineAsyncComponent` 进行异步渲染；
  - 在拿到 `steps` 后做 **预热**，提升首次交互的手感。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vite + Vue3 打包后如何查看“体积分布分析图”]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/体积分布分析图</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/体积分布分析图"/>
        <updated>2025-09-06T16:59:20.000Z</updated>
        <content type="html"><![CDATA[
## 总览

想在 **Vite + Vue3** 打包后看到类似 Webpack Bundle Analyzer 的交互式“依赖体积分布图”，最简单稳妥的方法是接入 `rollup-plugin-visualizer`。本文给出**最小改动**方案：按需启用分析模式、构建、自动打开 `stats.html`。

---

## 实现思路

- 使用 Rollup 可视化插件（Vite 打包底层是 Rollup）。
- 仅在“分析模式”挂载插件，避免影响日常构建速度。
- 构建完成自动生成并打开 `stats.html`（Treemap/Sunburst 可选）。
- 可选：开启 `sourcemap` 便于二次分析。

---

## 分步操作

### 1）安装依赖

```bash
# 任选包管理器
pnpm add -D rollup-plugin-visualizer
# 或
npm i -D rollup-plugin-visualizer
# 或
yarn add -D rollup-plugin-visualizer
```

### 2）修改 `vite.config.ts`（只给需要改的片段）

> 说明：以下片段为**增量修改**，请在你的 `vite.config.ts` 里按位置插入即可。

```ts
// ① 顶部新增一行：导入可视化插件
import { visualizer } from "rollup-plugin-visualizer";
```

```ts
// ② 在 defineConfig 回调里按需启用（若你当前不是回调形式，可改为回调：defineConfig(({ mode }) => ({ ... }))）
const enableAnalyze = process.env.ANALYZE === "true" || mode === "analyze";

// 复杂逻辑：仅在分析模式下挂载插件，避免常规构建受影响
enableAnalyze &&
  plugins.push(
    visualizer({
      // 复杂逻辑：输出 treemap 到项目根目录，并在构建结束自动打开
      filename: "stats.html",
      template: "treemap", // 可选：'treemap' | 'sunburst' | 'network'
      open: true,
      gzipSize: true,
      brotliSize: true,
    })
  );
```

```ts
// ③（可选）为了配合二次分析或排查问题，开启源码映射
build: {
  // 复杂逻辑：仅在分析模式下开启 sourcemap（若你已有 build 配置，请合并到其中）
  sourcemap: enableAnalyze;
}
```

> 小贴士：若你的 `plugins` 是直接字面量数组，改成先声明 `const plugins = [vue(/*...*/)]` 再 `.push(...)`，最后 `return { plugins }`。不想改结构也行：`plugins: [vue(), enableAnalyze && visualizer({...})].filter(Boolean)`。

### 3）新增构建脚本（二选一）

**方案 A（推荐，跨平台零依赖）：用 `--mode analyze` 触发**

```json
{
  "scripts": {
    "build": "vite build",
    "build:analyze": "vite build --mode analyze"
  }
}
```

**方案 B：用环境变量触发（类 Unix 系统方便）**

```json
{
  "scripts": {
    "build": "vite build",
    // 复杂逻辑：通过环境变量开启分析模式；Windows 可用 cross-env 做兼容
    "build:analyze": "ANALYZE=true vite build"
  }
}
```

---

## 使用方法

```bash
# 触发分析构建（使用你选择的方案）
pnpm run build:analyze

# 构建完成后会自动打开 stats.html
# 若未自动打开，可手动在项目根目录双击/用浏览器打开 stats.html
```

---

## 进阶玩法（可选）

### A. 自定义输出位置/图表类型

```ts
// 复杂逻辑：将报告输出到 dist 目录下并改为 sunburst 风格
visualizer({
  filename: "dist/bundle-report.html",
  template: "sunburst",
  open: true,
});
```

### B. 快速“拆包”以便观察效果

> 仅示例，按你实际依赖调整：

```ts
// 复杂逻辑：演示常见手动分包，便于在图里更清晰地区分
build: {
  rollupOptions: {
    output: {
      manualChunks: {
        vue: ['vue', 'vue-router', 'pinia'],
        // 如果你用到 Ant Design Vue / ECharts / AntV 等，可分别拆
        // antdv: ['ant-design-vue'],
        // echarts: ['echarts'],
        // antv: ['@antv/g2', '@antv/g2plot'],
      }
    }
  }
}
```

### C. 二次分析（Source Map）

```bash
# 可选：安装 source-map-explorer 做“按文件”体积分析
pnpm add -D source-map-explorer
# 构建（确保 sourcemap 已开启）
pnpm run build:analyze
# 生成 HTML 报告（路径按你的 dist 实际文件调整）
npx source-map-explorer "dist/assets/*.js" --html dist/sme.html
```

---

## 常见问题

- **stats.html 是空白/打不开？**
  多半是构建被缓存或浏览器拦截了本地文件。先清理 `dist` 再构建；或换个浏览器打开，必要时关闭浏览器的本地文件限制。

- **报告没自动打开？**
  CI/无头环境不会自动打开。把 `open: false`，直接到输出目录找报告 HTML 即可。

- **Windows 下 `ANALYZE=true` 不生效？**
  用方案 A（`--mode analyze`），或安装 `cross-env`：
  `cross-env ANALYZE=true vite build`。

- **体积异常大但定位不到模块？**
  开启 `sourcemap` 后再看 `stats.html`；若仍不清晰，配合 `source-map-explorer` 交叉验证。

---

## 小结

- 装一个 `rollup-plugin-visualizer`，按需启用分析模式，构建即得可交互分析图。
- 报告默认 `stats.html`，Treemap/Sunburst 随选。
- 需要更深入排查时，打开 `sourcemap` + `source-map-explorer` 双管齐下。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态表单「已勾选仍提示必填」的两处修复]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/Vue/动态表单「已勾选仍提示必填」的两处修复</id>
        <link href="https://herongdev.github.io/blog/posts/前端/Vue/动态表单「已勾选仍提示必填」的两处修复"/>
        <updated>2025-09-05T16:22:47.000Z</updated>
        <content type="html"><![CDATA[
---

title: 动态表单「已勾选仍提示必填」的两处修复
date: 2025-09-05
tags: \[Vue3, Ant Design Vue, 表单校验, 组件封装]

---

## 问题概述

复选框（`a-checkbox-group`）在 **必填** 时，即使勾选了第一项仍提示“请选择”。根因有两点：

1. 你的 `Checkbox` 包装组件把 `v-model:value` **定义成了 boolean**（默认 `false`），而 `a-checkbox-group` 需要 **数组**；
2. 通用的 `required: true` 规则对 **数组长度** 不做判断，需要为复选框补一条“至少选一项”的自定义校验。

下面给出**最小修改**代码片段（仅展示需要调整的部分）。

> 说明：按你的偏好，复杂逻辑的代码段我在**上一行加了注释**。

---

## 修改 1：`Checkbox` 组件把模型改为数组

把 `defineModel<boolean>` 改为 **`defineModel<any[]>`**，默认值设为 `[]`，并确保内部状态是数组。

```ts
// 复杂：CheckboxGroup 期望数组类型；默认值必须为 []，否则 antd 校验无法判定“是否已选择”
const model = defineModel<any[]>("value", { default: [] });
const innerValue = ref<any[]>(Array.isArray(model.value) ? model.value : []);

watch(model, (v) => (innerValue.value = Array.isArray(v) ? v : []));
watch(innerValue, (v) => (model.value = Array.isArray(v) ? v : []));
```

---

## 修改 2：为复选框补充“至少选一项”的校验规则

在 `getValidationRules` 中，为 `controlType === 'checkbox'` 增加自定义校验（**在你现有的特殊控件分支里添加一段即可**）。

```ts
// 复杂：CheckboxGroup 的必填校验——至少选择 1 项
} else if (field.controlType === 'checkbox') {
  rules.push({
    validator: async (_: any, v: any[]) => {
      const ok = Array.isArray(v) && v.length > 0
      if (!ok && field.required)
        return Promise.reject(t('files.form.rule.required', { label: field.label }))
      return Promise.resolve()
    },
    trigger: ['change', 'blur'],
  })
```

> 放置位置建议：就放在你现有的 `/* 特殊控件校验 */` 分支里，和 `stockholder / image / file` 同级。

---

## 可选增强：初始化把错误类型矫正为数组

若后端历史数据里该字段可能是 `false/null/''/单值`，可以在你已有的 `watch(_fields, ...)` 预处理里顺手矫正为数组，避免初始值导致“已选中但校验失败”。

```ts
// 复杂：把历史/异常初始值统一矫正为 CheckboxGroup 需要的数组
} else if (f.controlType === 'checkbox') {
  const v = formData[f.name]
  if (!Array.isArray(v)) formData[f.name] = v == null || v === false ? [] : [v]
}
```

---

## 结论

- **关键修复**在于：复选框的 `v-model` 类型必须是 **数组**；
- **规则层面**补充“至少一项”的自定义校验，避免通用 `required` 漏判。

应用以上两处修改后，勾选第一项即可通过校验，不再提示“请选择”。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pinia 并发去重与初始化策略实战：以 SVG 列表为例]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/下载与文件/Pinia 并发去重与初始化策略实战：以 SVG 列表为例</id>
        <link href="https://herongdev.github.io/blog/posts/前端/下载与文件/Pinia 并发去重与初始化策略实战：以 SVG 列表为例"/>
        <updated>2025-09-10T10:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 本文面向在 **Vue 3 + Pinia** 项目中使用 `useFetch`/接口拉取数据的同学，示例围绕「获取品种 SVG 列表」展开，落地三个高频问题：**并发去重（按参数维度）**、**稳健的 reset**、**失败后的可重试**。文末还给出 TTL、Abort、SWR 的可选扩展。

---

# 背景

很多项目会把「字典类/静态资源」放到全局 Store 并懒加载（init）。常见实现：

- 组件 A、B 同时挂载，各自 `init()` ——> **重复请求**
- 先用参数 `image_type=A` 拉了一次；随后用 `image_type=B` 再 `init()` ——> **错复用旧 Promise**
- `reset()` 粗暴把 `loading=false` ——> **与请求状态打架**
- 请求失败后 `_initPromise` 仍被占用 ——> **无法重试**

本文提供一版**通用模板**来避开这些坑。

---

# 常见坑位与根因

1. **并发重复请求**
   只做了「有无 in-flight Promise」的判断，却**没区分参数**：不同参数也会被“去重”。

2. **参数维度错乱**
   `init(A)` 正在请求时调用 `init(B)`，因为沿用相同 `_initPromise`，后者**拿到的是 A 的结果**。

3. **reset 不当**
   直接把 `loading=false`，破坏 `useFetch` 的内部状态机；同时没清掉参数 key，**后续“误以为已加载”**。

4. **失败不可重试**
   请求失败后 `_initPromise` 仍被引用，下一次 `init` 直接返回失败的 Promise，**卡死**。

---

# 最终方案（可直接复用）

## 设计要点

- **参数去重**：对 `params` 做稳定序列化（`JSON.stringify`）生成 `key`，仅当「key 相同」时复用 in-flight Promise。
- **失败清理**：出错时**清空** `_initPromise`，让下一次可以重新发起。
- **reset 温和**：不瞎改 `loading`，只清 `data`、`lastParamsKey`、`_initPromise`。
- **命中缓存**：当 `data` 已有且 `key` 一致时，直接返回（不再请求）。

## 完整代码

> 可以直接复制到 Hexo 代码块里使用（Pinia Store）。

```ts
import { defineStore } from "pinia";
import { useFetch } from "@/composables";

type InitParams = { image_type?: string; symbol?: string[] };

// 复杂逻辑：将参数序列化为稳定的去重 key，避免不同参数误用同一个 Promise/结果
const toKey = (p?: InitParams) => JSON.stringify(p ?? {});

export const useSvgStore = defineStore("svgStore", () => {
  const { data, loading, fetchData } = useFetch({
    url: "/api/symbol/svg_list",
    autoFetch: false,
  });

  // 复杂逻辑：只对“相同参数”的并发做去重
  let _initPromise: Promise<void> | null = null;
  let lastParamsKey = "";

  // 复杂逻辑：更稳健的 reset——不强改 loading；清空数据、参数 key 与 in-flight Promise
  const reset = () => {
    data.value = null;
    lastParamsKey = "";
    _initPromise = null;
  };

  // 复杂逻辑：参数去重 + 并发去重 + 失败后可重试
  const init = async (params?: InitParams) => {
    const key = toKey(params);

    // 同参数且已有进行中的请求 => 复用该 Promise；不同参数则允许重新发起
    if (_initPromise && key === lastParamsKey) return _initPromise;

    _initPromise = (async () => {
      // 已有数据且是同一参数 => 跳过请求
      if (
        Array.isArray(data.value) &&
        data.value.length > 0 &&
        key === lastParamsKey
      )
        return;
      try {
        await fetchData(params);
        lastParamsKey = key;
      } catch (e) {
        // 失败时清除占位，让下一次能重新尝试
        _initPromise = null;
        throw e;
      }
    })();

    return _initPromise;
  };

  return {
    loading,
    data,
    init,
    reset,
    fetchData,
  };
});

export default useSvgStore;
```

---

# 使用方式

## 1) 首屏懒加载（并发安全）

```ts
import { onMounted } from "vue";
import { useSvgStore } from "@/store/svg";

export default {
  setup() {
    const svgStore = useSvgStore();

    onMounted(() => {
      // 多个组件同时调用也没关系：同参数只会发一次请求
      svgStore.init({ image_type: "all" });
    });

    return { svgStore };
  },
};
```

## 2) 不同参数的加载

```ts
await svgStore.init({ image_type: "crypto" }); // 拉取加密品种
await svgStore.init({ image_type: "forex" }); // 拉取外汇品种（不会复用上一次 Promise）
```

## 3) 重新拉取

```ts
svgStore.reset();
// 下次再调用 init，会重新请求
await svgStore.init({ image_type: "all" });
```

---

# FAQ

### Q1：为什么去掉 `watch(data)`？

- 这类全局“静态资源”通常**只需在显示层消费**。在 Store 中 watch `data` 而不做任何处理，属于**冗余依赖**，会引发不必要的响应式开销。

### Q2：为什么 `reset` 不设置 `loading=false`？

- `loading` 由 `useFetch` 内部控制。外部强制改 `loading`，可能与尚在进行的请求状态冲突（比如请求刚开始你就把它改回 false）。**正确做法**是清空数据和并发标记，让下一次调用去自然驱动加载状态。

### Q3：如果我需要**强制刷新**（忽略已存在数据），怎么办？

- 最简单：`reset()` 后再 `init(params)`。
- 或扩展 `init(params, { force: true })`，当 `force` 为真时跳过“已有数据”判断。

---

# 进阶扩展（可选）

## 1) TTL 缓存（过期后自动重拉）

```ts
let ttlMs = 10 * 60 * 1000;
let fetchedAt = 0;

const isExpired = () => Date.now() - fetchedAt > ttlMs;

const init = async (params?: InitParams, opts?: { force?: boolean }) => {
  const key = toKey(params);
  if (_initPromise && key === lastParamsKey) return _initPromise;

  _initPromise = (async () => {
    const hasData = Array.isArray(data.value) && data.value.length > 0;
    if (!opts?.force && hasData && key === lastParamsKey && !isExpired())
      return;

    try {
      await fetchData(params);
      fetchedAt = Date.now();
      lastParamsKey = key;
    } catch (e) {
      _initPromise = null;
      throw e;
    }
  })();

  return _initPromise;
};
```

## 2) AbortController（中止旧请求）

若你的 `useFetch` 支持传入 `AbortSignal`，在「参数变化较频繁」的场景里，可以中止旧请求：

```ts
let controller: AbortController | null = null;

const init = async (params?: InitParams) => {
  const key = toKey(params);
  if (_initPromise && key === lastParamsKey) return _initPromise;

  controller?.abort();
  controller = new AbortController();

  _initPromise = (async () => {
    try {
      await fetchData({ ...(params || {}), signal: controller!.signal });
      lastParamsKey = key;
    } catch (e) {
      if ((e as any)?.name === "AbortError") return;
      _initPromise = null;
      throw e;
    }
  })();

  return _initPromise;
};
```

## 3) SWR（stale-while-revalidate）

- 先用缓存的 `data` 立即显示（哪怕过期）
- 背景里静默拉最新数据，成功后再更新 `data`
- 用户体验：**快**且**新**

---

# 调试建议

- 在 `init` 前后打印：`console.log('[svg:init]', params, lastParamsKey, !!_initPromise)`
- 捕获 `fetchData` 的异常信息：网络失败、接口 4xx/5xx 时，观察 `_initPromise` 是否被清理。
- 在 DevTools 的 **Network** 面板确认：并发相同参数的请求真的只发了一次，不同参数各自发一次。

---

# 总结

这套模板的核心是：**用参数 key 管理 in-flight Promise**，**reset 只清状态不碰 loading**，**错误要清空占位以便重试**。实际接入后：

- 并发安全 ✅
- 参数正确 ✅
- 重置与重试 ✅
- 扩展能力强（TTL/Abort/SWR）✅

把它抽象成你的「Store 初始化规范」，下次再遇到类似的“字典/基础数据”拉取，就能一把梭～
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个 downloadFile 就够了：直链与鉴权下载自动切换（Vue/TS）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/下载与文件/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）"/>
        <updated>2025-09-06T15:13:25.000Z</updated>
        <content type="html"><![CDATA[
## 需求背景

- 有的文件**公开直链**，直接点就能下；
- 有的需要**携带 Cookie/Token、自定义 Header 或用 POST** 才能拿到二进制流；
- 我们希望**一个函数**即可应对两类场景，并自动选择最优策略。

## 设计要点

- **优先直链（a.click）**：不加 header/body/credentials 时，直接跳转下载；
- **按需请求（fetch→Blob）**：当需要鉴权/自定义 Header/POST，先拿 Blob，再用 Object URL 触发下载；
- **文件名解析**：未显式传 `fileName` 时，尝试从 `Content-Disposition` 读取；
- **内存友好**：使用 Object URL 并及时 `URL.revokeObjectURL`。

## 代码

```ts
export type DownloadOptions = Omit<RequestInit, "signal"> & {
  fileName?: string;
  forceRequest?: boolean;
};

function _pickNameFromContentDisposition(
  cd: string | null
): string | undefined {
  if (!cd) return;
  const star = cd.match(/filename\*=(?:UTF-8'')?([^;]+)/i);
  const norm = cd.match(/filename=([^;]+)/i);
  const raw = (star?.[1] ?? norm?.[1])?.trim().replace(/^["']|["']$/g, "");
  try {
    return raw ? decodeURIComponent(raw) : undefined;
  } catch {
    return raw;
  }
}

export async function downloadFile(url: string, options: DownloadOptions = {}) {
  const { fileName, forceRequest, ...req } = options;
  const needRequest =
    !!forceRequest ||
    (req.method && req.method.toUpperCase() !== "GET") ||
    !!req.headers ||
    !!req.body ||
    !!req.credentials;

  if (!needRequest) {
    const a = document.createElement("a");
    a.href = url;
    if (fileName) a.download = fileName; // 跨域直链可能被忽略
    a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return;
  }

  const res = await fetch(url, req);
  if (!res.ok)
    throw new Error(`Download failed: ${res.status} ${res.statusText}`);

  let name =
    fileName ??
    _pickNameFromContentDisposition(res.headers.get("content-disposition"));
  const blob = await res.blob();
  const href = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.style.display = "none";
  a.href = href;
  if (name) a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(href);
}
```

## 使用示例

### 直链（公开资源）

```ts
await downloadFile("https://cdn.example.com/file.pdf", {
  fileName: "文档.pdf",
});
```

### 携带 Cookie/Token

```ts
await downloadFile("/api/report/export", {
  credentials: "include",
  headers: { Authorization: "Bearer xxx" },
  fileName: "报表.xlsx",
});
```

### POST 导出

```ts
await downloadFile("/api/export", {
  method: "POST",
  headers: { "Content-Type": "application/json", Authorization: "Bearer xxx" },
  body: JSON.stringify({ range: "2025-01-01~2025-09-01" }),
  fileName: "导出.csv",
});
```

## 注意事项

- **跨域直链**时，浏览器可能**忽略 `download` 文件名**，以服务器或默认名为准；
- 如需强制走请求分支，可传 `forceRequest: true`；
- 服务器若返回 `Content-Disposition`，无需传 `fileName` 也能自动命名；
- 大文件下载建议结合服务端分片/断点续传方案（本函数仅负责触发下载）。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArrayBuffer 与字符串互转方法对比]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/基础/ArrayBuffer 与字符串互转方法对比</id>
        <link href="https://herongdev.github.io/blog/posts/前端/基础/ArrayBuffer 与字符串互转方法对比"/>
        <updated>2025-09-10T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
# ArrayBuffer 与字符串互转方法对比

在前端开发中，处理二进制数据时经常会遇到 **ArrayBuffer**。如果需要和字符串互转，可以使用多种方式。本文整理了常见方案，并给出对比。

## 1. 使用 TextDecoder / TextEncoder （推荐）

### 思路

- `TextEncoder`：将字符串转为 `Uint8Array`（底层是 `ArrayBuffer`）。
- `TextDecoder`：将 `ArrayBuffer` 解码为字符串。

### 示例

```js
// 字符串 -> ArrayBuffer
const encoder = new TextEncoder();
const uint8 = encoder.encode("你好，世界");
const buffer = uint8.buffer;

// ArrayBuffer -> 字符串
const decoder = new TextDecoder("utf-8");
const text = decoder.decode(buffer);
console.log(text); // 你好，世界
```

✅ 特点：支持多种编码（UTF-8、GBK 等），最标准化。
❌ 缺点：在老旧浏览器可能不支持。

## 2. 使用 JSON + Buffer（适合传输 JSON 数据）

### 示例

```js
// 对象 -> ArrayBuffer
const obj = { msg: "Hello" };
const str = JSON.stringify(obj);
const uint8 = new TextEncoder().encode(str);

// ArrayBuffer -> 对象
const text = new TextDecoder().decode(uint8);
const data = JSON.parse(text);
console.log(data.msg); // Hello
```

✅ 特点：适合结构化数据传输。
❌ 缺点：仅适合 JSON 格式。

## 3. 使用 base64 中转（跨语言兼容）

### 示例

```js
// ArrayBuffer -> base64 -> 字符串
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// base64 -> ArrayBuffer
function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const len = binary.length;
  const buffer = new ArrayBuffer(len);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}
```

✅ 特点：跨平台、跨语言兼容。
❌ 缺点：编码后体积会增加 \~33%。

## 4. 手工遍历 Uint8Array

### 示例

```js
// ArrayBuffer -> 字符串（逐字节转码）
function bufferToString(buffer) {
  const bytes = new Uint8Array(buffer);
  let result = "";
  for (let i = 0; i < bytes.length; i++) {
    result += String.fromCharCode(bytes[i]);
  }
  return result;
}

// 字符串 -> ArrayBuffer
function stringToBuffer(str) {
  const buffer = new ArrayBuffer(str.length);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  return buffer;
}
```

✅ 特点：无依赖，浏览器通用。
❌ 缺点：只适合 ASCII，遇到中文/emoji 会乱码。

---

# 总结对比

| 方法                    | 优点                 | 缺点             | 适用场景        |
| ----------------------- | -------------------- | ---------------- | --------------- |
| **TextDecoder/Encoder** | 标准化，支持多种编码 | 老旧浏览器不支持 | 现代前端项目    |
| **JSON + Buffer**       | 简单，适合对象       | 限制于 JSON 格式 | 结构化数据      |
| **base64**              | 跨语言兼容           | 数据体积膨胀     | 网络传输，存储  |
| **手工遍历**            | 通用，无依赖         | 中文乱码         | 简单 ASCII 数据 |

---

💡 **最佳实践**：

- 处理文本 → 推荐 **TextDecoder/Encoder**
- 传输 JSON → 用 **JSON.stringify + TextEncoder**
- 跨语言通信 → 用 **base64**
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/基础/滚动条样式调整]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/基础/滚动条样式调整</id>
        <link href="https://herongdev.github.io/blog/posts/前端/基础/滚动条样式调整"/>
        <updated>2025-09-18T17:26:53.128Z</updated>
        <content type="html"><![CDATA[对于 chrome 浏览器，它提供了修改滚动条样式的接口，开发者只需要加上几句 css 脚本，就可轻松实现滚动条样式的修改.

先说一下滚动条的参数：
::-webkit-scrollbar 滚动条整体部分，可以设置宽度啥的
::-webkit-scrollbar-button 滚动条两端的按钮
::-webkit-scrollbar-track 外层轨道
::-webkit-scrollbar-track-piece 内层滚动槽
::-webkit-scrollbar-thumb 滚动的滑块
::-webkit-scrollbar-corner 边角
::-webkit-resizer 定义右下角拖动块的样式
/_ 设置滚动条的样式 _/
::-webkit-scrollbar {
width: 10px;
}
/_ 滚动槽 _/
::-webkit-scrollbar-track {
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
border-radius: 10px;
}
/_ 滚动条滑块 _/
::-webkit-scrollbar-thumb {
border-radius: 10px;
background: #bbb;
-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);
}
::-webkit-scrollbar-thumb:window-inactive {
background: rgba(255,0,0,0.4);
}

```css
/* 滚动条整体样式 */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
/* 滚动条轨道 */
::-webkit-scrollbar-track {
  background-color: transparent;
  border-radius: 5px;
}
/* 滚动条滑块 */
::-webkit-scrollbar-thumb {
  background-color: var(--color-neutral-4);
  border-radius: 5px;
}
/* 滚动条滑块悬停状态 */
::-webkit-scrollbar-thumb:hover {
  background-color: var(--color-neutral-6);
}
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[web应用开发/前端/Web 应用如何做到实时消息通知]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知</id>
        <link href="https://herongdev.github.io/blog/posts/前端/实时通信/web应用开发-前端-Web-应用如何做到实时消息通知"/>
        <updated>2025-09-05T14:10:20.000Z</updated>
        <content type="html"><![CDATA[
---

title: Web 应用如何做到“实时消息通知”
date: 2025-09-05
categories: \[Web 实时通讯, 架构设计]
tags: \[WebSocket, SSE, Web Push, 长轮询, 消息队列, Redis, 可用性, 安全]
description: 面向前端/全栈开发者，从选型到最小可行代码，教你在 Web 应用中实现稳定的实时消息通知。

---

# 总览

**目标**：在浏览器里第一时间看到来自服务端的新消息（聊天、新订单、系统告警等）。
**常见方案**：

- **WebSocket**：全双工、低延迟、最通用。
- **SSE（Server-Sent Events）**：服务端到客户端的单向推送，轻量、易用。
- **长轮询（Long Polling）**：兼容性最佳的兜底方案。
- **Web Push（Service Worker）**：浏览器级推送，页面不在前台也能收到（需用户同意）。

**快速选型**（简表）：

| 需求/约束                | 推荐                         |
| ------------------------ | ---------------------------- |
| 双向通信（聊天/协作）    | **WebSocket**                |
| 只下行推送、需超轻量     | **SSE**                      |
| 公司网络/代理限制 WS     | **SSE 或 长轮询**            |
| 需离线/后台通知          | **Web Push**                 |
| 海量连接、水平扩展       | **WS + Redis Pub/Sub 或 MQ** |
| 服务端易实现、兼容老后端 | **长轮询**                   |

---

# 实现思路（一图流）

1. **连接层**：浏览器（WS/SSE/HTTP） ↔ 反向代理（Nginx/Ingress） ↔ **推送网关服务**
2. **消息路由层**：**Redis Pub/Sub / Kafka / RabbitMQ** 做 fan-out 与广播
3. **业务层**：订单/聊天/告警服务把事件写入 **消息总线**
4. **状态与可靠性**：在线用户表、订阅关系、**Ack/重试/幂等**、**断线重连**、**心跳**、**权限校验**

---

# 分步实践

## 方案一：WebSocket（最通用）

### 最小可行后端（Node.js + `ws`）

```js
// 复杂逻辑：保存连接、鉴权、心跳、按用户分组转发
import { WebSocketServer } from "ws";
import jwt from "jsonwebtoken";

const wss = new WebSocketServer({ port: 8080 });
const clients = new Map(); // userId -> Set<ws>

wss.on("connection", (ws, req) => {
  // 复杂逻辑：从 ?token= 解析并校验用户身份
  const token = new URL(req.url, "http://x").searchParams.get("token");
  let userId = null;
  try {
    userId = jwt.verify(token, process.env.JWT_SECRET).sub;
  } catch {
    ws.close();
    return;
  }

  if (!clients.has(userId)) clients.set(userId, new Set());
  clients.get(userId).add(ws);

  // 复杂逻辑：心跳保活，清理僵尸连接
  ws.isAlive = true;
  ws.on("pong", () => (ws.isAlive = true));

  ws.on("message", (buf) => {
    // 这里可处理客户端上行，如已读回执/输入中状态
  });

  ws.on("close", () => {
    clients.get(userId).delete(ws);
    if (clients.get(userId).size === 0) clients.delete(userId);
  });
});

// 复杂逻辑：定时 ping
setInterval(() => {
  wss.clients.forEach((ws) => {
    if (!ws.isAlive) return ws.terminate();
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// 示例：向某用户推送
export function pushToUser(userId, payload) {
  const set = clients.get(userId);
  if (!set) return;
  const msg = JSON.stringify(payload);
  set.forEach((ws) => ws.readyState === ws.OPEN && ws.send(msg));
}
```

### 前端最小连接封装（浏览器）

```js
// 复杂逻辑：自动重连、指数退避、前台/后台状态感知
export function createWsClient(urlWithToken, onMsg) {
  let ws,
    retry = 0,
    timer;

  const connect = () => {
    ws = new WebSocket(urlWithToken);
    ws.onopen = () => {
      retry = 0;
    };
    ws.onmessage = (e) => onMsg(JSON.parse(e.data));
    ws.onclose = () => scheduleReconnect();
    ws.onerror = () => ws.close();
  };

  const scheduleReconnect = () => {
    clearTimeout(timer);
    const delay = Math.min(30000, 1000 * 2 ** retry++);
    timer = setTimeout(connect, delay);
  };

  // 复杂逻辑：页面隐藏时减小重连频率
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && ws?.readyState !== WebSocket.OPEN) {
      retry = Math.max(retry, 4); // 慢一些
    }
  });

  connect();
  return () => {
    clearTimeout(timer);
    ws?.close();
  };
}
```

### Nginx 反代（启用 WS 协议升级）

```nginx
# 复杂逻辑：确保 upgrade 头转发
location /ws/ {
  proxy_pass http://realtime:8080;
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 60s;
}
```

---

## 方案二：SSE（Server-Sent Events，轻量下行推送）

### 后端（Node.js + Express）

```js
// 复杂逻辑：SSE 连接池、心跳注释行、按用户推送
import express from "express";
import jwt from "jsonwebtoken";

const app = express();
const streams = new Map(); // userId -> res

app.get("/sse", (req, res) => {
  const token = req.query.token;
  let userId;
  try {
    userId = jwt.verify(token, process.env.JWT_SECRET).sub;
  } catch {
    return res.sendStatus(401);
  }

  res.set({
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
  });
  res.flushHeaders();
  streams.set(userId, res);

  // 复杂逻辑：心跳，防止中间设备断开
  const hb = setInterval(() => res.write(":hb\n\n"), 25000);

  req.on("close", () => {
    clearInterval(hb);
    streams.delete(userId);
  });
});

export function ssePush(userId, data) {
  const res = streams.get(userId);
  if (!res) return;
  res.write(`data: ${JSON.stringify(data)}\n\n`);
}

app.listen(8081);
```

### 前端

```js
// 复杂逻辑：SSE 自动重连由浏览器原生完成
const ev = new EventSource(`/sse?token=${encodeURIComponent(token)}`);
ev.onmessage = (e) => {
  const payload = JSON.parse(e.data);
  // 渲染消息
};
```

**何时用 SSE**：仅需服务端 → 浏览器推送（如系统广播、价格/进度更新），无需上行交互；在某些企业代理/防火墙下比 WS 更稳定。

---

## 方案三：长轮询（兼容兜底）

### 后端（Koa/Express 任意）

```js
// 复杂逻辑：如果没有新消息就挂起请求，直到有消息或超时
const waiters = new Map(); // userId -> res[]

app.get("/poll", (req, res) => {
  const userId = auth(req); // 自行实现鉴权
  (waiters.get(userId) ?? waiters.set(userId, []).get(userId)).push(res);
  req.setTimeout(65000); // 与前端超时一致
  req.on("close", () => cleanup(userId, res));
});

function notify(userId, payload) {
  const list = waiters.get(userId) || [];
  for (const res of list) res.json(payload);
  waiters.set(userId, []);
}
```

### 前端

```js
// 复杂逻辑：递归调用保持“长连接”效果
async function longPoll() {
  try {
    const r = await fetch("/poll", { credentials: "include" });
    if (r.ok) {
      const data = await r.json();
      // 处理消息
    }
  } catch (_) {
    /* 忽略网络错误 */
  } finally {
    setTimeout(longPoll, 100);
  } // 轻微间隔
}
longPoll();
```

---

## 方案四：Web Push（离线/后台通知）

> 适合 **提醒类** 场景：即便用户没打开页面、浏览器在后台，仍可收到通知（需 HTTPS 与用户授权）。

### 前端注册 Service Worker

```js
// 复杂逻辑：注册 SW 并申请通知权限，然后向后端上报订阅
const reg = await navigator.serviceWorker.register("/sw.js");
const permission = await Notification.requestPermission();
if (permission === "granted") {
  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: "<VAPID_PUBLIC_KEY_BASE64URL>",
  });
  await fetch("/push/subscribe", { method: "POST", body: JSON.stringify(sub) });
}
```

### Service Worker 接收

```js
// 复杂逻辑：展示系统级通知
self.addEventListener("push", (e) => {
  const data = e.data?.json() ?? {};
  e.waitUntil(
    self.registration.showNotification(data.title || "通知", {
      body: data.body,
    })
  );
});
```

### 后端发送（Node.js + web-push）

```js
// 复杂逻辑：使用 VAPID 签名向浏览器推送
import webpush from "web-push";
webpush.setVapidDetails(
  "mailto:admin@example.com",
  VAPID_PUBLIC,
  VAPID_PRIVATE
);

// subs 为持久化的订阅列表
export async function sendPush(sub, payload) {
  await webpush.sendNotification(sub, JSON.stringify(payload));
}
```

---

# 可扩展与高可用

- **水平扩展**：WS/SSE 多实例时，用 **Redis Pub/Sub** 或 **消息队列（Kafka/RabbitMQ）** 做广播/定向投递。
- **在线表/路由**：`userId -> connectionIds`（内存 + Redis）。
- **可靠性**：业务消息落库 → 推送 → 客户端 **Ack** → 未 Ack 重试；**消息去重键** 防止重复渲染。
- **断线重连**：客户端带 **上次 offset/lastId** 续传（SSE 原生有 `Last-Event-ID`）。
- **背压控制**：批量合并（coalesce）、节流；超大消息用链接拉取。
- **监控告警**：连接数、发送量、队列堆积、投递耗时、重试率、失败率。

---

# 安全与合规

- **鉴权**：连接时附带 **短期 JWT**，服务端校验与续期；不同通道（WS/SSE/HTTP）统一鉴权层。
- **权限**：服务端二次校验资源访问（不要把 topic 名称当权限）。
- **限流**：IP / 用户 / 通道维度限速；异常断开与重连风暴保护。
- **加密**：HTTPS/WSS；敏感字段服务端脱敏。
- **审计**：关键通知落库，包含投递结果与阅读状态。

---

# 最简“端到端”范例清单

> 你可以基于此快速拼装生产可用的实时通知：

1. **连接层**：WebSocket（上面 Node + `ws` 代码）
2. **消息总线**：Redis（`PUBLISH notifications:user:123 {...}`）
3. **业务写入**：订单服务下单成功 → 发布事件
4. **推送网关**：订阅 Redis 通道 → `pushToUser(userId, payload)`
5. **前端**：`createWsClient` 接收 → 写入本地状态/弹出提醒
6. **兜底**：前端检测 WS 不可用则回退 SSE/长轮询
7. **离线补充**：允许用户开启 Web Push 作后台提醒

---

# 常见坑与排错

- **公司代理挡 WS**：优先尝试 **SSE**；Nginx/Ingress 需正确配置 `Upgrade/Connection`。
- **连接泄漏**：记得 **清理 close** 事件、设置 **心跳**。
- **消息乱序/重复**：加入 **自增 offset / 事件时间戳 / 幂等键**。
- **大房间广播**：用 **频道广播 + 客户端过滤** 或 **服务端分片广播**。
- **移动网络切换**：重连后用 **lastId** 请求增量补齐。

---

# 结语

- **单点小流量**：直接 **SSE 或 WS** 即可。
- **中大型/海量**：**WS + Redis/MQ**，加上 **Ack/重试/幂等/监控**。
- **提醒类**：配上 **Web Push**，覆盖离线/后台。

需要我结合你现有技术栈（如 Next.js、Spring Boot、NestJS、Redis、Kafka）给出**最小改造的落地方案**和**只改动的代码片段**吗？我可以按你的项目结构直接贴可替换的文件/增量修改。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么需要“稳定引用”？——React/Vue 中避免 TanStack Table 无限渲染的原理与实战]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/常用库/Vue 中避免 TanStack Table 无限渲染的原理与实战</id>
        <link href="https://herongdev.github.io/blog/posts/前端/常用库/Vue 中避免 TanStack Table 无限渲染的原理与实战"/>
        <updated>2025-09-11T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 背景

- 当 columns/data 引用变化时，表格内部状态会重建，导致表格重新渲染。
  **当 `columns` 或 `data` 的引用在每次渲染时都变化时，TanStack Table 会认为表格配置变了，从而重建内部状态 → 触发重新渲染 → 如果你又在渲染过程中基于表格状态去更新外部状态，就可能进入无限循环。**

换句话说：

- **根因**：引用变化（不是值变，而是“新建对象/数组”的新引用）。
- **结果**：表格实例重新初始化，内部状态重建，触发表格渲染。
- **延伸**：若外部 `setState`/`watch` 又基于表格变化修改 `data/columns`，就会形成闭环 → 无限渲染。

这就是为什么要强调 **保持引用稳定**（React 用 `useMemo/useState`，Vue 用 `ref/shallowRef`）。

要不要我帮你画个 **“渲染循环因果图”**，直观展示这个无限渲染是怎么形成的？

## 核心结论（先看这个）

- **React**：函数组件每次渲染都会重新执行函数体，**字面量对象/数组**在每次渲染都会生成**新引用**；TanStack Table 看到 `data/columns` 引用变了，会重建内部状态并触发更新，若你的代码里又根据表格状态 `setState`，就会形成**渲染 → 新引用 → 重建 → 再渲染**的循环。
- **Vue 3**：`<script setup>` 顶层只跑一次，不会像 React 每次渲染都新建引用，但若你在 **computed/watch/render function** 里每次都**新建数组/对象**传下去，或用 **watch 回写源数据**，同样会造成**重复重建/回写循环**。
- 解决：**让 `data` 和 `columns` 的引用稳定**（只在必要时变），并避免 fallback 写法导致每次生成新数组。

## 一、为什么会“无限循环渲染”？

### 在 React 中

1. **引用不稳定**

   ```tsx
   export default function MyTable() {
     // ❌ 每次渲染都会创建全新的数组引用
     const columns = [
       /* ... */
     ];
     const data = [
       /* ... */
     ];

     // ⚠️ 这里一旦引用变化，useReactTable 会重建内部模型并触发状态更新
     const table = useReactTable({ columns, data });

     return <Table table={table} />;
   }
   ```

- 组件渲染 ⇒ `columns/data` 新引用 ⇒ 表格内部 `setState` ⇒ 组件再渲染 ⇒ 再次新引用…形成环。

2. **“看似无害”的 fallback 也会制造新引用**

   ```tsx
   const table = useReactTable({
     columns,
     data: data ?? [], // ❌ 每次渲染都会创建一个新的 []
   });
   ```

3. **依赖链放大**
   `useEffect/useMemo` 以**引用相等**判断变化。上游一旦“每次都是新引用”，下游优化全失效，导致更多无效重算、重渲染，甚至你的 `setState` 逻辑被反复触发。

> 额外注意：React 18 严格模式会**额外执行一次初始渲染**来帮助发现副作用问题，这会放大不稳定引用带来的抖动。

### 在 Vue 3 中

- `<script setup>` 顶层只执行一次，**顶层声明的常量/`ref`/`shallowRef` 是稳定的**。但下面几种写法会引发问题：

  1. **在 `computed` 或渲染函数里新建数组/对象**：每次依赖变更都会产出**新引用**传给子组件或表格，导致表格重建。
  2. **watch 回写源数据**：监听某值变化后又写回同一来源（或其派生），容易形成**自激活循环**。
  3. **fallback 新建**：`data.value ?? []` 直接写在绑定处，每次求值都产生新数组。

## 二、如何在 React 中正确避免

### ✅ 推荐做法

```tsx
// 在模块顶层定义稳定的空数组（fallback）
const FALLBACK_ROWS: User[] = [];

export default function MyTable() {
  // ✅ columns 用 useMemo 保证引用稳定
  const columns = useMemo<ColumnDef<User>[]>(
    () => [
      // ...
    ],
    []
  );

  // ✅ data 用 useState/useMemo/外部状态管理，避免每次重建
  const [data, setData] = useState<User[]>(() => [
    // 初始数据...
  ]);

  // ✅ fallback 使用模块常量，避免 "data ?? []" 的每次新建
  const table = useReactTable({
    columns,
    data: data ?? FALLBACK_ROWS,
  });

  return <Table table={table} />;
}
```

### ❌ 常见坑位（对照修改）

```tsx
// ❌ 坑1：直接字面量
const columns = [
  /* ... */
];
const data = [
  /* ... */
];

// ✅ 改：useMemo / useState / 顶层常量
```

```tsx
// ❌ 坑2：data ?? [] 每次新建
const table = useReactTable({ columns, data: data ?? [] });

// ✅ 改：data ?? FALLBACK_ROWS（FALLBACK_ROWS 是模块级常量）
```

```tsx
// ❌ 坑3：根据 table 的 getter 做 setState
useEffect(() => {
  // 复杂逻辑：每次行模型变就 setState，极易形成环
  setFilteredIds(table.getRowModel().rows.map((r) => r.id));
}, [table.getRowModel()]);
// ✅ 改：用事件/回调或受控参数，避免直接“读→立刻写”成环
```

## 三、如何在 Vue 3 中正确避免

### ✅ 推荐做法（<script setup>）

```ts
<script setup lang="ts">
// ✅ 顶层只执行一次：引用天然稳定
import type { ColumnDef } from '@tanstack/vue-table'
import { ref, shallowRef } from 'vue'

// ✅ 列通常用 shallowRef 避免深层代理开销，同时保持引用稳定
const columns = shallowRef<ColumnDef<User>[]>([
  // ...
])

// ✅ data 用 ref 持有；只有你显式赋值时才会变
const data = ref<User[]>([])

// ✅ fallback：模块级常量
const FALLBACK_ROWS: User[] = []

</script>

<template>
  <!-- ✅ 避免 data ?? [] 这样的内联新建 -->
  <TanStackTable :columns="columns" :data="data || FALLBACK_ROWS" />
</template>
```

### ❌ 常见坑位（对照修改）

```ts
<!-- ❌ 坑1：模板里内联新建数组/对象 -->
<TanStackTable :columns="[/*...*/]" :data="rows.map(x => ({...x}))" />

<!-- ✅ 改：在 <script setup> 顶层用 ref/shallowRef/computed 提前产出稳定引用 -->
```

```ts
// ❌ 坑2：watch 回写自身，形成循环
watch(data, () => {
  // 复杂逻辑：对 data 变化又把 data 重新赋值（哪怕值相同也会变引用）
  data.value = [...data.value]; // ⚠️ 极易自触发
});

// ✅ 改：只在必要时、且用“变更检测”后再写；或使用防抖/节流；避免对同源数据做无意义回写
watch(data, (nv, ov) => {
  if (nv !== ov && needNormalize(nv)) {
    data.value = normalize(nv);
  }
});
```

```ts
// ❌ 坑3：computed 每次返回新引用给子组件
const tableData = computed(() => rows.value.map((r) => ({ ...r })));
// 子组件把 props 当变化处理，触发表格重建

// ✅ 改：在装配阶段完成一次性结构化；或分片/缓存
const tableData = ref<User[]>([]);
watchEffect(() => {
  tableData.value = buildOnce(rows.value); // 只在 rows 真变时重建
});
```

> 小贴士：**columns 用 `shallowRef`** 通常更合适（列定义对象多且深），避免被深度代理带来的性能损耗与不必要的依赖追踪。

---

## 四、原理层面再解释一句话

- **React**：**函数体=渲染时刻**，字面量对象/数组每渲染一次就**新建引用**；库（TanStack Table）根据引用变更重建内部模型，再配合你自己的 `setState`，就可能形成闭环。
- **Vue**：**响应式=依赖追踪**，若你在响应式计算链条里**每次产出新引用**传递下去，或**监听后回写自身**，一样会形成\*\*“变化 → 重建 → 再变化”\*\*的回路。

---

## 五、实战检查清单

- [ ] `columns` 是否用 `useMemo`（React）或 `shallowRef`（Vue）？
- [ ] `data` 是否来自 `useState/ref` 或外部状态，而不是每次渲染重建？
- [ ] 是否避免 `data ?? []` 这类**内联新建** fallback？
- [ ] 是否存在“监听 A ⇒ 写回 A/其派生”的**自激活 watch/effect**？
- [ ] 大对象（列定义）是否避免深度代理（Vue 用 `shallowRef`）？

---

如需，我可以把你现有的 React/Vue 表格初始化代码**逐行体检**，只给出**需要修改的片段**并在复杂逻辑上一行加注释，帮你把“稳定引用”彻底梳理好。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试文章]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/常用库/split.js的使用</id>
        <link href="https://herongdev.github.io/blog/posts/前端/常用库/split.js的使用"/>
        <updated>2025-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[<一句话摘要，便于 SEO>]]></summary>
        <content type="html"><![CDATA[
# **Split.js** 配置项

## 1. `direction: 'horizontal'`

- **作用**：设置分割方向。
- **可选值**：
  - `'horizontal'`：左右分割（垂直分隔条）。
  - `'vertical'`：上下分割（水平分隔条）。
- **这里的用法**：`'horizontal'` 表示左边是 SymbolList，右边是 ChartPanel。

## 2. `sizes: [sidebarPanelWidth.value, containerWidth - sidebarPanelWidth.value]`

- **作用**：设置两个面板的初始尺寸（像素或百分比）。
- **值的含义**：
  - 第一个值：左侧面板宽度（这里是 `sidebarPanelWidth.value`）。
  - 第二个值：右侧面板宽度（容器总宽度减去左侧宽度）。
- **注意**：如果传百分比（如 `[30, 70]`），则按比例分配；传像素值则按固定像素。

## 3. `minSize: [0, 0]`

- **作用**：设置每个面板的最小尺寸。
- **值的含义**：
  - `[0, 0]` 表示两个面板都可以被拖到 0 像素（完全隐藏）。
- **常见用法**：防止面板被拖得太小导致内容不可见，比如 `[200, 300]`。

## 4. `maxSize: [tableWidth, Infinity]`

- **作用**：设置每个面板的最大尺寸。
- **值的含义**：
  - 第一个值：左侧最大宽度是 `tableWidth`（表格宽度）。
  - 第二个值：右侧最大宽度无限制（`Infinity`）。
- **用途**：避免左侧面板被拖得过宽，影响右侧内容显示。

## 5. `gutterSize: 8`

- **作用**：分隔条的宽度（水平分割时是宽度，垂直分割时是高度）。
- **值的含义**：`8` 表示分隔条宽度为 8 像素。

## 6. `snapOffset: chartPanelHeight.value < 10 ? 0 : 10`

- **作用**：拖动时的“吸附”距离。
- **值的含义**：
  - 如果 `chartPanelHeight` 小于 10，则吸附距离为 0（无吸附）。
  - 否则为 10 像素，表示拖动接近边界 10 像素时会自动吸附到边界。
- **用途**：提升拖动体验，方便快速收起或展开面板。

## 7. `elementStyle: (dimension, size, gutterSize) => ({ 'flex-basis': \`calc(${size}px - ${gutterSize}px)\` })`

- **作用**：自定义面板的 CSS 样式。
- **这里的逻辑**：
  - `flex-basis` 决定了面板在 Flex 布局中的基础尺寸。
  - 用 `calc()` 减去分隔条的宽度，保证布局精确。

## 8. `gutterStyle: () => ({ width: '8px', background: 'var(--ground-50)', cursor: 'col-resize' })`

- **作用**：自定义分隔条的样式。
- **值的含义**：
  - `width: '8px'`：分隔条宽度。
  - `background: 'var(--ground-50)'`：背景颜色（CSS 变量）。
  - `cursor: 'col-resize'`：鼠标悬停时显示左右拖动的光标。

## 9. `onDrag: (sizes) => handleSidebarResizing(sizes)`

- **作用**：拖动分隔条时触发的回调。
- **值的含义**：
  - `sizes` 是当前两个面板的尺寸数组。
  - `handleSidebarResizing(sizes)` 是你自定义的函数，用来更新状态（比如保存用户调整后的宽度）。

### 总结表

| 属性           | 作用            | 常用值示例                    |
| -------------- | --------------- | ----------------------------- |
| `direction`    | 分割方向        | `'horizontal'` / `'vertical'` |
| `sizes`        | 初始尺寸        | `[300, 700]` 或 `[30, 70]`    |
| `minSize`      | 最小尺寸        | `[200, 300]`                  |
| `maxSize`      | 最大尺寸        | `[500, Infinity]`             |
| `gutterSize`   | 分隔条宽度/高度 | `8`                           |
| `snapOffset`   | 吸附距离        | `0` / `10`                    |
| `elementStyle` | 面板样式        | 自定义函数                    |
| `gutterStyle`  | 分隔条样式      | 自定义函数                    |
| `onDrag`       | 拖动回调        | `(sizes) => { ... }`          |

如果你愿意，我可以帮你画一个 **Split.js 配置可视化示意图**，让你直观理解这些参数是如何影响布局的，这样你在调试时会更快找到合适的值。  
你想让我帮你画这个示意图吗？

# 如何隐藏侧板

- 将保存侧板宽度的变量的值设置为 0
- 调用 horizontalSplit.setSizes 方法，重置面板数组中的有面板的宽度值
- 如果是最外侧的面板，我们隐藏一下 gutter, 主要是通过给分隔面板的父 Ref 添加一个新的 no-gutter 样式类；这个样式主要就是 display: none !important;

# 如何分隔上下面板，并支持最大化、最小化和正常

- 安装库，给要分隔的面板和它的父面板加上类和 ref，便于控制
- 在 onMounted 后，初始化面板的初始大小，间隔，最大最小的尺寸
- 如果只有上下两块，它就只有三个状态：最大化、最小化、在最大和最小之间的任意尺寸；
- 我们通过调用 setSizes 设置 2 个面板的宽度，同时更新保存这 2 个值的数组；
- 如果我们想最大或最小化时，隐藏 gutter，可以在到达最大或最小时，给面板的父容器加上 no-gutter 样式类，隐藏 gutter，当切换到最大和最小之间时，我们又移除样式；
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/常用库/tanstack更新]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/常用库/tanstack更新</id>
        <link href="https://herongdev.github.io/blog/posts/前端/常用库/tanstack更新"/>
        <updated>2025-09-18T17:26:53.129Z</updated>
        <content type="html"><![CDATA[结论先说：
在 **@tanstack/vue-table v8.20+** 中，`useVueTable` 的 `data` 是按 **shallowRef（浅层响应）** 来处理的——**只侦听 `ref` 的 `.value` 本身是否换了新引用**。因此：

- **改数组元素的属性**（例如把某一行的 “报价” 改价）——**需要让 `dataRef.value` 指向一个**新的数组引用，表格才会进行必要的重算/渲染。
- **增删元素**（push/pop/splice）这种**原地修改**不会更换数组引用，表格**不会**感知，需要**重建一个新数组再赋回 `dataRef.value`**。
- 官方文档在 “Using Reactive Data” 专章明确说明了这一点，并给了示例：`dataRef.value.push(...)` 不会更新；`dataRef.value = [...dataRef.value, ...]` 才会更新。([tanstack.com][1])

---

## 为什么必须“换引用”？

- 适配层用 **shallowRef** 做了性能优化：**不追踪深层变动**（数组内部元素或其字段的改动），**只在 `.value` 指向新引用时**触发表格的行模型/排序/过滤等重算。
- TanStack Table 也明确：**当 `data/columns` 的引用变了**，或表格内部 state 变了，就会触发更新；而**稳定引用**避免无谓的重建/循环渲染。([tanstack.com][2])

---

## 实战建议（Vue 3）

### 1）更新单行“报价”字段（不可变更新）

> 逻辑：按 id 找到目标行 → 复制出一个新数组 → 用新对象替换该行 → 把**新数组**赋回 `dataRef.value`

```ts
// 在复杂逻辑上一行加注释：不可变更新，生成新数组引用以触发表格重算
function updatePriceById(id: string, price: number) {
  const idx = indexById.get(id);
  if (idx === undefined) return;
  const next = dataRef.value.slice();
  next[idx] = { ...next[idx], price };
  dataRef.value = next; // ← 必须换引用，shallowRef 才会触发更新
}
```

### 2）新增 / 删除一行

```ts
// 在复杂逻辑上一行加注释：新增时返回新数组引用（避免 push 原地修改）
function addRow(row: Row) {
  dataRef.value = [...dataRef.value, row]; // ← 换引用
}

// 在复杂逻辑上一行加注释：删除时用 filter 产生新数组引用（避免 splice 原地修改）
function removeRowById(id: string) {
  dataRef.value = dataRef.value.filter((r) => r.id !== id); // ← 换引用
}
```

### 3）批量高频更新（如行情报价流）

> 逻辑：把多次更新合并为**一帧**（或节流窗口）后再一次性换引用，降低开销

```ts
// 在复杂逻辑上一行加注释：用 requestAnimationFrame 合批更新，避免每次报价都重建数组
const pending: Record<string, number> = {};
let scheduled = false;

export function queuePrice(id: string, price: number) {
  pending[id] = price;
  if (scheduled) return;
  scheduled = true;
  requestAnimationFrame(() => {
    const next = dataRef.value.slice();
    for (const [id, p] of Object.entries(pending)) {
      const idx = indexById.get(id);
      if (idx !== undefined) next[idx] = { ...next[idx], price: p };
      delete pending[id];
    }
    dataRef.value = next; // ← 一次性换引用
    scheduled = false;
  });
}
```

### 4）保持行状态不丢（强烈建议）

> 逻辑：让表格用**稳定的行 id**，避免你替换数组后选中/展开等状态乱跳

```ts
// 在复杂逻辑上一行加注释：用 getRowId 保持行标识稳定（而非默认的行索引）
const table = useVueTable({
  columns,
  data: dataRef,
  getRowId: (row) => row.id,
});
```

（`getRowId` 的用途与示例详见官方 Rows/Row APIs 文档。) ([tanstack.com][3])

---

## 常见误区对照

- **误区**：`dataRef.value.push(row)` / `splice`
  **现象**：表格不更新或排序/分组不同步。
  **正确**：`dataRef.value = [...dataRef.value, row]` / `filter` 产生新数组再赋回。([tanstack.com][1])

- **误区**：`dataRef.value[i].price = x` 只改了对象字段
  **现象**：某些单元格可能更新，但**排序/汇总/分组**不重算或不一致。
  **正确**：替换为新对象，并**整体换引用**：`dataRef.value = withUpdatedRow(...)`。([tanstack.com][1])

- **误区**：把列定义/数据字面量写在 `<template>` 或渲染过程中
  **风险**：频繁生成新引用，引起不必要的重建甚至循环渲染（尤其是 React 端）。
  **正确**：列用 `shallowRef`、数据用 `ref`，在 `<script setup>` 顶层准备好稳定引用；React 用 `useMemo`/`useState`。([tanstack.com][2])

---

## 回答你的两个关键问题

1）**“难道我必须改变 `data.value` 才会重新渲染吗？”**

> 在 Vue 适配器中，是的——**要让表格识别到变化，需要让 `dataRef.value` 指向一个新数组引用**（哪怕你只是改了某个元素的某个字段）。这是由于官方采用 **shallowRef** 只侦听 `.value` 的引用变化。([tanstack.com][1])

2）**“如果数组元素增加、减少或变化，也不需要（= 不必）用 `.value` 重置数据源吗？”**

> 需要。**增/删/改**都应当以**不可变更新**的方式生成**新数组**并赋给 `dataRef.value`。原地 `push/pop/splice` 或只改对象字段不会触发表格的正确更新路径。官方给出的示例也明确了这一点（`push` 不更新，重新赋值才更新）。([tanstack.com][1])

---

## 性能与工程化补充

- **不可变更新的成本**：一次创建新数组是 O(n)，在“几千行”规模通常可接受；TanStack Table 内部对行模型有优化，配合虚拟滚动使用时依然顺滑。若有**高频行情**，建议合批（见上文 rAF 方案）或**按时间窗节流**。
- **服务端驱动**：若列表很大且更新频密，可只下发变化集（patch），在客户端\*\*应用 patch 后仍然以“新数组赋回”\*\*的方式触发表格刷新。
- **列与数据的“稳定引用”策略**：列用 `shallowRef([...])`，数据用 `ref<Row[]>([])`，统一通过“新数组赋回”来驱动更新，避免在模板/计算属性里临时构造数组对象。

---

### 参考

- **Table State (Vue) / Using Reactive Data**：支持 `ref/computed`，但**示例明确：必须给 `dataRef.value` 赋新数组**才会更新；`push` 不会触发。([tanstack.com][1])
- **FAQ / Data Guide / Table Instance**：强调需要**稳定引用**，错误做法会导致重复重建/循环渲染。([tanstack.com][2])
- **Rows / Row APIs**：使用 `getRowId` 保持行状态稳定。([tanstack.com][3])

如果你愿意，把你现在的 `useVueTable` 初始化和“报价更新”那段代码贴出来；我只给**需要修改的片段**，并在复杂逻辑上一行加注释，帮你改成**不可变更新 + 合批**的版本。

[1]: https://tanstack.com/table/latest/docs/framework/vue/guide/table-state "Table State (Vue) Guide | TanStack Table Vue Docs"
[2]: https://tanstack.com/table/latest/docs/faq?utm_source=chatgpt.com "FAQ | TanStack Table Docs"
[3]: https://tanstack.com/table/latest/docs/guide/rows?utm_source=chatgpt.com "Rows Guide | TanStack Table Docs"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/常用库/浮层]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/常用库/浮层</id>
        <link href="https://herongdev.github.io/blog/posts/前端/常用库/浮层"/>
        <updated>2025-09-18T17:26:53.129Z</updated>
        <content type="html"><![CDATA[好的，我给你一个**可落地**的实现方案：点击 `Bid/Ask` 单元格时，**在单元格旁边**弹出交易面板；若屏幕较小（如 ≤768px），自动改为 **底部 Drawer** 展示。方案要点：

- **定位与避免遮挡**：用 `@floating-ui/dom`（更稳健的 Popper 替代）做锚点定位，自动 `flip/shift/offset/size`，保证面板不超出视口。
- **滚动/缩放自适应**：用 `autoUpdate` 绑定 window 和滚动容器，实时重算位置。
- **渲染层级与性能**：面板 `Teleport` 到 `body`（脱离表格 DOM），避免虚拟滚动/溢出隐藏的裁切问题。
- **小屏体验**：用 `a-drawer` 底部弹出（建议 80vh），手势/返回键关闭。
- **关闭逻辑**：点击空白处、ESC 关闭；支持回收监听器。

> 下面**只给必要的修改片段**（遵循你“只给改动，不贴整文件”的偏好）。复杂逻辑处，我在**上一行加注释**。

---

## 1) 安装依赖

```bash
pnpm add @floating-ui/dom
```

---

## 2) 列定义：在 `Bid/Ask` 单元格里，传出“锚点元素 + 行数据 + 点击侧别”

> 在 `getSymbolListColumns` 的入参里增加 `onOpenTradePanel` 回调，并在 `Bid/Ask` 的根容器上绑定 `onClick`。

```ts
// ✅ 仅补充这段：给函数入参加一个 onOpenTradePanel
export const getSymbolListColumns = ({
  t,
  onToggleFav,
  allSymbolMarketStatus,
  // 在外层页面实现此回调，用于打开面板
  onOpenTradePanel,
}: {
  t: (key: string) => string
  onToggleFav: (row: SymbolListRow) => void
  allSymbolMarketStatus: Ref<Record<string, MarketState>>
  onOpenTradePanel: (opts: {
    row: SymbolListRow
    anchorEl: HTMLElement
    // 点击的是哪个列，决定预设买/卖侧
    side: 'buy' | 'sell'
  }) => void
}) => {
```

```tsx
// ✅ 仅修改 Bid 单元格：把最外层 <div> 增加 onClick，传出当前元素与侧别
// 复杂：e.currentTarget 作为锚点元素，确保定位到可见 DOM 节点
<div
  class={["cell-quote font-number", flashClass]}
  data-trend={bidTrend ?? "none"}
  onClick={(e: MouseEvent) => {
    // 复杂逻辑：从事件里取到触发元素，作为浮窗锚点
    const anchor = e.currentTarget as HTMLElement;
    onOpenTradePanel?.({
      row: (e as any).currentTarget?.["__row"] ?? ({} as any),
      anchorEl: anchor,
      side: "sell",
    });
  }}
>
  <PriceTrendCell value={bid} trend={bidTrend} />
</div>
```

```tsx
// ✅ 仅修改 Ask 单元格：同理传出 side='buy'
<div
  class={["cell-quote font-number text-ink-900", flashClass]}
  data-trend={askTrend ?? "none"}
  onClick={(e: MouseEvent) => {
    // 复杂逻辑：锚点 + 侧别（买）
    const anchor = e.currentTarget as HTMLElement;
    onOpenTradePanel?.({
      row: (e as any).currentTarget?.["__row"] ?? ({} as any),
      anchorEl: anchor,
      side: "buy",
    });
  }}
>
  <PriceTrendCell value={ask} trend={askTrend} class="text-ink-900" />
</div>
```

> 注：`(e as any).currentTarget?.['__row']` 是一个占位写法。若你已有 `row` 作用域，可在外层作用域捕获 `row.original`，再闭包带入；或者使用你项目里的“把 row 附着到 DOM”的现成方式。若需要，我可以按你实际表格封装补齐这一行。

---

## 3) 新增 composable：`useTradePanelOverlay.ts`

> 负责：开/关、定位、监听滚动与 Resize、小屏判断。**复杂逻辑均在上一行加注释**。

```ts
// src/composables/useTradePanelOverlay.ts
import { ref, shallowRef, onBeforeUnmount, computed } from "vue";
import {
  autoUpdate,
  computePosition,
  flip,
  shift,
  offset,
  size,
} from "@floating-ui/dom";

// 简单媒体查询（也可切到更通用的 useMediaQuery）
const isSmallScreen = () => window.matchMedia("(max-width: 768px)").matches;

export function useTradePanelOverlay() {
  const open = ref(false);
  const usingDrawer = ref(false);
  const anchorEl = shallowRef<HTMLElement | null>(null);
  const floatingEl = shallowRef<HTMLElement | null>(null);
  const style = ref<{
    top: string;
    left: string;
    minWidth?: string;
    maxHeight?: string;
  }>({ top: "0px", left: "0px" });
  let cleanup: (() => void) | null = null;

  // 复杂：根据可视区域与锚点动态定位（右侧优先，不够则 flip）
  const updatePosition = async () => {
    if (!anchorEl.value || !floatingEl.value) return;
    await computePosition(anchorEl.value, floatingEl.value, {
      placement: "right-start",
      middleware: [
        // 复杂：与锚点留出 8px 间距
        offset(8),
        // 复杂：当右侧空间不足时自动翻转到左/上/下
        flip(),
        // 复杂：将浮层保持在视口内
        shift({ padding: 8 }),
        // 复杂：根据视口动态裁剪高度，并回写到样式
        size({
          apply({ availableHeight, elements }) {
            const el = elements.floating as HTMLElement;
            el.style.maxHeight = Math.max(280, availableHeight - 16) + "px";
          },
          padding: 8,
        }),
      ],
    }).then(({ x, y }) => {
      style.value = { top: `${y}px`, left: `${x}px` };
    });
  };

  // 复杂：开启时使用 autoUpdate 绑定滚动/resize/布局变化自动重算
  const beginAutoUpdate = () => {
    if (!anchorEl.value || !floatingEl.value) return;
    cleanup = autoUpdate(anchorEl.value, floatingEl.value, updatePosition);
  };

  const endAutoUpdate = () => {
    cleanup?.();
    cleanup = null;
  };

  const openAt = (anchor: HTMLElement) => {
    anchorEl.value = anchor;
    usingDrawer.value = isSmallScreen();
    open.value = true;
    // 复杂：Drawer 模式无需定位
    if (!usingDrawer.value) {
      // 复杂：首次定位 + 监听
      requestAnimationFrame(() => {
        updatePosition();
        beginAutoUpdate();
      });
    }
  };

  const close = () => {
    open.value = false;
    endAutoUpdate();
  };

  onBeforeUnmount(endAutoUpdate);

  return {
    open,
    usingDrawer,
    anchorEl,
    floatingEl,
    style,
    openAt,
    close,
  };
}
```

---

## 4) 新增覆盖层组件：`TradePanelOverlay.vue`

> 用 `Teleport` 到 `body`。桌面显示**锚点浮窗**，小屏显示 **Drawer**。里面直接复用你给的“交易面板组件”。

```vue
<!-- src/components/TradePanelOverlay.vue -->
<template>
  <Teleport to="body">
    <!-- 桌面端：锚点浮窗 -->
    <transition name="fade">
      <div
        v-if="open && !usingDrawer"
        class="fixed z-[1500]"
        :style="style"
        ref="floatingEl"
      >
        <!-- 复杂：点击浮层外部关闭（盖一层透明背景） -->
        <div class="fixed inset-0 z-[-1]" @click="onBackdropClick"></div>

        <!-- 内容容器，宽度可根据面板需要微调 -->
        <div
          class="rounded-md shadow-lg bg-white w-[320px] max-h-[80vh] overflow-auto"
        >
          <TradePanel
            :symbolInfo="symbolInfo"
            :accountInfo="accountInfo"
            @close="close"
          />
        </div>
      </div>
    </transition>

    <!-- 小屏：底部 Drawer -->
    <a-drawer
      v-model:open="drawerOpen"
      placement="bottom"
      :height="drawerHeight"
      :closable="false"
      :mask-closable="true"
      @close="close"
    >
      <TradePanel
        :symbolInfo="symbolInfo"
        :accountInfo="accountInfo"
        @close="close"
      />
    </a-drawer>
  </Teleport>
</template>

<script setup lang="ts">
import { computed, watch, ref } from "vue";
import { useTradePanelOverlay } from "@/composables/useTradePanelOverlay";
import TradePanel from "@/path/to/你的交易面板组件.vue"; // ← 指向你贴的那个组件文件

const props = defineProps<{
  symbolInfo: any;
  accountInfo: any;
}>();

const { open, usingDrawer, floatingEl, style, close } = useTradePanelOverlay();

// 复杂：Drawer 的受控开关从 overlay 的 open/usingDrawer 派生
const drawerOpen = computed({
  get: () => open.value && usingDrawer.value,
  set: (v: boolean) => {
    if (!v) close();
  },
});

// 复杂：小屏建议高度 80vh，可按实际微调
const drawerHeight = computed(() => "80vh");

const emit = defineEmits(["backdropClick"]);
const onBackdropClick = () => emit("backdropClick");

// 暴露方法给外部控制打开（通过 defineExpose）
const openAt = (anchor: HTMLElement) => {
  // 复杂：把 openAt 暴露给父组件，父组件传入锚点元素
  // 实际逻辑在 composable 里
  (useTradePanelOverlay() as any).openAt(anchor);
};

defineExpose({ openAt, close, open, usingDrawer, floatingEl, style });
</script>

<style scoped>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.12s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

> 若你喜欢保持组件“纯展示”，也可以把 `useTradePanelOverlay` 搬去父组件，只在这里接收 `open/usingDrawer/style/...` 作为 props；我给的是“自包含”版本，便于直接用。

---

## 5) 父级页面接入（持表格的页面）

> 在渲染表格的父页面里放一个 `TradePanelOverlay` 单例，通过 `ref` 控制它。
> **只给新增/修改片段**：

```ts
// ✅ 新增：状态与回调
import { ref } from "vue";
import TradePanelOverlay from "@/components/TradePanelOverlay.vue";

const overlayRef = ref<InstanceType<typeof TradePanelOverlay> | null>(null);

const overlaySymbolInfo = ref<any>(null);
const overlayAccountInfo = ref<any>(null); // 你的账户信息来源
// 复杂：从列点击进入时设置默认买/卖侧，可通过 props 传给面板或在面板内 watch 决定
const overlayDefaultSide = ref<"buy" | "sell">("buy");

// ✅ 新增：提供给列定义的回调
const onOpenTradePanel = ({
  row,
  anchorEl,
  side,
}: {
  row: SymbolListRow;
  anchorEl: HTMLElement;
  side: "buy" | "sell";
}) => {
  overlaySymbolInfo.value = row; // 若 row 里就带了 symbolInfo
  overlayDefaultSide.value = side;
  // 复杂：通过 ref 调用浮层的 openAt，传入锚点元素
  overlayRef.value?.openAt(anchorEl);
};

// ✅ 传给列定义
const columns = getSymbolListColumns({
  t,
  onToggleFav,
  allSymbolMarketStatus,
  onOpenTradePanel,
});
```

```vue
<!-- ✅ 在父模板里挂一个浮层实例（单例即可） -->
<TradePanelOverlay
  ref="overlayRef"
  :symbolInfo="overlaySymbolInfo"
  :accountInfo="accountInfo"
/>
```

> 如果你的交易面板需要拿到 `defaultSide` 预设买卖，可以把 `overlayDefaultSide` 也作为 prop 传下去，在面板 `watch` 设置 `state.tradeSide`。

---

## 6) 交易面板组件里的小改动（可选）

> 当从 `Bid` 打开时默认 `SELL`，从 `Ask` 打开时默认 `BUY`。如果你要在面板内部处理，**只加下面这段**：

```ts
// ✅ 仅在 <script setup> 里新增：接收 defaultSide（buy/sell）
const props = withDefaults(
  defineProps<{
    /* ...原有 props... */
    defaultSide?: "buy" | "sell";
  }>(),
  { defaultSide: "buy" }
);

// 复杂：面板初次打开或 defaultSide 变化时，设置 tradeSide
watch(
  () => props.defaultSide,
  (val) => {
    // 复杂逻辑：与枚举映射
    state.tradeSide = val === "buy" ? TradeSide.BUY : TradeSide.SELL;
  },
  { immediate: true }
);
```

> 如果你选择**父组件**直接改 `state.tradeSide`，那这里就不需要改。

---

## 7) 关键细节与取舍说明（调研结论）

1. **定位库选择**

   - AntD 的 `a-popover`/`a-dropdown` 适合小内容；你的面板较长、交互多，**推荐 `@floating-ui/dom`**，具备 `flip/shift/size/autoUpdate`，在复杂容器（虚拟滚动、`overflow: hidden`）中更稳。

2. **Teleport 到 body**

   - 表格容器常有 `overflow` 或虚拟滚动；把浮层 `Teleport` 到 `body`，能避免裁切与定位偏差。

3. **滚动容器**

   - `autoUpdate` 会监听最近滚动容器与 window；对表格内滚动/外层滚动都能自动重算，**无需手写滚动监听**。

4. **小屏 Drawer**

   - 大面板在手机端贴边浮出可用性差，底部 Drawer（80vh）更好；AntD Drawer 自带遮罩、关闭动效、焦点管理。

5. **关闭策略**

   - 点击遮罩、ESC 关闭；桌面浮窗加一层“全屏透明层”用于点击外部关闭（我在上面代码里加了）。

6. **性能**

   - 面板只在打开时挂载；`autoUpdate` 只在打开时激活，关闭即清理监听，避免泄漏。

7. **尺寸自适应**

   - `size()` 中写回 `maxHeight`，配合容器 `overflow-auto`；小屏交由 Drawer 处理高度。

8. **可访问性**

   - Drawer 天生可聚焦；浮窗可在打开时把焦点 `focus()` 到面板第一个可交互元素（如 `AccountSelector`），需要的话可再补一行 `onMounted` 的 `nextTick(() => el.focus())`。

---

## 8) 常见坑位与解决

- **单元格点击拿不到 row**：在 TSX 渲染器作用域里提前捕获 `row.original` 到闭包变量，再传给 `onOpenTradePanel`。我在上面留了占位注释。
- **z-index 冲突**：AntD 遮罩是 1000/1050 级别；给浮窗根元素 `z-[1500]`（或自定义更高）避免被覆盖。
- **容器 transform 影响定位**：`@floating-ui` 使用 `getBoundingClientRect`，不受 transform 影响；避免自己写 `offsetTop` 之类计算。
- **面板过宽**：可在桌面端给固定宽度（如 320\~360px），在 `size()` 里只控制高度；更宽就更像侧边抽屉，不建议贴边弹出。

---

如果你把父页面/列定义文件结构贴出来（尤其是如何获取 `row`、账户信息在哪），我可以**按你的文件结构**把上面的占位和类型补齐成可直接粘贴运行的版本。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[/user 会不会匹配根路由 ‘/’？]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/路由/user-会不会匹配根路由-‘-’？</id>
        <link href="https://herongdev.github.io/blog/posts/前端/路由/user-会不会匹配根路由-‘-’？"/>
        <updated>2025-09-05T19:00:06.000Z</updated>
        <content type="html"><![CDATA[
---

title: “/user 会不会匹配根路由 ‘/’？”
date: 2025-09-05
tags: \[Vue Router 4, 路由匹配, 懒加载]

---

## 结论

不会。`/user` **不会**匹配到你定义的根路由 `{ path: '/' }`。它只会匹配到**自己**这条顶层路由 `{ path: '/user' }`，因此也**不会**渲染 `@/views/(public)/layout.vue`。

## 为什么

- Vue Router 使用基于 `path-to-regexp` 的**精确匹配**。`'/'` 不是“前缀匹配一切”，只匹配根路径本身，或作为**父路由**被命中的**相对子路由**所包含。
- 你现在把 `/user` 定义为**顶层**路由（不在 `children` 里），所以跳转到 `/user` 时，`to.matched` 里只有 `/user` 这一条记录，不会包含 `'/'` 那个布局。

## 什么时候会经过 `'/'` 布局？

只有当你把 **子路由写成相对路径** 时，例如：

```ts
// 复杂逻辑：相对子路由会被拼成 /user，且会渲染父布局
{
  path: '/',
  component: () => import('@/views/(public)/layout.vue'),
  children: [
    { path: 'user', component: () => import('@/views/user/page.vue') } // 注意没有前导斜杠
  ]
}
```

上面这种写法才会让 `/user` 经过 `layout.vue`。而你当前是：

```ts
{ path: '/user', component: () => import('@/views/user/page.vue') } // 顶层、绝对路径
```

两者行为不同。

## 快速自检（可在控制台验证）

```ts
// 复杂逻辑：查看匹配链，确认是否包含根布局
console.log(router.resolve("/user").matched.map((r) => r.path));
// 期望：['/user']，而不是 ['/', '/user']
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Axios 封装优化（登出后“仍有请求”与 401 统一处理）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/仍有请求与401统一处理）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/仍有请求与401统一处理）"/>
        <updated>2025-09-05T20:15:05.000Z</updated>
        <content type="html"><![CDATA[
> 只给**需要改的代码片段**；复杂逻辑我都在上一行加了**中文注释**。以下改动基于你贴的这份 `http` 封装。

## 1) 请求可“集中取消”& 退出后不再飞行

**位置：请求拦截器内（`_axios.interceptors.request.use`）头部插入**

```ts
// 复杂逻辑：为每个请求创建可集中取消的 AbortController，并桥接外部 signal
const ac = new AbortController();
if (req.signal) {
  const ext = req.signal as AbortSignal;
  if (ext.aborted) ac.abort();
  else ext.addEventListener?.("abort", () => ac.abort());
}
req.signal = ac.signal;
abortPool.add(ac);
// 复杂逻辑：把本次请求的 controller 暂存到 config 上，方便响应阶段释放
(req as any).__ac = ac;
```

**位置：响应成功拦截器（`res` 分支）里，`return res` 之前插入**

```ts
// 复杂逻辑：请求完成后，从取消池中释放 controller
const ac = (res.config as any).__ac as AbortController | undefined;
if (ac) abortPool.delete(ac);
```

**位置：响应失败拦截器（`err` 分支）里，`return Promise.reject(err)` 之前插入**

```ts
// 复杂逻辑：请求失败同样释放 controller，避免池子泄漏
const ac = (err?.config as any)?.__ac as AbortController | undefined;
if (ac) abortPool.delete(ac);
```

> 这样就和你现有的 `cancelAll()` 打通了：登出时执行 `cancelAll()`，所有在途请求立刻中止。

---

## 2) “未登录硬拦”鉴权请求（默认需要鉴权）

**位置：请求拦截器内，给你现有的加 Token 逻辑**改为如下\*\*

```ts
// 复杂逻辑：统一鉴权开关——默认需要鉴权，白名单或显式 { auth:false } 不需要
const needAuth =
  (req as any).auth !== false && !noAuthPaths.includes(req.url || "");

// 复杂逻辑：无 Token 且需要鉴权时，直接阻断请求，避免未登录拉数据
const at = storage.get(ACCESS_TOKEN);
const tt = storage.get(TOKEN_TYPE) || "Bearer";
if (needAuth && !at) {
  // 同时中止本次请求，确保不会真正发出
  ((req as any).__ac as AbortController | undefined)?.abort();
  return Promise.reject(new Error("UNAUTHENTICATED"));
}

// 复杂逻辑：有 Token 再注入 Authorization 头
if (needAuth && at) {
  req.headers = { ...req.headers, Authorization: `${tt} ${at}` };
}
```

> 使用方式：需要鉴权的 API **不用写任何额外配置**（默认会拦），公开 API（或登录/注册）**明确**加上 `{ auth: false }` 即可。

---

## 3) 统一 401 处理（去掉 `useRouter` 的非法使用）

**位置：你的 `codeResponseParser` 内，将 401 分支替换为：**

```ts
// 复杂逻辑：统一未授权处理（不在解析器里用 useRouter）
if (code === 401) {
  storage.remove(ACCESS_TOKEN);
  storage.remove(TOKEN_TYPE);
  // 复杂逻辑：避免组合式 API 环境限制，使用硬跳转到登录页
  if (window.location.pathname !== LOGIN_ROUTE.path) {
    window.location.replace(LOGIN_ROUTE.path);
  }
  throw new Error("未授权，请重新登录");
}
```

**位置：响应失败拦截器（`err` 分支）里，加入 HTTP 401 fallback**

```ts
// 复杂逻辑：后端直接返回 HTTP 401 时的兜底处理
if (err?.response?.status === 401) {
  storage.remove(ACCESS_TOKEN);
  storage.remove(TOKEN_TYPE);
  if (window.location.pathname !== LOGIN_ROUTE.path) {
    window.location.replace(LOGIN_ROUTE.path);
  }
}
```

> 说明：`useRouter()` 不能在解析器（组件外）调用，上面用 `window.location.replace` 做了上下文无关的重定向。

---

## 4) 实例方法：供登出调用（清鉴权头 & 集中取消）

**位置：`createAxiosHttp` 末尾、`return _axios as unknown as AxiosInstance` 前插入**

```ts
// 复杂逻辑：向实例挂载工具方法，供外部优雅下线使用
(_axios as any).cancelAll = cancelAll;
(_axios as any).setAuthToken = (token?: string | null, type = "Bearer") => {
  if (token) {
    _axios.defaults.headers.common.Authorization = `${type} ${token}`;
    storage.set(ACCESS_TOKEN, token);
    storage.set(TOKEN_TYPE, type);
  } else {
    delete _axios.defaults.headers.common.Authorization;
    storage.remove(ACCESS_TOKEN);
    storage.remove(TOKEN_TYPE);
  }
};
```

> 这样在 `logout()` 里可以写：`http.cancelAll?.(); http.setAuthToken?.(null)`。

---

## 5) （可选）请求方法支持 `formdata` 与 `auth` 透传

**位置：你重写的 `(_axios as any).request = async function ...` 的**函数签名**与**组装 `cfg`**部分替换为：**

```ts
// 复杂逻辑：扩展 contentType，支持 formdata；透传 { auth?: boolean, signal?: AbortSignal }
(_axios as any).request = async function <T, P = RequestParams>(
  url: string,
  method: Method = "GET",
  params?: P,
  reqCfg?: AxiosRequestConfig & { auth?: boolean; signal?: AbortSignal },
  contentType: "json" | "urlencoded" | "formdata" = "json"
): Promise<T> {
  const cfg: AxiosRequestConfig & { auth?: boolean } = {
    url,
    method,
    ...reqCfg,
    headers: { ...reqCfg?.headers },
  };

  if (method === "GET" || method === "HEAD") {
    cfg.params = params;
    cfg.paramsSerializer = (d) =>
      qs.stringify(d, { indices: false, skipNulls: true });
  } else {
    // 复杂逻辑：根据 contentType 选择编码方式
    if (contentType === "formdata") cfg.data = toFormData(params as any);
    else if (contentType === "urlencoded")
      cfg.data = toUrlencoded(params ?? ({} as any));
    else cfg.data = params;

    if (contentType === "urlencoded")
      cfg.headers = {
        ...cfg.headers,
        "Content-Type": "application/x-www-form-urlencoded",
      };
    if (contentType === "json")
      cfg.headers = { ...cfg.headers, "Content-Type": "application/json" };
    // formdata 让浏览器自动带 boundary，不手动设 Content-Type
  }

  return nativeRequest(cfg) as Promise<T>;
};
```

> 有了 `{ auth?: boolean }`，你在公开接口（如 `/api/pub/get_feednews`）调用时可以：

```ts
http.request("/api/pub/get_feednews", "GET", undefined, { auth: false });
```

---

## 6) （配合改动）登出时的两行调用（在你的 `authStore.logout()` 里加）

```ts
// 复杂逻辑：登出时立即中止所有在途请求 + 清鉴权头
http.cancelAll?.();
http.setAuthToken?.(null);
```

---

## 7) （可选）类型补充，便于在项目里显式写 `auth`

**新建：`types/axios.d.ts`**

```ts
// 复杂逻辑：为 AxiosRequestConfig 增加自定义字段 auth
import "axios";
declare module "axios" {
  interface AxiosRequestConfig {
    auth?: boolean;
  }
}
```

---

### 验证 Checklist

- 退出登录瞬间 Network 面板**无新的业务请求**（只有静态资源预取不算）。
- 任何标记 `{ auth: true | 默认 }` 的请求在**无 Token**时不会发出。
- 后端返回 **HTTP 401** 或 **业务码 401**，都能统一清理并跳到登录页。
- `cancelAll()` 能把“已发起未完成”的请求**立即中断**。

以上改完，你截图里“跳转后还发请求”的现象就会消失；即使有极短时序触发，也会被 **AbortController** 和 **未登录硬拦**兜住。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/鉴权-登录/单一入口：包装器 verifiedAction”方案（Vite+Vue3+Pinia）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/单一入口：包装器 verifiedAction”方案（Vite+Vue3+Pinia）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/单一入口：包装器 verifiedAction”方案（Vite+Vue3+Pinia）"/>
        <updated>2025-09-18T17:26:53.130Z</updated>
        <content type="html"><![CDATA[下面我给出**一套“单一入口：包装器 verifiedAction”方案**（Vite+Vue3+Pinia），目标是：**改动最少、好维护、好扩展、使用方便**。
实现要点：

- **Facade 外观服务 + Orchestrator 编排器 + Strategy 插件**（短信/邮箱/验证器 App/通行密钥）。
- 只在你的**关键提交流程**上包一层 `verifiedAction('security_code', () => yourAction())` 即可。
- 管理后台通过 `/api/security/list` 下发哪些模块需要 MFA；前端本地缓存 60s，**O(1)** 判断；需要才触发 `/api/security/begin` 的**AND/OR**组合验证编排。
- **所有新文件**都放到 `src/security/`，原有业务只需在**关键按钮的方法**里增加一行包装调用；以及在 `src/main.ts` **新增一行 import** 完成验证器注册。

> 你要求“对于调整的代码，给完整代码；说明目录位置”。下面逐个文件给出**目录与完整代码**。复杂逻辑我按你的习惯在**上一行加注释**。

---

# 新增文件（放入你的项目）

## 1）`src/security/types.ts`

```ts
export interface SecurityBeginReq {
  security_code: string;
  credential_type?: "1" | "2";
  passage_key?: string;
  [k: string]: any;
}

export interface Parameters {
  length?: number;
  [k: string]: any;
}

export interface Condition {
  type:
    | "sms_validate"
    | "email_validate"
    | "app_validate"
    | "biometric_validate"
    | string;
  result?: "pending" | "passed" | "failed" | string;
  failed_cnt?: number;
  send_cnt?: number;
  parameters?: Parameters;
  [k: string]: any;
}

export interface Step {
  operator: "AND" | "OR";
  conditions: Condition[];
  [k: string]: any;
}

export interface SecurityBeginData {
  begin_time: string;
  expire_time: string;
  passage_key: string;
  security_code: string;
  status: "0" | "1";
  steps: Step[];
  use_cnt: string;
  [k: string]: any;
}

export interface SecurityBeginRes {
  code: number;
  message: string;
  data: SecurityBeginData;
}

export type VerifyProof = { ok: boolean; proof?: string; detail?: any };

// 上一行：统一的验证器接口，便于动态加载与替换
export interface Verifier {
  // 上一行：执行该要素的完整流程（含弹窗/输入/调用后端），返回是否成功
  start(ctx: {
    condition: Condition;
    passageKey: string;
    securityCode: string;
  }): Promise<VerifyProof>;
}
```

---

## 2）`src/security/api.ts`

```ts
import { http } from "@/libs";
import type { SecurityBeginReq, SecurityBeginRes } from "./types";

// 上一行：统一封装 begin 接口，后续可插入重试/鉴权
export async function apiSecurityBegin(payload: SecurityBeginReq) {
  const resp = await http.call<SecurityBeginRes>({
    url: "/api/security/begin",
    method: "POST",
    data: payload,
  });
  if (resp.code !== 0 && resp.code !== 200)
    throw new Error(resp.message || "security begin failed");
  return resp.data;
}

// 上一行：获取开启 MFA 的业务模块清单
export async function apiSecurityList(): Promise<
  Array<{ model_code: string; model_value: string }>
> {
  const resp = await http.call<{
    code: number;
    message: string;
    data: Array<{ model_code: string; model_value: string }>;
  }>({
    url: "/api/security/list",
    method: "POST",
  });
  if (resp.code !== 200)
    throw new Error(resp.message || "security list failed");
  return resp.data || [];
}
```

---

## 3）`src/security/orchestrator.ts`

```ts
import { apiSecurityBegin } from "./api";
import type { Condition, VerifyProof, Verifier } from "./types";

// 上一行：插件注册表，按后端的 type 选择具体验证器
const registry = new Map<string, () => Promise<Verifier>>();
export function registerVerifier(
  type: string,
  loader: () => Promise<Verifier>
) {
  registry.set(type, loader);
}

// 上一行：OR 默认优先选择更强抗钓鱼要素
function preferChoice(conds: Condition[]) {
  const order = [
    "biometric_validate",
    "app_validate",
    "totp_validate",
    "email_validate",
    "sms_validate",
  ];
  const ranked = [...conds].sort(
    (a, b) => order.indexOf(a.type) - order.indexOf(b.type)
  );
  return ranked[0] || conds[0];
}

// 上一行：执行单个条件（按 type 动态加载插件，失败时可在内部控制重试/错误提示）
async function runOneCondition(
  cond: Condition,
  securityCode: string,
  passageKey: string
) {
  const loader = registry.get(cond.type);
  if (!loader) throw new Error(`未注册验证器: ${cond.type}`);
  const verifier = await loader();
  const { ok } = await verifier.start({
    condition: cond,
    passageKey,
    securityCode,
  });
  return ok;
}

// 上一行：核心编排：处理 AND/OR；支持 UI 选择 OR 内的要素（通过 onPick 回调）
export async function runSecurityFlow(input: {
  securityCode: string;
  credentialType?: "1" | "2";
  passageKey?: string;
  onPick?: (conds: Condition[]) => Promise<Condition>;
}) {
  let { passageKey } = input;
  // 上一行：1) 拉取/刷新策略
  const begin = await apiSecurityBegin({
    security_code: input.securityCode,
    credential_type: input.credentialType,
    passage_key: passageKey,
  });
  passageKey = begin.passage_key;

  if (begin.status === "1") return { ok: true, passageKey };

  for (const step of begin.steps) {
    if (step.operator === "AND") {
      for (const cond of step.conditions) {
        const ok = await runOneCondition(cond, input.securityCode, passageKey);
        if (!ok) throw new Error("验证未通过");
      }
    } else {
      const choice = input.onPick
        ? await input.onPick(step.conditions)
        : preferChoice(step.conditions);
      const ok = await runOneCondition(choice, input.securityCode, passageKey);
      if (!ok) throw new Error("验证未通过");
    }
  }

  // 上一行：3) 复核状态
  const confirm = await apiSecurityBegin({
    security_code: input.securityCode,
    credential_type: input.credentialType,
    passage_key: passageKey,
  });
  if (confirm.status !== "1") throw new Error("服务端未确认验证通过");
  return { ok: true, passageKey };
}
```

---

## 4）`src/security/mfa.service.ts`

```ts
import { apiSecurityList } from "./api";
import { runSecurityFlow } from "./orchestrator";
import type { Condition } from "./types";
import { pickOne } from "./ui";

// 上一行：统一外观：缓存 list、调用 begin、执行编排
export const MFAService = {
  _map: new Map<string, true>(),
  _fetchedAt: 0,
  _ttlMs: 60_000,

  // 上一行：拉取并缓存 /api/security/list，O(1) 判断是否启用
  async isRequired(code: string) {
    const now = Date.now();
    if (this._map.size === 0 || now - this._fetchedAt > this._ttlMs) {
      const list = await apiSecurityList();
      this._map = new Map(list.map((i) => [i.model_value, true]));
      this._fetchedAt = now;
    }
    return this._map.has(code);
  },

  // 上一行：执行完整的“拉策略→按 AND/OR 执行→复核”
  async ensure(
    code: string,
    opts?: {
      credentialType?: "1" | "2";
      onPick?: (c: Condition[]) => Promise<Condition>;
    }
  ) {
    return runSecurityFlow({
      securityCode: code,
      credentialType:
        opts?.credentialType ??
        (/\b(iPhone|iPad|Mac|Safari)\b/i.test(navigator.userAgent) ? "1" : "2"),
      onPick: opts?.onPick ?? pickOne,
    });
  },
};
```

---

## 5）`src/security/verifiedAction.ts`（业务入口——你只需用它包住关键动作）

```ts
import { MFAService } from "./mfa.service";

// 上一行：包装器：先看 list，启用才执行编排；否则直通
export async function verifiedAction<T>(
  securityCode: string,
  action: () => Promise<T>
): Promise<T> {
  if (!(await MFAService.isRequired(securityCode))) return action();
  const { ok } = await MFAService.ensure(securityCode);
  if (!ok) throw new Error("二次验证未通过");
  return action();
}
```

---

## 6）`src/security/ui.ts`（OR 场景下的方式选择弹窗，Ant Design Vue 实现）

```ts
import { Modal, Radio } from "ant-design-vue";
import type { Condition } from "./types";
import { createVNode, reactive } from "vue";

function labelOf(c: Condition) {
  const map: Record<string, string> = {
    sms_validate: "短信验证",
    email_validate: "邮箱验证",
    app_validate: "验证器 App",
    biometric_validate: "通行密钥",
  };
  return map[c.type] || c.type;
}

// 上一行：弹出选择器，返回用户选中的 Condition
export async function pickOne(conds: Condition[]): Promise<Condition> {
  const state = reactive({ value: conds[0]?.type });
  return new Promise((resolve) => {
    const m = Modal.confirm({
      title: "选择一种验证方式",
      content: () =>
        createVNode(
          Radio.Group,
          {
            value: state.value,
            "onUpdate:value": (v: string) => (state.value = v),
            style: "display:flex; flexDirection:column; gap:12px;",
          },
          {
            default: () =>
              conds.map((c) =>
                createVNode(
                  Radio,
                  { value: c.type, style: "display:block; margin:8px 0;" },
                  { default: () => labelOf(c) }
                )
              ),
          }
        ),
      okText: "确定",
      cancelText: "取消",
      onOk: () => {
        const found = conds.find((c) => c.type === state.value) || conds[0];
        resolve(found);
      },
      onCancel: () => resolve(conds[0]),
    });
  });
}
```

---

## 7）`src/security/register.ts`（注册所有验证器插件，应用启动时 import 一次）

```ts
import { registerVerifier } from "./orchestrator";

// 上一行：按需懒加载（避免首屏体积）
registerVerifier(
  "sms_validate",
  async () => (await import("./verifiers/sms")).default
);
registerVerifier(
  "email_validate",
  async () => (await import("./verifiers/email")).default
);
registerVerifier(
  "app_validate",
  async () => (await import("./verifiers/app")).default
);
registerVerifier(
  "biometric_validate",
  async () => (await import("./verifiers/webauthn")).default
);
```

---

## 8）`src/security/verifiers/sms.ts`（短信验证插件）

```ts
import { http } from "@/libs";
import type { Verifier } from "../types";
import { Modal, Input, message } from "ant-design-vue";
import { createVNode, ref } from "vue";

// 上一行：发送验证码 + 输入 + 校验
export default {
  async start({ passageKey, securityCode, condition }) {
    await http.call({
      url: "/api/security/sms/send",
      method: "POST",
      data: { passage_key: passageKey, security_code: securityCode },
    });

    const codeRef = ref("");
    // 上一行：用 Modal 实现输入框（可替换为你们统一弹窗组件）
    await new Promise<void>((resolve, reject) => {
      const m = Modal.confirm({
        title: "短信验证",
        content: () =>
          createVNode(Input, {
            value: codeRef.value,
            maxlength: condition.parameters?.length ?? 6,
            placeholder: "请输入短信验证码",
            "onUpdate:value": (v: string) => (codeRef.value = v),
          }),
        okText: "验证",
        cancelText: "取消",
        onOk: () => resolve(),
        onCancel: () => reject(new Error("取消验证")),
      });
    });

    const resp = await http.call<{ code: number; message: string }>({
      url: "/api/security/sms/verify",
      method: "POST",
      data: {
        passage_key: passageKey,
        security_code: securityCode,
        code: codeRef.value,
      },
    });

    const ok = resp.code === 0 || resp.code === 200;
    if (!ok) message.error(resp?.message || "短信验证失败");
    return { ok };
  },
} satisfies Verifier;
```

---

## 9）`src/security/verifiers/email.ts`（邮箱验证插件）

```ts
import { http } from "@/libs";
import type { Verifier } from "../types";
import { Modal, Input, message } from "ant-design-vue";
import { createVNode, ref } from "vue";

export default {
  async start({ passageKey, securityCode, condition }) {
    await http.call({
      url: "/api/security/email/send",
      method: "POST",
      data: { passage_key: passageKey, security_code: securityCode },
    });

    const codeRef = ref("");
    await new Promise<void>((resolve, reject) => {
      Modal.confirm({
        title: "邮箱验证",
        content: () =>
          createVNode(Input, {
            value: codeRef.value,
            maxlength: condition.parameters?.length ?? 6,
            placeholder: "请输入邮箱验证码",
            "onUpdate:value": (v: string) => (codeRef.value = v),
          }),
        okText: "验证",
        cancelText: "取消",
        onOk: () => resolve(),
        onCancel: () => reject(new Error("取消验证")),
      });
    });

    const resp = await http.call<{ code: number; message: string }>({
      url: "/api/security/email/verify",
      method: "POST",
      data: {
        passage_key: passageKey,
        security_code: securityCode,
        code: codeRef.value,
      },
    });

    const ok = resp.code === 0 || resp.code === 200;
    if (!ok) message.error(resp?.message || "邮箱验证失败");
    return { ok };
  },
} satisfies Verifier;
```

---

## 10）`src/security/verifiers/app.ts`（验证器 App 插件——推送+轮询示意）

```ts
import { http } from "@/libs";
import type { Verifier } from "../types";
import { Modal, message } from "ant-design-vue";

// 上一行：验证器 App：一般为“推送 + 轮询”确认
export default {
  async start({ passageKey, securityCode }) {
    // 上一行：后端发送推送，返回一个 ticket，前端轮询查询结果
    const init = await http.call<{
      code: number;
      message: string;
      data: { ticket: string };
    }>({
      url: "/api/security/app/push",
      method: "POST",
      data: { passage_key: passageKey, security_code: securityCode },
    });
    if (init.code !== 200 && init.code !== 0) {
      message.error(init.message || "发送验证请求失败");
      return { ok: false };
    }

    const ticket = init.data.ticket;
    const wait = (ms: number) => new Promise((res) => setTimeout(res, ms));
    let ok = false;

    // 上一行：简单轮询 30 秒，每 2 秒一次
    for (let i = 0; i < 15; i++) {
      const poll = await http.call<{
        code: number;
        message: string;
        data: { status: "pending" | "approved" | "rejected" };
      }>({
        url: "/api/security/app/poll",
        method: "POST",
        data: { ticket, passage_key: passageKey, security_code: securityCode },
      });
      if (poll.data.status === "approved") {
        ok = true;
        break;
      }
      if (poll.data.status === "rejected") {
        ok = false;
        break;
      }
      await wait(2000);
    }

    if (!ok) message.error("验证器 App 未通过或超时");
    return { ok };
  },
} satisfies Verifier;
```

---

## 11）`src/security/verifiers/webauthn.ts`（通行密钥/生物识别）

```ts
import { http } from "@/libs";
import type { Verifier } from "../types";

// 上一行：调用 WebAuthn 验证（navigator.credentials.get），并提交给后端核验
export default {
  async start({ passageKey, securityCode }) {
    // 上一行：从后端获取 assertion options（含 challenge、rpId 等）
    const optResp = await http.call<{
      code: number;
      message: string;
      data: any;
    }>({
      url: "/api/security/webauthn/options",
      method: "POST",
      data: { passage_key: passageKey, security_code: securityCode },
    });
    const options = optResp.data;

    // 上一行：拉起通行密钥验证（浏览器原生框）
    const cred = (await navigator.credentials.get({
      publicKey: {
        challenge: base64urlToBuffer(options.challenge),
        timeout: options.timeout ?? 60000,
        rpId: options.rpId,
        allowCredentials: options.allowCredentials?.map((c: any) => ({
          id: base64urlToBuffer(c.id),
          type: "public-key",
          transports: c.transports,
        })),
        userVerification: options.userVerification ?? "required",
      },
    })) as PublicKeyCredential;

    // 上一行：把客户端证明发回后端校验
    const verification = await http.call<{ code: number; message: string }>({
      url: "/api/security/webauthn/verify",
      method: "POST",
      data: {
        passage_key: passageKey,
        security_code: securityCode,
        id: cred.id,
        type: cred.type,
        rawId: bufferToBase64url(cred.rawId),
        response: {
          clientDataJSON: bufferToBase64url(cred.response.clientDataJSON),
          authenticatorData: bufferToBase64url(
            (cred.response as any).authenticatorData
          ),
          signature: bufferToBase64url((cred.response as any).signature),
          userHandle: bufferToBase64url(
            (cred.response as any).userHandle || new ArrayBuffer(0)
          ),
        },
      },
    });
    const ok = verification.code === 0 || verification.code === 200;
    return { ok };
  },
} satisfies Verifier;

function base64urlToBuffer(b64u: string) {
  const pad = "=".repeat((4 - (b64u.length % 4)) % 4);
  const b64 = (b64u + pad).replace(/-/g, "+").replace(/_/g, "/");
  const raw = atob(b64);
  const buf = new ArrayBuffer(raw.length);
  const view = new Uint8Array(buf);
  for (let i = 0; i < raw.length; ++i) view[i] = raw.charCodeAt(i);
  return buf;
}
function bufferToBase64url(buf: ArrayBuffer) {
  const bytes = new Uint8Array(buf);
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) s += String.fromCharCode(bytes[i]);
  return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
```

---

# 修改文件（给出完整代码）

> 只需在应用入口 `main.ts` **新增一行**，确保验证器在应用启动时完成注册。

## 12）`src/main.ts`（完整文件，新增 `import '@/security/register'`）

```ts
import { createApp } from "vue";
import { createPinia } from "pinia";
import piniaPluginPersistedstate from "pinia-plugin-persistedstate";
import App from "@/App.vue";
import router from "@/router";
import i18n, { loadLocaleData } from "@/locales";
import directives from "@/directives";
import "@/security/register";
import "virtual:svg-icons-register";
import "@/assets/styles/main.css";
import { mountIconCollector } from "@/plugins";
import videojs from "video.js";
import { http } from "@/libs";
import {
  codeResponseParser,
  axiosDataFallbackParser,
} from "@/libs/http/parsers";

// 先挂载图标拦截器 → 再挂载解析器，且解析器顺序为：业务壳 → fallback
mountIconCollector(http);
http.setGlobalParser([codeResponseParser, axiosDataFallbackParser]);

// 挂到全局，语言包才能访问到
// @ts-ignore
window.videojs = videojs;
const app = createApp(App);

const pinia = createPinia();
pinia.use(piniaPluginPersistedstate);

app.use(pinia);

// 在 Pinia 激活后（确保 store 可用）
app.use(router);
app.use(i18n);
app.use(directives);
app.mount("#app");
// 请求账户信息

loadLocaleData(i18n, "zh-CN");
```

---

# 如何使用（业务侧只改一行）

在任意需要二次验证的动作（例如“绑定验证器 App”、“发起提现”、“重置安全设置”……）的提交方法里：

```ts
import { verifiedAction } from "@/security/verifiedAction";

// 上一行：把原有提交包一层即可；'bind_auth' 要与后台 /api/security/list 的 model_value 对上
await verifiedAction("bind_auth", async () => {
  await api.bindAuthApp(formData);
});
```

> 运行过程：
> 1）`verifiedAction` 先用 `/api/security/list` 本地判断该模块是否启用；没启用就**直接执行**你的原逻辑；
> 2）启用了则调用 `/api/security/begin` 获取 `steps`，**AND 全过、OR 让用户选一个**；
> 3）成功后再次 `begin(passage_key)` 复核 `status=1`，**再继续**你的原逻辑（无侵入）；
> 4）后续新增/调整验证方式，只需添加一个 `verifiers/xxx.ts` 并在 `register.ts` 注册即可。

---

# 说明与后续可选增强

- 目前我**未改动你的 HTTP 拦截器**（避免大改）；若你希望“提交后服务端才要求二次验证”也**自动抬升并重放**，再告诉我你们约定的错误码/标识（例如 `message='step_up_required'`），我再给你**完整替换版** `src/libs/http/interceptors.ts`。
- 如果你更喜欢**模板改动**而不是方法改动，我可以再提供**自定义指令** `v-verify` 的完整文件；不过就“代码改动最少”而言，**包装器**是最稳的。
- 你也可以把**路由 meta.security_code** 用来标识“此页面包含需要 MFA 的操作”，但是否触发仍以 `verifiedAction` 为准。

需要我把某个**具体业务页面**改成示例（替换为 `verifiedAction`）吗？把文件路径发我，我直接给你**该文件的完整改造版**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/鉴权-登录/在路由 meta 中做权限控制]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/在路由 meta 中做权限控制</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/在路由 meta 中做权限控制"/>
        <updated>2025-09-18T17:26:53.131Z</updated>
        <content type="html"><![CDATA[下面是「在路由 meta 中做权限控制」在大公司里常见、相对稳妥的做法（结合 RBAC/ABAC/ReBAC 与前后端协同）。我给出可落地的 meta 结构与守卫模板，并标注哪些是**用户体验层面的前端拦截**，哪些必须**在服务端强制校验**。

---

## 核心共识（非常重要）

1. **前端路由 meta 只用于“体验层”**（引导、隐藏入口、避免无意义请求）；**真正的授权必须由服务端强制执行**（API/资源级校验）。这是防止“破坏访问控制”类风险的基本原则。([router.vuejs.org][1])
2. **模型分层**：

   - RBAC：角色/权限（适合“是否能进这个页面/菜单”这类粗粒度）。
   - ABAC：基于属性（时间、地域、订单所属人等）做细粒度条件判断。
   - ReBAC：基于关系（如“文档共享/项目成员/上下级”）做复杂共享授权，业界参考 **Zanzibar** / **OpenFGA**。([cheatsheetseries.owasp.org][2])

3. **把鉴权逻辑集中**在全局导航守卫/解析守卫里，避免散落各处；对需要异步确认的权限，放在 `beforeResolve`（确认导航前、组件解析后），以减少无用的请求与白屏。([router.vuejs.org][3])
4. Vue Router 的 **route meta** 天生就是放“路由附加信息”的地方（如 `requiresAuth`、`requiresCamera` 等），可作为授权“声明”。([router.vuejs.org][3])

---

## 推荐的 meta 结构（示例）

```ts
// routes.ts
{
  path: '/trading',
  name: 'Trading',
  component: () => import('@/pages/Trading.vue'),
  meta: {
    requiresAuth: true,                    // 需登录
    rolesAnyOf: ['trader', 'admin'],       // RBAC：满足其一即可
    permissionsAnyOf: ['trade:order.read'],// RBAC：权限点
    featureFlagsAllOf: ['trading'],        // 与灰度/开关系统联动
    // ABAC / ReBAC：交给策略引擎（本地或网关）判断
    policy: {
      action: 'page:view',
      // 可以是对象或函数（从路由参数构造资源）
      resource: (to) => ({ type: 'page', id: 'trading', tenantId: to.params.tenantId }),
    },
    auditEvent: 'page_trading_view',       // 可选：埋点/审计标识
  }
}
```

---

## 全局导航守卫模板（前端体验层 Gate）

```ts
// router/guards.ts
import { router } from "./router";
import { auth, authz, flags } from "@/services"; // 伪代码：身份、授权、灰度

router.beforeEach(async (to) => {
  // 1) 登录检查
  if (to.meta.requiresAuth && !auth.isAuthenticated()) {
    return { name: "Login", query: { redirect: to.fullPath } };
  }

  // 2) 特性开关（灰度/AB 实验）
  if (to.meta.featureFlagsAllOf?.length) {
    const ok = to.meta.featureFlagsAllOf.every((k) => flags.isEnabled(k));
    if (!ok) return { name: "NotFound" }; // 或展示“功能未开放”
  }

  // 3) 角色/权限（RBAC）
  if (to.meta.rolesAnyOf?.length) {
    const ok = to.meta.rolesAnyOf.some((r) => authz.hasRole(r));
    if (!ok) return { name: "Forbidden" };
  }
  if (to.meta.permissionsAnyOf?.length) {
    const ok = to.meta.permissionsAnyOf.some((p) => authz.hasPermission(p));
    if (!ok) return { name: "Forbidden" };
  }
});

/** 对需要异步校验（ABAC / ReBAC / 资源维度）的页面再做一次解析前校验 */
router.beforeResolve(async (to) => {
  if (!to.meta.policy) return;

  const resource =
    typeof to.meta.policy.resource === "function"
      ? to.meta.policy.resource(to)
      : to.meta.policy.resource;

  // 统一走“策略引擎/网关”查询（可对接 OPA/OpenFGA/自研鉴权服务）
  const allowed = await authz.can({
    action: to.meta.policy.action,
    resource, // 包含 tenantId/ownerId 等上下文
  });
  if (!allowed) return { name: "Forbidden" };
});
```

> 说明：`beforeEach` 做轻量、同步的快速拦截；`beforeResolve` 放需要异步/昂贵的策略校验（文档也建议在这里做“用户无法进入页面时应避免执行的操作”）。([router.vuejs.org][3])

---

## 服务端必须做的（真正的安全线）

- **所有 API 和资源下载接口都要做同样的授权检查**：携带用户身份（JWT/Session），在网关或服务里按 **RBAC + ABAC/ReBAC 策略**判断能否访问该“资源 + 动作”。不要信任前端路由结果。这个原则对应 OWASP 的建议。([router.vuejs.org][1])
- 推荐把策略**集中到策略引擎**：如 **OPA**（Policy-as-Code，解耦业务与策略）或 **Zanzibar/OpenFGA**（关系型授权，适合协作/共享）。([Auth0][4], [cheatsheetseries.owasp.org][2])
- **多租户**：把 `tenantId` 带入策略；禁止跨租户访问（路由参数与后端鉴权都要校验）。
- **审计与告警**：对拒绝访问/越权尝试做记录，便于排障与风控。

---

## 常见坑

- 只在前端做权限控制（**危险**）：刷新接口照样能被调用（被抓包/脚本命中）。([router.vuejs.org][1])
- 把大量权限清单打包到前端（**泄露内部枚举**）；建议按最小化下发、或只下发当前会用到的“声明”。
- 权限变更后的**本地缓存失效**问题：监听 token 刷新/用户信息变更，及时刷新本地 `authz` 状态。
- **路由切片**过多导致守卫零散：统一在**全局守卫**集中处理，再由页面局部做兜底。([router.vuejs.org][3])

---

## 何时选 RBAC / ABAC / ReBAC？

- **RBAC**：菜单/页面粒度、后管类系统优先（实现简单、维护成本低）。
- **ABAC**：需要“条件（时间、地域、金额、订单所有者）”时；与策略引擎搭配更灵活。([Auth0][4])
- **ReBAC（Zanzibar/OpenFGA）**：文档/项目/看板这类“共享关系/层级关系”复杂的业务。([cheatsheetseries.owasp.org][2])

---

如果你愿意，我可以把你现有的路由表整理成上述 meta 结构，并给出可直接落地的 `beforeEach/beforeResolve` 守卫代码（含 TypeScript 类型定义与单元测试样例）。

[1]: https://router.vuejs.org/api/interfaces/routerecordredirect?utm_source=chatgpt.com "Interface: RouteRecordRedirect - Vue Router"
[2]: https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html?utm_source=chatgpt.com "Authorization - OWASP Cheat Sheet Series"
[3]: https://router.vuejs.org/zh/guide/advanced/navigation-guards?utm_source=chatgpt.com "导航守卫 - Vue Router"
[4]: https://auth0.com/docs/manage-users/access-control/configure-core-rbac?utm_source=chatgpt.com "Configure Core Authorization Features for Role-Based ..."
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 composable 里“公共初始化 + 登录后初始化”的双阶段启动（增量修改）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/登录后初始化的双阶段启动（增量修改）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/登录后初始化的双阶段启动（增量修改）"/>
        <updated>2025-09-06T18:30:01.000Z</updated>
        <content type="html"><![CDATA[
## 思路

- 把**不需要登录**的请求抽成“公共初始化（public bootstrap）”，在应用进入时就触发（只触发一次）。
- 把**需要登录**且**命中鉴权路由**时才需要的数据，保留在你现有的 `watch` 分支里，但也确保只跑一次。
- 用**模块级 once 标记**避免多组件重复调用；必要时可加 `online` 事件进行弱网重试（可选）。

---

## 需要调整的代码（仅片段）

> 放在你这个 composable 文件里，**按位置插入**即可；复杂逻辑我已在上一行加中文注释。

### 1）导入（在文件顶部补充）

```ts
// 复杂逻辑：公私两段初始化需要生命周期/事件
import { watch, onMounted } from "vue";
```

### 2）模块级 once 标记（在文件顶部、`export function useAppBootstrap` 外面）

```ts
// 复杂逻辑：模块级“只执行一次”标记，防止多组件重复初始化
let __BOOT_PUBLIC_ONCE__ = false;
let __BOOT_PRIVATE_ONCE__ = false;
```

### 3）在 `useAppBootstrap` 内部新增“公共初始化”方法与调用（建议贴在你定义完各个 store 之后）

```ts
// 复杂逻辑：公共初始化——无需登录的数据，进入站点即预取，且只执行一次
const bootstrapPublic = async () => {
  if (__BOOT_PUBLIC_ONCE__) return;
  __BOOT_PUBLIC_ONCE__ = true;

  await Promise.all([
    // ⬇️ 把“无需 token 的初始化”放这里；按你项目实际取舍
    country.init().catch(() => {}),
    exchange.init({ keyword: "" }).catch(() => {}),
    marketCalendar.init().catch(() => {}),
    // 如果 server.init() 不依赖用户态，也可放到公共初始化
    server.init().catch(() => {}),
    // …你还有其它完全公开的数据，也可加进来
  ]);
};
```

```ts
// 复杂逻辑：进入应用即触发公共初始化（SSR/CSR 兼容性考虑，放到 onMounted 最稳妥）
onMounted(() => {
  bootstrapPublic();
});
```

### 4）给你原来的 `watch` 回调加“私有初始化只跑一次”的保护

```ts
// 复杂逻辑：仅在“已登录 && 路由需要鉴权 && 未跑过私有初始化”时执行
if (ok && need && !__BOOT_PRIVATE_ONCE__) {
  __BOOT_PRIVATE_ONCE__ = true;
  await Promise.all([
    user.fetchUserInfo().catch(() => {}),
    account.init({ withCategory: true, withExternal: true }).catch(() => {}),
    leverage.init().catch(() => {}),
    accountCurrency.init().catch(() => {}),
    externalServer.init().catch(() => {}),
    payChannel.init({ opt_type: "deposit" }).catch(() => {}),
    verifyStore.initVerifyInfo().catch(() => {}),
    inviteStore.getInviteGroupOptions().catch(() => {}),
    // ⚠️ server.init()/country/exchange/marketCalendar 已在公共初始化里跑过的可移除，避免重复
  ]);
}
```

---

## 可选增强

### A. 弱网场景“上线即补跑”

```ts
// 复杂逻辑：若用户初次进入时离线，恢复网络后自动补跑公共初始化（最多触发一次）
onMounted(() => {
  const handler = () => {
    bootstrapPublic();
  };
  window.addEventListener("online", handler, { once: true });
});
```

### B. Store 级幂等（示例片段，放到各自的 Pinia store 里）

```ts
// 复杂逻辑：在每个 init() 入口加幂等保护，彻底避免重复请求
if ((this as any)._inited) return;
(this as any)._inited = true;
```

---

## 小结

- 公共数据：`onMounted` 里 **立刻预取一次**，全站可复用。
- 私有数据：沿用你的 `watch`，但加一次性保护，避免路由/状态抖动造成的重复请求。
- 若存在弱网：监听 `online` 事件，**一次性**补跑公共初始化即可。

---

title: useAppBootstrap 放在哪？给你一份可直接复制的完整文件（含用法）
date: 2025-09-06
tags:

- Vue3
- Vite
- Pinia
- composable
  categories:
- 前端工程化

---

## 位置推荐

把文件放到：

```
src/composables/useAppBootstrap.ts
```

理由：可复用的启动逻辑属于“组合式函数（composable）”，与业务无关的初始化也方便在这里统一管理。

---

## 完整代码（可直接替换 `src/composables/useAppBootstrap.ts`）

```ts
// src/composables/useAppBootstrap.ts
import { onMounted, watch } from "vue";
import { useRouter } from "vue-router";
import {
  useAuthStore,
  useUserStore,
  useAccountStore,
  useServerStore,
  useLeverageStore,
  useAccountCurrencyStore,
  useCountryStore,
  useExchangeStore,
  useExternalServerStore,
  useMarketCalendarStore,
  usePayChannelStore,
} from "@/store";
import { useVerifyStore } from "@/store/verify";
import { useInviteStore } from "@/store/invite";

// 复杂逻辑：模块级“只执行一次”标记，避免多组件/多次进入页面重复请求
let __BOOT_PUBLIC_ONCE__ = false;
let __BOOT_PRIVATE_ONCE__ = false;

export function useAppBootstrap() {
  const router = useRouter();
  const auth = useAuthStore();
  const user = useUserStore();
  const account = useAccountStore();
  const server = useServerStore();
  const leverage = useLeverageStore();
  const accountCurrency = useAccountCurrencyStore();
  const country = useCountryStore();
  const exchange = useExchangeStore();
  const externalServer = useExternalServerStore();
  const marketCalendar = useMarketCalendarStore();
  const payChannel = usePayChannelStore();
  const verifyStore = useVerifyStore();
  const inviteStore = useInviteStore();

  // 复杂逻辑：公共初始化——无需登录可获取的数据，进入站点即预取，且只执行一次
  const bootstrapPublic = async () => {
    if (__BOOT_PUBLIC_ONCE__) return;
    __BOOT_PUBLIC_ONCE__ = true;

    await Promise.all([
      // ⬇️ 放“无需 token”的初始化
      country.init().catch(() => {}),
      exchange.init({ keyword: "" }).catch(() => {}),
      marketCalendar.init().catch(() => {}),
      server.init().catch(() => {}),
      // 如有其它公开数据，也可加在这里
    ]);
  };

  // 复杂逻辑：进入应用即触发公共初始化；若首次访问时离线，恢复网络后补跑一次（仅一次）
  onMounted(() => {
    bootstrapPublic();
    const handler = () => {
      bootstrapPublic();
    };
    window.addEventListener("online", handler, { once: true });
  });

  // 复杂逻辑：仅在“已登录 && 目标路由需要鉴权 && 未跑过私有初始化”时执行一次性私有初始化
  watch(
    [
      () => auth.isAuthenticated,
      () => router.currentRoute.value.meta?.requiresAuth,
    ],
    async ([ok, need]) => {
      if (ok && need && !__BOOT_PRIVATE_ONCE__) {
        __BOOT_PRIVATE_ONCE__ = true;

        await Promise.all([
          user.fetchUserInfo().catch(() => {}),
          account
            .init({ withCategory: true, withExternal: true })
            .catch(() => {}),
          leverage.init().catch(() => {}),
          accountCurrency.init().catch(() => {}),
          externalServer.init().catch(() => {}),
          payChannel.init({ opt_type: "deposit" }).catch(() => {}),
          verifyStore.initVerifyInfo().catch(() => {}),
          inviteStore.getInviteGroupOptions().catch(() => {}),
          // ⚠️ 已在公共初始化中完成的 server/country/exchange/marketCalendar 无需重复
        ]);
      }
    },
    { immediate: true }
  );
}

// （可选）测试/登出时重置标记
export function __resetBootstrapFlagsForTestOnly() {
  __BOOT_PUBLIC_ONCE__ = false;
  __BOOT_PRIVATE_ONCE__ = false;
}
```

---

## 如何使用（最小改动）

> 你**不需要**在每个页面手动调用，只需在 **App.vue** 顶层调用一次即可。

在 `src/App.vue` 的 `<script setup>` 里加入一行（**增量修改**）：

```ts
// 复杂逻辑：顶层调用一次，注册 watch + onMounted，即可全局生效
import { useAppBootstrap } from "@/composables/useAppBootstrap";
useAppBootstrap();
```

> 如果你的项目还没在 `main.ts` 里安装 Pinia/Router，请确认已安装（一般你已经有了）：

```ts
// 仅供核对：main.ts 应该已包含这些
// import { createApp } from 'vue'
// import { createPinia } from 'pinia'
// import router from './router'
// import App from './App.vue'
// createApp(App).use(createPinia()).use(router).mount('#app')
```

---

## 小结

- 文件放在：`src/composables/useAppBootstrap.ts`。
- 在 `App.vue` 顶层调用一次 `useAppBootstrap()` 即全局生效。
- 公共初始化：站点进入即跑；私有初始化：登录且命中鉴权路由时只跑一次。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[退出登录后跳转与请求是否会发出]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录后跳转与请求是否会发出</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录后跳转与请求是否会发出"/>
        <updated>2025-09-05T18:55:38.000Z</updated>
        <content type="html"><![CDATA[
---

title: 退出登录后跳转与请求是否会发出？（Vue Router 4 实战）
date: 2025-09-05
tags: \[Vue, Vue Router, Pinia, Axios, 登录, 退出]

---

## TL;DR（先给结论）

- `router.push('/user')` **不会**去加载 `@/views/(public)/layout.vue`；`/user` 是独立的**公开路由**，全局前置守卫会**先**跑，再决定是否进入目标路由，受保护布局组件不会被解析/执行。
- 真正会“误发请求”的常见来源是：① 旧页中**已发起但未取消**的请求；② `<keep-alive>` 相关的激活/停用副作用；③ 你在 HTTP 层没有对“无 Token 的鉴权请求”做**硬性拦截**。
- 给你三道保险：**彻底清 Token + 取消未决请求 + 请求层强拦**（可选再加根路由 `beforeEnter`）。

---

## 最小修改（仅给需要改的代码片段）

> 说明：按你的偏好，只给**需修改**片段；复杂逻辑在上一行加注释。

### 1) `auth` Store：退出时同时清理本地存储 Token、取消所有请求、清默认头

**文件：** `useAuthStore` 所在文件

```ts
// 新增导入
import storage from "store";
import { STORAGE_KEYS } from "@/constants";
const { ACCESS_TOKEN } = STORAGE_KEYS;
```

```ts
// 新增：统一清空本地 Token（Pinia + 本地存储）
function clearToken() {
  // 复杂逻辑：双通道清理，避免路由守卫误判已登录
  token.value = null;
  refresh.value = null;
  storage.remove(ACCESS_TOKEN);
}
```

```ts
// 调整 logout 函数（仅贴需要增加的片段）
async function logout() {
  try {
    await http.post("/api/pub/loginOut").catch(() => {});
    // 复杂逻辑：优雅下线——取消所有还在飞行中的请求，防止“未登录也发请求”
    http.cancelAll?.();
    // 复杂逻辑：清掉默认鉴权头，防止后续请求夹带旧 Token
    http.setAuthToken?.(null);

    clearToken();
    resetAllStores();
  } catch (error) {
    console.error(error);
    throw error;
  }
}
```

> 你现在的调用 `await authStore.logout(); router.push('/user')` 没问题；若不想留下历史记录，可换成：

```ts
// 可选：避免回退到已登录页
await router.replace({ name: "user" });
```

---

### 2) `http` 工具：加“全局取消池 + 无 Token 时硬拦需要鉴权的请求”

**文件：** 你的 `@/utils/http`（或创建一个轻量封装）

```ts
// 新增：全局取消池
const abortPool = new Set<AbortController>();

export function cancelAll() {
  // 复杂逻辑：退出登录时集中取消所有未决请求
  abortPool.forEach((c) => c.abort());
  abortPool.clear();
}

export function setAuthToken(token?: string | null) {
  // 复杂逻辑：动态设置/清除默认鉴权头
  if (token) {
    axios.defaults.headers.common.Authorization = `Bearer ${token}`;
  } else {
    delete axios.defaults.headers.common.Authorization;
  }
}
```

```ts
// 在请求拦截里增加以下片段（保留你已有逻辑）
http.interceptors.request.use((config) => {
  // 复杂逻辑：为每个请求绑定 AbortController，纳入全局取消池
  const ac = new AbortController();
  (config as any).signal = ac.signal;
  abortPool.add(ac);

  // 复杂逻辑：对标记了 { auth: true } 的请求做硬性校验，无 Token 直接终止
  const needAuth = (config as any).auth === true;
  const token = storage.get(ACCESS_TOKEN);
  if (needAuth && !token) {
    ac.abort();
    // 用标准错误中断；也可自定义错误码
    throw new axios.Cancel("UNAUTHENTICATED");
  }
  return config;
});
```

```ts
// 在响应/错误拦截里释放对应的 controller（保持池干净）
const detach = (cfg?: any) => {
  if (!cfg?.signal) return;
  for (const ac of abortPool) {
    if (cfg.signal === ac.signal) {
      abortPool.delete(ac);
      break;
    }
  }
};
http.interceptors.response.use(
  (resp) => {
    detach(resp.config);
    return resp;
  },
  (err) => {
    detach(err?.config);
    return Promise.reject(err);
  }
);
```

> 使用方式：**凡是需要登录才能访问的接口**，在调用时带上 `{ auth: true }`：

```ts
// 复杂逻辑：打上鉴权标记，无 Token 时在请求层被硬拦
http.get("/api/secure/profile", { auth: true });
```

---

### 3) 根布局路由（可选加固）：未登录禁止进入，阻止懒加载 `layout.vue`

> 这是“冗余但稳”的**第四道锁**：即使有人误配了守卫，根布局也进不去。

**文件：** 路由表所在文件

```ts
// 新增导入（如果本文件里还没有）
import storage from "store";
import { STORAGE_KEYS } from "@/constants";
import { LOGIN_ROUTE } from "./constants";
const { ACCESS_TOKEN } = STORAGE_KEYS;
```

```ts
// 在 path: '/' 那个根路由对象上新增 beforeEnter（只贴新增的属性）
beforeEnter: (to, from, next) => {
  // 复杂逻辑：未登录直接拒绝进入受保护根布局，避免解析/执行 layout.vue
  const token = storage.get(ACCESS_TOKEN)
  if (!token) return next({ name: LOGIN_ROUTE.name, replace: true })
  next()
},
```

---

## 为什么你会怀疑 `layout.vue` 被加载？

常见场景有三种（任选对号入座）：

1. **旧页未决请求**：你还在“受保护页面”时就发出了请求，`push('/user')` 后这些请求仍会完成，除非你**主动取消**（上面第 2 步已解决）。
2. **`<keep-alive>` 激活/停用副作用**：离开/进入时有数据拉取，需要在未登录时短路。
3. **预加载 Chunk**：如果手动开启过 `webpackPrefetch` 等，会看到静态资源拉取，但这不等同于“业务请求”发出。

---

## 排查清单（按优先级）

1. 退出后 `localStorage`/`store` 里是否还残留 `ACCESS_TOKEN`？（第 1 步已处理）
2. 所有**需要登录**的接口是否统一加了 `{ auth: true }` 并被请求拦截器“硬拦”？（第 2 步）
3. 页面里有没有在 `onMounted` **直接拉数据**但无 Token 校验的逻辑？（在组件中加早返回）
4. 是否使用了 `<keep-alive>` 并在 `activated`/`deactivated` 发请求？（同样做登录短路）
5. 仍担心懒加载？给根布局加 `beforeEnter`（第 3 步“加固锁”）。

---

## 你最关心的那句直白话

- **不会**：`router.push('/user')` 不会去跑 `@/views/(public)/layout.vue` 里的业务请求。
- **会**：如果**旧页**的请求已经发出且你没有取消，它们**会继续完成**。上面给的三段修改能把这类“该停的请求”全部截住。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[退出登录要不要 resetAllStores]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录要不要-resetAllStores</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/退出登录要不要-resetAllStores"/>
        <updated>2025-09-05T20:45:33.000Z</updated>
        <content type="html"><![CDATA[
## 结论

- **应该保留 `resetAllStores()`**（避免残留用户数据/权限态），但**直接在登出时先重置**会触发一堆 `watchEffect` / `watch` 的依赖变化，从而在组件卸载前**又发出请求**。
- 正确做法：**先撤鉴权与在途请求 → 跳公开页卸载组件 → 最后再 `resetAllStores()`**；同时在页面副作用里用 `isAuthenticated`/`isLoggingOut` 做**登录短路**。

## 推荐顺序（一眼抄）

1. **标记登出中**（`isLoggingOut = true`）
2. **取消所有在途请求**（`http.cancelAll()`）
3. **清鉴权**（`http.setAuthToken(null)` + 清本地 `ACCESS_TOKEN/TOKEN_TYPE` + 清内存 `token`）
4. **跳到公开路由**（`router.replace('/user')`）
5. **最后** `resetAllStores()`
6. **清掉登出标记**（`isLoggingOut = false`）

## 仅需修改的代码片段

### A) `auth` Store：按顺序登出（在 store 内部做跳转，保证顺序）

```ts
// 新增
import { useRouter } from "vue-router";

// 新增
const isLoggingOut = ref(false);
```

```ts
// 调整 logout（顺序：撤鉴权→跳公开页→reset）
async function logout() {
  const router = useRouter();
  try {
    isLoggingOut.value = true;
    await http.post("/api/pub/loginOut").catch(() => {});

    // 复杂逻辑：统一掐断飞行中的请求，避免“卸载前再打一次”
    http.cancelAll?.();

    // 复杂逻辑：清鉴权（默认头 + 本地存储 + 内存）
    http.setAuthToken?.(null);
    storage.remove(ACCESS_TOKEN);
    storage.remove(TOKEN_TYPE);
    token.value = null;
    refresh.value = null;

    // 复杂逻辑：先跳到公开页，卸载受保护组件，阻断其副作用
    await router.replace({ name: "user" });

    // 复杂逻辑：组件已卸载，再重置所有 store，安全不抖动
    resetAllStores();
  } catch (error) {
    console.error(error);
    throw error;
  } finally {
    isLoggingOut.value = false;
  }
}
```

> 这样**无需**在组件里再 `router.push('/user')`；如果你保留组件层跳转，记得删除那一行以免重复。

---

### B) 页面副作用：加“登录短路”（防抖再保险）

> 示例：你在 `public/dashboard` 页和分析卡片里原来用 `watchEffect` 拉数据。

```ts
// 复杂逻辑：登出过程/未登录时直接短路，不发请求
import { useAuthStore } from '@/plugins'
import { storeToRefs } from 'pinia'
const { isAuthenticated, isLoggingOut } = storeToRefs(useAuthStore())

watch(/* 精确依赖或 isAuthenticated */ , () => {
  if (!isAuthenticated.value) return
  if (isLoggingOut?.value) return
  // 这里再发请求
}, { immediate: true })
```

> 说明：**副作用短路 + A 部分的顺序**，两层兜底，基本杜绝“退出时还在请求”。

---

## 什么时候可以“不 resetAllStores”？

- 仅在**演示/临时**场景；正式项目**不建议**。不重置会遗留：上一个用户的**列表数据、选择态、分页、缓存**等，存在隐私与越权风险。

---

## 小结

- **不是不要 `resetAllStores()`，而是要把它放在最后**，并在副作用处加“登录短路”。
- 真正能解决“跳转后还在请求”的，是**顺序**（撤鉴权 → 跳公开页 → 重置）+ **取消在途** + **副作用短路**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）]]></title>
        <id>https://herongdev.github.io/blog/posts/后端/NestJS/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）</id>
        <link href="https://herongdev.github.io/blog/posts/后端/NestJS/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）"/>
        <updated>2025-09-07T20:40:23.000Z</updated>
        <content type="html"><![CDATA[
---

title: 在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）
date: 2025-09-07
tags:

- NestJS
- Redis
- ioredis
- 教程
  categories:
- 后端
  description: 手把手带你在 NestJS 中集成 Redis（基于 ioredis），涵盖安装、配置、Provider、全局模块封装、业务实践（限流/一次性令牌）、Docker、本地调试与常见报错排查。

---

# 目标与适用读者

- 目标：在 **NestJS** 项目中稳定接入 **Redis**，通过 **ioredis** 驱动，提供可复用的 `RedisService`（封装 `set/get/del/incr/expire`、NX 写入等），并支持 **全局模块**、**环境配置**、**本地/生产** 两套部署。
- 适用：会基本 NestJS 模块/依赖注入的同学；数据库用 TypeORM/Prisma 均可（与本教程无冲突）。

---

# 技术栈选型

- Redis 客户端：**ioredis**（成熟、支持集群/哨兵、TypeScript 友好）。
- Nest 集成方式：自定义 **Provider + 全局模块**，暴露 `REDIS_CLIENT` 与 `RedisService`。
- 配置：`.env` 中支持 `REDIS_URL` 或 `REDIS_HOST/PORT/PASSWORD/DB`。

---

# 目录结构（建议）

```
src/
  common/
    redis/
      redis.module.ts       # 全局模块（@Global）
      redis.service.ts      # 业务友好封装（依赖 REDIS_CLIENT）
  app.module.ts             # 或各业务模块，引入 RedisModule 一次即可
```

---

# 第一步：安装依赖

```bash
# 使用 pnpm（推荐）
pnpm add ioredis
# 或者 npm
# npm i ioredis
```

---

# 第二步：准备环境变量

建议在 `.env`（或 `.env.dev`）中添加 **二选一**：

```ini
# 方式 A：URL 一行式（含密码与 DB 索引，推荐）
REDIS_URL=redis://:password@localhost:6379/0

# 方式 B：分散式
REDIS_HOST=127.0.0.1
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0
```

---

# 第三步：编写 `RedisService`

> 放在 `src/common/redis/redis.service.ts`
> 命名**清晰可读**，复杂逻辑上方有中文注释。

```ts
import { Injectable, Inject } from "@nestjs/common";
import type { Redis } from "ioredis";

// 复杂：作为底层连接的注入令牌；项目全局唯一
export const REDIS_CLIENT = "REDIS_CLIENT";

@Injectable()
export class RedisService {
  constructor(@Inject(REDIS_CLIENT) private readonly redisClient: Redis) {}

  // 复杂：统一封装写入并设置过期时间，便于存挑战/一次性令牌
  async setWithTimeToLive(
    key: string,
    value: string,
    timeToLiveSeconds = 300
  ): Promise<void> {
    await this.redisClient.set(key, value, "EX", timeToLiveSeconds);
  }

  async getValue(key: string): Promise<string | null> {
    return this.redisClient.get(key);
  }

  async deleteKey(key: string): Promise<void> {
    await this.redisClient.del(key);
  }

  // 复杂：自增计数用于限流（第一次返回 1）
  async incrementKey(key: string): Promise<number> {
    return this.redisClient.incr(key);
  }

  // 复杂：给键设置过期时间，配合 incrementKey 实现简单窗口限流
  async expireKey(key: string, seconds: number): Promise<void> {
    await this.redisClient.expire(key, seconds);
  }

  // 复杂：仅当键不存在时写入并设置 TTL（一次性令牌/幂等防重放）
  async setIfAbsentWithTimeToLive(
    key: string,
    value: string,
    timeToLiveSeconds: number
  ): Promise<boolean> {
    // 复杂：NX 确保不存在才写入；避免并发下的重复写入
    const result = await this.redisClient.set(
      key,
      value,
      "NX",
      "EX",
      timeToLiveSeconds
    );
    return result === "OK";
  }
}
```

---

# 第四步：编写 `RedisModule`（全局模块，一次引入处处可用）

> 放在 `src/common/redis/redis.module.ts`，标记 `@Global()`，自动对全局开放。

```ts
import { Global, Module } from "@nestjs/common";
import * as IORedis from "ioredis";
import { RedisService, REDIS_CLIENT } from "./redis.service";

@Global()
@Module({
  providers: [
    {
      provide: REDIS_CLIENT,
      // 复杂：通过工厂读取 .env，创建 ioredis 客户端
      useFactory: () => {
        const url = process.env.REDIS_URL;
        const host = process.env.REDIS_HOST ?? "127.0.0.1";
        const port = parseInt(process.env.REDIS_PORT ?? "6379", 10);
        const password = process.env.REDIS_PASSWORD || undefined;
        const db = parseInt(process.env.REDIS_DB ?? "0", 10);

        const client: IORedis.Redis = url
          ? new (IORedis as any)(url)
          : new (IORedis as any)({ host, port, password, db });

        // 复杂：记录连接错误，便于排查
        client.on("error", (err: any) => {
          // eslint-disable-next-line no-console
          console.error("[Redis] connection error:", err?.message || err);
        });

        return client;
      },
    },
    RedisService,
  ],
  exports: [REDIS_CLIENT, RedisService],
})
export class RedisModule {}
```

---

# 第五步：在应用中引入 `RedisModule`

> 只需在**任意一个模块**引入一次（例如 `AppModule`），因为它是 `@Global()`。

```ts
// src/app.module.ts（或你任一根模块）
import { Module } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";
import { RedisModule } from "./common/redis/redis.module";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    RedisModule, // 复杂：全局模块，仅需引入一次
    // ... 你的其它模块
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

---

# 第六步：业务中使用示例

### 6.1 限流（每分钟最多 10 次）

```ts
import { Injectable, TooManyRequestsException } from "@nestjs/common";
import { RedisService } from "src/common/redis/redis.service";

@Injectable()
export class LoginService {
  constructor(private readonly redisService: RedisService) {}

  // 复杂：按 IP 做 60 秒/10 次 限流
  async limitByIp(ipAddress: string) {
    const rateLimitKey = `rl:login:${ipAddress}`;
    const currentCount = await this.redisService.incrementKey(rateLimitKey);
    if (currentCount === 1) {
      await this.redisService.expireKey(rateLimitKey, 60);
    }
    if (currentCount > 10) {
      throw new TooManyRequestsException("请求过于频繁，请稍后再试");
    }
  }
}
```

### 6.2 一次性令牌（幂等/防重放）

```ts
// 复杂：仅当 key 不存在时写入，5 分钟有效
const ok = await this.redisService.setIfAbsentWithTimeToLive(
  `once:${token}`,
  "1",
  300
);
if (!ok) {
  throw new Error("令牌已使用或失效");
}
```

### 6.3 短期会话/挑战值（例如 WebAuthn）

```ts
await this.redisService.setWithTimeToLive(
  `webauthn:register:${userId}`,
  challengeBase64Url,
  300
);
const cached = await this.redisService.getValue(`webauthn:register:${userId}`);
// ... 验证后删除
await this.redisService.deleteKey(`webauthn:register:${userId}`);
```

---

# 第七步：Docker Compose（本地起 Redis）

> `docker-compose.yml`（项目根目录）

```yaml
version: "3.9"
services:
  redis:
    image: redis:7-alpine
    container_name: demo-redis
    ports:
      - "6379:6379"
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - redis-data:/data
volumes:
  redis-data:
```

启动：

```bash
docker compose up -d
# .env 示例
# REDIS_URL=redis://localhost:6379
```

---

# 第八步：生产环境注意事项

- **连接池与超时**：ioredis 默认复用单连接；高并发可根据需要创建多个客户端或使用 `cluster`/`sentinel`。
- **密码与 ACL**：生产务必启用密码或 ACL；不要暴露无鉴权实例。
- **键名规范**：`<领域>:<用途>:<实体>`（如 `webauthn:auth:ch:<challenge>`），可读性与清理都更好。
- **TTL 策略**：短期挑战/令牌务必设置 TTL，并在验证后删除，避免重放。
- **监控**：监控 `connected clients`、`keyspace hits/misses`、`latency`；必要时加慢日志。
- **持久化**：默认 RDB；根据业务考虑 AOF（`appendonly yes`）与混合持久化。

---

# 第九步：常见报错与排查

- **Nest can't resolve dependencies of the RedisService (REDIS_CLIENT)**
  说明：未注册 `REDIS_CLIENT` Provider。
  解决：确保 `RedisModule`（或 `AppModule` 的 `providers`）里 **provide: REDIS_CLIENT** 已配置，并且模块被应用引入。
- **ECONNREFUSED / getaddrinfo ENOTFOUND**
  说明：Redis 未启动或地址错误。
  解决：检查 `REDIS_URL/REDIS_HOST/REDIS_PORT`，本地起容器或服务端口是否 6379。
- **WRONGPASS invalid username-password pair**
  说明：密码有误或未配置。
  解决：核对 `REDIS_URL` 中 `:password@` 或 `REDIS_PASSWORD`。
- **Ready check failed**
  说明：网络/权限/ACL 问题或连接尚未可用。
  解决：检查安全组/防火墙；对云服务需配置白名单。

---

# 第十步：单元测试（Mock Redis）

> 不在测试中连真实 Redis，可用 `ioredis-mock` 或手写假对象。

```ts
import { Test } from "@nestjs/testing";
import { RedisService, REDIS_CLIENT } from "src/common/redis/redis.service";

describe("RedisService", () => {
  it("set/get works", async () => {
    // 复杂：用最小可用的假客户端满足接口
    const fakeClient = {
      storage: new Map<string, string>(),
      set: function (k: string, v: string) {
        this.storage.set(k, v);
        return Promise.resolve("OK");
      },
      get: function (k: string) {
        return Promise.resolve(this.storage.get(k) ?? null);
      },
      del: function (k: string) {
        this.storage.delete(k);
        return Promise.resolve();
      },
      incr: function (k: string) {
        const next = Number(this.storage.get(k) ?? "0") + 1;
        this.storage.set(k, String(next));
        return Promise.resolve(next);
      },
      expire: function () {
        return Promise.resolve();
      },
    } as any;

    const moduleRef = await Test.createTestingModule({
      providers: [
        { provide: REDIS_CLIENT, useValue: fakeClient },
        RedisService,
      ],
    }).compile();

    const redis = moduleRef.get(RedisService);
    await redis.setWithTimeToLive("foo", "bar", 60);
    expect(await redis.getValue("foo")).toBe("bar");
  });
});
```

---

# 结语

至此，你已经完成了 **NestJS × Redis（ioredis）** 的完整接入：

- 全局模块提供底层连接与服务封装；
- 业务中可轻松完成 **限流**、**一次性令牌**、**短期会话/挑战** 等高频需求；
- 本地用 Docker 起 Redis，生产注意密码、ACL、监控与 TTL 策略。

需要我把你的现有项目改造为 **全局 `RedisModule` 方案** 或 **在 `AppModule` 直接注册 Provider** 的最小改动 **完整文件**，就把相关文件发我（或让我复用你上面的 `AppModule` 路径）。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AI 时代：系统课程的价值、定位与路线图]]></title>
        <id>https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图</id>
        <link href="https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图"/>
        <updated>2025-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[AI 擅长局部解题，但系统性、权衡与落地需要课程提供“结构化路径”。本文给出价值判断、差异化定位、结构设计、风险与最小可行路线。]]></summary>
        <content type="html"><![CDATA[
## 结论

- “系统课程＋博客”在 AI 时代更有价值：AI 能补局部知识，但难给“由浅入深的体系、场景权衡、复盘与职业路径”。
- 差异化关键：工程落地（SOP/Checklist/MRE/观测与度量）、权衡（Trade-off）、真实复盘与团队协作。
- 难度与风险：持续产出、版权合规、转化与交付。以“可验证的工程实践”做护城河，值得做。

## 为什么在 AI 时代更有价值

- AI 的短板：上下文有限、缺乏全局体系与演进路线、对 Why/Trade-off 薄弱、难处理非完备信息。
- 课程的角色：给“脉络与标准动作”；学员用 AI 追问局部细节，构成最优组合。

## 传统培训的空白

- 多停留“API/八股/题库”，少谈生产问题、平台化工程、合规/安全、观测与性能、协作与落地。
- 实战同质化，缺真实业务约束与指标验证，缺事故复盘与上线闭环。

## 差异化定位与设计

- 工程落地：每模块配 SOP ＋ Checklist ＋最小可复现（MRE）＋观测/指标模板。
- 权衡为骨架：何时做/不做，代价/收益，灰度/回滚方案，失败复盘。
- 专题系列：生产问题定位、性能与分布式、数据治理与一致性、安全与合规、团队协作与流程。
- 作品集导向：设计题 → 实现 → 观测/基准 → 复盘，形成可投递 Portfolio。

## 课程结构（由浅入深）

- Level 0：能力地图（路线图/评估表）
- Level 1：基础与最佳实践（现代前端/工程化基础，快速过）
- Level 2：体系工程（构建/测试/发布/观测/安全/合规）
- Level 3：生产问题与权衡（性能、网络、数据一致性、幂等、限流、熔断、回滚）
- Level 4：平台与协作（多仓/MonoRepo、规范化、流水线、指标治理）
- Capstone：端到端项目（灰度、回滚、SLO、事故演练与复盘）

## 与“国外系统课程＋ AI”的结合

- 参考框架与案例，必须本地化：国内云/合规、常用栈、网络/CDN/容器差异。
- AI 作“内容助理”而非“策展人”：生成素材/雏形/题库；你把关正确性、权衡、边界与度量。
- 明确来源与改编，避免版权风险。

## 难度与风险

- 产出节奏：先做一个金刚区（如“生产问题复盘”）打爆款，再扩张。
- 版权与合规：授权/引用规范；示例代码素材需可再发布。
- 转化与交付：从免费内容 → 专题导读 → 训练营 → 口碑。
- 期望管理：明确承诺边界，不做虚假“保就业”。

## 商业模式

- 免费区：系统博文、复盘、Checklist、Demo（SEO 与信任）
- 付费区：训练营/系统课（作业批改、走查、复盘、1v1）
- 长尾：模板包/脚手架/工作坊
- 定价：首期开营“半价＋强交付”，用成功案例突破冷启动

## 度量与证明

- 前/后测、作业通过率、问题解决周期、事故率/SLO 改善、作品集与面试反馈、NPS 与转介绍

## 最小可行路径（3 步）

1. 选一个差异化专题（建议“生产问题复盘”），产出系列博文＋模板包＋公开课；
2. 升级为 4 ～ 6 周试点班：每周作业＋代码走查＋复盘报告；
3. 在案例基础上扩展到“性能与分布式”“数据治理”“安全与合规”等模块，形成矩阵。

## 延伸阅读

- 生产问题复盘：
  - [/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）](/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）)
- AI 协作与边界：
  - [/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界](/posts/AI-协作与边界/AI-时代：工程师不可替代的价值与协作边界)
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统课程大纲与招生 README（骨架）]]></title>
        <id>https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/系统课程大纲与招生README（骨架）</id>
        <link href="https://herongdev.github.io/blog/posts/商业化与营收/课程与训练营/系统课程大纲与招生README（骨架）"/>
        <updated>2025-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[课程目标与对象、大纲结构、日程安排、作业与考核、报名方式与FAQ 的可复用骨架模板。]]></summary>
        <content type="html"><![CDATA[
# 课程介绍

- 课程定位：工程落地为核心，强调 SOP/Checklist/MRE/观测与度量。
- 适合对象：有 1 ～ 5 年经验，想从“能写页面”进阶到“能落地系统”的工程师。
- 学习产出：可投递的作品集、问题复盘报告、基准与观测面板、团队落地 SOP。

# 课程大纲（节选）

- 模块 0：能力地图与路线
- 模块 1：现代工程基础（构建/测试/发布基础）
- 模块 2：工程体系（可观测/安全/合规/规范化）
- 模块 3：生产问题与权衡（性能/网络/一致性/幂等/限流/熔断/回滚）
- 模块 4：平台与协作（多仓/MonoRepo/流水线/指标治理）
- Capstone：端到端项目（灰度、回滚、SLO、事故演练与复盘）

# 日程与学习方式（示例：6 周）

- 第 1 周：体系化工程启航 + 能力评估
- 第 2 ～ 5 周：每周 2 次直播/录播 + 作业（代码走查/观测/复盘）
- 第 6 周：Capstone 收官展示与简历/作品集打磨

# 作业与考核

- 强制作业：每周 1 次最小可复现 + 复盘报告（含观测截图/基准数据）
- 评估维度：正确性/鲁棒性/性能/可观测/规范/表达
- 通过门槛：达到基线 + 一处可验证优化

# 度量指标（示例）

- 前/后测提升、作业通过率、问题解决周期、SLO 改善、作品集质量、NPS、转介绍

# 报名与名额

- 报名链接：<填写>
- 名额与价格：<填写>
- 退课与售后：<填写>

# FAQ（示例）

- 我基础一般可以学吗？
- 是否有助教/代码走查？
- 是否提供发票/合同？

# 延伸阅读

- 课程价值与路线：
  - [/posts/商业化与营收/课程与训练营/AI 时代：系统课程的价值、定位与路线图](/posts/商业化与营收/课程与训练营/AI时代：系统课程的价值、定位与路线图)
- 试点班方案：
  - [/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）](/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）)
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用 VitePress 从零搭建个人博客（含 GitHub Pages 发布）]]></title>
        <id>https://herongdev.github.io/blog/posts/平台与博客/Hexo/hello-world</id>
        <link href="https://herongdev.github.io/blog/posts/平台与博客/Hexo/hello-world"/>
        <updated>2025-09-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[一步步完成初始化、写作、构建、RSS、以及 GitHub Pages 自动发布]]></summary>
        <content type="html"><![CDATA[
## 前置条件

- Node.js 18+（推荐 20）
- Git 与 GitHub 账号

## 1）初始化项目

```bash
mkdir my-blog && cd my-blog
npm init -y
```

## 2）安装与创建 VitePress

```bash
npm i -D vitepress

# 快速启动开发（首次运行会创建 docs/.vitepress 基础结构）
npx vitepress init # 如未安装可用：npm create vitepress@latest
```

选择 “Blog” 模板或空模板均可。本仓库采用 `docs` 作为内容根目录。

开发预览：

```bash
npm run docs:dev
```

## 3）项目结构建议

```txt
docs/
  index.md                 # 首页（可用 hero 布局）
  posts/                   # 博文目录
    hello-world.md         # 你的第一篇文章（本页）
  .vitepress/
    config.ts              # 站点配置
    dist/                  # 构建输出（自动生成）
```

## 4）基础配置（docs/.vitepress/config.ts）

本仓库已内置一份可用于 GitHub Pages 的配置，关键点：

```ts
// 只展示关键片段
const BASE = process.env.BASE || "/";
const SITE_HOSTNAME = process.env.SITE_URL || "https://example.com";

export default {
  lang: "zh-CN",
  title: "我的博客",
  description: "记录、积累人气、可被搜索引擎良好收录的个人博客",
  base: BASE.endsWith("/") ? BASE : `${BASE}/`,
  sitemap: { hostname: SITE_HOSTNAME },
  themeConfig: {
    nav: [
      { text: "首页", link: "/" },
      { text: "文章", link: "/posts/hello-world" },
    ],
    search: { provider: "local" },
    outline: { level: [2, 3] },
  },
  // 如需在 Markdown 中写原始 HTML，可将 markdown.html 设为 true
  markdown: { html: false },
};
```

> 提示：GitHub Pages 二级路径（`https://<owner>.github.io/<repo>`）要设置 `BASE=/<repo>/`。

## 5）写第一篇文章（本页示例）

在 `docs/posts/` 下新建 Markdown 文件，建议包含 Frontmatter：

```md
---
title: 我的第一篇 VitePress 文章
description: 这是一段用于 SEO 的摘要
date: 2025-01-01
tags: [随笔]
---

这里是正文内容，可以使用 Markdown 语法、代码块等。
```

## 6）本地预览

```bash
npm run docs:dev
```

打开终端输出的本地地址，检查首页与文章路由是否可用。

## 7）生成静态站点

```bash
npm run build
```

构建产物在 `docs/.vitepress/dist` 目录。你可以用：

```bash
npm run docs:preview
```

进行本地预览。

## 8）生成 RSS（可选）

本仓库内置 `scripts/gen-rss.mjs`，`npm run build` 后会自动生成 RSS/Atom/JSON：

- 产物：`docs/.vitepress/rss.xml`、`atom.xml`、`feed.json`
- 设置站点地址：通过环境变量 `SITE_URL` 指定，例如：

```bash
SITE_URL="https://<owner>.github.io/<repo>" npm run build
```

如需单独生成：

```bash
SITE_URL="https://<owner>.github.io/<repo>" npm run rss
```

## 9）发布到 GitHub Pages（自动）

本仓库已包含工作流：`.github/workflows/deploy.yml`。

操作步骤：

1. 将仓库推送到 GitHub，分支 `main` 或 `master`。
2. 编辑工作流，将占位替换为你的信息：
   - `SITE_URL: https://<owner>.github.io/<repo>`
   - `BASE: /<repo>/`
3. 在 GitHub → Settings → Pages：
   - Build and deployment → Source 选择：GitHub Actions。

工作流会：安装依赖 → 构建 → 上传 `docs/.vitepress/dist` → 部署到 Pages。

## 10）常见问题

- 构建时报 HTML 标签错误：本配置默认 `markdown.html=false`，避免原始 HTML 引起解析问题。确需使用时改为 `true`，并确保标签闭合正确。
- 访问 404 或资源路径不对：多为 `base` 未设置为仓库名，如 `BASE=/your-repo/`。
- 中文文件名：VitePress 支持中文路径，但在 Windows 下请确保 Git 编码与终端能正确显示。

## 11）下一步

- 自定义主题外观、接入统计脚本（在 `head` 中注入）
- 组织文章分类/侧边栏
- 接入站点地图（已开启）、结构化数据、以及搜索优化

祝写作愉快！
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo 千篇文章的“分目录存储 + 目录树导航”实战（含 URL、分类、脚手架）]]></title>
        <id>https://herongdev.github.io/blog/posts/平台与博客/Hexo/hexo博客分类分目录组织</id>
        <link href="https://herongdev.github.io/blog/posts/平台与博客/Hexo/hexo博客分类分目录组织"/>
        <updated>2025-09-04T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 目标：当文章**成千上万**时，既能在磁盘上**分目录管理**，又能在站点里以**目录树（分类层级）**浏览，并让 **URL 跟随分类层级**，同时保持 GitHub Project Pages 的子路径（`/blog/`）不乱。

## 1 屏跑通

1. **物理分目录**：`source/_posts/` 下建多级子目录；`hexo new post 路径/标题` 可直接写入对应子目录。
2. **URL 跟随分类层级**：把 `permalink` 改成 `:categories/:title/`，并在每篇文章的 front-matter 写层级 `categories: [父, 子]`。
3. **目录树页面**：确认有 `source/categories/index.md`（`type: categories`），NexT 会按层级展示。
4. **脚手架（scaffolds）**：为高频目录建模板，一键新建时自动带好层级分类。
5. **GitHub Pages 子路径**：你是项目页 → 继续保持 `url: https://<你>.github.io/<仓库名>` 与 `root: /<仓库名>/`。

---

## 一、物理分目录（递归扫描，直接可用）

Hexo 会**递归**读取 `source/_posts/` 的子目录，所以可以放心分层管理。

```bash
# 在 _posts 下建立层级目录
mkdir -p source/_posts/GIS/GeoServer
mkdir -p source/_posts/前端/NextJS

# 新建文章时直接带路径（两种都行）
hexo new post GIS/GeoServer/切片入门
hexo new "GIS/GeoServer/缓存与预热"
```

```yaml
# 复杂：建议开启“同名资源文件夹”，让每篇文章的图片等资产跟随文章文件夹
# _config.yml（站点根配置）只需改这一行
post_asset_folder: true
```

> 开启后，`hexo new post GIS/GeoServer/切片入门` 会生成
> `source/_posts/GIS/GeoServer/切片入门.md` 与 `source/_posts/GIS/GeoServer/切片入门/`（放图）。

## 二、URL & 页面跟“分类层级”走（而不是物理目录名）

**关键点**：页面导航与 URL 建议依赖 **front-matter 的 categories**，而不是物理目录。
这样**更可控**（物理目录可随时重构、不影响 URL）。

```yaml
# 复杂：让文章链接包含“分类层级”
# _config.yml（站点根配置）
permalink: :categories/:title/
```

> 你在 GitHub Project Pages（项目页），**继续保持子路径**（别动就对了）：

```yaml
# 复杂：站点部署在 /blog/ 子路径下
url: https://herongxhr-netizen.github.io/blog
root: /blog/
```

在每篇文章顶部写**层级分类**（数组顺序即层级）：

```md
---
title: 切片入门
date: 2025-09-04
# 复杂：层级分类会生成 /GIS/GeoServer/ 的目录层级与 URL
categories: [GIS, GeoServer]
tags: [GeoServer, 切片, 缓存]
# （可选）若想自定义更友好的英文链接
# slug: geoserver-tiling-intro
---
```

## 三、目录树页面与导航菜单

确认你已有分类页与标签页（否则先创建）：

```bash
hexo new page categories
hexo new page tags
```

编辑索引页 front-matter（**只需这几行**）：

```md
---
title: 分类
type: categories
---
```

```md
---
title: 标签
type: tags
---
```

在 NexT 主题菜单里露出入口（`themes/next/_config.yml`）：

```yaml
# 复杂：在菜单里显示分类/标签
menu:
  home: /
  categories: /categories/
  tags: /tags/
```

---

## 四、批量高效新建：自定义脚手架（scaffolds）

为高频目录做脚手架，自动带上层级分类与常用字段。

**示例 1：GIS 系列脚手架**
创建 `scaffolds/gis.md`：

```md
---
title: { { title } }
date: { { date } }
# 复杂：预置层级分类，后续文章自动套用
categories: [GIS, GeoServer]
tags:
---
```

使用（指定脚手架名）：

```bash
# 复杂：--s 指定使用自定义脚手架 "gis"
hexo new --s gis "瓦片缓存策略"
```

**示例 2：NextJS 系列脚手架**
`scaffolds/nextjs.md`：

```md
---
title: { { title } }
date: { { date } }
categories: [前端, NextJS]
tags:
---
```

使用：

```bash
hexo new --s nextjs "App Router 与 RBAC"
```

> 贴士（可选）：在 `package.json` 里加脚本别名，敲更短：

```json
{
  "scripts": {
    "new:gis": "hexo new --s gis",
    "new:next": "hexo new --s nextjs"
  }
}
```

使用：`npm run new:gis "OpenLayers 点聚合最佳实践"`

---

## 五、目录结构示例（仅供参考）

```
source/_posts/
├─ GIS/
│  └─ GeoServer/
│     ├─ 切片入门.md
│     ├─ 切片入门/         # 文章同名资源文件夹（图片等）
│     └─ 缓存与预热.md
└─ 前端/
   └─ NextJS/
      └─ App Router 与 RBAC.md
```

> **注意**：物理目录**不会**自动变成 URL；URL 由 `permalink` + 文章的 `categories` 决定。

---

## 六、搜索与站点生成（与你现有配置兼容）

你已使用 `hexo-generator-searchdb`（本地搜索），与分目录/层级分类**无冲突**，无需额外改动。
每次发文后按旧流程即可：

```bash
hexo clean && hexo g && hexo s
# 自动部署（GitHub Actions）仍是：git add . && git commit && git push
```

---

## 七、常见坑位（快速定位）

- **页面 404 / 样式丢失**：`_config.yml` 的 `url/root` 未按**项目页子路径**设置（应为 `/blog/`）。
- **URL 没有层级**：缺少 `permalink: :categories/:title/` 或文章没写 `categories: [父, 子]`。
- **分类页不展示树**：`source/categories/index.md` 的 `type` 不是 `categories`；或主题菜单未加入口。
- **物理目录改变但 URL 想保持不变**：别动 front-matter 的 `categories`，URL 就不会变。
- **想迁移到“用户页”（根路径）**：把仓库改名为 `<用户名>.github.io`，并把

  ```yaml
  # 复杂：用户页改为根路径部署
  url: https://<用户名>.github.io
  root: /
  ```

  重新部署即可。

---

## 复盘清单（照这个一项项核对）

- [ ] `_config.yml` 已设置

  ```yaml
  permalink: :categories/:title/
  url: https://herongxhr-netizen.github.io/blog
  root: /blog/
  post_asset_folder: true
  ```

- [ ] 文章 front-matter 用层级分类（`[父, 子]`）。
- [ ] 有 `source/categories/index.md` 与 `type: categories`。
- [ ] NexT 菜单里有 `/categories/` 与 `/tags/`。
- [ ] 脚手架按需要创建（`scaffolds/*.md`），新建时用 `hexo new --s <脚手架> "标题"`。

---

### FAQ

**Q：必须物理分目录吗？**
A：不是必须，但**强烈建议**。这样 Git 与编辑器里都更可管理；而 URL/导航交给分类层级来控制，二者解耦。

**Q：以后想批量重构目录怎么办？**
A：直接移动文件夹即可；只要 front-matter 的 `categories` 不改，URL 不会变（避免 SEO 损失）。

**Q：图片怎么引用？**
A：启用 `post_asset_folder: true` 后，文章内用相对路径（如 `![](切片入门/示意图.png)`）即可。

---
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 hexo 在 github 部署个人博客]]></title>
        <id>https://herongdev.github.io/blog/posts/平台与博客/Hexo/使用-hexo-在-github-部署个人博客</id>
        <link href="https://herongdev.github.io/blog/posts/平台与博客/Hexo/使用-hexo-在-github-部署个人博客"/>
        <updated>2025-09-04T18:04:44.000Z</updated>
        <content type="html"><![CDATA[
# 整体实现思路

- **写作方式**：本地写 Markdown（VSCode/Typora），利用 Hexo 生成静态文件。
- **站点能力**：front-matter 实现**分类/标签**；装 `hexo-generator-searchdb` 提供**本地搜索**（纯静态，无后端）。
- **部署方式**：用 **GitHub Actions** 在每次 `push main` 时自动构建，把 `public/` 发布到 **`gh-pages`** 分支；**Pages** 指向该分支即可上线。
- **路径模式**：你当前是**项目页**（仓库名不是 `<用户名>.github.io`），所以站点路径是 `https://<用户名>.github.io/<仓库名>/`，Hexo 里必须设置 `url` 和 `root`。

---

# 分步实现过程

## 1）环境与初始化（已有可跳过）

```bash
npm i -g hexo-cli
hexo init blog && cd blog
npm i
hexo s   # 本地预览 http://localhost:4000
```

## 2）启用主题与“分类/标签/搜索”

```bash
# 安装 NexT（已安装可跳过）
npm i hexo-theme-next

# 生成分类与标签页面
hexo new page categories
hexo new page tags
```

在两个索引页文件顶部加 front-matter（**只需新增这几行**）：

```md
---
title: 分类
type: categories
---
```

```md
---
title: 标签
type: tags
---
```

安装本地搜索索引插件（**一次性**）：

```bash
npm i hexo-generator-searchdb --save
```

**站点配置 `_config.yml` 里新增（或确认存在）**：

```yaml
# 复杂：生成 search.json，供主题读取（静态搜索，无后端）
search:
  path: search.json
  field: post
  content: true
```

**主题配置 `themes/next/_config.yml` 里开启**：

```yaml
# 复杂：在 NexT 主题中开启本地搜索
local_search:
  enable: true
```

## 3）Hexo 站点路径设置（项目页必改）

打开根目录的 **`_config.yml`**，**只改这两行**：

```yaml
# 复杂：GitHub Project Pages 部署在 /blog/ 子路径（用你的用户名和仓库名）
url: https://<你的GitHub名>.github.io/<你的仓库名>
root: /<你的仓库名>/
```

> 你当前仓库是 `herongxhr-netizen/blog`，因此应为：
> `url: https://herongxhr-netizen.github.io/blog` > `root: /blog/`

## 4）把项目推到 GitHub（已有仓库可跳过初始化）

```bash
git init
git add .
git commit -m "init blog"
git branch -M master
git remote add origin https://github.com/<你的GitHub名>/<你的仓库名>.git
git push -u origin master
```

## 5）创建自动部署（GitHub Actions）

在仓库中新建文件 **`.github/workflows/deploy.yml`**，内容如下：

```yaml
# 复杂：构建 Hexo 并把生成的 public/ 发布到 gh-pages
name: Deploy Hexo to GitHub Pages
on:
  push:
    # 注意检查这个分支是否存在，另外还要注意master|main 两种默认主分支
    branches: [master]
permissions:
  contents: write
jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm i
      - run: npx hexo clean && npx hexo g
      - uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          publish_branch: gh-pages
```

> 作用：每次推送到 `master`，自动构建 Hexo 并把 `public/` 发布到 `gh-pages` 分支。

## 6）打开 GitHub Pages（指向 `gh-pages`）

仓库 → **Settings → Pages**：

- **Source** 选 **Deploy from a branch**
- **Branch** 选 **`gh-pages`**，**Folder** 选 **`/(root)`** → Save
  访问：`https://<你的GitHub名>.github.io/<你的仓库名>/`

## 7）写第一篇/后续文章（固定节奏）

```bash
hexo new post "我的第一篇文章"
# 编辑 source/_posts/我的第一篇文章.md，增加分类/标签 front-matter
hexo s                 # 本地预览确认
git add . && git commit -m "post: 第一篇" && git push
# -> Actions 自动构建 -> Pages 自动更新
```

## 故障排查（按频率排序）

1. **页面样式丢失或 404**

   - 九成是 `_config.yml` 的 `url/root` 不匹配“项目页子路径”。
   - 修复：按上面的两行改好 → `git push` 触发重建。

2. **推送成功但没自动发布**

   - 检查 **Actions** 是否执行、是否报“权限不足”。
   - 修复：打开 **Read and write permissions** 或在 workflow 增加 `permissions: contents: write`。

3. **Pages 仍显示旧内容**

   - 浏览器缓存或 GitHub Pages 缓存未刷新。
   - 修复：改动任意文件再推一次，或等几分钟刷新。

4. **找不到搜索框/搜索无结果**

   - 主题未开启 `local_search.enable` 或站点未生成 `search.json`。
   - 修复：确认两处配置；本地 `hexo clean && hexo g` 看 `public/search.json` 是否存在。

5. **想改成“用户页”根路径**

   - 把仓库改名为 `<你的GitHub名>.github.io`；
   - `_config.yml` 改为：

     ```yaml
     # 复杂：用户页部署在根路径
     url: https://<你的GitHub名>.github.io
     root: /
     ```

   - Pages 的 Source 仍选 `gh-pages`。

---

需要的话，把你当前 `themes/next/_config.yml` 里想开的功能（目录、代码复制、文章 TOC、暗色主题）告诉我；我会**只列需要修改的那几行**，并在复杂行上面加注释。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vite 项目中静态导入 vs 动态导入的全面对比]]></title>
        <id>https://herongdev.github.io/blog/posts/架构与工程化/性能与稳定性/Vite 项目中静态导入 vs 动态导入的全面对比</id>
        <link href="https://herongdev.github.io/blog/posts/架构与工程化/性能与稳定性/Vite 项目中静态导入 vs 动态导入的全面对比"/>
        <updated>2025-09-13T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
在做 **MFA（二次验证）** 的时候，你可能会遇到这样一个设计问题：  
验证器模块（短信、邮箱、App、WebAuthn 等）到底是 **静态导入**，还是用 `import()` 动态导入？

本文从 **构建、运行时、调试、体验、MFA 实战选择** 五个角度，把区别和最佳实践详细说明。

## 一、语法层面对比

### 静态导入

```ts
import sms from "./verifiers/sms";
registerVerifier("sms_validate", async () => sms);
```

- **在构建时**就确定依赖关系。
- 编译产物会直接打进主 chunk。
- `async () => sms` 只是伪装成 Promise，不会触发代码分割。

### 动态导入

```ts
registerVerifier("sms_validate", () =>
  import("./verifiers/sms").then((m) => m.default ?? m)
);
```

- `import()` 是运行时调用，返回真正的 Promise。
- 触发 **代码分割**，生成独立 chunk。
- 首次调用时才去加载。

## 二、构建层面区别

| 维度             | 静态导入                         | 动态导入                         |
| ---------------- | -------------------------------- | -------------------------------- |
| **打包方式**     | 打入入口 chunk                   | 分割为独立 chunk                 |
| **首屏体积**     | 更大                             | 更小                             |
| **Tree-shaking** | 有效，但整个文件都会被打包进来   | chunk 内也能摇树，但以文件为单位 |
| **缓存策略**     | 和主包一起缓存，版本变了整体失效 | 独立 chunk，可单独缓存           |

## 三、运行时区别

| 维度             | 静态导入               | 动态导入                       |
| ---------------- | ---------------------- | ------------------------------ |
| **首次加载**     | 已经在主包，无额外请求 | 触发一次异步加载               |
| **延迟**         | 零延迟                 | 首次有网络开销（弱网可能转圈） |
| **常用模块体验** | 即点即用               | 首次点可能卡顿                 |
| **冷门模块体验** | 白白拖慢首屏           | 不加载，节省资源               |

## 四、调试 & SSR

- **调试**

  - 静态导入：调试时所有 verifier 都会随入口加载。
  - 动态导入：调试时能直观看到 `verifiers-sms.js` 之类的分包。

- **SSR**

  - 静态导入：和 Node 端 `import` 行为一致。
  - 动态导入：服务端执行时也会懒加载，需要注意 `ssr.noExternal` 设置。

## 五、用户体验区别

- **静态导入**

  - 优点：操作无延迟。
  - 缺点：即使用户从不点“WebAuthn”，也把相关代码拉下来了。

- **动态导入**

  - 优点：只在需要时才拉；多用户场景下整体流量更省。
  - 缺点：第一次点 WebAuthn 验证时，会有一次加载等待。

## 六、Vite 特性与额外点

- **预加载支持**
  动态导入可配合 `<link rel="modulepreload">` 或手动 `import()` 提前热身，减少等待。

- **import.meta.glob**
  动态导入可以批量注册：

  ```ts
  const modules = import.meta.glob("./verifiers/*.ts");
  registerVerifier("sms", () => modules["./verifiers/sms.ts"]());
  ```

- **并发优化**
  多次点击同一验证器时，浏览器会复用动态导入的 Promise，不会重复请求。

## 七、在 MFA 场景的选择

MFA 有多种验证器：

- **短信/邮箱**：实现简单、体积很小，**常见场景**几乎人人要用。
- **App 验证器 / WebAuthn**：可能引入加密、FIDO 库，体积较大，**用户比例低**。

### 最佳实践建议

1. **常用、体积小的验证器（短信、邮箱） → 静态导入**

   - 避免点击时的首次加载延迟。
   - 不会显著增加首屏体积。

2. **少用、体积大的验证器（App、WebAuthn） → 动态导入**

   - 减少主包体积，首屏加载更快。
   - 用户只有在触发时才会加载。

### 混合模式写法

```ts
// 常用的静态导入
import sms from "./verifiers/sms";
import email from "./verifiers/email";
registerVerifier("sms_validate", async () => sms);
registerVerifier("email_validate", async () => email);

// 体积大的走动态导入
registerVerifier("app_validate", () =>
  import("./verifiers/app").then((m) => m.default ?? m)
);
registerVerifier("biometric_validate", () =>
  import("./verifiers/webauthn").then((m) => m.default ?? m)
);
```

## 八、总结

- **静态导入**：快，但拖大首屏。
- **动态导入**：首屏轻，但首次交互有延迟。
- **MFA 实战**：推荐 **混合策略**——

  - **短信/邮箱**：静态导入（高频 + 小体积）。
  - **App/WebAuthn**：动态导入（低频 + 大体积）。

这样既保证了**日常操作流畅**，又兼顾了**首屏性能和扩展性**。 🚀
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是 `AbortController`？]]></title>
        <id>https://herongdev.github.io/blog/posts/架构与请求/请求层/AbortController-Api的使用</id>
        <link href="https://herongdev.github.io/blog/posts/架构与请求/请求层/AbortController-Api的使用"/>
        <updated>2025-09-06T11:18:10.000Z</updated>
        <content type="html"><![CDATA[
### 什么是 `AbortController`？

`AbortController` 是一个 Web API，允许开发者在 JavaScript 中主动取消某些异步操作，例如网络请求（`fetch`）、定时器或其他可取消的操作。它是现代 Web 开发中处理异步任务的重要工具，特别是在需要中断或取消正在进行的操作时。`AbortController` 提供了简单、标准化的方式来实现取消功能，广泛用于浏览器环境。

`AbortController` 是在 WHATWG 的 DOM 规范中定义的，最初主要与 `fetch` API 配合使用，但现在也被其他 API（如 `ReadableStream`）支持。它的核心思想是提供一个信号（`AbortSignal`），通过这个信号可以通知相关操作停止执行。

---

### 核心概念

1. **AbortController**:

   - `AbortController` 是一个构造函数，用于创建控制器对象。
   - 它有一个 `signal` 属性，返回一个 `AbortSignal` 对象，用于监听取消信号。
   - 它还有一个 `abort()` 方法，调用后会触发取消信号。

2. **AbortSignal**:

   - `AbortSignal` 是 `AbortController` 的信号对象，传递给支持取消的 API（如 `fetch`）。
   - 当 `AbortController` 的 `abort()` 方法被调用时，`AbortSignal` 会触发 `abort` 事件，通知相关操作取消。

3. **用途**:
   - 取消网络请求（例如用户切换页面时取消未完成的 `fetch` 请求）。
   - 中止某些异步任务（如文件读取、流操作）。
   - 提高性能，避免不必要的资源消耗。
   - 实现用户交互中的取消功能（如取消上传或下载）。

---

### 工作原理

`AbortController` 的工作流程可以简单总结为以下步骤：

1. 创建一个 `AbortController` 实例。
2. 将其 `signal` 属性传递给支持取消的 API（如 `fetch`）。
3. 在需要取消操作时，调用 `AbortController` 的 `abort()` 方法。
4. 相关的 API 会接收到取消信号并停止操作，同时抛出 `AbortError` 异常。

---

### 使用示例

以下是一个使用 `AbortController` 取消 `fetch` 请求的详细代码示例：

```javascript
// 创建 AbortController 实例
const controller = new AbortController();
const signal = controller.signal;

// 发起一个 fetch 请求，传入 signal
fetch("https://api.example.com/data", { signal })
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => {
    if (error.name === "AbortError") {
      console.log("请求被取消");
    } else {
      console.error("请求失败:", error);
    }
  });

// 假设 2 秒后取消请求
setTimeout(() => {
  controller.abort(); // 调用 abort() 方法取消请求
}, 2000);
```

#### 代码解释：

- `new AbortController()` 创建控制器。
- `controller.signal` 获取信号对象，传递给 `fetch` 的 `signal` 选项。
- `controller.abort()` 触发取消，`fetch` 请求会立即停止，并抛出 `AbortError`。
- 使用 `catch` 捕获错误并判断是否为 `AbortError`。

---

### 实际应用场景

1. **取消网络请求**:

   - 用户在页面上点击“搜索”，但在结果返回前又切换到另一个页面，可以用 `AbortController` 取消未完成的请求，避免浪费带宽。
   - 示例：用户在输入框快速输入时，取消之前的搜索请求，只处理最新的请求。

2. **清理定时器或事件监听器**:

   - 虽然 `AbortController` 本身不直接控制 `setTimeout` 或事件监听器，但可以通过监听 `AbortSignal` 的 `abort` 事件来实现类似功能。

3. **流操作**:

   - 在处理 `ReadableStream` 或 `WritableStream` 时，`AbortController` 可用于取消流传输。

4. **用户交互**:
   - 提供“取消”按钮，让用户手动中止上传、下载或其他耗时操作。

---

### 高级用法：监听 `AbortSignal` 事件

`AbortSignal` 是一个 `EventTarget`，可以监听其 `abort` 事件，用于自定义取消逻辑。

```javascript
const controller = new AbortController();
const signal = controller.signal;

// 监听 abort 事件
signal.addEventListener("abort", () => {
  console.log("操作已被取消");
});

// 模拟一个异步任务
async function doWork() {
  try {
    const response = await fetch("https://api.example.com/data", { signal });
    const data = await response.json();
    console.log(data);
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("任务被取消");
    } else {
      console.error("任务失败:", error);
    }
  }
}

doWork();

// 3 秒后取消任务
setTimeout(() => {
  controller.abort();
}, 3000);
```

#### 说明：

- `signal.addEventListener('abort', ...)` 监听取消事件。
- 可以在取消时执行额外的清理逻辑，例如关闭资源或更新 UI。

---

### 注意事项

1. **浏览器兼容性**:

   - `AbortController` 在现代浏览器（如 Chrome、Firefox、Safari）中广泛支持，IE 不支持。
   - 对于旧浏览器，可能需要使用 polyfill。

2. **异常处理**:

   - 调用 `abort()` 后，相关 API 会抛出 `AbortError`，需要在代码中捕获并处理。

3. **不可恢复**:

   - 一旦调用 `abort()`，`AbortController` 实例不可重用，必须创建新的实例。

4. **支持的 API**:

   - 目前主要与 `fetch` 和 `ReadableStream` 等 API 配合使用，其他场景需要开发者手动实现取消逻辑。

5. **性能优化**:
   - 使用 `AbortController` 可以减少不必要的资源消耗，尤其在高并发或频繁请求的场景下。

---

### 扩展：结合 React 示例

在 React 中，`AbortController` 常用于组件卸载时取消请求，避免内存泄漏。

```javascript
import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    const controller = new AbortController();
    const signal = controller.signal;

    async function fetchData() {
      try {
        const response = await fetch("https://api.example.com/data", {
          signal,
        });
        const data = await response.json();
        console.log(data);
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("请求被取消");
        } else {
          console.error("请求失败:", error);
        }
      }
    }

    fetchData();

    // 组件卸载时取消请求
    return () => {
      controller.abort();
    };
  }, []);

  return <div>加载中...</div>;
}
```

#### 说明：

- 在 `useEffect` 中创建 `AbortController`。
- 在组件卸载时（`return` 回调），调用 `abort()` 取消请求。
- 防止因组件卸载而导致的内存泄漏或状态更新错误。

---

### 总结

`AbortController` 是一个简单而强大的工具，用于在 Web 开发中取消异步操作。它通过 `AbortSignal` 提供了一种标准化的取消机制，广泛应用于 `fetch` 请求、流操作等场景。它的主要优点包括：

- **简单易用**：只需要创建控制器并调用 `abort()` 即可。
- **灵活性**：支持多种异步操作的取消。
- **性能优化**：避免不必要的资源消耗。
- **现代化**：符合现代 Web 开发的需求，特别是在用户交互和性能敏感的场景中。

通过合理使用 `AbortController`，开发者可以更好地管理异步任务，提升 Web 应用的性能和用户体验。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）]]></title>
        <id>https://herongdev.github.io/blog/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）</id>
        <link href="https://herongdev.github.io/blog/posts/架构与请求/请求层/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）"/>
        <updated>2025-09-06T16:20:26.000Z</updated>
        <content type="html"><![CDATA[
````yaml
title: Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）
date: 2025-09-06
tags:
  - Axios
  - Vue3
  - TypeScript
  - Interceptor
  - Auth
---

## 目标
- 保留按前缀（如 `/api/pub`）**自动放行**的白名单机制；
- 支持**逐请求显式关闭鉴权**（即便该接口不在白名单里）；
- 避免与 Axios 自带的 `config.auth`（Basic Auth）混淆；
- 兼容历史 `(req as any).auth` 写法，**渐进迁移**到 `useAuth`。

## 方案总览
1. **类型扩展**：给 `AxiosRequestConfig` 增加 `useAuth?: boolean`。
2. **对象式入口透传**：`http.call({... useAuth })` 直达拦截器。
3. **拦截器优先级**：优先读 `useAuth` → 回退老的 `auth` → 再按前缀与实例默认值判定。
4. **显式移除头**：当不需要鉴权时，从请求头里**删除** `Authorization`，避免误带默认 token。
5. **调用方式**：`http.get/post(..., { useAuth:false })` 或 `http.call({ useAuth:false })`。

---

## 关键改动（最小补丁）

### 1) 扩展 Axios 配置
> 避免与 Basic Auth 的 `config.auth` 冲突，用单独的 `useAuth`。

```ts
// src/types/http/axios.d.ts
declare module 'axios' {
  export interface AxiosRequestConfig {
    /** 覆盖实例默认鉴权：true=强制带token；false=强制不带token */
    useAuth?: boolean
  }
}
````

### 2) 对象式入口支持 `useAuth`

```ts
// src/lib/http/types.ts（RequestOptions 中新增）
useAuth?: boolean
```

```ts
// src/lib/http/call.ts（buildAxiosConfigFromOptions 末尾透传）
if (typeof (options as any).useAuth === "boolean") {
  (cfg as any).useAuth = (options as any).useAuth;
}
```

### 3) 请求拦截器：判定与显式移除头

```ts
// src/lib/http/client.ts（拦截器内替换判定片段）

// 1) 优先 useAuth，回退旧的 auth
const explicitAuth =
  typeof (req as any).useAuth === "boolean"
    ? (req as any).useAuth
    : typeof (req as any).auth === "boolean"
    ? (req as any).auth
    : undefined;

const needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);
const accToken = storage.get(ACCESS_TOKEN);
const tokenType = storage.get(TOKEN_TYPE) || "Bearer";

// 2) 不需要鉴权：显式移除 Authorization，避免误带默认头
if (!needAuth) {
  const h = (req.headers || {}) as Record<string, any>;
  delete h.Authorization;
  delete h.authorization;
  req.headers = h;
} else {
  // 需要鉴权但无 token：中断
  if (!accToken) {
    abortController.abort();
    return Promise.reject(new Error("UNAUTHENTICATED"));
  }
  // 需要鉴权且有 token：注入
  req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };
}
```

---

## 调用方式示例

### A) 传统 axios 三参（推荐）

```ts
// 公开接口（不走 /api/pub，但也不需要 token）
await http.get("/api/third/get_login_credential_code", { useAuth: false });

// POST 且不带 token
await http.post("/api/third/login_by_credential", payload, { useAuth: false });
```

### B) 对象式入口

```ts
await http.call({
  url: "/api/third/get_login_credential_code",
  method: "GET",
  useAuth: false,
});

await http.call({
  url: "/api/third/login_by_credential",
  method: "POST",
  data: payload,
  useAuth: false,
});
```

---

## 兼容与迁移

- 旧代码里的 `(req as any).auth = false` 仍可用（拦截器已回退支持），但**建议逐步统一到 `useAuth`**。
- 仍保留 `publicPrefixes`（如 `/api/pub`）自动放行；`useAuth:false` 仅在**个别不走白名单的公开接口**上使用。

---

## 常见坑

- **不要**再用 `config.auth = false`：那是 Basic Auth，类型不对、语义也不对。
- 如果调用过 `http.setAuthToken` 写了默认头，**不显式移除**就会误带 token；本方案在拦截器中已处理。
- 确保 `tsconfig.json` 的 `include` 覆盖到 `src/types`，让编辑器识别 `useAuth` 类型。

---

## 验收清单

- [ ] `src/types/http/axios.d.ts` 已生效（编辑器能识别 `useAuth`）。
- [ ] `http.call` 能接收 `useAuth` 并透传到拦截器。
- [ ] 拦截器在 `useAuth:false` 时**不发送 Authorization**；在需要鉴权但无 token 时**立即中断**。
- [ ] 现网公开接口（不在 `/api/pub`）能通过 `{ useAuth:false }` 正常调用。

> 结论：这套改动**小而稳**，语义清晰、类型安全，满足“前缀白名单 + 逐请求显式关闭鉴权”的企业级最佳实践。

```
::contentReference[oaicite:0]{index=0}
```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「请求层大重构」——从散乱到企业级：类型、目录与演进路线]]></title>
        <id>https://herongdev.github.io/blog/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线</id>
        <link href="https://herongdev.github.io/blog/posts/架构与请求/请求层/「请求层大重构」——从散乱到企业级：类型、目录与演进路线"/>
        <updated>2025-09-06T11:58:07.000Z</updated>
        <content type="html"><![CDATA[
## 目标与判断

你的现状：页面里混着 `api.d.ts / axios.d.ts / common.ts` 等类型与封装，随着“对象入参 + 零破坏兼容”推进，类型边界和目录粘在一起，开始“乱”。

**结论（大厂常用做法）**：保持 `axios` 原语义不覆写，新增对象式入口（如 `http.call`）；**类型集中管理**、**代码生成** 与 **运行时校验** 组合；请求层**分三层**（core/http、api/generated、api/modules），再用**查询层**（TanStack Query/Vue Query）管理缓存与重试；本地与集成测试统一用 **MSW** 拦截网络层。这些都是一线公司里稳定落地的模式。([axios-http.com][1], [orval.dev][2], [GitHub][3], [tanstack.com][4], [mswjs.io][5])

---

## 推荐目录（企业级分层）

```txt
src/
  lib/
    http/                      # Core 请求层（只做“通用能力”）
      client.ts                # axios 实例与拦截器（不覆写 axios.request）
      call.ts                  # 新增对象式入口：http.call(options)
      interceptors.ts          # 拦截器拆分：auth、retry、logging
      cancel.ts                # 取消池/AbortController 管理
      types.ts                 # RequestOptions、HttpError、CodeResponse 等
      index.ts                 # 统一导出 http 实例与类型
  api/
    __generated__/             # OpenAPI 代码生成产物（只读）
      client.ts
      schemas.ts               # 可选：导出 Zod/类型
      README.md
    modules/                   # 领域 API（手写，薄封装）
      user.ts
      order.ts
      price.ts
  features/                    # 业务功能（视框架而定：React/Vue）
    price-trend/
      queries.ts               # TanStack Query/Vue Query 的 hooks
      components/...
  types/
    http/                      # 类型声明集中地（仅 .d.ts）
      axios.d.ts               # module augmentation：扩展 AxiosInstance（如 .call）
      api.d.ts                 # 全局响应范式、工具类型
    common.ts                  # 与请求无关的通用类型
tests/
  msw/
    server.ts                  # MSW 服务端/浏览器初始化
    handlers/                  # 接口级别的 mock 处理器
```

- `lib/http` 只做“通用能力”（超时、重试、鉴权、取消、日志、错误规约），**不写任何“业务 URL”**；这能保证“可替换/可迁移”。拦截器是 axios 官方推荐扩展点。([axios-http.com][1])
- `api/__generated__` 用 OpenAPI/Swagger **生成**强类型客户端，避免手写 drift；常见工具：**orval**、**openapi-typescript-codegen**、OpenAPI Generator。([orval.dev][2], [GitHub][3], [openapi-generator.tech][6])
- `api/modules` 是“轻薄门面层”：把生成代码或 `http.call` 包一层，落地**统一的错误/返回范式**，方便埋点与切面。
- `features/*/queries.ts` 将请求函数交给 **TanStack Query/Vue Query** 管理缓存、并发、重试、失效、SSR 等。([tanstack.com][7])
- `tests/msw` 用 **MSW** 在浏览器/Node 统一拦截 HTTP，保证本地/CI 可重复。([mswjs.io][5])

---

## 类型与声明管理：收口与增量

### 1) `.d.ts` **只放声明，不放实现**

- 将你现有的 `api.d.ts / axios.d.ts` **合并/去重**后放到 `src/types/http/` 下，职责清晰：

  - `axios.d.ts`：**module augmentation**（扩展 `AxiosInstance`，如新增 `call<T>()` 签名，不改原生 `get/post`）。TypeScript 官方建议通过声明合并做到“对第三方库的扩展”。([typescriptlang.org][8], [Stack Overflow][9], [futurestud.io][10])
  - `api.d.ts`：与后端约定的响应外层、错误码、工具类型（如 `CodeResponse<T>`、`PageResp<T>`）。

- `common.ts` 只保留**与请求无关**的通用类型/常量，避免耦合。

> **示例（module augmentation）**：将 `.call` 加入 `AxiosInstance`（放 `src/types/http/axios.d.ts`）

```ts
// 在同名模块作用域内“声明合并”，不会改动运行时代码
declare module "axios" {
  export interface AxiosInstance {
    // 简化：对象式入口
    call<T = any, P = Record<string, any>>(options: {
      url: string;
      method?: import("axios").Method;
      params?: P;
      data?: unknown;
      requestConfig?: import("axios").AxiosRequestConfig;
      contentType?: "json" | "urlencoded" | "formdata";
    }): Promise<T>;
  }
}
```

### 2) **运行时校验（可选但推荐）**

- 对关键接口采用 **Zod**/生成器产出的 schema，做“入站/出站”校验，尽早暴露协议漂移。([Zod][11])
- 如果你用 **Zodios**，可直接以 Zod 定义端点 → 生成强类型 axios 客户端。([zodios.org][12], [npm][13])

---

## 代码生成：把“类型维护成本”降到最低

- **orval**：从 OpenAPI 生成 TS 客户端，内置 React/Vue Query 集成、缓存与 MSW mock 模板，工程化最佳。([orval.dev][2], [GitHub][14], [npm][15])
- **openapi-typescript-codegen**：轻量、纯客户端生成，适合你已有 Query 层。([GitHub][16])

> 建议：把生成产物放进 `src/api/__generated__`，并**加入 lint/tsc**，但**排除 format**（防止误改）。CI 里加“变更即失败”的 diff 检查，确保版本与后端规范同步。

---

## Core HTTP 的“硬规范”

1. **不覆写** `axios.request`，新增 `http.call(options)`，保持 `http.get/post/...` 零破坏兼容（你已走在正确路线上）。
2. **拦截器**：鉴权（注入 `Authorization`）、401 统一处理、取消池、日志/链路 ID、错误归一化。([axios-http.com][1])
3. **FormData 正确处理**：

   - **不要手动设置** `Content-Type: multipart/form-data`，让浏览器带 boundary；否则容易 4xx/网络错误。([axios-http.com][17], [GitHub][18])

4. **错误范式**：将 `AxiosError` → 统一 `HttpError`（含 `status`、`code`、`message`、`traceId`、`isNetworkError`）。
5. **请求命名与埋点**：在 `requestConfig` 中允许 `opName`、`skipAuth`、`retry` 等自定义键，统一日志与灰度。

---

## 查询层（React/Vue）：“把副作用交给专业工具”

- 用 **TanStack Query / Vue Query** 管理缓存、并发去重、后台刷新、窗口聚焦重刷、错误边界、SSR/Hydration、离线等硬问题；你的 `http.call` / 生成客户端只需提供 **纯函数** 即可。([tanstack.com][19])
- 典型封装（以 React 为例）：

```ts
// features/price-trend/queries.ts
import { useQuery } from "@tanstack/react-query";
import { priceApi } from "@/api/modules/price";

export const useGamePriceTrend = (gameId: string, stores: string[]) =>
  useQuery({
    queryKey: ["priceTrend", gameId, stores],
    // 复杂逻辑上一行注释：调用领域 API，返回 Promise，交由 Query 管理缓存与失败重试
    queryFn: () => priceApi.getTrend({ gameId, stores }),
    staleTime: 5 * 60 * 1000,
    gcTime: 60 * 60 * 1000,
    retry: 2,
  });
```

> TanStack 官方定位就是“声明式异步/服务端状态管理”，在大厂广泛使用。([tanstack.com][7])

---

## Mock 与测试：MSW 打通本地与 CI

- **MSW** 在浏览器/Node 拦截真实网络层，mock 定义可复用到 Storybook/E2E/单元测试，减少“环境不可用”的波动。([mswjs.io][5])
- 放到 `tests/msw/handlers`，与 `api/modules` 一一对应；生成器也能产出 mock 模板（如 orval）。([GitHub][14])

---

## 迁移策略（零停机）

1. **先落地 core/http 与 `http.call`**（不动 `get/post`）。
2. **挑 1 ～ 2 个模块**迁移到 `api/modules`（使用 `http.call` 或 `__generated__` 客户端），沉淀错误与重试策略。
3. **接入 TanStack/Vue Query** 的“易变接口”（价格趋势、榜单、列表）以验证缓存收益。
4. 稳定后再逐步 **把老的页面直连 http 的代码迁到 modules**；期间保留 `api.d.ts` 的兼容类型，避免一次性爆炸式改动。
5. 接入 **MSW** 保障端到端可测。

---

## 你现有文件的落位建议

- `/mnt/data/api.d.ts` → `src/types/http/api.d.ts`（保留响应范式与工具类型，去掉与 axios 的交叉声明）
- `/mnt/data/axios.d.ts` → `src/types/http/axios.d.ts`（**只做 module augmentation**：为 `AxiosInstance` 增加 `.call` 的签名，不定义实现）
- `/mnt/data/common.ts` → `src/types/common.ts`（与请求无关的类型保留在此；若有请求相关的工具类型，迁到 `lib/http/types.ts`）

---

## 最小代码约定（只列关键片段）

```ts
// lib/http/call.ts
import type { AxiosRequestConfig, Method } from "axios";
import http from "./client";
import { toFormData, toUrlencoded } from "./utils";

export type RequestContentType = "json" | "urlencoded" | "formdata";
export interface RequestOptions<P = Record<string, any>> {
  url: string;
  method?: Method;
  params?: P;
  data?: unknown;
  requestConfig?: AxiosRequestConfig;
  contentType?: RequestContentType;
}

export async function call<T, P = Record<string, any>>(
  opt: RequestOptions<P>
): Promise<T> {
  const {
    url,
    method = "GET",
    params,
    data,
    requestConfig,
    contentType = "json",
  } = opt;
  if (!url) throw new Error("Missing url");

  const cfg: AxiosRequestConfig = { ...(requestConfig || {}), url, method };
  if (method === "GET" || method === "HEAD") {
    cfg.params = params ?? requestConfig?.params;
  } else {
    // 复杂逻辑上一行注释：统一 body 选择并按 contentType 组织
    const body = data ?? params ?? requestConfig?.data;
    if (contentType === "formdata")
      cfg.data = body instanceof FormData ? body : toFormData(body as any);
    else if (contentType === "urlencoded")
      cfg.data =
        body instanceof URLSearchParams
          ? body
          : toUrlencoded((body ?? {}) as any);
    else cfg.data = body;
  }
  return http.request(cfg) as Promise<T>;
}
```

> `client.ts` 里注册拦截器与取消池；`index.ts` 里 `export { http }` 与 `export { call }`；FormData 时**别手动设置** `Content-Type`，让浏览器带 boundary（官方文档有说明，也有 issue 讨论）。([axios-http.com][17], [GitHub][18])

---

## 校验清单（落地前检查）

- [ ] **不覆写** `axios.request`；保留 `http.get/post/...`
- [ ] `.d.ts` **只放声明**；`axios.d.ts` 仅做 module augmentation
- [ ] `http.call` **对象式入口**可用；FormData 不手设 `Content-Type`
- [ ] 统一 `HttpError`；401/取消池/日志在拦截器层
- [ ] 关键接口用 **Zod** 校验或生成器 schema
- [ ] 接入 **TanStack/Vue Query** 管理缓存与重试
- [ ] **MSW** 拦截器与 handlers 就位；本地/CI 可跑通

---

## 参考与延伸

- Axios 拦截器官方文档（拦截请求/响应的标准扩展点）。([axios-http.com][1])
- Axios Multipart/FormData 说明（自动序列化；不要手动 `Content-Type`）。([axios-http.com][17])
- 不要手动设置 FormData 的 `Content-Type`（社区/issue 共识）。([GitHub][18], [Stack Overflow][20])
- TypeScript **声明合并 / 模块增强**（官方手册）。([typescriptlang.org][8])
- Orval（OpenAPI → TS 客户端、Query、MSW mock 一体化）。([orval.dev][2], [GitHub][14])
- openapi-typescript-codegen（轻量生成 TS 客户端）。([GitHub][16])
- TanStack Query（React/Vue 的服务端状态/数据获取）。([tanstack.com][4])
- MSW（浏览器/Node 的网络层 API Mock）。([mswjs.io][5])

---

如果你愿意，我可以把你现有的 `api.d.ts / axios.d.ts / common.ts` **逐条清点**并给出**迁移 diff**（仅贴需要修改的片段，复杂处在上一行加注释），直接落到上面的目录结构里。

[1]: https://axios-http.com/docs/interceptors?utm_source=chatgpt.com "Interceptors | Axios Docs"
[2]: https://orval.dev/?utm_source=chatgpt.com "orval - Restful client generator"
[3]: https://github.com/ferdikoomen/openapi-typescript-codegen/wiki?utm_source=chatgpt.com "Home · ferdikoomen/openapi-typescript-codegen Wiki"
[4]: https://tanstack.com/query/docs?utm_source=chatgpt.com "TanStack Query"
[5]: https://mswjs.io/docs/?utm_source=chatgpt.com "Introduction - Mock Service Worker"
[6]: https://openapi-generator.tech/docs/generators/typescript/?utm_source=chatgpt.com "Documentation for the typescript Generator"
[7]: https://tanstack.com/query/latest/docs?utm_source=chatgpt.com "Overview | TanStack Query React Docs"
[8]: https://www.typescriptlang.org/docs/handbook/declaration-merging.html?utm_source=chatgpt.com "Documentation - Declaration Merging"
[9]: https://stackoverflow.com/questions/52637028/how-can-i-use-typescripts-declaration-merging-with-an-interface-imported-from-a?utm_source=chatgpt.com "How can I use Typescript's declaration merging with an ..."
[10]: https://futurestud.io/tutorials/typescript-module-augmentation-overwrites-declarations-instead-of-merging-them?utm_source=chatgpt.com "TypeScript — Module Augmentation Overwrites Declarations ..."
[11]: https://zod.dev/?utm_source=chatgpt.com "Zod: Intro"
[12]: https://www.zodios.org/?utm_source=chatgpt.com "Zodios | Zodios"
[13]: https://www.npmjs.com/package/%40zodios/axios?activeTab=readme&utm_source=chatgpt.com "zodios/axios"
[14]: https://github.com/orval-labs/orval?utm_source=chatgpt.com "orval-labs/orval"
[15]: https://www.npmjs.com/package/orval?utm_source=chatgpt.com "orval"
[16]: https://github.com/ferdikoomen/openapi-typescript-codegen?utm_source=chatgpt.com "ferdikoomen/openapi-typescript-codegen"
[17]: https://axios-http.com/docs/multipart?utm_source=chatgpt.com "Multipart Bodies | Axios Docs"
[18]: https://github.com/axios/axios/issues/5067?utm_source=chatgpt.com "Content type changed from multipart/form-data to ..."
[19]: https://tanstack.com/query/v5/docs/react/guides/queries?utm_source=chatgpt.com "TanStack Query React Docs"
[20]: https://stackoverflow.com/questions/75742226/cant-set-content-type-header-for-axios-with-formdata?utm_source=chatgpt.com "Can't set Content-Type header for axios with FormData"

下面给你一套**可直接落地**的企业级请求层目录与**所有涉及文件的完整代码**（不使用 Hexo）。
特点：不覆盖 `axios.request`、保留 `http.get/post/...` 零破坏；新增对象式入口 `http.call(options)`；类型集中在 `.d.ts` 与 `types.ts`；复杂逻辑行已在上一行加中文注释。

---

## 目录结构

```
src/
  lib/
    http/
      client.ts
      call.ts
      types.ts
      utils.ts
      index.ts
  api/
    modules/
      user.ts
      price.ts
  types/
    http/
      axios.d.ts
      api.d.ts
    common.ts
  tests/
    msw/
      server.ts
      handlers/
        price.ts
```

> 说明：`api/__generated__`（OpenAPI 代码生成）在此略去，你可以后续接入 orval/openapi-typescript-codegen；当前示例定位为手写模块层。

---

## src/lib/http/types.ts

```ts
import type {
  AxiosInstance,
  AxiosRequestConfig,
  Method,
  AxiosResponse,
} from "axios";

/** 请求体类型枚举 */
export type RequestContentType = "json" | "urlencoded" | "formdata";

/** 对象式入参：与 axios 原生保持解耦 */
export interface RequestOptions<P = Record<string, any>> {
  url: string;
  method?: Method;
  /** GET/HEAD 下作为查询串；非 GET/HEAD 下作为 body 的回退来源 */
  params?: P;
  /** 非 GET/HEAD 的首选请求体 */
  data?: unknown;
  /** 附加的 axios 配置（headers/timeout/signal 等） */
  requestConfig?: AxiosRequestConfig;
  contentType?: RequestContentType;
}

/** 统一的错误对象，可在拦截器里规约 */
export interface HttpError extends Error {
  status?: number;
  code?: number | string;
  data?: unknown;
  traceId?: string;
  isNetworkError?: boolean;
}

/** 统一的响应解析器签名：返回 undefined 表示“跳过，让后续解析器或原始响应继续处理” */
export type ResponseParser<T = any, R = AxiosResponse<any>> = (
  resp: R
) => T | undefined;

/** 为 http 实例扩展的方法（实现见 client.ts / call.ts） */
export interface HttpInstance extends AxiosInstance {
  call<T = any, P = Record<string, any>>(
    options: RequestOptions<P>
  ): Promise<T>;
  cancelAll(): void;
  setAuthToken(token?: string | null, type?: string): void;
  setGlobalParser(parsers: ResponseParser<any, any>[]): void;
  setAuthorization(token: string, expires: number | Date, name?: string): void;
  removeAuthorization(name?: string): void;
  checkAuthorization(name?: string): boolean;
}
```

---

## src/lib/http/utils.ts

```ts
/** 将对象转为 FormData；数组按 key[] 追加；对象值 JSON.stringify */
export function toFormData(params?: Record<string | number, unknown>) {
  const formData = new FormData();
  if (!params) return formData;
  Object.entries(params).forEach(([k, v]) => {
    if (Array.isArray(v)) {
      v.forEach((val) =>
        formData.append(
          `${k}[]`,
          typeof val === "object" ? JSON.stringify(val) : String(val)
        )
      );
    } else if (typeof v === "object" && v !== null) {
      formData.append(k, JSON.stringify(v));
    } else if (v !== null && v !== undefined) {
      formData.append(k, String(v));
    }
  });
  return formData;
}

/** 将对象转为 application/x-www-form-urlencoded（支持嵌套/数组） */
export function toUrlencoded(params: Record<string | number, unknown>) {
  const urlencoded = new URLSearchParams();
  function walk(obj: Record<string | number, unknown>, parent = "") {
    for (const [k, v] of Object.entries(obj)) {
      const key = parent ? `${parent}[${k}]` : k;
      if (v === null || v === undefined) continue;
      if (Array.isArray(v)) {
        v.forEach((item) =>
          urlencoded.append(
            `${key}[]`,
            typeof item === "object" ? JSON.stringify(item) : String(item)
          )
        );
      } else if (typeof v === "object") {
        walk(v as Record<string | number, unknown>, key);
      } else {
        urlencoded.append(key, String(v));
      }
    }
  }
  walk(params);
  return urlencoded;
}
```

---

## src/lib/http/call.ts

```ts
import type { AxiosRequestConfig } from "axios";
import qs from "qs";
import type { RequestOptions } from "./types";
import { toFormData, toUrlencoded } from "./utils";

/** 复杂逻辑上一行注释：根据 contentType 组织 body 并设置 headers/paramsSerializer */
export function buildAxiosConfigFromOptions(
  options: RequestOptions
): AxiosRequestConfig {
  const {
    url,
    method = "GET",
    params,
    data,
    requestConfig,
    contentType = "json",
  } = options;

  if (!url) throw new Error("Missing url");

  const cfg: AxiosRequestConfig = {
    ...(requestConfig || {}),
    url,
    method,
    headers: {
      // 默认 Content-Type，稍后允许外部覆盖；formdata 会主动删除以让浏览器自动带 boundary
      "Content-Type":
        contentType === "urlencoded"
          ? "application/x-www-form-urlencoded"
          : "application/json",
      ...(requestConfig?.headers || {}),
    },
  };

  if (method === "GET" || method === "HEAD") {
    cfg.params = params ?? requestConfig?.params;
    // 复杂逻辑上一行注释：数组无索引、跳过 null
    cfg.paramsSerializer = (d) =>
      qs.stringify(d, { indices: false, skipNulls: true });
  } else {
    // 复杂逻辑上一行注释：优先 data，回退 params（兼容旧思路）
    const body = data ?? params ?? requestConfig?.data;
    if (contentType === "formdata") {
      // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type
      if (cfg.headers) delete (cfg.headers as any)["Content-Type"];
      cfg.data = body instanceof FormData ? body : toFormData(body as any);
    } else if (contentType === "urlencoded") {
      cfg.data =
        body instanceof URLSearchParams
          ? body
          : toUrlencoded((body ?? {}) as Record<string, any>);
      cfg.headers = {
        ...cfg.headers,
        "Content-Type": "application/x-www-form-urlencoded",
      };
    } else {
      cfg.data = body;
      cfg.headers = { ...cfg.headers, "Content-Type": "application/json" };
    }
  }
  return cfg;
}
```

---

## src/lib/http/client.ts

```ts
import axios from "axios";
import Cookie from "js-cookie";
import storage from "store";
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";
import type { HttpInstance, ResponseParser } from "./types";
import { buildAxiosConfigFromOptions } from "./call";
import { STORAGE_KEYS } from "@/constants";
import { LOGIN_ROUTE } from "@/router/constants";

const { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;

/** —— 取消池：统一管理所有请求的 AbortController —— */
const abortPool = new Set<AbortController>();

/** 对外暴露：集中取消所有未决请求（如退出登录时） */
function cancelAll() {
  abortPool.forEach((c) => c.abort());
  abortPool.clear();
}

/** 创建 axios 实例并安装拦截器 */
function createAxiosHttp(
  config: AxiosRequestConfig,
  opts: {
    authDefault?: boolean;
    publicPrefixes?: string[];
  } = {}
): HttpInstance {
  const authDefault = opts.authDefault ?? true;
  const publicPrefixes = opts.publicPrefixes ?? ["/api/pub"];

  const _axios = axios.create(config) as AxiosInstance;

  // —— 业务增强：全局解析器（按顺序尝试，返回 undefined 表示跳过） ——
  (_axios as any).setGlobalParser = (parsers: ResponseParser<any, any>[]) => {
    _axios.interceptors.response.use(
      (resp: AxiosResponse) => {
        for (const p of parsers) {
          const r = p(resp);
          if (r !== undefined) return r;
        }
        return resp;
      },
      (err) => {
        if (err?.response) {
          const e: any = new Error(err.response.statusText);
          e.status = err.response.status;
          e.code = err.response.data?.code;
          e.data = err.response.data;
          throw e;
        }
        // 网络层错误（超时/断网/跨域）
        const e: any = new Error(err?.message || "Network Error");
        e.isNetworkError = true;
        throw e;
      }
    );
  };

  // —— cookie 鉴权工具方法（部分场景需要，同你原实现保持一致） ——
  (_axios as any).setAuthorization = (
    token: string,
    expires: number | Date,
    name?: string
  ) => {
    Cookie.set(name ?? _axios.defaults.xsrfCookieName!, token, { expires });
  };
  (_axios as any).removeAuthorization = (name?: string) => {
    Cookie.remove(name ?? _axios.defaults.xsrfCookieName!);
  };
  (_axios as any).checkAuthorization = (name?: string) => {
    return Boolean(Cookie.get(name ?? _axios.defaults.xsrfCookieName!));
  };

  // —— 请求拦截器：统一接入取消池/授权头/公开前缀 ——
  _axios.interceptors.request.use((req) => {
    // 复杂逻辑上一行注释：桥接外部 signal 与内部 AbortController，并加入取消池
    const abortController = new AbortController();
    if ((req as any).signal) {
      const ext = (req as any).signal as AbortSignal;
      if (ext.aborted) abortController.abort();
      else ext.addEventListener?.("abort", () => abortController.abort());
    }
    (req as any).signal = abortController.signal;
    abortPool.add(abortController);
    // 复杂逻辑上一行注释：把 controller 暂存在 config 上，响应阶段释放
    (req as any).__abortController = abortController;

    // 复杂逻辑上一行注释：根据前缀与开关决定是否附加 Authorization
    const url = req.url || "";
    const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));
    // 优先使用 req.auth(boolean)；否则用实例默认值 + 前缀约定
    const explicitAuth =
      typeof (req as any).auth === "boolean" ? (req as any).auth : undefined;
    const needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);
    const accToken = storage.get(ACCESS_TOKEN);
    const tokenType = storage.get(TOKEN_TYPE) || "Bearer";
    if (needAuth && !accToken) {
      ((req as any).__abortController as AbortController | undefined)?.abort();
      return Promise.reject(new Error("UNAUTHENTICATED"));
    }
    if (needAuth && accToken) {
      req.headers = {
        ...req.headers,
        Authorization: `${tokenType} ${accToken}`,
      };
    }
    return req;
  });

  // —— 响应拦截器：释放取消控制器；401 统一处理 ——
  _axios.interceptors.response.use(
    (res) => {
      const abortController = (res.config as any).__abortController as
        | AbortController
        | undefined;
      if (abortController) abortPool.delete(abortController);
      return res;
    },
    (err) => {
      if (err?.response?.status === 401) {
        storage.remove(ACCESS_TOKEN);
        storage.remove(TOKEN_TYPE);
        if (window.location.pathname !== LOGIN_ROUTE.path) {
          window.location.replace(LOGIN_ROUTE.path);
        }
      }
      const abortController = (err?.config as any)?.__abortController as
        | AbortController
        | undefined;
      if (abortController) abortPool.delete(abortController);
      return Promise.reject(err);
    }
  );

  // —— 实例级取消 ——
  (_axios as any).cancelAll = cancelAll;

  // —— 实例级鉴权头设置（与本地存储联动） ——
  (_axios as any).setAuthToken = (token?: string | null, type = "Bearer") => {
    if (token) {
      _axios.defaults.headers.common.Authorization = `${type} ${token}`;
      storage.set(ACCESS_TOKEN, token);
      storage.set(TOKEN_TYPE, type);
    } else {
      delete _axios.defaults.headers.common.Authorization;
      storage.remove(ACCESS_TOKEN);
      storage.remove(TOKEN_TYPE);
    }
  };

  // —— 新增对象式入口：http.call(options) ——
  (_axios as any).call = async function <T = any>(
    options: Parameters<typeof buildAxiosConfigFromOptions>[0]
  ): Promise<T> {
    const cfg = buildAxiosConfigFromOptions(options);
    return _axios.request(cfg) as Promise<T>;
  };

  return _axios as unknown as HttpInstance;
}

const http = createAxiosHttp(
  {
    timeout: 10000,
    baseURL: import.meta.env.VITE_API_URL as string,
    withCredentials: true,
    xsrfCookieName: "Authorization",
    xsrfHeaderName: "Authorization",
  },
  { authDefault: true, publicPrefixes: ["/api/pub"] }
);

export default http;
export { cancelAll };
```

---

## src/lib/http/index.ts

```ts
export { default as http, cancelAll } from "./client";
export * from "./types";
export * from "./utils";
export * from "./call";
```

---

## src/api/modules/user.ts

```ts
import { http } from "@/lib/http";
import type { RequestOptions } from "@/lib/http/types";

/** 复杂逻辑上一行注释：领域 API 薄封装，避免页面直接感知 URL/方法/解析细节 */
export const userApi = {
  getProfile() {
    return http.get<{ id: string; name: string; roles: string[] }>(
      "/api/user/profile"
    );
  },

  updateProfile(input: { name?: string }) {
    return http.call<void>({
      url: "/api/user/profile",
      method: "PUT",
      data: input,
      contentType: "json",
    });
  },

  /** 演示：URLSearchParams */
  search(params: { keyword?: string; page?: number }) {
    const options: RequestOptions<typeof params> = {
      url: "/api/user/search",
      method: "GET",
      params,
      requestConfig: { timeout: 8000 },
    };
    return http.call<{ list: any[]; total: number }>(options);
  },
};
```

---

## src/api/modules/price.ts

```ts
import { http } from "@/lib/http";

/** 复杂逻辑上一行注释：后端采用 CodeResponse 外包裹，交由全局解析器转换 */
export const priceApi = {
  getTrend(input: { gameId: string; stores: string[] }) {
    return http.call<Array<{ store: string; date: string; price: number }>>({
      url: "/api/price/trend",
      method: "POST",
      data: input,
      contentType: "json",
      requestConfig: { timeout: 15000 },
    });
  },
};
```

---

## src/types/http/axios.d.ts

```ts
// 声明合并：扩展 AxiosInstance，而不改动运行时代码
import type { AxiosRequestConfig } from "axios";

declare module "axios" {
  export interface AxiosInstance {
    call<T = any, P = Record<string, any>>(options: {
      url: string;
      method?: Method;
      params?: P;
      data?: unknown;
      requestConfig?: AxiosRequestConfig;
      contentType?: "json" | "urlencoded" | "formdata";
    }): Promise<T>;

    cancelAll(): void;
    setAuthToken(token?: string | null, type?: string): void;
    setGlobalParser(parsers: Array<(resp: any) => any | undefined>): void;
    setAuthorization(
      token: string,
      expires: number | Date,
      name?: string
    ): void;
    removeAuthorization(name?: string): void;
    checkAuthorization(name?: string): boolean;
  }
}
```

---

## src/types/http/api.d.ts

```ts
// 与后端约定的通用响应外壳
export interface CodeResponse<T = any> {
  code: number;
  data: T;
  message?: string;
}

// 常见分页返回
export interface PageResp<T> {
  list: T[];
  total: number;
  page: number;
  pageSize: number;
}

// 解析器（如果你希望有全局类型）
export type ResponseParser<T = any, R = any> = (resp: R) => T | undefined;
```

---

## src/types/common.ts

```ts
// 放与请求无关的通用类型
export type ID = string | number;

export interface Dict<T = any> {
  [key: string]: T;
}
```

---

## （可选）全局解析器：将 CodeResponse<T> 解开

> 你可以把它放到任意初始化位置（如 `src/app.ts` 或 `src/main.ts`）并在启动时挂载。

```ts
// src/app.setup-http.ts
import type { AxiosResponse } from "axios";
import { http } from "@/lib/http";
import { LOGIN_ROUTE } from "@/router/constants";
import storage from "store";
import { STORAGE_KEYS } from "@/constants";
import type { CodeResponse } from "@/types/http/api";

const { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;

/** 复杂逻辑上一行注释：仅处理符合 CodeResponse 形状的响应，其他透传 */
function isCodeResp<T>(d: unknown): d is CodeResponse<T> {
  return (
    !!d && typeof d === "object" && "code" in (d as any) && "data" in (d as any)
  );
}

export const codeResponseParser = <T, R = CodeResponse<T>>(
  res: AxiosResponse<R>
): T | undefined => {
  const payload = res.data as any;
  if (!isCodeResp<T>(payload)) return undefined;
  const { code, data, message = "" } = payload;

  if (code === 401) {
    storage.remove(ACCESS_TOKEN);
    storage.remove(TOKEN_TYPE);
    if (window.location.pathname !== LOGIN_ROUTE.path) {
      window.location.replace(LOGIN_ROUTE.path);
    }
    throw new Error("未授权，请重新登录");
  }
  if (code === 200) return (data ?? null) as T;
  throw new Error(message || "后端错误");
};

// 启动时挂载
http.setGlobalParser([codeResponseParser]);
```

---

## tests/msw/server.ts

```ts
import { setupServer } from "msw/node";
import { handlers } from "./handlers/price";

export const server = setupServer(...handlers);

// 在测试框架的 setup 中调用：
// beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }))
// afterEach(() => server.resetHandlers())
// afterAll(() => server.close())
```

---

## tests/msw/handlers/price.ts

```ts
import { http, HttpResponse } from "msw";

// 示例：与你的 priceApi.getTrend 匹配
export const handlers = [
  http.post("/api/price/trend", async ({ request }) => {
    const body = (await request.json()) as any;
    // 复杂逻辑上一行注释：模拟后端的 CodeResponse 外壳
    return HttpResponse.json({
      code: 200,
      data: [
        { store: "Steam", date: "2025-09-01", price: 199 },
        { store: "Epic", date: "2025-09-01", price: 189 },
      ],
      message: "ok",
    });
  }),
];
```

---

# 使用要点

- 老代码：`http.get/post/...` **完全不受影响**。
- 新写法：`http.call({ url, method, data/params, contentType, requestConfig })` 更可读/可扩展。
- `FormData` 场景不要手设 `Content-Type`，已在实现里处理。
- 推荐在应用初始化处挂载 `codeResponseParser`，让模块层拿到的就是“已解壳”的数据。

如果你要把你现有的 `api.d.ts / axios.d.ts / common.ts` 内容**原封不动**迁入以上文件名，也可以把原定义贴出来，我帮你对齐/去重并完善类型冲突的 diff。

下面把你要的 **`cancel.ts` 完整代码**给出，并说明如何在 `client.ts` 接入；最后把 “FormData 自动带 boundary，需移除手动设置的 Content-Type” 的含义讲清楚。

---

## 1) `src/lib/http/cancel.ts`（完整代码）

```ts
// src/lib/http/cancel.ts

/**
 * 维护一个全局取消池，用于集中取消所有尚未完成的请求。
 * 注意：只存放“活跃中的” AbortController；请求结束后要及时释放。
 */
const abortPool = new Set<AbortController>();

/** 复杂逻辑上一行注释：把外部 signal（若有）与内部 controller 绑定，外部取消时联动内部取消 */
function linkExternalSignal(
  external?: AbortSignal,
  controller?: AbortController
) {
  if (!external || !controller) return;
  if (external.aborted) {
    // 外部已取消则立即同步内部取消
    controller.abort();
    return;
  }
  // 外部后续取消时，触发内部取消
  external.addEventListener("abort", () => controller.abort());
}

/**
 * 创建一个“已纳入取消池管理”的 AbortController。
 * - 会自动与外部 signal（如果传入）联动；
 * - 会自动加入全局 abortPool，方便统一取消；
 * - 调用方需在请求完成/失败时调用 releaseController 释放。
 */
export function makeTrackedController(
  externalSignal?: AbortSignal
): AbortController {
  const controller = new AbortController();
  linkExternalSignal(externalSignal, controller);
  abortPool.add(controller);
  return controller;
}

/** 将 controller 从取消池释放（请求完成/失败时务必调用，避免内存泄漏） */
export function releaseController(controller?: AbortController) {
  if (controller) abortPool.delete(controller);
}

/** 退出登录或全局重置时：集中取消所有未决请求 */
export function cancelAll() {
  abortPool.forEach((c) => c.abort());
  abortPool.clear();
}
```

---

## 2) 在 `client.ts` 中的**最小改动**

> 按你的偏好，这里**只给需要改的片段**，并在复杂逻辑上一行加注释。

**2.1 顶部引入：**

```ts
// + 新增
import { makeTrackedController, releaseController, cancelAll } from "./cancel";
```

**2.2 删除原本在 client.ts 里的这两段：**

```ts
// - 删除
const abortPool = new Set<AbortController>();
function cancelAll() {
  /* ...原实现... */
}
```

**2.3 请求拦截器里替换创建/管理 controller 的逻辑：**

```ts
// —— 将外部 signal 与内部 AbortController 关联，并纳入统一取消池 ——
const abortController = makeTrackedController(
  (req as any).signal as AbortSignal | undefined
);
(req as any).signal = abortController.signal;
(req as any).__abortController = abortController;
```

**2.4 响应与异常分支里释放 controller：**

```ts
// —— 请求完成：释放与该请求关联的 AbortController ——
releaseController(
  (res.config as any).__abortController as AbortController | undefined
);

// —— 异常完成：同样需要释放 AbortController ——
releaseController(
  (err?.config as any)?.__abortController as AbortController | undefined
);
```

**2.5 保持对外暴露实例方法：**

```ts
// 实例级的取消功能依然可用
(_axios as any).cancelAll = cancelAll;
```

> 这样，取消逻辑就从 `client.ts` 拆分到了独立的 `cancel.ts`，便于复用与测试；`client.ts` 里只保留“如何在拦截器中使用”的胶水代码。

---

## 3) “FormData 自动带 boundary，需移除手动设置的 Content-Type” 是啥意思？

- 当你在**浏览器环境**用 `FormData` 作为请求体时，真正发请求的是浏览器（或者 fetch/XHR），它会自动把请求头 `Content-Type` 设置成：

  ```
  Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXyz...
  ```

  这里的 `boundary` 是一段**分隔符**，用来把每个字段/文件的二进制块分割开。**这个 boundary 是浏览器动态生成的**。

- **如果你手动把 `Content-Type` 固定写成 `multipart/form-data`**（没有 `boundary=...`），服务端收到的内容就**无法正确分段解析**，经常出现 400/422 或 “Unexpected end of form / Missing boundary” 之类错误。

- 因此，在我们封装里（`contentType === 'formdata'` 分支）会：

  ```ts
  // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type
  if (cfg.headers) delete (cfg.headers as any)["Content-Type"];
  cfg.data = body instanceof FormData ? body : toFormData(body as any);
  ```

  这么做是**故意**把 `Content-Type` 删除，让浏览器自己填上带 `boundary` 的正确值。

> 小结：
>
> - **浏览器 + FormData**：不要手写 `Content-Type`，让它自动带 boundary（我们代码里已处理）。
> - **Node.js 端（无浏览器）**：若用 `form-data`/`formdata-node` 等库，也应**让库自己设置**或通过库提供的方法拿到带 `boundary` 的 header，而不是手写。

---

需要我把 `client.ts` 根据上面的片段**整合成完整文件**再贴一次，也可以说一声；但如果你已经在用我之前给的版本，只要按上面的 4 处小改即可完成 `cancel.ts` 的接入。

简短结论先给你：

- **Axios 封装没有“唯一正确解”**，但大厂普遍遵循“**分层 + 零破坏 + 渐进演进**”三原则：
  Core（http 客户端能力）→ Domain API（领域方法）→ View/State（查询层）。
- **TanStack Query（React Query / Vue Query）不是必须**。当你的页面需要**缓存、并发去重、重试、后台刷新、预取、分页/无限滚动、乐观更新**中的多项时，它的价值非常高；否则可以先不用，等复杂度上来了再加。

下面给你一套“可落地的选择题”，帮你快速拍板。

---

## 一、Axios 封装到底怎么选？

### 方案 A：**极简封装（Core + 少量 Domain API）**

适用：后端接口简单、页面少、交互不复杂，或以 **Server Actions/Route Handlers（Next.js 14）** 为主、客户端请求很少。
要点：

- Core 层：一个 `http` 实例（拦截器、取消池、统一错误、鉴权）、`http.call(options)` 对象式入口（你现在这版 ✅）。
- Domain 层：在 `src/api/modules/*` 里写薄封装函数（避免在页面拼 URL/方法）。
  优点：学习/维护成本最低；对现有代码**零破坏**。
  缺点：项目一复杂，**缓存/并发/重试**容易重复造轮子。

### 方案 B：**标准化封装（Core + Domain API + 代码生成）**

适用：接口较多、多人协作、需要**强类型**对齐后端（避免“文档/实现漂移”）。
要点：

- 在 A 的基础上加 **OpenAPI 代码生成**（orval/openapi-typescript-codegen），产物放 `api/__generated__`，**只读、不手改**。
- Domain 层再包一层“门面”，统一错误处理/埋点/灰度。
  优点：类型和接口更新**自动跟进**；减少手抄 DTO。
  缺点：引入生成链路，需要后端提供/维护 OpenAPI。

### 方案 C：**企业级（Core + Domain + 代码生成 + 查询层 TanStack）**

适用：**列表/详情很多**、需要**缓存/失效/后台刷新/并发去重/预取/SSR**等能力；或你已经遇到“重复请求、抖动、复杂 loading 状态”问题。
要点：

- 在 B 的基础上引入 **TanStack Query（React）/Vue Query（Vue3）** 做服务端状态管理。
- 页面里不直接 `http.call`，而是用 `useQuery/useMutation` 调你封装好的 Domain API。
  优点：把“**缓存/并发/重试/错误边界/重整化**”交给成熟库，页面只管渲染。
  缺点：学习成本 ↑，需要 Provider 初始化与查询键设计。

---

## 二、到底要不要用 TanStack Query？（自测 8 题）

请数一数你满足了多少条（≥3 条就**建议上**）：

1. 同一数据被**多处页面/组件复用**，且你想要**共享缓存**。
2. 同一接口在短时间内可能被**多次触发**（需要**请求去重**）。
3. 希望**失败自动重试**、**退避**，或在**网络恢复**/**窗口聚焦**时自动**后台刷新**。
4. 有**分页/无限滚动**，并且要处理**下一页预取**或**乐观更新**。
5. 需要**预取数据**（用户悬停/路由即将跳转时先打请求）。
6. 你在做 **Next.js 14** 前端页面，既有 **Server Components** 也有 **Client Components**，客户端数据要**SSR Hydration** 或 **延迟刷新**。
7. 想**显式管理缓存过期（staleTime）** 与 **垃圾回收（gcTime）**，防止反复打接口。
8. 现在已经在手写“请求缓存/合流/状态机”，感觉**心智负担**上来了。

> 结合你的项目：有**价格趋势**、**多商店选择**、**首页与详情复用价格数据**、后续还要**图表/列表**，我建议：
>
> - 在**这些“读多写少”的模块**上用 TanStack Query；
> - 其他简单页面（一次性拉取、无复杂刷新），继续用现在的 `http.call` 即可。
>   这样“**按需引入**”，增量演进，不会一刀切。

---

## 三、你现在的最佳落地路线（最少折腾）

1. **保留现有 http 层（你已完成）**

   - `client.ts + cancel.ts + call.ts + types.ts + utils.ts`，不覆盖 `axios.request`，**零破坏**保留 `get/post`。

2. **Domain API 薄封装**

   - 在 `src/api/modules/*` 暴露语义化函数（`priceApi.getTrend`等），页面不拼 URL。

3. **对“需要缓存/并发去重”的模块上 TanStack Query**

   - 只在“价格趋势、榜单、列表”这些位置用 Query，其它模块不强求。

4. **后续再接 OpenAPI 代码生成**（可选）

   - 先让 Query 跑顺，再把类型维护成本转移给生成器，逐步替换手写 DTO。

5. **MSW 做联调与测试**（可选）

   - 本地/CI 统一拦截，减少后端不可用带来的卡点。

---

## 四、常见误区（避免踩坑）

- **覆写 `axios.request`** → 破坏 `get/post` 的语义（你已经改成 `.call`，很对）。
- **手写 `Content-Type: multipart/form-data`** → FormData 的 `boundary` 会丢（我们已在 `formdata` 分支删除该头，让浏览器自动带）。
- **在组件里定义 DTO/类型** → 类型四散；建议集中到 `types/http/*` 与 `api/__generated__`。
- **重复写缓存/重试/去重** → 已有成熟轮子（TanStack Query）；自己写容易遗漏边角。
- **取消控制器不释放** → 造成内存泄漏；我们用 `releaseController` 在响应/异常两侧都释放。

---

## 五、如果暂时不用 TanStack Query，也能稳住吗？

可以。你的 `http.call + modules` 架构，配合\*\*轻量的自定义缓存（Map + 过期时间）\*\*也能顶一阵子。但一旦出现“**相同查询在多处使用**”、“**滚动列表/分页**”、“**需要重试与后台刷新**”的需求，**切到 TanStack Query 成本更低**（只需把 Domain API 包进 `useQuery`），没必要造大轮子。

---

### 你现在可以怎么做（两步）：

- **短期**：继续用现有封装；把价格趋势这块接入 Query（仅此一处），体会收益。
- **中期**：如果感觉不错，再把“新闻列表/攻略列表”等也迁到 Query；并考虑引入 OpenAPI 代码生成，降低类型维护成本。

需要的话，我可以基于你现有的模块，直接给出**一个最小的 TanStack Query 集成示例**（包含 Provider、`useQuery` 的示例调用、SSR Hydration 的注意点），只贴**必要的代码片段**，不改你现有文件结构。

结论：**你的“核心响应拦截器”（释放 AbortController + 401 跳转）先执行，`setGlobalParser` 里注册的“全局解析器”后执行**。

原因（Axios 规则）：

- **response 拦截器是 FIFO**：谁**先注册**，谁**先执行**。
- **request 拦截器是 LIFO**：谁**后注册**，谁**先执行**。（顺带一提）

在你这份代码里：

1. `createAxiosHttp` 里先注册了“核心响应拦截器”。
2. 应用启动时再调用 `http.setGlobalParser([...])`，此时**追加**一个响应拦截器。
   → 因为 response 是 FIFO，所以**核心拦截器先跑**，**全局解析器后跑**。

执行顺序具体是：

- **成功响应路径 (`fulfilled`)**
  ① 核心响应拦截器：`releaseController(...)` → `return res`
  ② 全局解析器：遍历 parsers，可能把 `AxiosResponse` 解包成你的业务数据（或继续返回原响应）

- **失败响应路径 (`rejected`)**
  ① 核心响应拦截器：遇到 `401` 清 token + 跳登录；不管什么错误都先 `releaseController(...)`；`return Promise.reject(err)`
  ② 全局解析器：拿到上一步抛出的 `err`，再做标准化/改写错误对象（如果你这么实现）

> 小提示：如果你**想让全局解析器先执行**，就必须**更早注册**它（例如把 `setGlobalParser` 的安装逻辑挪到 `createAxiosHttp` 里、并放在核心拦截器之前），或者在核心拦截器内部先调用解析器再做释放/跳转。但你当前这种“先释放/401，再解析”的顺序其实更稳：能确保无论成功还是失败，**先释放资源**再做业务级处理，避免泄漏。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生产问题复盘：试点班（大纲/日程/作业/度量/素材）]]></title>
        <id>https://herongdev.github.io/blog/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）</id>
        <link href="https://herongdev.github.io/blog/posts/生产问题与深度调试/前端疑难杂症/生产问题复盘：试点班（大纲-日程-作业-度量-素材）"/>
        <updated>2025-09-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[基于真实生产问题的 4～6 周训练营方案：大纲、日程、作业与考核、度量指标与落地素材清单。]]></summary>
        <content type="html"><![CDATA[
## 课程目标

- 建立“从信号到因果”的定位方法论与可复现流程
- 搭建最小可复现（MRE）、观测面板与基准测试
- 交付可投递的复盘报告与改进方案

## 课程大纲

- Week 1：问题定义与信号采集（日志/指标/Trace 基线）
- Week 2：复现场景与最小复现（MRE），错误预算与 SLO
- Week 3：定位技术：长任务/网络抖动/资源争用/内存泄漏
- Week 4：治理与回归：限流/熔断/幂等/回滚、回归基线
- Week 5（可选）：端到端演练：灰度、回滚演练、事故演习
- Week 6（可选）：Capstone 展示与简历/作品集打磨

## 日程（示例 4 周）

- 每周 2 次直播/录播 + 1 次作业走查 + 1 次办公小时
- 每周固定提交：MRE 仓库、观测截图、复盘报告

## 作业与考核

- 作业 1：采集与基线（日志/指标/Trace 基线 + 一处异常信号）
- 作业 2：最小可复现（MRE）与故障注入脚本
- 作业 3：定位与因果链报告（含观测和对照）
- 作业 4：治理与回归（限流/熔断/幂等/回滚）
- 考核维度：正确性、鲁棒性、可观测、复盘完整性、表达与协作

## 度量指标

- 平均问题解决时长（前/后测）
- 80 分位问题解决时长
- 回滚率、事故率、SLO 改善
- 作业通过率、复盘报告评分、作品集完成率

## 落地素材清单（结合你现有文章）

- 请求层与鉴权（目录：`架构与请求/请求层`）
- Vue 性能与交互（目录：`前端/Vue`）
- 实时通信与网络抖动（目录：`前端/实时通信`）
- 登录与会话问题（目录：`前端/鉴权-登录`）
- 下载/直链 vs 鉴权（目录：`前端/下载与文件`）
- Web 推送与标识（目录：`Web-API-与推送`）

> 每周选择 1 ～ 2 篇相关文章作为阅读材料与作业素材；
> 每篇文章配套：MRE 仓库（或片段）、观测面板截图、复盘要点 Checklist。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TradingView `study_templates` 的 CRUD 端点（含最小后端示例）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/tradeview/TradingView study_templates 的 CRUD 端点（含最小后端示例）</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/tradeview/TradingView study_templates 的 CRUD 端点（含最小后端示例）"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## REST 端点一览（官方定义）

> `charts_storage_url/{charts_storage_api_version}/study_templates?client={client_id}&user={user_id}`
> 版本：**1.1**；动作：**List / Save / Load / Delete**。([TradingView][1])

### 1) 列表（R：List）

- **GET** `/1.1/study_templates?client=...&user=...`
- **响应**：

```json
{ "status": "ok", "data": [{ "name": "MyTemplate" }] }
```

（返回所有模板名）([TradingView][1])

### 2) 保存（C：Create；亦用于覆盖“U：Update”）

- **POST** `/1.1/study_templates?client=...&user=...`
- **请求体**：

```json
{ "name": "MyTemplate", "content": "{...library-supplied-json...}" }
```

- **响应**：`{ "status": "ok" }`

> 文档未提供单独“更新”端点；**同名 POST 即覆盖**。如需“重命名”，自行实现“读旧 → 存新 → 删旧”。([TradingView][1])

### 3) 读取（R：Load）

- **GET** `/1.1/study_templates?client=...&user=...&chart={chart_id}&template={name}`
- **响应**：

```json
{ "status": "ok", "data": { "name": "MyTemplate", "content": "{...}" } }
```

（`chart` 为当前图表 id，库会带上）([TradingView][1])

### 4) 删除（D：Delete）

- **DELETE** `/1.1/study_templates?client=...&user=...&template={name}`
- **响应**：`{ "status": "ok" }` ([TradingView][1])

> 以上端点路径与 `client_id / user_id / charts_storage_api_version(=1.1)` 的来源见 REST 概览。([TradingView][2])

---

## 最小后端路由片段（Express）

> 只给“需要的代码”，可直接粘到你的 `server.js` 中；复杂逻辑已在上一行注释。

```js
// 列出或读取单个模板
app.get("/1.1/study_templates", (req, res) => {
  const { client, user, chart, template } = req.query;
  // ← 复杂逻辑：带 template= 则返回单个；否则返回列表
  if (template) {
    const key = `${client}:${user}:${template}`;
    const item = store.get(key);
    return res.json(
      item
        ? { status: "ok", data: { name: template, content: item.content } }
        : { status: "error", message: "not found" }
    );
  }
  const list = [...store.keys()]
    .filter((k) => k.startsWith(`${client}:${user}:`))
    .map((k) => ({ name: k.split(":").slice(2).join(":") }));
  res.json({ status: "ok", data: list });
});

// 保存（创建/覆盖）
app.post("/1.1/study_templates", (req, res) => {
  const { client, user } = req.query;
  const { name, content } = req.body;
  // ← 复杂逻辑：同名即覆盖，实现“U”
  if (!name || !content)
    return res.json({ status: "error", message: "name/content required" });
  store.set(`${client}:${user}:${name}`, { content });
  res.json({ status: "ok" });
});

// 删除
app.delete("/1.1/study_templates", (req, res) => {
  const { client, user, template } = req.query;
  store.delete(`${client}:${user}:${template}`);
  res.json({ status: "ok" });
});
```

---

## 前端对接要点（再次强调）

```js
// ← 复杂逻辑：不配这些就会出现 /undefined/... 的错误 URL
enabled_features: ['study_templates'],
charts_storage_url: 'http://localhost:9005',
charts_storage_api_version: '1.1',
client_id: 'your-app',
user_id: 'user-123',
```

（以上字段与行为来自官方“Saving & Loading / REST”与“Indicator template methods”。）([TradingView][2])

---

## 参考文档

- Save & load REST API（总览、示例后端、参数解释）([TradingView][2])
- Indicator template methods（四个端点的请求与响应）([TradingView][1])

如果你用的是 **NestJS** 或需要 **重命名** 的自定义端点，我可以按你项目结构给出“最小改动片段”。

[1]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/indicator-template-methods/ "Indicator template methods | Advanced Charts Documentation"
[2]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/ "Save and load REST API | Advanced Charts Documentation"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 TradingView（Charting Library）里实现“保存指标模板”（study\_templates）——完整前后端实战]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/tradeview/在 TradingView（Charting Library）里实现“保存指标模板”（study_templates）——完整前后端实战</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/tradeview/在 TradingView（Charting Library）里实现“保存指标模板”（study_templates）——完整前后端实战"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 整体实现思路

- **目标**：在你的嵌入式 TradingView 图表里启用“指标模板”按钮，支持保存/读取一组指标及其参数。
- **核心**：Charting Library 通过 **REST API** 调你的后端：
  `charts_storage_url/{charts_storage_api_version}/study_templates?client={client_id}&user={user_id}`，必须把 `charts_storage_api_version` 设为 **"1.1"**（study templates 自 1.1 起支持）。([TradingView][1])
- **前端**：

  1. 在 Widget 里 **开启 featureset：`study_templates`**，让顶栏出现“指标模板”按钮；
  2. 配置 `charts_storage_url`、`charts_storage_api_version:"1.1"`、`client_id`、`user_id`。([TradingView][2])

- **后端**：实现 4 个端点（列/存/载/删），返回标准 JSON。你也可以用 **save_load_adapter** 走自定义存取流程，但仍需要你有后端。([TradingView][3])

---

## 分步实现过程

### 步骤一：准备与目录

- 前端：已集成 **Charting Library**（本地 `charting_library/` 静态资源）与你的 Datafeed。
- 后端：任意 Web 框架皆可，示例用 **Node.js + Express**（也可 FastAPI 等）。

> 友情提示：**“图表模板（Chart template）”≠“指标模板（Study template）**。前者是配色主题，另一个是指标组合。本教程做的是 **Study Templates**。([TradingView][2])

---

### 步骤二：前端——开启 UI + 指定存储

在你创建 `widget` 的位置，加入以下关键配置（**只看关键字段**）：

```html
<!-- index.html 片段：挂一个容器 -->
<div id="tvchart" style="width:100%;height:600px"></div>

<script src="/charting_library/charting_library.standalone.js"></script>
<script src="/charting_library/datafeeds/udf/dist/bundle.js"></script>
<script>
  function init() {
    const widget = new TradingView.widget({
      container: "tvchart",
      library_path: "/charting_library/",
      symbol: "AAPL",
      interval: "D",
      datafeed: new Datafeeds.UDFCompatibleDatafeed(
        "https://demo-feed-data.tradingview.com"
      ),
      autosize: true,

      // ↑ 复杂逻辑：启用“指标模板”按钮，并指向后端存储（必须 1.1）
      enabled_features: ["study_templates"], // 显示“指标模板”按钮
      charts_storage_url: "http://localhost:9005", // 你的后端服务根地址
      charts_storage_api_version: "1.1", // Study Templates 自 1.1 起支持
      client_id: "demo-app", // 自定义：用来分组/隔离
      user_id: "user-1", // 你的业务用户 ID
    });
  }
  window.addEventListener("DOMContentLoaded", init);
</script>
```

以上字段的含义与开启方式见 **Featuresets** 与 **Widget Options** 文档；Study Templates 的 REST 端点见 **Saving/Loading** 文档。([TradingView][2])

---

### 步骤三：后端——实现 REST 四件套

用 **Express** 起一个极简可跑的存储服务（内存版，便于本地联调；生产请换 DB）：

```js
// server.js
const express = require("express");
const cors = require("cors");
const app = express();

app.use(cors()); // ← 复杂逻辑：允许前端跨域访问
app.use(express.json({ limit: "1mb" }));

// 简易内存存储：key = `${client}:${user}:${name}`
const store = new Map();

// 列出模板 或 读取单个模板
app.get("/1.1/study_templates", (req, res) => {
  const { client, user, chart, template } = req.query;

  // ← 复杂逻辑：若带 template 参数则返回单个；否则返回列表
  if (template) {
    const key = `${client}:${user}:${template}`;
    const item = store.get(key);
    if (!item) return res.json({ status: "error", message: "not found" });
    // ← 复杂逻辑：返回标准 data 对象（name + content）
    return res.json({
      status: "ok",
      data: { name: template, content: item.content },
    });
  }

  const list = [...store.keys()]
    .filter((k) => k.startsWith(`${client}:${user}:`))
    .map((k) => ({ name: k.split(":").slice(2).join(":") }));

  res.json({ status: "ok", data: list });
});

// 保存模板
app.post("/1.1/study_templates", (req, res) => {
  const { client, user } = req.query;
  const { name, content } = req.body;
  if (!name || !content)
    return res.json({ status: "error", message: "name/content required" });

  const key = `${client}:${user}:${name}`;
  store.set(key, { content });
  res.json({ status: "ok" });
});

// 删除模板
app.delete("/1.1/study_templates", (req, res) => {
  const { client, user, template } = req.query;
  const key = `${client}:${user}:${template}`;
  store.delete(key);
  res.json({ status: "ok" });
});

// 启动服务
app.listen(9005, () => console.log("Storage server on http://localhost:9005"));
```

> REST 端点的路径、查询参数与响应结构，均来自 **Save & load REST API / Indicator template methods** 的官方定义。([TradingView][3])

---

### 步骤四：联调与自测

1. 启动后端：`node server.js`
2. 打开前端页面 → 顶部会出现 **“指标模板”** 按钮。
3. 任意加几个指标 → 点击“指标模板 → 保存为…”；随后可在“打开模板”里看到刚保存的项。
4. 浏览器开发者工具中可看到对 `.../1.1/study_templates?...` 的网络请求。
   （如 URL 出现 `undefined`，通常是未配置 `charts_storage_url`/`charts_storage_api_version`/`client_id`/`user_id`，或版本不是 1.1。）([TradingView][1])

---

### 步骤五：（可选）低层自定义

若你要插入鉴权头、改错误处理或自己接管存取流程，可实现 **`save_load_adapter`** 并在 Widget 里设置 `save_load_adapter: {...}`。官方提供接口说明与示例。([TradingView][4])

---

## 最简代码示例（可直接跑）

> **前端最小化 HTML**（静态托管即可）与 **后端 Express**（内存存储）。复杂位置均已在上一行加注释。

```html
<!-- public/index.html -->
<div id="tvchart" style="width:100%;height:600px"></div>
<script src="/charting_library/charting_library.standalone.js"></script>
<script src="/charting_library/datafeeds/udf/dist/bundle.js"></script>
<script>
  const w = new TradingView.widget({
    container: "tvchart",
    library_path: "/charting_library/",
    symbol: "AAPL",
    interval: "D",
    datafeed: new Datafeeds.UDFCompatibleDatafeed(
      "https://demo-feed-data.tradingview.com"
    ),
    // ← 复杂逻辑：启用“指标模板”并指定 1.1 存储端点与用户
    enabled_features: ["study_templates"],
    charts_storage_url: "http://localhost:9005",
    charts_storage_api_version: "1.1",
    client_id: "demo-app",
    user_id: "user-1",
  });
</script>
```

```bash
# 后端依赖并启动
npm i express cors
node server.js
```

---

## 常见问题与排错

- **URL 出现 `/undefined/.../study_templates?client=undefined&user=undefined`**
  ⇒ 没配或配错 `charts_storage_url / charts_storage_api_version / client_id / user_id`；确认版本为 **"1.1"**。([TradingView][1])
- **看不到“指标模板”按钮**
  ⇒ 未启用 `enabled_features: ['study_templates']`，或使用的不是 Advanced Charts/Charting Library。([TradingView][2])
- **返回结构不对**
  ⇒ 对照“Indicator template methods”的请求/响应格式改正字段。([TradingView][5])
- **与“图表模板”混淆**
  ⇒ Chart template 是配色主题，另有 `chart_template_storage` feature，与 Study template 无关。([TradingView][2])

---

## 官方文档与地址（建议收藏）

```text
# Saving & Loading 概览（含三种实现方式：REST / Adapter / Low-level）
https://www.tradingview.com/charting-library-docs/latest/saving_loading/          # :contentReference[oaicite:12]{index=12}

# REST API 总入口
https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/
# 指标模板（study_templates）四件套
https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/indicator-template-methods/   # :contentReference[oaicite:13]{index=13}

# Widget 关键参数（含 charts_storage_* 与版本说明）
https://www.tradingview.com/charting-library-docs/latest/api/interfaces/Charting_Library.ChartingLibraryWidgetOptions/   # :contentReference[oaicite:14]{index=14}

# 开启/关闭功能（Featuresets 表）
https://www.tradingview.com/charting-library-docs/latest/customization/Featuresets/                                      # :contentReference[oaicite:15]{index=15}

# API Handlers save_load_adapter（自定义存取钩子）
https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-adapter/                               # :contentReference[oaicite:16]{index=16}
```

---

## 小结

- 前端：启用 `study_templates`，并配置 `charts_storage_url + charts_storage_api_version:"1.1" + client_id + user_id`。
- 后端：按官方 REST 规范实现 **列/存/载/删** 四件套即可跑通。
- 若你给我当前前端 `widget` 选项与后端一条实际响应（去敏），我可以继续帮你“逐行对照文档”把最后的坑补齐。

[1]: https://www.tradingview.com/charting-library-docs/latest/api/interfaces/Charting_Library.ChartingLibraryWidgetOptions/?utm_source=chatgpt.com "Interface: ChartingLibraryWidgetOptions | Advanced Charts ..."
[2]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/?utm_source=chatgpt.com "Saving and loading charts | Advanced Charts Documentation"
[3]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/?utm_source=chatgpt.com "Save and load REST API | Advanced Charts Documentation"
[4]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-adapter/?utm_source=chatgpt.com "API handlers for saving and loading | Advanced Charts ..."
[5]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/indicator-template-methods/?utm_source=chatgpt.com "Indicator template methods | Advanced Charts ..."

---

title: TradingView 指标模板请求参数是 undefined？一眼看穿并修好
date: 2025-09-17
tags:

- TradingView
- Charting Library
- study_templates
  description: 你的请求 URL 出现 /charting_library/undefined/undefined/study_templates?client=undefined\&user=undefined，说明未正确配置 charts_storage_url / charts_storage_api_version / client_id / user_id，或把 library_path 误当成存储地址。下面给出最小修改片段与自检清单。

---

## 发生了什么（快速诊断）

你看到的
`http://localhost:9005/charting_library/undefined/undefined/study_templates?client=undefined&user=undefined`
对应的是 **“指标模板 REST API”**，正确格式应为：
`{charts_storage_url}/{charts_storage_api_version}/study_templates?client={client_id}&user={user_id}`。当这些参数没配/配错时，就会出现 `undefined` 串联到 URL 里。([TradingView][1])

> 结论：**charts_storage_url / charts_storage_api_version / client_id / user_id 未设置**，或把 **library_path**（静态资源路径）误当成了 charts_storage_url（数据存储服务地址）。([TradingView][2])

---

## 只改需要改的代码（最小补丁）

在你创建 `widget` 的地方补齐/修正如下选项（不要贴全文件，只替换或新增这些行）：

```js
// ✅ 指标模板需要的存储配置（REST）
enabled_features: ['study_templates'], // 开启模板功能  ← 复杂逻辑：启用相关 UI 与调用
charts_storage_url: 'http://localhost:9005', // 你的后端存储服务根地址（别用 library_path）
charts_storage_api_version: '1.1',           // 版本号固定用 1.1
client_id: 'your-app',                        // 你的应用名，用于分组
user_id: 'user-123',                          // 你系统里能标识用户的唯一ID
```

这些字段的含义与要求见官方文档（`study_templates` 的增删改查都走这个 REST 前缀）。([TradingView][1])

---

## 你的后端要响应哪些接口？

最少要实现以下 REST 路由（以 `charts_storage_url = http://localhost:9005` 为例）：

- `GET  /1.1/study_templates?client={client}&user={user}` → 返回模板列表
- `POST /1.1/study_templates?client={client}&user={user}` → 保存模板（body: `name`, `content`）
- `GET  /1.1/study_templates?client={client}&user={user}&chart={id}&template={name}` → 读取模板
- `DELETE /1.1/study_templates?client={client}&user={user}&template={name}` → 删除模板
  返回结构与字段见官方“Indicator template methods”。([TradingView][1])

> 想省事：官方给了**完整示例后端**（Python + PostgreSQL），可直接跑起来再按需改造。([GitHub][3])

---

## 自检清单（按顺序排查）

1. **确认没把 `library_path` 当存储地址**：`library_path` 只用于加载前端静态资源。([TradingView][2])
2. **前端参数四件套齐全**：`charts_storage_url / charts_storage_api_version / client_id / user_id`。([TradingView][2])
3. **已启用模板功能**：`enabled_features: ['study_templates']`（视集成需要）。示例与第三方教程均有此配置。([DEV Community][4])
4. **后端路由与返回格式正确**：路径、查询串与 JSON 字段符合文档。([TradingView][1])
5. 若不想走 REST，也可实现 **`save_load_adapter`** 接口由你接管保存/加载逻辑（低层 API）。([TradingView][5])

---

## 什么时候会仍然“空空如也”？

- 你的后端返回 `status: "ok"` 但 `data` 为空（首次使用很正常）。([TradingView][1])
- 请求被浏览器扩展或跨域策略拦截（检查 CORS、代理与拦截器）。
- 仍在第三方“嵌入图表”但其侧**未启用 study_templates**。

---

## 需要我继续跟进吗？

把你当前的 `widget` 配置片段（仅含上面这些字段）和后端接口返回的一条实际响应（去隐私）发我，我帮你对照文档核对参数与返回格式，定位剩余问题。

[1]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-rest-api/indicator-template-methods/?utm_source=chatgpt.com "Indicator template methods | Advanced Charts ..."
[2]: https://www.tradingview.com/charting-library-docs/latest/api/interfaces/Charting_Library.ChartingLibraryWidgetOptions/?utm_source=chatgpt.com "Interface: ChartingLibraryWidgetOptions | Advanced Charts ..."
[3]: https://github.com/tradingview/saveload_backend?utm_source=chatgpt.com "tradingview/saveload_backend"
[4]: https://dev.to/amree/how-to-integrate-tradingview-s-html5-charting-library-with-ruby-on-rails-v6-13be?utm_source=chatgpt.com "How to Integrate TradingView's HTML5 Charting Library ..."
[5]: https://www.tradingview.com/charting-library-docs/latest/saving_loading/save-load-adapter/?utm_source=chatgpt.com "API handlers for saving and loading | Advanced Charts ..."
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[现在 iOS 能否稳定拿到“唯一标识”？——主流技术、限制与可落地方案（附你这段 Swift 的微调建议）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/唯一标识/现在 iOS 能否稳定拿到“唯一标识</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/唯一标识/现在 iOS 能否稳定拿到“唯一标识"/>
        <updated>2025-09-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 一句话结论

**不能**。iOS 在系统与审核层面**不提供也不允许**获取“跨应用/跨安装/跨设备”的稳定唯一标识。你能拿到的只有**在特定前提下“较稳定”的替代物**（如 IDFV、Keychain 自生成 UUID、经用户授权的 IDFA）以及**隐私友好型的归因/信誉能力**（如 SKAdNetwork、DeviceCheck、App Attest）。核心原因：**IDFA 需 ATT 授权**，**IDFV 受卸载规则影响**，**指纹识别被明令禁止**。([Apple Developer][1])

## 主流“标识/信号”一览（能否“稳定唯一”？）

| 能力                                  |         是否可跨应用 |               是否可跨安装 | 是否可跨设备 | 说明                                                                                                                |
| ------------------------------------- | -------------------: | -------------------------: | -----------: | ------------------------------------------------------------------------------------------------------------------- |
| **IDFA**                              |         ✅（同意后） | ✅（用户可随时关闭、重置） |           ❌ | iOS 14.5+ 必须先获 **ATT** 授权，拒绝则返回不可用/全零。用于广告归因而非强绑定身份。([Apple Developer][1])          |
| **IDFV**                              |  ✅（同开发者 Team） |                         ❌ |           ❌ | **当设备上同一开发者的所有 App 被删光后再装**，IDFV 会变化（Apple 文档明确）。([Apple Developer][2])                |
| **Keychain 自生成 UUID**              |                   ❌ |                **通常 ✅** |           ❌ | **实践上**多次重装仍在，但**非官方保证**，在抹除设备/恢复/重置钥匙串等情况下会丢失；不要当作强承诺。([苹果支持][3]) |
| **DeviceCheck（二进制 2 位 + 令牌）** |  ✅（同开发者 Team） |                         ✅ |           ❌ | 由 Apple 服务器保存**每设备两位状态**，可跨重装，用于“每设备限领”“反作弊基线”。不是 ID。([Apple Developer][4])      |
| **App Attest（设备内密钥对）**        |         ✅（同应用） |                         ❌ |           ❌ | 用来证明“请求来自你真 App + 真设备环境”，**密钥不随重装保留**，更像**完整性证明**而非 ID。([Apple Developer][5])    |
| **推送 Token**                        | ✅（同开发者可收集） |                         ❌ |           ❌ | 可能随系统/账号/还原而变，不能当唯一 ID。（官方未承诺稳定性）                                                       |
| **SKAdNetwork / AdAttributionKit**    |                    — |                          — |            — | **聚合归因**，无设备级 ID，隐私优先，不需 ATT。([Apple Developer][6])                                               |

> 结论：**没有一个选项能满足“三跨”**（跨应用/跨安装/跨设备）的绝对稳定唯一。

## 为什么做不到“稳定唯一”？

1. **政策与审核**：Apple 明确禁止通过收集多种设备信号进行**指纹识别**，**无论用户是否同意跟踪**都不允许；并用**隐私清单 + 必填理由 API**强力约束。([Apple Developer][7])
2. **API 设计**：

   - **IDFA**受 **ATT** 管控；用户拒绝即不可用。([Apple Developer][1])
   - **IDFV**天生绑定“**设备 × 开发者**”，按文档规定满足条件就会变。([Apple Developer][2])
   - **Keychain**适合保存敏感“**小数据**”，但**未文档化保证**“卸载后仍在”的行为，不能当契约写进需求。([苹果支持][3])

## 2025 年主流、合规的“设备识别/反作弊/归因”组合拳

> 目标：**够用且合规**，实现“同设备再来能识别、用户不授权也能基本控滥用、广告可归因”。

1. **基础安装标识（侧重可用性）**

   - 采用 **IDFV（优先） + Keychain 自生成 UUID（兜底）**，**仅存哈希**（加盐）用于**去标识化**统计与“安装级”识别。**不要**把它当“永不变”的强 ID。([Apple Developer][2])

2. **广告与增长**

   - 若用户授权 ATT → 用 **IDFA**；未授权 → **SKAdNetwork/AdAttributionKit** 做**聚合归因**，避免用户级跟踪。([Apple Developer][1])

3. **反作弊与完整性**

   - **DeviceCheck**：跨重装维持“每设备 2bit 状态”（如是否已领过新人礼包）。
   - **App Attest**：校验 App 与设备环境的**完整性**（反注入/模拟/批量刷）。注意**重装即“从头开始”**。([Apple Developer][8])

4. **账号体系优先**

   - 从**设备标识转向账号标识**（含 **Passkeys** 登录），跨设备、跨平台的稳定性来自**账号**而非设备。

5. **合规红线**

   - **指纹识别禁止**；使用“可能被滥用”的 API 需在**隐私清单**中声明**合法理由**。([Apple Developer][7])

---

## 适配你现有 Swift 代码的**微调建议**（只给改动片段，复杂逻辑上方含注释）

> 你的整体思路对路：**IDFV/Keychain** + 可选 **IDFA**，并做**加盐哈希**与**策略**。下面是若干稳健性/合规性细节小修。

```swift
// 复杂逻辑：避免在主线程阻塞等待 ATT；且用授权状态判断，不再依赖 isAdvertisingTrackingEnabled
@objc public static func getIDFAOrNull(_ requestATT: Bool) -> String? {
    if #available(iOS 14.5, *), requestATT,
       ATTrackingManager.trackingAuthorizationStatus == .notDetermined {
        // 在后台队列同步等待，但调用方请勿在主线程直接调用此方法
        let sem = DispatchSemaphore(value: 0)
        DispatchQueue.global().async {
            ATTrackingManager.requestTrackingAuthorization { _ in sem.signal() }
        }
        _ = sem.wait(timeout: .now() + 2.5) // 稍放宽等待时间
    }
    if #available(iOS 14.5, *) {
        guard ATTrackingManager.trackingAuthorizationStatus == .authorized else { return nil }
    }
    let id = ASIdentifierManager.shared().advertisingIdentifier.uuidString
    let stripped = id.replacingOccurrences(of: "-", with: "").replacingOccurrences(of: "0", with: "")
    return stripped.isEmpty ? nil : id
}
```

```swift
// 复杂逻辑：方法名更准确；保留旧别名避免上层改动
@objc public static func prefetchIdfaAfterConsent() {
    _ = getIDFAOrNull(true)
}
// 兼容旧安卓同名别名（避免破坏现有调用）
@objc public static func prefetchOaidAfterConsent() {
    prefetchIdfaAfterConsent()
}
```

```swift
// 复杂逻辑：cacheKey 加上 policy，确保不同策略下缓存不串
private static func cacheKey(optionsJson: String, exposeRaw: Bool) -> String {
    let pol = (try? parseOptions(optionsJson))?.policy ?? "global"
    return "o:\(optionsJson)#p:\(pol)#c:\(consent ? 1 : 0)#s:\(strict ? 1 : 0)#x:\(exposeRaw ? 1 : 0)#salt:\(salt)"
}
```

```swift
// 复杂逻辑：对 IDFA 的 IdValue 也允许受控暴露原值（默认 false），与其它源对齐
if includeEff.contains("idfa") {
    let idfa = effectiveStrict ? nil : getIDFAOrNull(opts.requestATT)
    let limited = (idfa == nil)
    let msg = limited ? "no-permission-or-limited" : nil
    // 将 exposeRaw 传入，而不是强制 false
    result["idfa"] = buildValue(source: "idfa", value: idfa, exposeRaw: opts.exposeRaw, limited: limited, msg: msg)
}
```

> 额外提示
>
> - **不要在主线程**里调用会等待 ATT 的方法，避免卡 UI。
> - `isAdvertisingTrackingEnabled` 在 ATT 时代**并非决定性信号**，以 `ATTrackingManager` 状态为准。([Apple Developer][1])

---

## 推荐的最小可行方案（MVP 落地顺序）

1. **服务端建模**：`install_id`（Keychain UUID 的加盐哈希） + `id_source`（idfv/guid/idfa…）+ `first_seen_ts`。
2. **客户端策略**：`policy: "cn"` 下默认 `["idfv","guid"]`；`"global"` 才考虑 `idfa`。你代码已支持。
3. **增长归因**：集成 **SKAdNetwork/AdAttributionKit**；用户授权后再启用 IDFA 路径。([Apple Developer][6])
4. **反作弊**：上线 **DeviceCheck** 的 2bit 状态（如 `hasClaimed` / `isFlagged`），关键流程用 **App Attest** 做请求完整性校验。([Apple Developer][8])
5. **合规**：在隐私清单中申报“必填理由 API”，并**不要**实现任何“设备指纹”。([Apple Developer][7])

---

## 关键参考

- **IDFA 需 ATT 授权**与获取限制。([Apple Developer][1])
- **IDFV 的变更规则**（删除同 Vendor 的所有 App 后会变）。([Apple Developer][2])
- **Keychain 是敏感小数据的安全存储**，但卸载持久性**非官方契约**（工程圈普遍观察到“多次重装仍在”）。([苹果支持][3])
- **DeviceCheck / App Attest** 的用途与持久性特征。([Apple Developer][8])
- **SKAdNetwork/AdAttributionKit** 做隐私友好型归因。([Apple Developer][6])
- **禁止设备指纹**与隐私清单“必填理由 API”。([Apple Developer][7])

---

### 小结

- **没有**“一把通吃、永不变”的 iOS 设备唯一标识。
- **工程上**用 **IDFV + Keychain UUID（哈希）** 做“安装级”识别，**授权后**再用 IDFA；**归因**走 SKAdNetwork；**反作弊**以 DeviceCheck/App Attest 为主；**长期稳定**靠**账号体系**。
- **合规优先**：别做指纹识别；把隐私清单与 ATT 路径打通，体验与审核两不误。

[1]: https://developer.apple.com/documentation/adsupport/asidentifiermanager/advertisingidentifier?utm_source=chatgpt.com "advertisingIdentifier | Apple Developer Documentation"
[2]: https://developer.apple.com/documentation/uikit/uidevice/identifierforvendor?utm_source=chatgpt.com "identifierForVendor | Apple Developer Documentation"
[3]: https://support.apple.com/guide/security/keychain-data-protection-secb0694df1a/web?utm_source=chatgpt.com "Keychain data protection"
[4]: https://developer.apple.com/documentation/devicecheck?utm_source=chatgpt.com "DeviceCheck | Apple Developer Documentation"
[5]: https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity?utm_source=chatgpt.com "Establishing your app's integrity"
[6]: https://developer.apple.com/documentation/storekit/skadnetwork/?utm_source=chatgpt.com "SKAdNetwork | Apple Developer Documentation"
[7]: https://developer.apple.com/documentation/bundleresources/describing-use-of-required-reason-api?utm_source=chatgpt.com "Describing use of required reason API"
[8]: https://developer.apple.com/documentation/devicecheck/accessing-and-modifying-per-device-data?utm_source=chatgpt.com "Accessing and modifying per-device data"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[别再逼用户记密码：Passkey-first 的完整方案（注册、迁移、恢复、风控）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkey-first 的完整方案（注册、迁移、恢复、风控）</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkey-first 的完整方案（注册、迁移、恢复、风控）"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 结论（TL;DR）

完全可以做到**无需记密码**：

- **新用户**直接走 **Passkey-first** 注册（JIT 建号 + 可发现凭据），之后**一直用通行密钥登录**；
- **老用户**用一次**无密码迁移**（邮件魔法链接/短信一次码/现场已登录会话）来**绑定通行密钥**，以后也不需要密码。
- 密码只作为**备用恢复方式**（可选），而不是每天都要输入的“主入口”。

## 两类用户路径（推荐落地）

### A. 新用户：Passkey-first（彻底无密码）

1. 登录页主按钮：**「继续使用通行密钥」**（启用 Conditional UI/Autofill）。
2. 后端 `generateRegistrationOptions`：`residentKey:'required'`，`requireUserVerification:true`，JIT 创建 **pending** 账户。
3. `verifyRegistrationResponse` 成功后：签发登录态 → 引导补资料/绑定手机号或邮箱。
4. 以后登录：**generateAuthenticationOptions（不传 allowCredentials）** 即可**无用户名直登**。

> 这样用户**从未设置过密码**，也无需记忆。

### B. 老用户：无密码迁移 → 绑定 Passkey

给用户三个等价入口，任选其一完成**一次性绑定**：

- **魔法链接**：输入邮箱 → 收链接 → 点击即登录 → 立刻提示「一键绑定通行密钥」。
- **一次性验证码**：输入邮箱/手机号 → 填 6 位码 → 立刻提示绑定。
- **已登录会话**：若用户已在某设备登录，直接在**安全设置**页提示「添加通行密钥」。

绑定完成后，该账号**后续登录都走 passkey**，无需再输入密码。

## 账号恢复与“丢钥匙”预案（关键，否则体验会反噬）

- **要求首绑就注册两把钥匙**（例如手机 + 电脑）。
- **允许多把通行密钥**（硬件 Key、手机、电脑各一），并提供命名/吊销。
- **备用通道**（只用于恢复，不作为日常登录）：

  - 魔法链接 / 一次性验证码；
  - **恢复码**（一次性使用，生成后提示妥善保管）；
  - **管理员人工恢复**（适用于员工场景，配风控核验）。

- **敏感操作“升级验证”**：资金/权限变更时强制使用 **passkey + 已登录会话** 或二次生物验证。

## 你的后端（NestJS + simplewebauthn）最小改造清单

> 遵循你的偏好：只列**关键改动点**，不贴整段代码。

- **注册/登录都要求 UV（强用户验证）**
  在 `verifyRegistrationResponse` 与 `verifyAuthenticationResponse` 里将
  `requireUserVerification: true`（你当前是 `false`）。
  _// 复杂逻辑：确保是“人手持有设备”在操作，符合 passkey 设计初衷_

- **保留你现有的 JIT 建号**（你已经实现 ✅）
  首次注册直接创建 pending 员工 → 验证成功即激活/赋最小权限。

- **新增「无密码迁移」两条辅助路由**

  - `POST /auth/magic-link/start`：写入一次性 token（Redis TTL），发邮件链接。
  - `GET /auth/magic-link/callback`：消费 token → 创建会话 → 立刻发 `generateRegistrationOptions` 让用户绑定通行密钥。
    _// 复杂逻辑：仅首次绑定使用；成功后引导多设备再绑定一把_

- **允许一个账号绑定多把凭据**
  你的 `passkey_credentials` 表已支持多行（同 `subjectId` 多 `credentialId`）。补充：昵称、创建时间、最后使用时间、来源设备。

- **风控/限流**
  已有 Redis 限流基础上，给魔法链接/验证码也做：**同邮箱 5 次/小时**、**同 IP 20 次/小时**。

- **设备唯一**（若你业务需要）
  不把“设备唯一”当身份学前置条件；而是绑定成功后在**业务授权层**做限制（例如一机一号白名单），避免与 passkey 的“跨设备同步”理念冲突。

## 前端 UX 要点（极大影响转化）

- 登录页优先级：**「继续使用通行密钥」**（主按钮）
  下面一行较轻样式提供「其他方式」→ 魔法链接 / 一次性码。
- 启用 **Conditional UI/Autofill**（浏览器/系统会自动弹 Passkey 选择器）。
- 首次绑定成功后，显式提示\*\*「再添加一把通行密钥以防手机丢失」\*\*。
- 设置页提供\*\*「查看/重命名/移除」\*\*通行密钥列表。

## 方案权衡与常见问答

- **必须先注册吗？** 是。至少要有**一次**把该账户的**公钥**写入你库里，后续才能凭签名登录。
- **可以不设密码吗？** 完全可以。密码变成**备用恢复手段**（可选），而非日常入口。
- **没有 Passkey 的设备怎么登录？** 魔法链接/一次性码仅作为**救场**；登录后立刻提示**绑定**。
- **安全性会不会下降？** 不会——前提是**日常登录只走 passkey**，而恢复通道加**限流/风控**，并鼓励**多设备多把钥匙**。

## 一页落地清单（供你排期）

1. 登录页改版：主入口 **Passkey**，次入口 **魔法链接/一次码**。
2. 后端把 `requireUserVerification` 改为 **true**（注册 & 登录）。
3. 新增魔法链接两条路由 + Redis TTL/限流。
4. 设置页支持**多把凭据**的增删改查（带最后使用时间）。
5. 首绑后强提示**添加第二把**。
6. 文案与支持：加入\*\*“如何恢复账号”\*\*帮助页。

### 小结

你完全可以提供\*\*“从第一天起就不需要记密码、也不必再输密码”\*\*的体验：

- 新用户走 **Passkey-first**；
- 老用户用**一次性无密码手段**完成绑定；
- 以后所有登录**都用通行密钥**；
- 通过**多把钥匙 + 恢复通道 + 风控**，把“忘记密码”的痛点与“丢设备”的风险同时解决。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Passkeys/WebAuthn 配置项全集：可选值与作用（注册 + 登录，含 simplewebauthn v11+）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys-WebAuthn 配置项全集：可选值与作用（注册 + 登录，含 simplewebauthn v11+）</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys-WebAuthn 配置项全集：可选值与作用（注册 + 登录，含 simplewebauthn v11+）"/>
        <updated>2025-09-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
> 目标：把 **Passkeys/WebAuthn** 中"你会实际用到的配置项"一次讲清楚：
>
> - 覆盖 **注册（create）** 与 **登录（get）** 两个阶段
> - 对应 **服务端（simplewebauthn / @simplewebauthn/server v11+）** 产出的"options"以及**前端** `navigator.credentials.create()/get()` 的参数
> - 每个字段给出 **可选值** + **含义** + **常用建议**
> - 标注**兼容性/陷阱**与**推荐默认值**

---

## 总览思维导图（速查）

- 注册 Registration（`navigator.credentials.create()` / `generateRegistrationOptions()`）

  - 基础：`rp`, `user`, `challenge`, `pubKeyCredParams`(= simplewebauthn 的 `supportedAlgorithmIDs`), `timeout`, `attestation`
  - 选择器：`authenticatorSelection` → `residentKey`, `userVerification`, `authenticatorAttachment`, `requireResidentKey(旧)`
  - 其他：`excludeCredentials`, `hints(浏览器端)`, `extensions`（常用：`credProps`, `largeBlob`, `prf`, `appidExclude(兼容U2F)`）

- 登录 Authentication（`navigator.credentials.get()` / `generateAuthenticationOptions()`）

  - 基础：`challenge`, `timeout`, `rpId`, `userVerification`
  - 定位：`allowCredentials`
  - 其他：`hints(浏览器端)`, `mediation(浏览器端Conditional UI)`, `extensions`（常用：`uvm`, `largeBlob`, `appid(兼容U2F)`）

---

## 一、注册 Registration 配置项

### 1. 基础字段

| 字段                                 | 可选值/类型                                        | 作用                                                                 | 建议                                                                     |
| ------------------------------------ | -------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| `rp.id`                              | 域名字符串（如 `example.com`）                     | **Relying Party ID**。**必须与站点有效父域匹配**，决定凭据的绑定域。 | 用你的主域名；本地开发用同源域。                                         |
| `rp.name`                            | 文本                                               | 在系统提示里展示给用户看的"站点名"。                                 | 友好易识别，如"公司后台"。                                               |
| `user.id`                            | `ArrayBuffer`/`Uint8Array`（**v11+ 推荐二进制**）  | 用户唯一 ID（不会显示给用户）。                                      | 用数据库主键编码为 `Uint8Array`。                                        |
| `user.name`                          | 文本                                               | 用户名（可能显示给用户）。                                           | 用登录名/邮箱；唯一。                                                    |
| `user.displayName`                   | 文本                                               | 美观显示名（一定会显示）。                                           | 用昵称/真实姓名。                                                        |
| `challenge`                          | 随机字节                                           | 防重放挑战，**必须一次性使用**。                                     | 服务端生成并缓存（Redis）；**Base64url** 存储。                          |
| `timeout`                            | 毫秒                                               | 超时。                                                               | 60000–120000ms，按体验权衡。                                             |
| `attestation`（= `attestationType`） | `'none' \| 'indirect' \| 'direct' \| 'enterprise'` | 是否要设备证明（隐私/合规取舍）。                                    | **默认 `none`**；合规强要求才用 `direct/enterprise`。                    |
| `pubKeyCredParams`                   | COSE 列表（如 `[{alg:-7,type:'public-key'}]`）     | 指定可接受算法。                                                     | **最少含 `-7`(ES256)**；为兼容可加 `-257`(RS256)；前瞻可加 `-8`(EdDSA)。 |

> 在 **simplewebauthn v11+** 中，你常会看到把算法用更直观的 `supportedAlgorithmIDs: number[]` 来传（例如 `[-7, -257]`）。两者等价，服务端会转换为 `pubKeyCredParams`。

### 2. 认证器选择器 `authenticatorSelection`

| 子字段                    | 可选值                                       | 作用                                                          | 影响/陷阱                                                             | 推荐                                                 |
| ------------------------- | -------------------------------------------- | ------------------------------------------------------------- | --------------------------------------------------------------------- | ---------------------------------------------------- |
| `residentKey`             | `'required' \| 'preferred' \| 'discouraged'` | 是否创建**可发现凭据**（也就是"**passkey**"：可免用户名）。   | `required` 会占用设备存储但带来一键直登；`discouraged` 不是 passkey。 | **`required`** 做 passkey 体验；保守用 `preferred`。 |
| `userVerification`        | `'required' \| 'preferred' \| 'discouraged'` | 是否要求生物识别/PIN。                                        | `required` 更安全但可能多一步；`discouraged` 少见。                   | B2C：**`preferred`**；高敏后台：**`required`**。     |
| `authenticatorAttachment` | `'platform' \| 'cross-platform'`             | 限定**平台认证器**（如手机/电脑内置）或**跨平台**（安全钥）。 | 限太死会掉成功率。                                                    | 一般**不指定**；或按场景选择。                       |
| `requireResidentKey`      | `boolean`（**已过时**）                      | 旧字段，等价于 `residentKey` 早期语义。                       | 新实现请用 `residentKey`。                                            | 不再使用。                                           |

### 3. 排他清单 `excludeCredentials`

| 字段                 | 类型                                                              | 作用                                          | 建议                                               |
| -------------------- | ----------------------------------------------------------------- | --------------------------------------------- | -------------------------------------------------- |
| `excludeCredentials` | `{ type:'public-key', id: ArrayBuffer, transports?: string[] }[]` | 列出**不允许重复注册**的已有凭据（按 `id`）。 | 取用户已有的 credentialId 全部填上，避免重复创建。 |

### 4. 浏览器"提示" `hints`（可选，前端）

| 值                                                 | 作用                                            | 备注                           |
| -------------------------------------------------- | ----------------------------------------------- | ------------------------------ |
| `'security-key'`, `'client-device'`, `'hybrid'` 等 | 给浏览器一个**提示**，帮助选择认证器/传输方式。 | 不是所有浏览器都实现；可不填。 |

### 5. 扩展 `extensions`（注册）

> 扩展是"可选增强"。不同平台支持度不同，**启用前要允许降级**。

| 扩展名                | 方向    | 可选值                                       | 作用                                                | 返回/副作用                                           | 建议                                   |
| --------------------- | ------- | -------------------------------------------- | --------------------------------------------------- | ----------------------------------------------------- | -------------------------------------- |
| `credProps`           | reg     | `true/false`                                 | 要求返回**凭据属性**（是否为 resident key）。       | `clientExtensionResults.credProps = { rk?: boolean }` | **建议 `true`**，落库凭据类型。        |
| `largeBlob`           | reg/get | `{ support: 'required' \| 'preferred' }`     | 支持**大对象存储**（绑定在凭据上）。                | 需要平台/设备支持；可用于小量用户数据。               | 如无强需求，默认不启或设 `preferred`。 |
| `prf`（WebAuthn PRF） | reg/get | `{ eval?: {...}, evalByCredential?: {...} }` | 让认证器基于密钥派生伪随机值，做**对称派生**用途。  | 前沿能力，支持度逐步增长。                            | 高阶场景再用。                         |
| `appidExclude`        | reg     | 旧 U2F 兼容                                  | 防止已在 U2F AppID 下注册的密钥在当前 rpId 再注册。 | 遗留兼容。                                            | 仅做历史迁移时用。                     |

---

## 二、登录 Authentication 配置项

### 1. 基础字段

| 字段               | 可选值/类型                                  | 作用                   | 建议                                             |
| ------------------ | -------------------------------------------- | ---------------------- | ------------------------------------------------ |
| `challenge`        | 随机字节                                     | 防重放挑战。           | 服务器生成并缓存（Redis）。                      |
| `timeout`          | 毫秒                                         | 超时。                 | 60000–120000ms。                                 |
| `rpId`             | 域名                                         | 与注册时相同的 RP ID。 | 填你站点主域。                                   |
| `userVerification` | `'required' \| 'preferred' \| 'discouraged'` | 是否要求生物识别/PIN。 | B2C：**`preferred`**；高敏后台：**`required`**。 |

### 2. 定位凭据 `allowCredentials`

| 字段               | 类型                                                             | 作用                                                                 | 典型用法                                          |
| ------------------ | ---------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------- |
| `allowCredentials` | `{ type:'public-key', id:ArrayBuffer, transports?: string[] }[]` | **白名单**方式，限定可用哪些凭据（常在"用户名已知"的传统登录流）。   | 用户名 → 查出该用户所有 credentialId → 全部填入。 |
| （为空或不传）     | ——                                                               | 允许**可发现凭据**自由匹配（配合 Conditional UI 可"无用户名直登"）。 | **Passkey 体验**常用做法。                        |

### 3. 浏览器端 UI 行为

| 字段                                                                          | 值                                        | 作用                                                                                  | 备注                            |
| ----------------------------------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------- |
| `mediation`（在 `navigator.credentials.get()` 的 `publicKey` 旁边、同级传入） | `'conditional' \| 'required' \| 'silent'` | **Conditional UI** 关键：`'conditional'` 允许地址栏内直接弹出选择框，实现"一键直登"。 | 需 HTTPS + 满足浏览器启用条件。 |
| `hints`                                                                       | 同注册                                    | 选择器提示                                                                            | 可省略。                        |

### 4. 扩展 `extensions`（登录）

| 扩展名      | 方向    | 作用                                                               | 返回                                  | 建议              |
| ----------- | ------- | ------------------------------------------------------------------ | ------------------------------------- | ----------------- |
| `uvm`       | get     | 请求返回 **User Verification Methods**（使用了何种生物识别/PIN）。 | `clientExtensionResults.uvm` 列出方法 | 可用于风控/审计。 |
| `largeBlob` | reg/get | 同上                                                               | 同上                                  | 同上              |
| `appid`     | get     | 兼容 U2F 的 AppID 登录                                             | 同上                                  | 仅历史迁移用。    |
| `prf`       | get     | 同上                                                               | 同上                                  | 高阶用途再用。    |

---

## 三、simplewebauthn（v11+）与服务端路由要点

> 你项目里已有：`/passkeys/register|login/(options|verify)`；挑战 **Base64url** 存 Redis；`passkey_credentials` 表存 `credential_id/public_key/counter`。

### 1. 生成注册选项（server）

常见字段（simplewebauthn 名称可能与原生略有不同）：

- `rpID`, `rpName`
- `userID: Uint8Array`, `userName`, `userDisplayName`
- `supportedAlgorithmIDs: number[]` → 映射到 `pubKeyCredParams`
- `attestationType: 'none' | 'indirect' | 'direct' | 'enterprise'`
- `authenticatorSelection: { residentKey, userVerification, authenticatorAttachment? }`
- `excludeCredentialIDs: Uint8Array[]`（封装后会变成 `excludeCredentials`）
- `timeout`, `extensions`（如 `credProps: true`）

**默认推荐（B2C/通用）：**

```ts
attestationType: 'none',
supportedAlgorithmIDs: [-7, -257], // ES256 优先兼容 RS256
authenticatorSelection: {
  residentKey: 'required',        // 明确走 passkey
  userVerification: 'preferred',  // 有则强校验，兼顾成功率
  // authenticatorAttachment 不限定
},
extensions: { credProps: true },
timeout: 120_000
```

### 2. 生成登录选项（server）

- `rpID`, `timeout`, `userVerification`
- `allowCredentialIDs?: Uint8Array[]`（有"已知用户流"用它；**passkey 直登**常为空）
- 你也可以在响应中带标识，提示前端是否采用 **Conditional UI**。

**默认推荐：**

```ts
userVerification: 'preferred',
timeout: 120_000,
// allowCredentialIDs 为空，鼓励可发现凭据 + Conditional UI
```

---

## 四、常见组合场景与参数模板

### A. 标准 Passkey（支持 Conditional UI）

**注册（create）**

- `attestation: 'none'`
- `supportedAlgorithmIDs: [-7, -257]`
- `authenticatorSelection.residentKey: 'required'`
- `authenticatorSelection.userVerification: 'preferred'`
- `extensions.credProps: true`

**登录（get）**

- `userVerification: 'preferred'`
- `allowCredentials` **不传/空**
- 浏览器端 `mediation: 'conditional'`（配合地址栏直登）

### B. 高安全后台/企业管理台

**注册**

- `attestation: 'none' | 'direct'`（合规要求再上 `direct`）
- `supportedAlgorithmIDs: [-7, -257]`
- `residentKey: 'required'`
- `userVerification: 'required'`
- `extensions.credProps: true`

**登录**

- `userVerification: 'required'`
- 已知用户流：填 `allowCredentials` 精确定位
- 不强追求 Conditional UI

### C. 兼容旧设备/历史 U2F

- 算法包含 `-257`
- 迁移阶段可能用到 `appid`/`appidExclude` 扩展（仅过渡）

---

## 五、易踩坑与实战建议

1. **RP ID 与域名**：`rp.id` 必须是**当前站点的有效父域**（或相同域）。子域 ↔ 主域要规划好。
2. **二进制 userID/credentialID**：simplewebauthn v11+ 推荐 **`Uint8Array`**；**持久化前做 base64url 编解码**。
3. **挑战 challenge**：务必 **一次性**、**短期缓存**（Redis）并按 **base64url** 存。
4. **计数器 counter**：验证成功后更新数据库的 `signCount`/`counter`，用于克隆检测。
5. **算法集合**：至少包含 **ES256(-7)**；为兼容再加 **RS256(-257)**。
6. **residentKey 与存储**：`required` 会在设备上保存可发现凭据，空间有限；建议允许用户管理/删除。
7. **Conditional UI 条件**：HTTPS、正确 RP、支持的浏览器版本等；前端要传 `mediation:'conditional'`。
8. **extensions 兼容**：`credProps` 安全开启；`largeBlob/prf/uvm` 按需，用前先检测支持与回退路径。
9. **跨端同步**：平台 passkey（iCloud/Google Password Manager）可跨设备同步，但**RP ID 必须一致**。
10. **合规与隐私**：`attestation!='none'` 需维护证书信任与合规评估，一般 B2C 不建议开启。

---

## 六、最小可用清单（可直接抄）

**注册 options（服务端生成）**

```ts
{
  rpID: 'example.com',
  rpName: '示例站点',
  userID: Uint8Array.from(...),     // 二进制
  userName: 'alice',
  userDisplayName: 'Alice',
  supportedAlgorithmIDs: [-7, -257],
  attestationType: 'none',
  authenticatorSelection: {
    residentKey: 'required',
    userVerification: 'preferred'
  },
  extensions: { credProps: true },
  timeout: 120_000
}
```

**登录 options（服务端生成）**

```ts
{
  rpID: 'example.com',
  userVerification: 'preferred',
  // allowCredentialIDs: [] // 留空以支持 passkey 直登
  timeout: 120_000
}
```

**浏览器端（登录）启用 Conditional UI（示例）**

```ts
const cred = await navigator.credentials.get({
  publicKey: authenticationOptions,
  // 关键：在同级位置（不是 publicKey 里）
  mediation: "conditional",
});
```

---

## 结语

以上就是 **Passkeys/WebAuthn 配置项的"全景图 + 默认建议"**。如果你把这些默认值落到当前项目，我可以按你仓库结构给出**最小改动的代码片段**（复杂逻辑行上加注释），直接对接你现有的 `/passkeys/*` 路由与 Redis/DB。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebAuthn Passkeys：options 全字段长啥样？取值有哪些？（simplewebauthn v11+ 实战）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys：options</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Passkeys：options"/>
        <updated>2025-09-08T00:33:31.000Z</updated>
        <content type="html"><![CDATA[
> 适用版本：**@simplewebauthn/server v11+**
> 重点变化：`pubKeyCredParams` ➜ `supportedAlgorithmIDs`；注册验证结果中的 `credentialID/credentialPublicKey` ➜ 移到 `registrationInfo.credential`。

# 一、两类 options 是什么？

- **注册（Creation）**：发给前端 `navigator.credentials.create({ publicKey })` 的参数

  - 服务器生成：`generateRegistrationOptions(opts)`
  - 前端收到的是 **PublicKeyCredentialCreationOptions(JSON)**

- **登录（Request/Assertion）**：发给前端 `navigator.credentials.get({ publicKey })` 的参数

  - 服务器生成：`generateAuthenticationOptions(opts)`
  - 前端收到的是 **PublicKeyCredentialRequestOptions(JSON)**

> 前端 JSON 里的 `challenge` / `user.id` 等，通常是 **base64url** 字符串；服务端入参多数用 **Buffer/Uint8Array**。

# 二、注册：服务端入参 & 前端 options 全量长相

## 2.1 服务端入参（`generateRegistrationOptions(opts)`）

```ts
const options = await generateRegistrationOptions({
  // —— RP（你的站点） ——
  rpName: "Shop Thrive", // 展示名（弹窗可见）
  rpID: "example.com", // RP ID（域名，需与前端同源后缀匹配）

  // —— 用户信息（必须） ——
  // 注意：userID 必须是字节数组（Uint8Array/Buffer），不是 string
  userID: Buffer.from("user-123", "utf8"),
  userName: "user-123", // 可读名（设备 UI 展示）
  userDisplayName: "Alice Zhang", // 可选；不传时库会处理

  // —— 安全策略 ——
  // v11+：用 supportedAlgorithmIDs 指定算法（替代 pubKeyCredParams）
  // 常用：-7=ES256；如需兼容更广，可加 -257=RS256/-8=EdDSA 等
  supportedAlgorithmIDs: [-7, -257],

  // 要求/偏好做本地用户验证（UV：指纹/人脸/PIN）
  // 'required' | 'preferred' | 'discouraged'
  userVerification: "required",

  // 选择哪类认证器与凭证形态
  authenticatorSelection: {
    // 'platform'（本机/系统）| 'cross-platform'（外接/钥匙）| 不填（都可）
    authenticatorAttachment: "platform",
    // 要不要可发现凭证（resident key），用于“无用户名一键登录”
    // 'required' | 'preferred' | 'discouraged'
    residentKey: "required",
    // 旧字段（某些库还在）：requireResidentKey: true,
  },

  // 证明链/隐私：'none' | 'indirect' | 'direct' | 'enterprise'
  attestationType: "none",

  // —— 体验/兼容 ——
  timeout: 60_000, // 毫秒
  excludeCredentials: [
    // 防重复注册（可选）
    {
      id: Buffer.from("...", "base64url"),
      type: "public-key",
      transports: ["internal", "usb"],
    },
  ],

  // —— 扩展（按需） ——
  extensions: {
    credProps: true, // 要求返回“是否可发现凭证”等属性
    // largeBlob: { support: 'required' | 'preferred' },
    // hmacCreateSecret: true,
    // // 老 FIDO 兼容场景：
    // appidExclude: 'https://example.com'
  },
});
```

### COSE 算法常用映射

| ID              | 名称                  | 说明                                        |
| --------------- | --------------------- | ------------------------------------------- |
| **-7**          | ES256                 | ECDSA w/ SHA-256（最常用，passkey 默认）    |
| **-257**        | RS256                 | RSA w/ SHA-256（更广兼容）                  |
| **-8**          | EdDSA                 | 常见为 Ed25519（浏览器/平台支持度差异较大） |
| -35 / -36       | ES384 / ES512         | 更高位椭圆曲线                              |
| -38 / -39 / -40 | PS256 / PS384 / PS512 | RSA-PSS 系列                                |

> 生产一般 `[-7]` 足够；如有老设备需求，可加 `-257`。

---

## 2.2 前端收到的 **注册 options（完整 JSON 示例）**

```json
{
  "rp": { "name": "Shop Thrive", "id": "example.com" },
  "user": {
    "id": "dXNlci0xMjM", // base64url（服务端 userID 的 JSON 形式）
    "name": "user-123",
    "displayName": "Alice Zhang"
  },
  "challenge": "9P0mB1o0f1...Q",
  "pubKeyCredParams": [
    // 注意：这是浏览器原生结构；simplewebauthn 已根据 supportedAlgorithmIDs 生成
    { "type": "public-key", "alg": -7 },
    { "type": "public-key", "alg": -257 }
  ],
  "timeout": 60000,
  "attestation": "none",
  "authenticatorSelection": {
    "authenticatorAttachment": "platform",
    "residentKey": "required",
    "userVerification": "required"
  },
  "excludeCredentials": [
    { "type": "public-key", "id": "...", "transports": ["internal", "usb"] }
  ],
  "extensions": {
    "credProps": true
  }
}
```

> 实际上浏览器可能省略部分可选字段；**你看到的字段少，不代表“没生效”**，很多值有默认行为。

# 三、登录：服务端入参 & 前端 options 全量长相

## 3.1 服务端入参（`generateAuthenticationOptions(opts)`）

```ts
const options = await generateAuthenticationOptions({
  // —— 基本项 ——
  rpID: "example.com",
  timeout: 60_000,

  // —— UV 要求 ——
  // 'required' | 'preferred' | 'discouraged'
  userVerification: "preferred",

  // —— 可选：指定可用凭证（有用户名场景）
  // 省略则启用“可发现凭证”（一键直登：浏览器列出该站点可用 passkey）
  allowCredentials: [
    {
      id: Buffer.from("credential-id-base64url", "base64url"),
      type: "public-key",
      transports: ["internal", "usb", "nfc", "ble", "hybrid"], // 按需
    },
  ],

  // —— 扩展（按需） ——
  extensions: {
    // uvm: true,                    // 请求返回用户验证方式矩阵（支持时）
    // appid: 'https://example.com' // 老 FIDO 兼容
  },
});
```

### `transports` 可能值

- `usb` / `nfc` / `ble`：外接钥匙传输方式
- `internal`：平台认证器（如 iOS/Android/Windows 内置）
- `cable` / `hybrid`：跨设备传输（手机帮电脑解锁的流程）

---

## 3.2 前端收到的 **登录 options（完整 JSON 示例）**

```json
{
  "rpId": "example.com",
  "challenge": "jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg",
  "timeout": 60000,
  "userVerification": "preferred",
  "allowCredentials": [
    { "type": "public-key", "id": "...", "transports": ["internal", "hybrid"] }
  ],
  "extensions": {
    "uvm": true
  }
}
```

> **条件式 UI（passkeys 一键直登）**：这是 `navigator.credentials.get()` 的**第二个参数**里的 `mediation: 'conditional'`，**不在** `publicKey` 这个 JSON 里。
> 形如：
>
> ```ts
> navigator.credentials.get({ publicKey: options, mediation: "conditional" });
> ```

---

# 四、关键字段取值解释（速查表）

## 4.1 `userVerification`

| 值            | 含义                                                              | 推荐                   |
| ------------- | ----------------------------------------------------------------- | ---------------------- |
| `required`    | 必须进行本地用户验证（指纹/人脸/PIN）；不支持 UV 的认证器会被排除 | **后台/金融** 强烈推荐 |
| `preferred`   | 优先进行 UV；不支持也可继续                                       | **通用登录** 默认      |
| `discouraged` | 不鼓励 UV                                                         | 不推荐用于登录         |

> **服务端也要对应开启**：`verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })` 才算真正强制。

## 4.2 `authenticatorSelection`

| 字段                      | 值                                       | 说明                                     |
| ------------------------- | ---------------------------------------- | ---------------------------------------- |
| `authenticatorAttachment` | `platform` / `cross-platform`            | 本机认证器 vs 外接钥匙；不填=都可        |
| `residentKey`             | `required` / `preferred` / `discouraged` | 是否创建**可发现凭证**（一键直登的前提） |
| `requireResidentKey`      | `boolean`                                | 旧字段；等价于 `residentKey: 'required'` |

## 4.3 `attestationType`（simplewebauthn）

| 值                    | 说明                     | 备注         |
| --------------------- | ------------------------ | ------------ |
| `none`                | 不收集证明链（隐私友好） | **最常用**   |
| `indirect` / `direct` | 收集不同强度的证明链     | 较少用       |
| `enterprise`          | 企业场景                 | 需要配套策略 |

## 4.4 `allowCredentials` / `excludeCredentials`（描述符）

```ts
{
  id: Uint8Array | Buffer,     // 凭证ID（服务端存 base64url，生成时转回二进制）
  type: 'public-key',
  transports?: ('usb'|'nfc'|'ble'|'internal'|'cable'|'hybrid')[]
}
```

## 4.5 `supportedAlgorithmIDs`（替代 `pubKeyCredParams`）

- 传 **COSE 算法 ID** 数组（见上表）。
- 浏览器最终在前端 JSON 里仍会以 `pubKeyCredParams` 形式出现（这是 WebAuthn 原生结构），不冲突。

---

# 五、生产推荐模板

### 注册（Creation）

```ts
await generateRegistrationOptions({
  rpName: "Your App",
  rpID: "yourdomain.com",
  userID: Buffer.from(userId, "utf8"),
  userName: userNameOrEmail,
  supportedAlgorithmIDs: [-7], // 如需更广：[-7, -257]
  userVerification: "required",
  authenticatorSelection: {
    authenticatorAttachment: "platform",
    residentKey: "required",
    userVerification: "required",
  },
  attestationType: "none",
  timeout: 60_000,
  // excludeCredentials: [...],      // 防重复注册（可选）
  extensions: { credProps: true },
});
```

### 登录（Request）

```ts
await generateAuthenticationOptions({
  rpID: "yourdomain.com",
  timeout: 60_000,
  userVerification: "required",
  // 省略 allowCredentials → 可发现凭证（推荐做“一键直登”）
  // allowCredentials: [...],       // 指定账号登录时使用
  // extensions: { uvm: true },
});
```

> 核心校验与安全实践：
>
> 1. **challenge** 统一按 **base64url 字符串** 存/比；用后删除；短 TTL（≤5 分钟）。
> 2. **requireUserVerification: true**（服务端）与前端的 `userVerification: 'required'` 配套。
> 3. 注册时显式 `residentKey: 'required'`，保证后面能做“无用户名一键登录（conditional UI）”。

---

# 六、常见疑问

- **为什么我的 `options` 字段很少？**
  浏览器/库会省略默认字段；只要关键项（`rpId`、`challenge`、用户/算法/策略）正确，功能完全等价。
- **`challenge` 看起来很短，安全吗？**
  默认 32 字节随机数（base64url 后 ≈43 字符）已足够安全。
- **字段大小写为何不一致？**
  库的**入参**是 `rpID`、`userID`（TypeScript 结构）；前端 JSON 是 WebAuthn 原生的 `rpId`、`user.id`。库会正确映射。

---

如果你想把现有 NestJS 代码里的配置**替换为上面的“生产推荐模板”**，告诉我你文件里的具体几行；我只给“需要替换的片段”，并在复杂逻辑上一行加注释，符合你的改码规则。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebAuthn 选项详解：attestationType / supportedAlgorithmIDs / authenticatorSelection / extensions.credProps]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn 选项详解：attestationType-supportedAlgorithmIDs-authenticatorSelection-extensions.credProps</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn 选项详解：attestationType-supportedAlgorithmIDs-authenticatorSelection-extensions.credProps"/>
        <updated>2025-09-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 场景

你在注册时传了这段配置：

```ts
attestationType: 'none',
supportedAlgorithmIDs: [-7], // 仅 ES256；如需 RS256 可再加 -257
authenticatorSelection: {
  residentKey: 'required',
  userVerification: 'preferred',
},
extensions: { credProps: true },
```

下面把**作用**、**可选值**与**含义**逐项讲清楚，并给出常见取值建议。

---

## 1) `attestationType`

**作用**：告诉浏览器/认证器，你希望拿到怎样的"证明这把公钥来自哪个厂商/设备"的**证明材料（Attestation）**。
**可选值**（WebAuthn 标准/`simplewebauthn` 一致）：

| 取值         | 含义                                                     | 典型用途                                    |
| ------------ | -------------------------------------------------------- | ------------------------------------------- |
| `none`       | 不要设备证明，只要公钥即可；最隐私、最通用。             | **推荐**给 B2C/通用站点（不校验设备来源）。 |
| `indirect`   | 由平台挑选匿名化或中介的证明格式，可能给到有限厂商信息。 | 基本很少用。                                |
| `direct`     | 要求直接的设备证明，便于校验厂商证书链。                 | 合规/高安全场景，需维护证书信任。           |
| `enterprise` | 企业专用，可拿到可唯一识别设备的证明。                   | 需要设备可追溯的企业场景；通常需额外资质。  |

> 你的取值：`'none'` → 省心、隐私友好、成功率高。

---

## 2) `supportedAlgorithmIDs`

**作用**：指定**可接受的公钥算法**（COSE 算法 ID 列表）。浏览器会在这些里选一个创建公钥。
**常见取值**（COSE ID → 算法）：

| COSE ID | 算法                                      | 说明                                           |
| ------- | ----------------------------------------- | ---------------------------------------------- |
| `-7`    | **ES256**（ECDSA w/ SHA-256）             | **WebAuthn 强烈推荐/最普及**，跨平台兼容最好。 |
| `-257`  | **RS256**（RSASSA-PKCS1-v1_5 w/ SHA-256） | 一些旧平台/安全钥匙需要；密钥体积更大。        |
| `-8`    | **EdDSA**（常见 Ed25519）                 | 新趋势，部分平台/浏览器逐步支持。              |

> 你的取值：`[-7]` → 仅 ES256。
> **建议**：如需兼容老设备/Windows Hello 某些环境，可改为 `[-7, -257]`；若想前瞻支持，可加 `-8`（视目标平台而定）。

---

## 3) `authenticatorSelection`

**作用**：约束要创建哪种类型的凭据/交互体验。

### 3.1 `residentKey`

是否创建**可发现凭据（Discoverable Credential / "本地居民密钥"）**，也就是通常说的**Passkey**（用户名可省略，靠设备里保存的账户标识来找回）。

| 取值          | 含义                               | 体验影响                                                        |
| ------------- | ---------------------------------- | --------------------------------------------------------------- |
| `required`    | **必须**创建可发现凭据。           | 支持"无用户名登录"、**Conditional UI 一键直登**；占用设备存储。 |
| `preferred`   | **尽量**创建；不行就退回不可发现。 | 成功率高，可能部分用户仍生成不可发现。                          |
| `discouraged` | 不鼓励（通常就创建不可发现凭据）。 | 需要用户名 + 凭据句柄才能登录；非 passkey 体验。                |

> 你的取值：`'required'` → 明确走 **Passkey** 路线（推荐做法）。

### 3.2 `userVerification`

是否要求**用户验证**（UV：指纹/人脸/PIN 等）。

| 取值          | 含义                       | 体验影响                                 |
| ------------- | -------------------------- | ---------------------------------------- |
| `required`    | 必须进行 UV。              | **最安全**，一定会弹 biometrics/PIN。    |
| `preferred`   | 能 UV 就做；没有也可继续。 | **折中**：有生物识别就用，没有也不阻塞。 |
| `discouraged` | 不希望 UV。                | 免打扰，但安全性最低，少见于账号体系。   |

> 你的取值：`'preferred'` → 让支持生物识别的设备走强校验，同时兼顾广泛兼容性。
> **建议**：如果是**高敏/企业后台**，可改为 `'required'`。

---

## 4) `extensions: { credProps: true }`

**作用**：启用 **Credential Properties 扩展**，让返回结果里带上**这把凭据是否为可发现凭据**等属性。
**返回**：通常会得到 `clientExtensionResults.credProps = { rk?: boolean }`，其中：

- `rk: true` → 表示**创建了可发现凭据**（resident key）。
- `rk: false/缺失` → 不是可发现凭据，或平台未返回。

> 你的取值：`credProps: true` → 便于**落库记录**这把凭据是否为 passkey、做后续风控或回显。

---

## 常见组合与建议

- **通用 B2C / 技术社区登录**（首选）

  ```ts
  attestationType: 'none',
  supportedAlgorithmIDs: [-7, -257], // ES256 优先，兼容 RS256
  authenticatorSelection: { residentKey: 'required', userVerification: 'preferred' },
  extensions: { credProps: true }
  ```

  - 目标：高成功率 + Passkey 体验 + 宽兼容。

- **高安全后台/企业管理台**

  ```ts
  attestationType: 'none' | 'direct', // 视合规要求
  supportedAlgorithmIDs: [-7, -257],
  authenticatorSelection: { residentKey: 'required', userVerification: 'required' },
  extensions: { credProps: true }
  ```

  - 目标：强制生物识别；如需设备可追溯再考虑 `direct/enterprise`（谨慎）。

---

## 小结（对应你的现配）

- `attestationType: 'none'`：最省心、最隐私，推荐。
- `supportedAlgorithmIDs: [-7]`：仅 ES256；为兼容面可加 `-257`（RS256），前瞻再加 `-8`（EdDSA）。
- `residentKey: 'required'`：明确走 **Passkey/可发现凭据**，利于**无用户名登录**与**Conditional UI**。
- `userVerification: 'preferred'`：有生物识别就启用，兼顾成功率与体验。
- `credProps: true`：拿到 `rk` 标志，便于你在服务端做记录与策略。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn「认证（navigator.credentials.get）」options]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn「认证（navigator.credentials.get）」options</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn「认证（navigator.credentials.get）」options"/>
        <updated>2025-09-18T17:26:53.138Z</updated>
        <content type="html"><![CDATA[## 一、后端返回的 `PublicKeyCredentialRequestOptions`（认证阶段 options）

这是浏览器发起 **get/assertion** 的必要参数对象。常见字段如下（都由**后端**生成与返回）：

### 1) `challenge`（必填）

- **类型**：`BufferSource`（你通常用 base64url 字符串传，到前端转成 `ArrayBuffer`）
- **作用**：一次性的随机值，防重放。浏览器会把它写进 `clientDataJSON`，并参与签名校验（后端要比对它是否与发给客户端的一致）。([W3C][1])
- **要点**：应足够随机/高熵；后端必须保存并在验证时对上。([GitHub][2])

### 2) `rpId`（可选）

- **类型**：字符串（域名）
- **作用**：指定**Relying Party ID**。若不填，默认是**调用页面的有效顶级域名(ETLD+1)或其子域**。必须与当前页面域满足“后缀匹配”规则；否则浏览器直接抛 `SecurityError`。([GitHub][3])
- **跨站/多域**：如果你希望 `app.example.com` 也能使用 `example.com` 作为 rpId，需要在 `https://example.com/.well-known/webauthn` 配置 **Related Origin Requests** 白名单；否则也会 `SecurityError`。注意 Firefox 尚不支持该机制。([web.dev][4])

### 3) `allowCredentials`（可选）

- **类型**：`PublicKeyCredentialDescriptor[]`
- **作用**：限制可用的凭据集合（凭据 ID 列表）。如果你想做**无用户名/可发现凭据（discoverable credentials）**登录，通常**留空**让浏览器从设备中自动发现。([W3C][1])
- **子字段**：

  - `type`: 目前恒为 `"public-key"`。([MDN Web Docs][5])
  - `id`: **credentialId**（二进制）；前端需 base64url→ArrayBuffer。([MDN Web Docs][5])
  - `transports`: **提示**浏览器优先尝试的传输介质（不是安全校验的一部分）。值包括：`"ble" | "hybrid" | "internal" | "nfc" | "usb"`（有的实现还保留 `"cable"`；`"hybrid"`为其替代）。([MDN Web Docs][6])

### 4) `userVerification`（可选）

- **类型**：`"required" | "preferred" | "discouraged"`
- **作用**：要求是否必须本地生物识别/解锁等**用户验证**：

  - `"required"`：必须有人脸/指纹/设备 PIN；后端验证 `UV` 标志位。
  - `"preferred"`：尽量有（最常用默认）。
  - `"discouraged"`：不要求。([MDN Web Docs][5])

### 5) `timeout`（可选）

- **类型**：毫秒
- **作用**：给浏览器的人机交互超时建议。浏览器**可忽略**或有自己的上限/下限。([MDN Web Docs][5])

### 6) `extensions`（可选）

- **类型**：对象
- **作用**：扩展输入（如历史 U2F 兼容的 `appid`、`uvm` 等，不同实现支持不同）。后端在验证时也会得到**扩展输出**以决定后续处理。([MDN Web Docs][5])

> ⚠️ **`mediation` 不属于 `PublicKeyCredentialRequestOptions`！**
> 它是 `navigator.credentials.get({ publicKey, mediation })` 的**顶层**参数，用来启用 **Conditional UI**（`'conditional'`）、`'required'`、`'optional'`、`'silent'` 等。放在 `publicKey` 里会被忽略。([MDN Web Docs][7])

**最简调用形态（仅示意差异处）**：

```ts
const publicKey = toPublicKeyOptions(optionsFromServer);
const mediation = optionsFromServer.mediation; // 由你自己透传
const cred = await navigator.credentials.get({ publicKey, mediation }); // ← mediation 在顶层
```

（`mediation: 'conditional'` 可启用表单自动填充式的 passkey UI）([MDN Web Docs][7])

## 二、你回传给后端的断言 `payload`（认证结果）

```ts
const payload = {
  id,                // 字符串 ID（可视化用）
  rawId,             // base64url(二进制 credentialId) —— 服务端验证优先用它
  type,              // "public-key"
  options_token,     // 你系统自有：把 options 与本次会话/挑战绑定的防重放令牌
  response: {
    clientDataJSON,      // 包含 challenge/ origin / type 等
    authenticatorData,   // rpIdHash/flags/signCount/扩展输出
    signature,           // 对 (authenticatorData || SHA256(clientDataJSON)) 的签名
    userHandle | null,   // 可发现凭据时可能包含到用户主键的字节串
  },
  // 可选：clientExtensionResults
}
```

每个字段的用处——

### 1) `id` / `rawId`

- **`id`**：DOM 字符串形式的凭据标识（实现可把二进制编码成可打印字符串）。
- **`rawId`**：真正的二进制凭据 ID（你已做 base64url）。**后端应以 `rawId` 匹配数据库中的 credential 记录**。([MDN Web Docs][5])

### 2) `type`

- 目前恒为 `"public-key"`。后端可做兜底校验。([MDN Web Docs][5])

### 3) `response.clientDataJSON`

- **浏览器生成的 JSON（再序列化为 ArrayBuffer）**，包含：

  - `type`：本次操作类型，认证为 `"webauthn.get"`；
  - `challenge`：后端发的挑战（base64url），**后端必须与会话中保存的挑战比对**；
  - `origin`：调用页面的源（协议+域+端口），用来防钓鱼；
  - 可能还有 `crossOrigin` 等。

- **服务器验证**会对 `clientDataJSON` 做 SHA-256，作为签名消息的一部分。([W3C][1])

### 4) `response.authenticatorData`

- 由**认证器**返回的二进制结构，包含：

  - `rpIdHash`：`SHA-256(rpId)`；
  - `flags`：位标志（如 `UP` 用户在场、`UV` 用户已验证、`BE/BS/AT/ED` 等）；
  - `signCount`：签名计数（防克隆）；
  - 以及扩展输出（如果启用）。([MDN Web Docs][8])

- **服务器需检查**：

  - `rpIdHash` 是否与期望 rpId 匹配；
  - `flags` 是否满足 `userVerification` 要求（如要求 `UV=1`）；
  - `signCount` 是否单调递增（> 上次保存的值）。([W3C][1])

### 5) `response.signature`

- 认证器使用**该凭据绑定的公钥**对应的**私钥**对如下字节串签名：
  `authenticatorData || SHA-256(clientDataJSON)`
- **服务器**用数据库保存的**公钥**验证签名的真实性。([W3C][1])

### 6) `response.userHandle`（可能为 `null`）

- **discoverable credentials** 场景下，认证器可回传**与凭据绑定的用户标识**（byte\[]）。
- 后端可据此直接找到用户（无须用户名）。若你只用非可发现凭据或 `allowCredentials` 白名单，常见为 `null`。([W3C][1])

### 7) `clientExtensionResults`（可选）

- 前端可一并传回，服务端可依据需要处理（例如 `uvm` 等）。([MDN Web Docs][5])

### 8) `options_token`（你系统自定义）

- **标准外**字段，用于**把“本次 options”与“本次 verify”绑定**（有的系统用 session/redis，也有的用外带 token）。目的：**抗重放**与**防参数串改**。无统一规范，思路与保存 `challenge` 并验证一致。可参考 SimpleWebAuthn 关于“保存 challenge 的会话方案”。([SimpleWebAuthn][9])

---

## 三、服务端典型验证清单（认证）

后端在收到上面的 `payload` 后，一般需要做（摘要）：

1. 按 `rawId` 查找已注册的凭据与其公钥；
2. 校验 **`challenge`**（来自已保存的 options）；
3. 校验 **`origin`** 与 **`rpIdHash`**（域/站点匹配）；
4. 按 `userVerification` 要求检查 **`flags`** 中的 `UP/UV`；
5. 用保存的**公钥**验证 **`signature`**；
6. 检查并更新 **`signCount`**（克隆检测）；
7. 处理扩展输出（若配置）。
   这些步骤在 W3C 规范“验证认证断言”一节与社区文档中有详细说明。([W3C][1])

---

## 四、与你当前代码的两个关键提示

1. **`mediation` 放错位置**
   `mediation` 必须放在 `navigator.credentials.get({ publicKey, mediation })` 的顶层，而不是 `publicKey` 里。否则 Conditional UI 不生效。([MDN Web Docs][7])

2. **`rpId` 本地兜底**
   本地开发建议在前端兜底 `rpId='localhost'`（或让后端按环境返回），否则很容易 `SecurityError`。跨域/多域要配 **`/.well-known/webauthn`** 以启用 Related Origin Requests（当前 Firefox 不支持，需考虑降级策略）。([web.dev][4])

---

## 五、`allowCredentials` 使用小抄

- **用户名+密码+随后二次验证（绑定到用户）**：通常**传递用户的所有 credentialId** 列表到 `allowCredentials`，限制可选项。
- **无用户名/一键直登（discoverable）**：**留空** `allowCredentials`，并使用 `mediation: 'conditional'` 以获得自动填充式 UI。([developers.yubico.com][10])
- `transports` 仅是**提示**给浏览器，不影响安全验证逻辑。([developers.yubico.com][11])

---

如果你愿意，我可以按你的接口结构再给一个\*\*“后端认证校验要点对照表”**（结合 `@simplewebauthn/server` 的参数名、如何比对 challenge、如何处理 signCount 与 UV 要求等），并补充**错误映射\*\*（`NotAllowedError/SecurityError` 等）与常见排错 Checklist。

[1]: https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com "Web Authentication: An API for accessing Public Key ..."
[2]: https://github.com/w3c/webauthn/issues/1856?utm_source=chatgpt.com "Clarify the need for truly randomly generated challenges ..."
[3]: https://github.com/w3c/webauthn/wiki/Explainer%3A-Related-origin-requests?utm_source=chatgpt.com "Explainer: Related origin requests · w3c/webauthn Wiki"
[4]: https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com "Allow passkey reuse across your sites with Related Origin ..."
[5]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com "PublicKeyCredentialRequestOpti..."
[6]: https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com "AuthenticatorAttestationResponse: getTransports() method"
[7]: https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com "CredentialsContainer: get() method - Web APIs - MDN - Mozilla"
[8]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data?utm_source=chatgpt.com "Authenticator data - Web APIs | MDN - Mozilla"
[9]: https://simplewebauthn.dev/docs/packages/server?utm_source=chatgpt.com "simplewebauthn/server"
[10]: https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/WebAuthn_Client_Authentication.html?utm_source=chatgpt.com "WebAuthn Client Authentication"
[11]: https://developers.yubico.com/java-webauthn-server/JavaDoc/webauthn-server-core/2.3.0/com/yubico/webauthn/data/AuthenticatorTransport.html?utm_source=chatgpt.com "AuthenticatorTransport (webauthn-server-core 2.3.0 API)"

好嘞——下面给你一份\*\*“后端认证校验要点对照表 + SimpleWebAuthn（v11+）实务清单”**，把**后端返回的 `options` 各字段作用/取值\*\*，以及**前端回传给后端的断言 payload**如何被验证，逐一对齐。还附上**最小必要的服务端代码片段**（只放关键行、复杂逻辑行上方有中文注释），以及**常见坑与错误映射**。文末都给了权威出处。

---

## 一、认证阶段 `PublicKeyCredentialRequestOptions`（后端生成 → 前端 `navigator.credentials.get({ publicKey, mediation? })`）

| 字段               | 必须 | 类型/典型值                                                        | 作用 & 校验点                                                                                                                                                                          |       |       |       |                                               |
| ------------------ | ---: | ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- | ----- | ----- | --------------------------------------------- |
| `challenge`        |   ✅ | 高熵随机字节（前端以 **base64url** 字符串接收 → 转 `ArrayBuffer`） | **防重放**。浏览器会把它写进 `clientDataJSON` 并参与签名；后端必须与会话中保存的 challenge 完全一致才通过。([MDN Web Docs][1])                                                         |       |       |       |                                               |
| `rpId`             |   ⭕ | 域名字符串（如 `example.com` / `localhost`）                       | 指定 **RP ID**。应与当前页面域名满足后缀匹配；不匹配浏览器直接抛 **`SecurityError`**。多域/跨站共用需配置 `/.well-known/webauthn` 的 **Related Origin Requests** 白名单。([GitHub][2]) |       |       |       |                                               |
| `allowCredentials` |   ⭕ | `[{ type: 'public-key', id: <Buffer>, transports?: [...] }]`       | 限定可用凭据（**credentialId 白名单**）。做 **无用户名/可发现凭据** 登录时通常留空，让浏览器从设备中自动发现。`transports` 为提示（\`"internal"                                        | "usb" | "nfc" | "ble" | "hybrid"\` 等）。([udn.realityripple.com][3]) |
| `userVerification` |   ⭕ | `"required" \| "preferred" \| "discouraged"`                       | 是否必须本地生物识别/解锁。若设为 `"required"`，后端需检查 `UV` 标志。([MDN Web Docs][1])                                                                                              |       |       |       |                                               |
| `timeout`          |   ⭕ | 毫秒数                                                             | 用户交互超时建议；浏览器可忽略。([MDN Web Docs][1])                                                                                                                                    |       |       |       |                                               |
| `extensions`       |   ⭕ | 任意对象（各扩展自定义形态）                                       | WebAuthn 扩展输入；验证时可读取扩展输出决定策略（如 `uvm` 等）。([MDN Web Docs][4])                                                                                                    |       |       |       |                                               |
| `mediation`        |   ❌ | **不在 `publicKey` 里！**                                          | **在 `navigator.credentials.get` 顶层**传入（例如 `'conditional'` 开启 Conditional UI/表单自动填充式 UI）。放进 `publicKey` 会被忽略。([MDN Web Docs][5])                              |       |       |       |                                               |

> 小结：你 `toPublicKeyOptions(...)` 里把 `mediation` 放进了 `publicKey`，应移到 `credentials.get` 的顶层；`rpId` 在本地开发建议兜底为 `localhost`，否则极易 `SecurityError`。([MDN Web Docs][5])

---

## 二、前端回传给后端的断言 `payload`（认证结果）

你当前回传结构（简化）是对的：

```ts
{
  id,                // UI 标识；通常不用于严谨校验
  rawId,             // <- base64url(credentialId二进制)，后端用它匹配库中凭据
  type,              // "public-key"
  options_token,     // 你的系统自定义防重放/绑会话令牌
  response: {
    clientDataJSON,      // 含 challenge / origin / type="webauthn.get"
    authenticatorData,   // 含 rpIdHash / flags(UP/UV/...) / signCount / 扩展输出
    signature,           // 对 (authenticatorData || SHA256(clientDataJSON)) 的签名
    userHandle | null,   // 可发现凭据时可能存在（用户主键字节串）
  },
  clientExtensionResults? // 可选
}
```

- **`clientDataJSON`**：后端需校验 `challenge`、`origin`、`type="webauthn.get"`，再做 `SHA-256` 参与签名验证。([MDN Web Docs][6])
- **`authenticatorData`**：后端校验 `rpIdHash==SHA256(rpId)`、`flags`（例如是否包含 `UV`）、并进行 **`signCount` 单调递增**检查。([MDN Web Docs][6])
- **`signature`**：用数据库保存的**公钥**验签，消息是 `authenticatorData || SHA256(clientDataJSON)`。([MDN Web Docs][7])

---

## 三、SimpleWebAuthn（v11+）后端验证清单（认证）

> 术语对齐：
>
> - 生成 options：`generateAuthenticationOptions()`
> - 校验断言：`verifyAuthenticationResponse()`（v11+）

**1）生成认证 options（登录 / 二次校验）**

```ts
// 复杂逻辑：用用户已绑定的 credentialId 组装 allowCredentials；若做“无用户名直登”，则留空
const opts = await generateAuthenticationOptions({
  rpID: process.env.RP_ID, // 上一行：与页面域名/Related Origins 配套
  allowCredentials: userCreds?.map((c) => ({
    id: base64url.toBuffer(c.credentialId), // 上一行：DB里通常以base64url存；此处还原为Buffer
    type: "public-key",
    transports: c.transports as any, // 可选；仅提示 UA 选择通道
  })),
  userVerification: "preferred", // 或 'required'（则后端需检查 UV）
  timeout: 60_000,
  // extensions: {...}                              // 需要再加
});

// 复杂逻辑：把 challenge 与会话绑定（如用 Redis，键=会话ID）；严格用 base64url 存储与比对
await redis.setEx(`webauthn:challenge:${sid}`, 300, opts.challenge); // 5分钟有效
return opts;
```

要点：**challenge 必须保存并一次性使用**；即使验证失败也要作废，防止重放。([简单网页认证][8])

**2）验证断言**（前端把 `PublicKeyCredential` 序列化为上面的 payload 发来）

```ts
// 复杂逻辑：取回并删除 challenge，保证一次性使用
const expectedChallenge = await redis.getDel(`webauthn:challenge:${sid}`);

const verification = await verifyAuthenticationResponse({
  response: payload, // 上一行：就是你发来的 id/rawId/type/response/...
  expectedChallenge, // 严格等比对；base64url 字面一致
  expectedOrigin: process.env.ORIGIN, // 例：https://app.example.com
  expectedRPID: process.env.RP_ID, // 例：example.com（或 localhost）
  requireUserVerification: true, // 若你在 options 里要求 UV，此处也应 true
});

if (!verification.verified) {
  // … 统一返回登录失败/请重试
  throw new UnauthorizedException("webauthn verification failed");
}

// 复杂逻辑：依据 authenticationInfo 更新 signCount、定位凭据与用户
const { newCounter, credentialID, credentialDeviceType, userVerified } =
  verification.authenticationInfo;

// 上一行：比对/更新 DB 中该 credential 的 counter；若 newCounter <= 已存值，则可能存在克隆风险
await credentialRepo.updateById(credentialID, { counter: newCounter });

// 复杂逻辑：若 userHandle 存在，可用于无用户名直登从凭据反查用户
// （simplewebauthn 已做基础校验；你可根据业务增加“账号冻结/设备绑定”等策略）
```

接口与字段含义、错误场景见官方文档。([简单网页认证][9])

---

## 四、浏览器端调用要点（只列差异处）

```ts
const publicKey = toPublicKeyOptions(optionsFromServer);

// 上一行：Conditional UI 时，请把 mediation 放在顶层（不是 publicKey 内）
const mediation = optionsFromServer.mediation ?? undefined;

// 上一行：本地开发/线下环境，rpId 建议兜底为 'localhost'
if (["localhost", "127.0.0.1"].includes(location.hostname)) {
  (publicKey as any).rpId = "localhost";
}

const cred = await navigator.credentials.get({ publicKey, mediation });
```

- `mediation: 'conditional'` 可启用表单自动填充式 Passkey 选择 UI。([MDN Web Docs][5])
- 多域共享凭据需配置 **`/.well-known/webauthn`** 的 Related Origin Requests；否则会 **`SecurityError`**。([web.dev][10])

---

## 五、常见坑 & 错误映射（含排查建议）

- **`SecurityError`**：`rpId` 与当前页面域不匹配；或跨域未配置 **Related Origin Requests**。

  - 检查：页面 `origin`、服务端 `rpId`、以及是否有 `/.well-known/webauthn` JSON（Chrome 支持、Firefox 目前不支持）。([web.dev][10])

- **`NotAllowedError`**：用户取消、未选择、超时或环境不支持。

  - 建议：UI 上给“重试/改用其它方式”；适当延长 `timeout`。([MDN Web Docs][5])

- **验签失败**：服务端公钥与凭据不匹配，或签名消息拼装错误（必须 `authenticatorData || SHA256(clientDataJSON)`）。([MDN Web Docs][7])
- **`UV` 不满足**：前端 `userVerification: 'required'`，但设备未解锁；后端 `requireUserVerification: true` 会拒绝。([MDN Web Docs][1])
- **`signCount` 未递增**：提示可能的凭据克隆（部分平台计数恒 0，需在策略上兼容）。([MDN Web Docs][6])
- **JOSE/曲线不支持**（如 OKP/Ed25519）导致 `verifyAuthenticationResponse` 报错：升级依赖或改用受支持算法；参考 SimpleWebAuthn 的已知问题。([简单网页认证][9])

---

## 六、字段作用快速对照（你问到的两类）

**A. 后端返回给前端的 `options` 字段（认证阶段）**

- `challenge`：一次性随机数，**必须保存并严格匹配**；验证链路里参与签名。([MDN Web Docs][1])
- `rpId`：RP ID 域；**决定可用凭据的作用域**；与页面域不匹配会被浏览器直接拒绝。([GitHub][2])
- `allowCredentials`：可用凭据白名单；空则走“设备自动发现”（更适合**无用户名/直登**）。([udn.realityripple.com][3])
- `userVerification`：本地解锁强度要求；后端需一致地要求/校验。([MDN Web Docs][1])
- `timeout`：交互时间建议。([MDN Web Docs][1])
- `extensions`：功能扩展输入。([MDN Web Docs][4])
- `mediation`：**顶层参数**（非 `publicKey` 字段）；控制 Conditional UI。([MDN Web Docs][5])

**B. 你回传给后端的断言字段（认证结果）**

- `id`/`rawId`：凭据标识，**以 `rawId` 匹配库中凭据**。([MDN Web Docs][1])
- `type`：恒为 `"public-key"`。([MDN Web Docs][1])
- `response.clientDataJSON`：含 `challenge`/`origin`/`type` 等，**要校验**；其哈希参与签名。([MDN Web Docs][6])
- `response.authenticatorData`：含 `rpIdHash`/`flags`/`signCount` 等，**要校验并更新 counter**。([MDN Web Docs][6])
- `response.signature`：对（`authenticatorData || SHA256(clientDataJSON)`）的签名，**用公钥验签**。([MDN Web Docs][7])
- `response.userHandle`：可发现凭据时可能有；可用于**无用户名直登**回查账号。([MDN Web Docs][1])
- `clientExtensionResults`：若使用扩展，建议一并传回。([MDN Web Docs][4])
- `options_token`：**你系统自定义**的会话/挑战绑定令牌，目的与保存/匹配 challenge 一致（防重放）。([简单网页认证][8])

---

## 七、参考与延伸

- MDN：`PublicKeyCredentialRequestOptions` 字段总览（挑战、UV、allowCredentials 等）。([MDN Web Docs][1])
- MDN：`CredentialsContainer.get()`（顶层 `mediation` 选项）。([MDN Web Docs][5])
- MDN：`AuthenticatorAssertionResponse`（断言结构、`signature` 含义）。([MDN Web Docs][6])
- W3C WebAuthn Level 3（2025-01-27 版）。([W3C][11])
- Chrome/Web.dev：**Related Origin Requests** 与 `/.well-known/webauthn`。([web.dev][10])
- SimpleWebAuthn：`@simplewebauthn/server` 与 `@simplewebauthn/browser` 文档与“Passkeys”最佳实践。([简单网页认证][9])

---

如果你接下来想**严格对齐你后端（NestJS + Redis + SimpleWebAuthn v11+）的参数名**，我可以把上面的两段服务端片段，分别扩成**控制器/服务方法**的“最小可运行版本”，并把\*\*`expectedChallenge/Origin/RPID`**、**`newCounter`\*\* 更新、**设备 ID→ 账号绑定**等都按你现有项目约定补齐。需要的话直接说一声。

[1]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com "PublicKeyCredentialRequestOpti..."
[2]: https://github.com/w3c/webauthn/wiki/Explainer%3A-Related-origin-requests?utm_source=chatgpt.com "Explainer: Related origin requests · w3c/webauthn Wiki"
[3]: https://udn.realityripple.com/docs/Web/API/PublicKeyCredentialRequestOptions/allowCredentials?utm_source=chatgpt.com "PublicKeyCredentialRequestOpti..."
[4]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions?utm_source=chatgpt.com "Web Authentication extensions - Web APIs - MDN"
[5]: https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com "CredentialsContainer: get() method - Web APIs - MDN - Mozilla"
[6]: https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAssertionResponse?utm_source=chatgpt.com "AuthenticatorAssertionResponse - Web APIs | MDN - Mozilla"
[7]: https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAssertionResponse/signature?utm_source=chatgpt.com "AuthenticatorAssertionResponse: signature property - Web APIs"
[8]: https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com "Passkeys"
[9]: https://simplewebauthn.dev/docs/packages/server?utm_source=chatgpt.com "simplewebauthn/server"
[10]: https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com "Allow passkey reuse across your sites with Related Origin ..."
[11]: https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com "An API for accessing Public Key Credentials - Level 3"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[userVerification:]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/preferred是啥</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/preferred是啥"/>
        <updated>2025-09-08T00:12:36.000Z</updated>
        <content type="html"><![CDATA[
好，我逐条拆解你看到的这段响应，并把“该用什么值”“挑战长度”为啥看起来短、“大厂是不是也这样返回”讲清楚；最后给出**只需改几行**的建议（不贴整文件）。

---

# 1、`"userVerification": "preferred"` 是啥？

**它告诉浏览器/认证器：是否必须做“本地用户验证（UV）”**（指纹/人脸/PIN）。可选值只有 3 个：

| 值                            | 含义                                                     | 常见效果/场景                                                                                                |
| ----------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **`required`**                | **必须**进行本地用户验证（没有 UV 能力的认证器会被排除） | 金融、后台管理、提升安全性。旧 U2F 钥匙（无 PIN）会被拒。                                                    |
| **`preferred`**（你现在的值） | **优先**做 UV，如果设备支持就做；不支持也可以继续        | 一般网站登录、降低失败率。绝大多数“平台 passkey”（Android/Apple）都会做 UV，所以体验和 `required` 基本一样。 |
| **`discouraged`**             | **不鼓励**做 UV（允许仅“持有设备”就通过）                | 很少用；降低安全门槛，适合低风险二级操作（不建议用于登录）。                                                 |

> 注意：这只是“**意愿**”。真正的**强制**要在**服务端验证**时也打开：
> `verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })`。
> 否则前端说 `required`，服务端放宽为 `false`，就**没有被强制**。

**给你的建议：**

- 如果这是**员工后台**或敏感操作：前端设 `userVerification: 'required'`，服务端配套 `requireUserVerification: true`。
- 如果是**大众登录**：`preferred` + 风控/设备指纹/异常登录再二次验证。

# 2、这个 `challenge` 看起来“很短”，正常吗？

**正常。**

- simplewebauthn 默认生成 **32 字节**随机挑战（≈ **256 bit**）。
- 32 字节用 **base64url** 表示通常是 **43\~44 个字符**（无 `=` 填充）。
- 你看到的：`jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg`，长度 43，很标准。
- 我们服务端已把 challenge 统一按 **base64url** 存/比（你代码里已处理），与前端 `clientDataJSON.challenge` 能**精确一致**。

> 若你担心强度，也可以自定义更长挑战（例如 64 字节），但 32 字节已足够随机且是行业常见默认。

# 3、大厂实践里返回的也是这种结构吗？

**是的。**这就是 WebAuthn 规范的 **PublicKeyCredentialRequestOptions(JSON)** 的形态，各家（Google、Apple、微软、GitHub、PayPal…）都会返回类似结构。差异主要在**有没有 `allowCredentials`** 和某些可选字段：

- 一键直登/可发现凭证：**省略 `allowCredentials`**（你现在就是），浏览器会弹出该 RP 的可用 passkey 列表。
- 指定账号登录：会带 `allowCredentials: [{ id, type: 'public-key' }, ...]`。
- 其他常见字段：`rpId`、`challenge`、`timeout`、`userVerification`、有时 `extensions`。
- 前端会另外传 `mediation: 'conditional'`（这不是 options 里的字段，而是 `navigator.credentials.get` 的参数，用于条件式 UI）。

所以你这个响应：

```json
{
  "options": {
    "rpId": "localhost",
    "challenge": "…",
    "timeout": 60000,
    "userVerification": "preferred"
  }
}
```

**完全合理**、符合规范，也符合大厂常见做法（本地开发把 `rpId` 设为 `localhost` 没问题，上线要换为你的主域）。

# 4、如果你要“更安全”，只改这几行（前后端各一处）

**后端·验证时强制 UV（把 `false` 改为 `true`）**

```ts
// 复杂：强制需要本地用户验证（指纹/人脸/PIN）
requireUserVerification: true,
```

> 出现位置：
>
> - `verifyRegistrationResponse({...})`
> - `verifyAuthenticationResponse({...})`

**生成登录 options 时（可选）：把首选项也改为 required**

```ts
// 复杂：要求认证器执行 UV
userVerification: 'required',
```

> 这两处配合使用，才能做到“名副其实的强制 UV”。

---

# 5、小补充：别名/大小写别差异别担心

- simplewebauthn（v11+）返回的 JSON 用 `rpId`（小写 d）；
- 你传入 `generateAuthenticationOptions({ rpID: '…' })` 是库的入参写法；
- **这是正常的**：入参/出参字段命名略有差异，但库会正确映射。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/test</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/test"/>
        <updated>2025-09-08T00:19:02.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[公司电脑登录“另一个谷歌账号”还能用我之前的通行密钥吗？（结论 + 原理 + 落地要点）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/公司电脑登录另一个谷歌账号还能用我之前的通行密钥吗</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/公司电脑登录另一个谷歌账号还能用我之前的通行密钥吗"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 结论速览

**可以，但要满足其一**：

1. **同账号同步**：公司电脑上的 Chrome/Edge **登录的是同一个 Google 账号 A**（且允许密码管理器/数据同步）→ 该通行密钥会通过 **Google Password Manager** 同步过来，直接可用。([Google 帮助][1])
2. **跨设备（Hybrid/手机扫码）**：即使公司电脑登录的是 **Google 账号 B**、本机没有那把密钥，也**仍可用手机上的那把密钥**（Android 的 Google Password Manager 或 iPhone 的 iCloud Keychain）**扫码/Bluetooth 完成登录**——前提是**后端/前端允许 hybrid 传输**。([FIDO Alliance][2])

> 反之，如被企业策略禁用密码管理器/蓝牙/Passkeys，或你把 `allowCredentials` 限得过死且**没启用 `hybrid`**，就可能失败。([chromeenterprise.google][3])

## 为什么“不同账号”也能登录（在手机在场时）

- **跨设备登录机制（Hybrid/caBLE）**：桌面浏览器在没有本机凭据时会展示 **二维码/附近设备** 流程，手机扫描后通过 **BLE 近距校验** 与端到端加密信道完成签名；这**不要求**桌面与手机是同一个 Google 账号，只要**手机里有那把通行密钥**即可。([FIDO Alliance][2])
- **苹果官方也支持“非 Apple 设备用 iPhone 的 Passkey”**：在 Windows/Chrome 上选择“其他方式/来自附近设备”，显示二维码，用 iPhone 扫码 + Face/Touch ID 即可。([Apple 支持][4])

## 你这次能不能“直接成功”？看这三件事

1. **前端是否把 `hybrid` 加进 `allowCredentials[*].transports`**（没有就很难触发手机扫码）。([MDN Web Docs][5])
2. **是否采用了“可发现凭据”的正确姿势**：

   - **场景 A（已知用户）**：给出**该用户的全部 credentialId** 列表；
   - **场景 B（账号发现/一键直登）**：**省略 `allowCredentials`（传空数组）**，让浏览器列出本机/手机上此 RP 可用的 passkeys。([web.dev][6])

3. **现场环境**：电脑与手机 **蓝牙可用**、企业策略未禁用密码管理器/Passkeys/蓝牙等。([chromeenterprise.google][3])

> 提醒：当你**指定了 `allowCredentials`** 时，浏览器**只能**用到列表里**存在的那几个 credentialId**；若当前设备（包括通过手机走 hybrid）**没有完全匹配的那个 ID**，就会匹配失败。要覆盖更多情况，可**把该用户已绑定的所有 ID 都给出**，或在需要“账号发现”时**传空数组**。([MDN Web Docs][5])

## 开发落地要点（最小改动）

> 你之前的代码基本已经具备能力，这里只强调关键两处“容易踩坑”的地方（**只给改动点**）：

```ts
// 复杂逻辑：构建 allowCredentials 时一定带上 hybrid，让桌面可用“用手机的通行密钥”
const transports: AuthenticatorTransport[] = [
  "hybrid",
  "internal",
  "usb",
  "nfc",
  "ble",
];
```

（依据：`PublicKeyCredentialRequestOptions.allowCredentials[].transports` 支持 `"hybrid"`；建议把注册时的 `getTransports()` 存起来用于后续请求。([MDN Web Docs][5])）

```ts
// 复杂逻辑：兜底为“账号发现/条件式 UI”——当精确匹配失败时，传空的 allowCredentials
await navigator.credentials.get({
  publicKey: {
    challenge,
    allowCredentials: [], // ← 让浏览器/系统列出该 RP 可发现的 passkeys（含手机扫码）
    userVerification: "preferred",
  },
  // 支持时启用 Conditional UI（表单自动填充）
  mediation: await(
    PublicKeyCredential as any
  ).isConditionalMediationAvailable?.()
    ? "conditional"
    : undefined,
});
```

（依据：**Discoverable credentials** 场景下推荐**省略 `allowCredentials`**，由浏览器列出可用 passkeys。([web.dev][6])）

---

## 具体到你的问题：公司电脑（Google 账号 B）是否“支持”？

- **支持（方式一）**：把公司电脑切换/新增到 **Google 账号 A**，并开启 Google Password Manager 同步 → 通行密钥会同步到该电脑，**无需手机**即可登录。([Google 帮助][1])
- **支持（方式二）**：保持 **账号 B** 不变，但**手机在身边**且前端允许 **`hybrid`** → 桌面以 **二维码/附近设备** 方式调用**手机上的通行密钥**完成登录。([FIDO Alliance][2])
- **可能不支持**：被企业策略禁用（密码管理器/蓝牙/Passkeys）、或你的实现**把 `allowCredentials` 限死**且当前设备/手机**找不到匹配的 credentialId**。([chromeenterprise.google][3])

---

## 参考

- **Discoverable/省略 allowCredentials**：web.dev 深入指南。([web.dev][6])
- **Google Password Manager 同步机制**：Google 支持 & 开发者文档。([Google 帮助][1])
- **跨设备（Hybrid/QR+BLE）**：FIDO Alliance 概述、Chrome/开发者说明、苹果支持“在非 Apple 设备上用 iPhone 的 Passkey”。([FIDO Alliance][2])
- **`transports` 包含 `hybrid`**：MDN & 规范。([MDN Web Docs][5])
- **企业策略可能限制**：Chrome/Edge 企业策略文档。([chromeenterprise.google][3])

> 一句话落地：**要么同账号同步，要么启用 hybrid 走“手机在身边”的跨设备登录**；实现上**别忘了 `transports: ['hybrid', ...]`，必要时在兜底流程里**把 `allowCredentials` 置空\*\*以启用“账号发现”。

[1]: https://support.google.com/accounts/answer/6197437?co=GENIE.Platform%3DDesktop&hl=en&utm_source=chatgpt.com "Use passwords & passkeys across your devices - Computer"
[2]: https://fidoalliance.org/passkeys/?utm_source=chatgpt.com "Passkeys: Passwordless Authentication"
[3]: https://chromeenterprise.google/policies/?utm_source=chatgpt.com "Chrome Enterprise Policy List & Management"
[4]: https://support.apple.com/guide/iphone/use-passkeys-to-sign-in-to-websites-and-apps-iphf538ea8d0/ios?utm_source=chatgpt.com "Use passkeys to sign in to websites and apps on iPhone"
[5]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com "PublicKeyCredentialRequestOpti..."
[6]: https://web.dev/articles/webauthn-discoverable-credentials?utm_source=chatgpt.com "Discoverable credentials deep dive | Articles"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/需求实现/登录鉴权/区分类型来源]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/区分类型来源</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/区分类型来源"/>
        <updated>2025-09-18T17:26:53.139Z</updated>
        <content type="html"><![CDATA[区分通行密钥的来源
再次强调，开发者无需做出任何更改，即可使其通行密钥实现与 iCloud 钥匙串保持一致。Chrome 个人资料和 iCloud 钥匙串之间的 API 行为已经完全相同。

依赖方可以通过查看凭据的身份验证器数据中的 AAGUID（用于指示身份验证器类型的标识符），了解通行密钥的来源，并区分通行密钥是在 iCloud 钥匙串中还是在 Chrome 个人资料中创建的。

在 Chrome 个人资料中创建的通行密钥的 AAGUID 为：adce0002-35bc-c60a-648b-0b25f1f05503。在 iCloud 钥匙串中，00000000-0000-0000-0000-000000000000 将于 2023 年 9 月起停用。您可以在众包 AAGUID 代码库中找到已知的 AAGUID。

https://passkeydeveloper.github.io/passkey-authenticator-aaguids/explorer/

Include MDS authenticators
AAGUID
Name
Filter by name...
X Icon light Icon dark
ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4 Google Password Manager
adce0002-35bc-c60a-648b-0b25f1f05503 Chrome on Mac
08987058-cadc-4b81-b6e1-30de50dcbe96 Windows Hello
9ddd1817-af5a-4672-a2b9-3e3dd95000a9 Windows Hello
6028b017-b1d4-4c02-b4b3-afcdafc96bb2 Windows Hello
dd4ec289-e01d-41c9-bb89-70fa845d4bf2 iCloud Keychain (Managed)
531126d6-e717-415c-9320-3d9aa6981239 Dashlane
bada5566-a7aa-401f-bd96-45619a55120d 1Password
b84e4048-15dc-4dd0-8640-f4f60813c8af NordPass
0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6 Keeper
891494da-2c90-4d31-a9cd-4eab0aed1309 Sésame
f3809540-7f14-49c1-a8b3-8f813b225541 Enpass
b5397666-4885-aa6b-cebf-e52262a439a2 Chromium Browser
771b48fd-d3d4-4f74-9232-fc157ab0507a Edge on Mac
39a5647e-1853-446c-a1f6-a79bae9f5bc7 IDmelon
d548826e-79b4-db40-a3d8-11116f7e8349 Bitwarden
fbfc3007-154e-4ecc-8c0b-6e020557d7bd iCloud Keychain
53414d53-554e-4700-0000-000000000000 Samsung Pass
66a0ccb3-bd6a-191f-ee06-e375c50b9846 Thales Bio iOS SDK
8836336a-f590-0921-301d-46427531eee6 Thales Bio Android SDK
cd69adb5-3c7a-deb9-3177-6800ea6cb72a Thales PIN Android SDK
17290f1e-c212-34d0-1423-365d729f09d9 Thales PIN iOS SDK
50726f74-6f6e-5061-7373-50726f746f6e Proton Pass
fdb141b2-5d84-443e-8a35-4698c205a502 KeePassXC
cc45f64e-52a2-451b-831a-4edd8022a202 ToothPic Passkey Provider
bfc748bb-3429-4faa-b9f9-7cfa9f3b76d0 iPasswords
b35a26b2-8f6e-4697-ab1d-d44db4da28c6 Zoho Vault
b78a0a55-6ef8-d246-a042-ba0f6d55050c LastPass
de503f9c-21a4-4f76-b4b7-558eb55c6f89 Devolutions
22248c4c-7a12-46e2-9a41-44291b373a4d LogMeOnce
a10c6dd9-465e-4226-8198-c7c44b91c555 Kaspersky Password Manager
d350af52-0351-4ba2-acd3-dfeeadc3f764 pwSafe
d3452668-01fd-4c12-926c-83a4204853aa Microsoft Password Manager
6d212b28-a2c1-4638-b375-5932070f62e9 initial
This is a community-driven list of known passkey provider AAGUIDs to assist with naming passkeys in end user passkey management interfaces (e.g. account settings). It is not intended to be used for any other purpose and could go away at any time.
This does not replace FIDO's Metadata Service (MDS), which should continue to be used for all authoritative security details about FIDO authenticators. Some AAGUIDs in this list may not appear in FIDO MDS.
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/需求实现/登录鉴权/所有配置项 + 有效值 + 作用]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/所有配置项 + 有效值 + 作用</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/所有配置项 + 有效值 + 作用"/>
        <updated>2025-09-18T17:26:53.139Z</updated>
        <content type="html"><![CDATA[太对路了——把“所有配置项 + 有效值 + 作用”讲清楚，前后端各怎么用，以及**如何判断注册来源是谷歌 / 苹果 / 微软**。下面一次性讲透，并给你几段**只需粘贴的最小改动**代码（遵循你“不整段贴全”的要求）。

---

# 一、后端（SimpleWebAuthn）配置项总览

## 1) `generateRegistrationOptions(...)`（注册发起）

**常用参数（含有效值 & 作用）**

- `rpName: string`
  你的站点/应用展示名称（出现在系统弹窗里）。

- `rpID: string`
  Relying Party ID（通常就是你的域名，如 `example.com`；App 内使用同 RP ID）。用于**同源校验**，必须与前端 `origin`、系统 UI 一致。

- `userID: BufferSource`
  你后端的用户唯一 ID（建议将数字/UUID 转成 `Buffer.from(...)`）。注册后可反查到用户。

- `userName: string`
  用户名（可用 userId 占位），供系统 UI 展示/内部标识。

- `userDisplayName?: string`
  友好展示名（可选）。

- `attestationType: 'none' | 'direct' | 'indirect' | 'enterprise'`
  **建议：`'none'`**。iOS/Android 平台 Passkey **常不给可验证的证明**；`direct` 往往拿不到签名链。除非企业场景才考虑 `enterprise`。([web.dev][1])

- `authenticatorSelection?: { ... }`

  - `residentKey: 'required' | 'preferred' | 'discouraged'`
    **建议：`'required'`**（= 可发现凭据 / Discoverable Credential），才能**无用户名直登**。
  - `userVerification: 'required' | 'preferred' | 'discouraged'`
    **建议：`'required'` 或 `preferred`**（Face/Touch/Windows Hello）。
  - `authenticatorAttachment?: 'platform' | 'cross-platform'`
    仅当你**只想收平台内置**时可设 `platform`；多数场景**不设**，允许安全钥匙。

- `supportedAlgorithmIDs: number[]`（COSE 算法）

  - `-7` = ES256（**最广泛支持**：Apple/Google/Windows）
  - `-257` = RS256（部分平台/旧设备）
  - `-8` = EdDSA（Ed25519，逐步普及）
    **建议**：至少 `[-7]`；为兼容性可加 `-257`；前瞻可再加 `-8`。

- `excludeCredentials?: [{ id, type, transports? }...]`
  避免同一 Authenticator 重复注册（也可限制每供应商最多 1\~2 把）。([web.dev][1])

- `extensions?: { credProps?: true, ... }`
  建议打开 `credProps: true`，以便在回包里知道是否生成了 `rk`（resident key = 可发现凭据）。

> 这些字段的“形状”和默认值与 WebAuthn 规范一致，SimpleWebAuthn 会帮你生成随机 `challenge` 并做类型转换。参考其“Passkeys”与包文档。([simplewebauthn.dev][2])

---

## 2) `verifyRegistrationResponse(...)`（注册校验）

**关键输入**

- `response`：前端原样回传的对象
- `expectedChallenge`：你发出的那个 challenge
- `expectedOrigin`：前端实际 origin（H5 如 `https://a.com`；App WebView/中间层同）
- `expectedRPID`：上文 `rpID`
- `requireUserVerification: boolean`：**建议 true/或至少 preferred**，确保生物特征/系统 PIN 过一遍。

**关键输出（部分）**

- `verified: boolean`
- `registrationInfo`:

  - `credential: { id, publicKey, counter, transports, aaguid? }`
  - `credentialDeviceType: 'singleDevice' | 'multiDevice'`
  - `credentialBackedUp: boolean`（云端已备份，多设备同步）
    这些在理解“passkey 是不是云同步、多设备”等非常有用。([simplewebauthn.dev][2])

---

## 3) `generateAuthenticationOptions(...)`（登录发起）

- `rpID: string`：同上
- `allowCredentials?: [{ id, type, transports? }...]`
  **不传** → 走**无用户名发现式**（条件 UI / 可发现凭据）。
  如要“只允许此用户的凭据”，可传该用户的已绑定 credentialId 列表。
- `userVerification: 'required' | 'preferred' | 'discouraged'`
  **建议：`required` 或 `preferred`**。
- `timeout?: number`：如 60000
- `extensions?: { appidExclude?, largeBlob? ... }`：一般默认即可。

---

## 4) `verifyAuthenticationResponse(...)`（登录校验）

- `response` / `expectedChallenge` / `expectedOrigin` / `expectedRPID` 同注册
- `authenticator`：从你库里取出的该 credential 的
  `{ credentialID<Buffer>, credentialPublicKey<Buffer>, counter<number>, transports? }`
- `requireUserVerification`：同上
- 输出包含 `newCounter`（要**入库更新**，抵御重放）。

---

# 二、前端配置项（H5 & App）

你前端已经封装了：

- `createRegistrationPayload(publicKeyOptions)`
- `createAuthenticationPayload(publicKeyOptions, { conditional })`

**它们要的 `publicKeyOptions` 就是 WebAuthn 规范里的**：

### A) `PublicKeyCredentialCreationOptions`（注册）

- `rp: { id, name }` —— **rp.id 必须与后端 rpID 一致**
- `user: { id<BufferSource>, name, displayName }`
- `challenge: BufferSource`
- `pubKeyCredParams: [{ type: 'public-key', alg: -7 | -257 | -8 ... }]`
- `timeout?: number`
- `attestation: 'none' | 'direct' | 'indirect' | 'enterprise'` —— 建议 `'none'`
- `authenticatorSelection`（同后端）
- `excludeCredentials?: ...`
- `extensions?: { credProps?: true }`

### B) `PublicKeyCredentialRequestOptions`（登录）

- `rpId: string`
- `challenge: BufferSource`
- `allowCredentials?: ...`（**不传**=可发现凭据）
- `userVerification: 'required' | 'preferred' | 'discouraged'`
- `timeout?: number`
- `extensions?: ...`

### C) H5 的“条件 UI”（无用户名直登）

- Chrome 需传 `mediation: 'conditional'`（有些库用 second param `{ conditional: true }` 实现）
- Safari/iOS/macOS 会自动弹出
  参考 SimpleWebAuthn browser 包文档（含 auto/conditional 说明）。([simplewebauthn.dev][3])

### D) App 端（iOS/Android 原生）

- **iOS** 用 `ASAuthorizationPlatformPublicKeyCredentialProvider`；
  **Android** 用 `androidx.credentials` 的 `CreatePublicKeyCredentialRequest` / `GetPublicKeyCredentialOption`。
  它们都吃**同一份 `publicKey` JSON**（即上面 Options），所以你的 UTS 插件只需**透传**。
  （这也是官方推荐形态，减少 JS ↔ 原生映射误差。）

---

# 三、如何识别“谷歌/苹果/微软”平台？

**权威方式：看 AAGUID**（注册阶段返回的 `authenticatorData` 里带的**设备模型 GUID**）。

- SimpleWebAuthn 在 `verifyRegistrationResponse` 的结果里就可取到（见下方补丁）。
- 然后对照**社区维护的映射表**（含名称与图标 SVG）。

  - **Android / Google Password Manager** 示例 AAGUID：`ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4`。([web.dev][1])
  - **Windows Hello** 常见 AAGUID：
    `08987058-cadc-4b81-b6e1-30de50dcbe96`、`9ddd1817-af5a-4672-a2b9-3e3dd95000a9`、`6028b017-b1d4-4c02-b4b3-afcdafc96bb2`。([Corbado][4])
  - **Apple / iCloud Keychain**：**常返回全零**（出于隐私/无证明情况下），即：`00000000-0000-0000-0000-000000000000`，因此“无法唯一识别”，可标注为“Apple/未知”。([Apple Developer][5])
  - 第三方管理器（1Password、Bitwarden…）请用社区清单匹配（长期维护）。([GitHub][6])

> 注意：**只有在有可验证的 attestation 时，AAGUID 才能被强信任**；iOS/Android 常不给直接证明，所以**只能当“展示用途”**（比如在“已绑定的通行密钥”列表里显示来源与图标）。([web.dev][1])

---

# 四、与前端过程的联动 —— 每个配置项如何在“流”里落位

**注册流（JIT + 可发现凭据）**

1. 前端调 `/passkeys/register/options`
   服务器用上述“推荐值”生成：

   - `attestationType: 'none'`
   - `authenticatorSelection: { residentKey: 'required', userVerification: 'preferred' }`
   - `supportedAlgorithmIDs: [-7]`（可再加 `-257`）
   - `extensions: { credProps: true }`

2. 前端拿到 `options` 后：

   - H5：`createRegistrationPayload(options)`；
   - App：UTS 插件把 `options.publicKey` 透传给 iOS/Android 原生。

3. 后端 `verifyRegistrationResponse(...)`：

   - 对 `expectedChallenge/Origin/RPID` 校验
   - 成功后**落 DB**：`credentialId`、`publicKey`、`counter`、`transports`、`aaguid`、`credentialDeviceType`、`credentialBackedUp`、**（可选）clientEnv**（前端传的系统信息，便于“来源”辅助展示）。

4. 在“我的通行密钥”页：

   - 显示**创建时间**、**最近使用时间**、**来源**（由 AAGUID 映射 + `clientEnv` 兜底）。

**登录流（无用户名直登）**

1. 前端调 `/passkeys/login/options`（不传 `allowCredentials`）

   - 服务器 `generateAuthenticationOptions({ rpID, userVerification: 'required' })`。
   - H5：传 `{ conditional: true }` 开条件 UI；App：直接调原生 GetAPI。

2. `verifyAuthenticationResponse(...)`：

   - 验证签名 + 更新 `counter`；
   - 颁发会话；
   - 记录使用时间（用于“最近使用”展示）。

---

# 五、**最小改动代码片段**（仅贴需要添加/修改的行）

> 遵循你“不要整段完整代码”的偏好。以下三处直接加入即可。

### 1) **注册校验**里：保存 `aaguid` 并映射供应商

**位置**：你的 `verifyRegistration(...)` 逻辑保存凭据之后

```ts
// 在“入库凭据”代码之后，追加以下几行：

// —— 读取 AAGUID（库版本不同，可能在 registrationInfo 或 registrationInfo.credential 下）
// 复杂：兼容字段差异，先取 registrationInfo.aaguid，再尝试 credential.aaguid
const aaguid =
  (verification.registrationInfo as any)?.aaguid ??
  (verification.registrationInfo as any)?.credential?.aaguid ??
  null;

// —— 供应商映射（最小内置 + 可扩展）
const provider = mapAAGUIDToProvider(aaguid);

// —— 更新凭据的元信息（你已有 creds.createCredential，可补个 updateMetadata）
await this.creds.updateCredentialMetadata(credentialIdB64, {
  aaguid,
  provider, // 'Google Password Manager' | 'Windows Hello' | 'Apple/Unknown' | '1Password' | ...
});
```

**并新增一个工具函数（放 service 尾部或 utils）：**

```ts
// 简单映射；建议你结合“社区 AAGUID 列表”按需扩展
function mapAAGUIDToProvider(aaguid?: string | null) {
  if (!aaguid) return "Unknown";
  const v = aaguid.toLowerCase();
  // Google Password Manager (Android)
  if (v === "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4")
    return "Google Password Manager"; // Android
  // Windows Hello
  if (
    v === "08987058-cadc-4b81-b6e1-30de50dcbe96" ||
    v === "9ddd1817-af5a-4672-a2b9-3e3dd95000a9" ||
    v === "6028b017-b1d4-4c02-b4b3-afcdafc96bb2"
  )
    return "Windows Hello";
  // Apple 常返回全零（无证明），只能标注 Unknown/Apple
  if (v === "00000000-0000-0000-0000-000000000000") return "Apple/Unknown";
  // 其他第三方（1Password/Bitwarden…）可按社区清单补充
  return "Unknown";
}
```

> 参考：AAGUID 识别 & 示例、Windows Hello AAGUID 列表、社区映射清单。([web.dev][1])

---

### 2) **注册发起**里：确保“可发现凭据 + credProps”

**位置**：`generateRegistrationOptions(...)` 调用处

```ts
// 调整/补充字段（只示例关键行）
attestationType: 'none',
supportedAlgorithmIDs: [-7], // 兼容性再加 -257
authenticatorSelection: {
  residentKey: 'required',          // ★ 允许无用户名直登
  userVerification: 'preferred',    // 或 'required'
  // authenticatorAttachment: 'platform' // 如你只想收平台内置再打开
},
extensions: { credProps: true },
```

---

### 3) **前端 Verify Body**：附带“环境指纹”（用于供应商兜底判定/显示）

**位置**：你生成 `verifyRegBody` / `verifyBody` 处

```ts
// 复杂：结合 uni.getSystemInfo 的关键字段，告诉后端“来自哪个端”
const sys = await uni.getSystemInfo();
const clientEnv = {
  osName: sys.osName, // 'ios' | 'android' | 'harmonyos' | ...
  uniPlatform: sys.uniPlatform, // 'app' | 'web' | 'mp-weixin' ...
  hostName: sys.hostName || null, // 浏览器/宿主标识（H5/小程序）
};
const verifyRegBody = { ...corePayload, userId, clientEnv }; // 注册 verify
const verifyBody = { ...payload, clientEnv }; // 登录 verify
```

> 这样当 AAGUID 是全零/缺失时（苹果常见），你也能在后台列表用 `osName` 做轻量标注（如 “来自 iOS（Apple/Unknown）”）。

---

# 六、**最佳默认模板**（直接抄）

### 注册 options（后端）

```ts
generateRegistrationOptions({
  rpName: "你的产品名",
  rpID: rpID, // 你的域
  userID: Buffer.from(String(user.id), "utf8"),
  userName: String(user.id),
  attestationType: "none",
  supportedAlgorithmIDs: [-7],
  authenticatorSelection: {
    residentKey: "required",
    userVerification: "preferred",
    // authenticatorAttachment: 'platform'
  },
  extensions: { credProps: true },
});
```

### 登录 options（后端）

```ts
generateAuthenticationOptions({
  rpID,
  userVerification: "required", // 或 preferred
  // 不传 allowCredentials → 可发现凭据直登
});
```

### H5 条件 UI（前端）

```ts
// 复杂：开启条件 UI（Chrome）
const verifyBody = await createAuthenticationPayload(options, {
  conditional: true,
});
```

---

# 七、常见坑 & 提醒

- **RPID / Origin 严格匹配**：H5 与 App WebView/中间层均需一致，否则验签失败。
- **iOS & Android 多数“无 attestation”**：AAGUID 仅作展示，不作强风控。([web.dev][1])
- **计数器务必更新**：每次登录校验通过后，把 `newCounter` 入库。
- **多把 Passkey 管理**：建议列表里展示：创建时间、最近使用、**来源（AAGUID/环境兜底）**，并允许删除。([web.dev][1])
- **算法兼容**：主打 `-7(ES256)`，必要时加 `-257(RS256)`；`-8(EdDSA)`逐步普及但不必强依赖。
- **Android “Credential Manager”** 和 **iOS ASAuthorization**：都吃同一份 `publicKey` JSON，UTS 插件只需透传（你的结构已满足“只在 index.uts 做薄层”的最佳实践）。
- **AAGUID 映射表**：可定期拉取社区清单（本地缓存一份 JSON），但注意它**不是安全来源**，仅供 UI 显示。([GitHub][6])

---

如果你愿意，我可以再给你把**后端 `creds` 表结构里新增 `aaguid/provider/last_used_at`** 的迁移 SQL 和\*\*“通行密钥管理”接口**的最小改动补丁，也按你的规则只贴**修改行\*\*。

[1]: https://web.dev/articles/webauthn-aaguid "Determine the passkey provider with AAGUID  |  Articles  |  web.dev"
[2]: https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com "Passkeys"
[3]: https://simplewebauthn.dev/docs/packages/browser?utm_source=chatgpt.com "simplewebauthn/browser"
[4]: https://www.corbado.com/glossary/windows-hello?utm_source=chatgpt.com "What is Windows Hello? Definition, AAGUID and Role in ..."
[5]: https://developer.apple.com/forums/tags/passkeys-in-icloud-keychain/?page=2&sortBy=lastUpdated&utm_source=chatgpt.com "Passkeys in iCloud Keychain"
[6]: https://github.com/passkeydeveloper/passkey-authenticator-aaguids "GitHub - passkeydeveloper/passkey-authenticator-aaguids: This repo contains a community sourced list of AAGUIDs for passkey credential managers to help with naming in end user management UIs"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[“只绑定了苹果，但在 Windows 的 Chrome 登录怎么办？”——跨设备 Passkey 的正确处理方式（含最小改动代码）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/跨设备 Passkey 的正确处理方式</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/跨设备 Passkey 的正确处理方式"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 快速回答

是的，**把当前用户绑定的所有凭据（credentialId 列表，不是“类型”）都给浏览器**是更稳妥的主路线。即使本机没有该 passkey，也可以通过 **跨设备（Hybrid/caBLE）** 用手机（iPhone/Android）扫码登录：浏览器弹出“用附近设备/手机的通行密钥”选项，展示二维码，用户用手机确认后完成签名。苹果官方与 WebAuthn 规范均明确支持这一路径。([Apple Developer][1])

> 这意味着：**在 Windows 的 Chrome 上，即使用户只在 iPhone（iCloud Keychain）里有 passkey，也能通过**“**用 iPhone 登录**”**扫码完成认证**，前端无需硬拒绝。([苹果支持][2])

---

## 推荐策略（更合理的业界做法）

1. **优先基于真实凭据，而不是猜供应商**：把用户已绑定的所有 `credentialId` 作为 `allowCredentials` 发给浏览器；若用 **Conditional UI**（表单自动填充），规范要求把 `allowCredentials` 设为空数组，让浏览器列出可发现凭据。([web.dev][3])
2. **启用跨设备能力**：为每个 `allowCredentials` 描述符补上 `transports`，包含 `'hybrid'` 等，以便触发“手机扫码登录”的混合传输。规范与 MDN 都有“hybrid/获取可用传输方式”的说明。([W3C][4])
3. **做能力探测与兜底**：

   - `PublicKeyCredential.isConditionalMediationAvailable()` → 支持则走 Conditional UI；([MDN Web Docs][5])
   - 失败（如设备上没有匹配凭据/用户取消）则**回退到** `allowCredentials: []` 或提示“换设备/用手机”。

4. **“类型 type”建议在**“**验证完成后**”**再落定**：后端从**本次使用的 credentialId** 查到供应商（可用 **AAGUID→ 供应商** 映射），再记录 `1=苹果/2=谷歌`。这样比前置“猜类型”健壮。([Apple Developer][6])

---

## 仅需修改的代码片段

> 以下是**在你已有实现基础上**的最小改动：
> 1）更新“选择类型”的函数：**Windows+Chrome 且只绑了苹果**时，不再返回 `-1`，而是**返回 1**，允许跨设备；
> 2）补一个**登录兜底**：先用 allowList 试；失败则退回 **空 allowList +（可用时）Conditional UI**；
> 3）构建 `allowCredentials` 时带上 `transports: ['hybrid', 'internal', 'usb', 'nfc', 'ble']`。

### 1）更新你之前的 `decidePasskeyType`（只改 Windows 分支）

```ts
// 复杂逻辑：Windows 上若无谷歌但绑定了苹果，允许走“混合传输（iPhone 扫码）”
if (isWindows) {
  if (isChromium && hasGoogle) return 2;
  if (hasApple) return 1; // ← 新增：不再直接 -1，支持用 iPhone 跨设备登录
  return -1;
}
```

> 依据：WebAuthn L3 支持 **hybrid** 传输；苹果官方支持在非 Apple 设备上用 iPhone 扫码使用 passkey。([W3C][4])

### 2）构建 `allowCredentials`（新增一个小工具）

```ts
// 复杂逻辑：为每个已绑定凭据提供 transports，开启跨设备选项（hybrid）
function buildAllowCredentials(creds: { id: string }[]) {
  const transports: AuthenticatorTransport[] = [
    "hybrid",
    "internal",
    "usb",
    "nfc",
    "ble",
  ];
  return creds.map((c) => ({
    type: "public-key",
    id: base64urlToUint8Array(c.id),
    transports, // ← 关键
  }));
}
```

> 规范与 MDN 对 `hybrid`/传输有说明；大多数现代 passkey 为“可发现凭据”。([W3C][4])

### 3）登录兜底逻辑（先 allowList，失败再空列表 + Conditional UI）

```ts
// 复杂逻辑：先尝试“精确匹配已绑定凭据”；失败再回退到“让浏览器列出所有可发现凭据”
export async function loginWithFallback(opts: {
  challenge: Uint8Array;
  userCreds: { id: string }[]; // 你的数据库里拿到的本用户全部 credentialId
}) {
  // 尝试 1：用 allowCredentials 精确匹配（含 hybrid，支持跨设备）
  try {
    return await startAuthentication({
      publicKey: {
        challenge: opts.challenge,
        allowCredentials: buildAllowCredentials(opts.userCreds),
        timeout: 45000,
        userVerification: "preferred",
      },
    });
  } catch (e: any) {
    // 复杂逻辑：没有可用凭据/用户取消等 -> 回退到 Conditional UI 或空 allowList
    const supportConditional =
      await PublicKeyCredential.isConditionalMediationAvailable?.();

    return await startAuthentication({
      publicKey: {
        challenge: opts.challenge,
        // 关键：空 allowCredentials 让浏览器展示“可发现凭据”（含手机扫码）
        allowCredentials: [],
        userVerification: "preferred",
      },
      // 条件式 UI 可用则用 'conditional'，否则退到默认
      mediation: supportConditional ? "conditional" : ("optional" as any),
    });
  }
}
```

> 资料：
>
> - **Conditional UI**/表单自动填充与能力探测（`isConditionalMediationAvailable`）。([MDN Web Docs][5])
> - 空 `allowCredentials` → 由浏览器列出**可发现凭据**。([simplewebauthn.dev][7])

> 小提示：Chrome 传入多个 `allowCredentials` 时，UI 可能只挑一个呈现，选择策略并非由你控制，这是正常现象。([Stack Overflow][8])

---

## 服务器端两点备注

- **生成认证参数**：把数据库中的所有本用户凭据（按你愿意的优先级排序）传给 `generateAuthenticationOptions({ allowCredentials })`；若走 Conditional UI 的路由，则按规范**清空** `allowCredentials`。SimpleWebAuthn 文档与规范对这点都有说明。([simplewebauthn.dev][7])
- **确定“type”**：验证成功后，后端能拿到本次使用的 `credentialID`（SimpleWebAuthn 的返回会携带，近期版本将其规范为 base64url 字符串），再根据你存的 **AAGUID→ 供应商** 映射落定 `1/2`；不建议在认证前硬判供应商。([GitHub][9])

---

## 为什么这是主流最佳实践

- **跨设备是官方一等公民**：WebAuthn L3/CTAP 明确“**hybrid**”传输；当本机没有该 passkey 时，可用手机扫码完成登录。([W3C][4])
- **Discoverable credentials/Passkeys 普及**：空 `allowCredentials` 让浏览器列出所有可发现凭据，配合 **Conditional UI** 达到一键直登体验。([web.dev][3])
- **苹果官方明确**：**在非 Apple 设备上也能用 iPhone 的 passkey**（二维码/附近设备）。([Apple Developer][1])

---

## 结论

- 你的理解是对的：**把用户已绑定的所有凭据给浏览器**，浏览器会自动选择本机/外接/手机可用的那一个。
- **在 Windows Chrome 但只绑定了苹果时**，不要提前判 `-1`。按本文最小改动：**类型返回 1**，前端通过 `allowCredentials + hybrid` 与**兜底的空列表/Conditional UI**，就能让用户**用 iPhone 扫码完成登录**。
- 长期看，把“类型”挪到**验证后**基于 `credentialID→AAGUID→供应商` 来落定，才是更健壮的主路线。

[1]: https://developer.apple.com/passkeys/?utm_source=chatgpt.com "Passkeys Overview"
[2]: https://support.apple.com/guide/iphone/use-passkeys-to-sign-in-to-websites-and-apps-iphf538ea8d0/ios?utm_source=chatgpt.com "Use passkeys to sign in to websites and apps on iPhone"
[3]: https://web.dev/articles/webauthn-discoverable-credentials?utm_source=chatgpt.com "Discoverable credentials deep dive | Articles"
[4]: https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com "An API for accessing Public Key Credentials - Level 3"
[5]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isConditionalMediationAvailable_static?utm_source=chatgpt.com "isConditionalMediationAvailable() static method - Web APIs"
[6]: https://developer.apple.com/documentation/authenticationservices/supporting-passkeys?utm_source=chatgpt.com "Supporting passkeys | Apple Developer Documentation"
[7]: https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com "Passkeys"
[8]: https://stackoverflow.com/questions/76330542/webauthn-allowcredentials-and-credential-selection?utm_source=chatgpt.com "Webauthn - allowCredentials and credential selection"
[9]: https://github.com/MasterKale/SimpleWebAuthn/releases?utm_source=chatgpt.com "Releases · MasterKale/SimpleWebAuthn"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「浏览器/平台探测」与 UA 字符串解读（含 UA-CH、WebAuthn 能力探测与实战示例）]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/浏览器/「浏览器/平台探测」与 UA 字符串解读（含 UA-CH、WebAuthn 能力探测与实战示例）</id>
        <link href="https://herongdev.github.io/blog/posts/前端/浏览器/「浏览器/平台探测」与 UA 字符串解读（含 UA-CH、WebAuthn 能力探测与实战示例）"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 一、整体思路

- **优先用 UA-CH（User-Agent Client Hints）**：更隐私、可控，浏览器逐步**冻结**传统 UA 字符串的细节，官方鼓励迁移到 UA-CH。([WICG][1])
- **UA 兜底**：当 UA-CH 不可用或信息不足，再解析 `navigator.userAgent`。([MDN Web Docs][2])
- **能力优先**：涉及 Passkeys/WebAuthn 时，尽量做“**能力探测**”而不是“品牌猜测”，例如探测平台验证器、条件式 UI 等。([MDN Web Docs][3])

## 二、分步实现

### 步骤 1：读取低熵 UA-CH（无需权限）

```ts
// 复杂逻辑：优先读取 UA-CH 的低熵字段，获取平台与品牌
const uaData = (navigator as any).userAgentData;
const platform = uaData?.platform ?? ""; // 例：'Windows' | 'macOS' | 'Android' | 'iOS' ...
const brands = uaData?.brands ?? []; // 例：[ {brand:'Chromium', version:'140'}, {brand:'Microsoft Edge', version:'140'} ]
```

- `platform`：当前平台名称。
- `brands`：浏览器“品牌”列表（Chromium/Chrome/Edge 等），常用于判断是否 Chromium 家族。
  以上字段由 **NavigatorUAData** 暴露，属于 UA-CH 的“低熵”部分。([MDN Web Docs][4])

### 步骤 2：读取高熵 UA-CH（需显式请求）

```ts
// 复杂逻辑：请求高熵字段，获取更细粒度的版本/架构/模式等
const high = uaData
  ? await uaData.getHighEntropyValues([
      "architecture", // CPU 架构：'x86' | 'arm' ...
      "bitness", // 位宽：'64' | '32'
      "model", // 设备型号（移动端常见）
      "platformVersion", // 平台版本：如 Windows 内核版本
      "uaFullVersion", // 浏览器完整版本号
      "fullVersionList", // 全量 brand+version 列表
      "wow64", // 是否 WOW64 兼容层
    ])
  : {};
```

这些字段由 `NavigatorUAData.getHighEntropyValues()` 一次性返回，便于做平台差异化或下载架构选择（如 32/64 位）。([MDN Web Docs][5])

> 常见用途举例：
>
> - **bitness/architecture**：选择下载 64 位或 32 位安装包。([MDN Web Docs][6])
> - **platformVersion**：区分 **Windows 10 vs 11** 的行为、样式或性能开关。([Microsoft Learn][7])
> - **fullVersionList**：更精确地判断浏览器及其完整版本。([MDN Web Docs][5])

### 步骤 3：UA 字符串兜底解析

```ts
// 复杂逻辑：在 UA-CH 不可用时兜底解析 UA 字符串
const ua = navigator.userAgent; // 传统 UA，需注意已逐步“去细节化”
const isEdge = /\bEdg\/([\d.]+)/.test(ua); // Edge 使用 "Edg/..." 标记
const isChrome = /\bChrome\/([\d.]+)/.test(ua) && !isEdge;
const isSafari = /Safari\/[\d.]+$/.test(ua) && !isChrome && !isEdge;
```

- `Navigator.userAgent` 是传统 UA 字符串，仍可用，但细节可能被“冻结”。([MDN Web Docs][2])
- **Edge** 在 UA 中以 `Edg/<version>` 标记；不要只匹配 `Edge`。([MDN Web Docs][8])

### 步骤 4：WebAuthn/Passkeys 能力探测（推荐）

```ts
// 复杂逻辑：是否存在“平台验证器”（本机指纹/面容/Windows Hello 等）
const uvpaa =
  await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();

// 复杂逻辑：是否支持“条件式 UI”（表单自动填充一键直登）
const canConditional = await(
  PublicKeyCredential as any
).isConditionalMediationAvailable?.();

// 复杂逻辑：未来可用：一次性查询浏览器 WebAuthn 能力集合
const caps = await(PublicKeyCredential as any).getClientCapabilities?.();
```

- `isUserVerifyingPlatformAuthenticatorAvailable()`：探测本机是否有“可用户验证”的平台验证器。([MDN Web Docs][3])
- `isConditionalMediationAvailable()`：探测是否支持 **Conditional UI** 登录体验。([MDN Web Docs][9])
- `getClientCapabilities()`：WebAuthn Level 3 引入的能力查询。([MDN Web Docs][10])

---

## 三、UA-CH 字段一览与用途

| 字段              | 类型/示例                                       | 作用与典型用法                                                     |
| ----------------- | ----------------------------------------------- | ------------------------------------------------------------------ |
| `platform`        | `"Windows"` / `"macOS"` / `"Android"` / `"iOS"` | 粗粒度平台判断（低熵）。([MDN Web Docs][4])                        |
| `brands`          | `[{brand:'Chromium',version:'140'}...]`         | 判断是否基于 Chromium、有哪些品牌标识（低熵）。([MDN Web Docs][4]) |
| `architecture`    | `"x86"` / `"arm"`                               | CPU 架构（高熵，需申请）。([MDN Web Docs][5])                      |
| `bitness`         | `"64"` / `"32"`                                 | 选择 64/32 位资源（高熵）。([MDN Web Docs][6])                     |
| `model`           | `"iPhone"` 等                                   | 设备型号（移动端常见，高熵）。([MDN Web Docs][5])                  |
| `platformVersion` | `"13.0.0"`                                      | Windows 11 等版本区分（高熵）。([Microsoft Learn][7])              |
| `uaFullVersion`   | `"140.0.0.0"`                                   | 浏览器完整版本（高熵）。([MDN Web Docs][5])                        |
| `fullVersionList` | `[{brand:'Chromium',version:'140.0.0.0'}, ...]` | 更精确识别品牌+版本（高熵）。([MDN Web Docs][5])                   |
| `wow64`           | `true/false`                                    | 是否运行在 WOW64 兼容层（高熵）。([MDN Web Docs][5])               |

> 注意：UA-CH 的“高熵”字段需要通过 JS 显式请求或服务端通过 `Accept-CH` 提示，浏览器才会提供。([MDN Web Docs][4])

---

## 四、最简代码示例

> 仅演示关键探测点；复杂逻辑处已在上一行写注释。

```ts
// 复杂逻辑：综合 UA-CH 与 UA，返回 { platform, isChromium, isEdge, isSafari, versions }
export async function detectRuntime() {
  const navAny = navigator as any;
  const uaData = navAny.userAgentData;
  const ua = navigator.userAgent;

  let platform = "";
  let brands: Array<{ brand: string; version: string }> = [];
  let fullVersionList: Array<{ brand: string; version: string }> = [];

  if (uaData) {
    platform = uaData.platform ?? "";
    brands = uaData.brands ?? [];
    try {
      // 复杂逻辑：尽量取到完整版本列表
      const high = await uaData.getHighEntropyValues(["fullVersionList"]);
      fullVersionList = high.fullVersionList ?? [];
    } catch {}
  }

  // 复杂逻辑：判断 Chromium 家族（从 brands 与 UA 双通道）
  const brandsText = brands.map((b) => b.brand).join(" ");
  const isChromium =
    /Chrom(e|ium)|Google Chrome|Microsoft Edge|Opera|OPR|Brave/i.test(
      brandsText
    ) || /\b(Chrome|Chromium|Edg|OPR|Brave)\b/i.test(ua);

  // 复杂逻辑：Edge、Chrome、Safari 的基本判断
  const isEdge = /\bEdg\/[\d.]+/.test(ua);
  const isChrome = /\bChrome\/[\d.]+/.test(ua) && !isEdge;
  const isSafari = /Safari\/[\d.]+$/.test(ua) && !isChrome && !isEdge;

  return {
    platform,
    isChromium,
    isEdge,
    isSafari,
    versions: { brands, fullVersionList },
  };
}

// 复杂逻辑：WebAuthn 能力探测（平台验证器 & 条件式 UI）
export async function detectWebAuthn() {
  const uvpaa =
    await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
  const canConditional = await (
    PublicKeyCredential as any
  ).isConditionalMediationAvailable?.();
  const caps = await (PublicKeyCredential as any)
    .getClientCapabilities?.()
    .catch(() => undefined);
  return { uvpaa, canConditional, caps };
}
```

- UA-CH 的 **fullVersionList** 提供比 UA 更稳的“品牌+完整版本”。([MDN Web Docs][5])
- WebAuthn 的三个静态探测方法可用于决定是否展示 **条件式 UI**、是否允许**平台凭据**登录等。([MDN Web Docs][3])

---

## 五、UA 字符串逐段拆解（实战）

给定 UA：

```
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
(KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0
```

逐段含义：

- **`Mozilla/5.0`**：历史兼容标记，表示“与 Mozilla 兼容”。如今几乎所有浏览器都会带上它。([Stack Overflow][11])
- **`(Windows NT 10.0; Win64; x64)`**：平台信息（Windows，内核版本 10.0，64 位）。
- **`AppleWebKit/537.36`**：渲染引擎历史标识（WebKit/Blink 系都常带此段，出于兼容）。([MDN Web Docs][8])
- **`(KHTML, like Gecko)`**：历史说明“像 Gecko 一样”，早期对站点嗅探的兼容产物。
- **`Chrome/140.0.0.0`**：**Chromium/Chrome** 基因的版本号片段。
- **`Safari/537.36`**：同样是历史兼容字段，非真正 Safari 也会带。([MDN Web Docs][8])
- **`Edg/140.0.0.0`**：**Microsoft Edge** 的明确标记（注意是 `Edg/` 而非 `Edge/`）。([MDN Web Docs][8])

> 结论：这串 UA 同时包含 WebKit/Chrome/Safari 的历史兼容片段，**真正决定“它是 Edge”的是结尾的 `Edg/140...`**。这就是你看到“怎么什么都有”的原因：**为了兼容旧站点的 UA 嗅探**，浏览器刻意保留了多段看似“矛盾”的标识。([MDN Web Docs][8])

---

## 六、最佳实践与注意事项

1. **能用 UA-CH 就别靠 UA**：UA 正在“去细节化/冻结”，准确性和可持续性不如 UA-CH。([MDN Web Docs][4])
2. **WebAuthn 以“能力探测”为先**：优先根据 `uvpaa/conditional` 等能力决定登录体验，而非“浏览器品牌”。([MDN Web Docs][3])
3. **确定“供应商/来源”时用 AAGUID**：注册阶段记录 **AAGUID**（如需），比 UA/UA-CH 更可靠。([web.dev][12])

---

## 七、快速参考

- UA-CH 规范与 API：MDN、WICG 文档与 Chrome 指南。([MDN Web Docs][4])
- UA 基础与 Edge 标记：MDN UA 参考、Microsoft 文档。([MDN Web Docs][8])
- WebAuthn 能力：MDN 与 WebAuthn Level 3。([MDN Web Docs][3])

> 有了上述探测与解读框架，你就可以**稳定地拿到平台/浏览器/能力**信息，并在 Passkeys 场景里用“**能力优先**”的策略，提供更一致的登录体验。

[1]: https://wicg.github.io/ua-client-hints/?utm_source=chatgpt.com "User-Agent Client Hints - GitHub Pages"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgent?utm_source=chatgpt.com "Navigator: userAgent property - Web APIs - MDN - Mozilla"
[3]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isUserVerifyingPlatformAuthenticatorAvailable_static?utm_source=chatgpt.com "isUserVerifyingPlatformAuthentic..."
[4]: https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API?utm_source=chatgpt.com "User-Agent Client Hints API - Web APIs - MDN - Mozilla"
[5]: https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData/getHighEntropyValues?utm_source=chatgpt.com "NavigatorUAData: getHighEntropyValues() method - Web APIs"
[6]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Sec-CH-UA-Bitness?utm_source=chatgpt.com "Sec-CH-UA-Bitness header - HTTP - MDN"
[7]: https://learn.microsoft.com/en-us/microsoft-edge/web-platform/how-to-detect-win11?utm_source=chatgpt.com "Detect Windows 11 and CPU architecture using User ..."
[8]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/User-Agent?utm_source=chatgpt.com "User-Agent header - HTTP - MDN - Mozilla"
[9]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isConditionalMediationAvailable_static?utm_source=chatgpt.com "isConditionalMediationAvailable() static method - Web APIs"
[10]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential?utm_source=chatgpt.com "PublicKeyCredential - Web APIs - MDN"

[11]: https://stackoverflow.com/questions/5125438/why-do-chrome-and-ie-put-mozilla-5-0-in-the-user-agent-they-send-to-the-server?utm_source=chatgpt.com "Why do Chrome and IE put \"Mozilla 5.0\" in the User-Agent ..."
[12]: https://web.dev/articles/webauthn-aaguid?utm_source=chatgpt.com "Determine the passkey provider with AAGUID | Articles"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TOTP 验证器（Google/Microsoft）原理与前后端实现全解析]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/TOTP 验证器（Google/Microsoft）原理与前后端实现全解析</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/TOTP 验证器（Google/Microsoft）原理与前后端实现全解析"/>
        <updated>2025-09-12T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## TL;DR

- **原理**：Google/Microsoft 等验证器本质上都是 **OATH 标准的 TOTP**（基于时间的一次性密码），源自 RFC 6238（基于 HOTP/RFC 4226 扩展）。默认 **30 秒**一换码，**6 位**数字，使用 **HMAC-SHA1/256/512** 计算。([IETF Datatracker][1])
- **绑定**：后端生成一个 **Base32 密钥（secret）**，拼成 `otpauth://` URI 给前端展示为 **二维码**；用户用验证器扫二维码 → 验证器开始本地算码 → 用户回填**一次性验证码**到后端校验 → 校验通过即开启 2FA。**不需要、也不应该再把 secret 发回后端**（后端已经有）。([GitHub][2])
- **实现**：前端渲染二维码（例如 qrcode），后端用库（Node.js `otplib`、Python `pyotp`、Java `java-otp`）生成 secret、构造 `otpauth://`、校验验证码并完成持久化与风控。([Otplib][3])

---

## 一、常见验证器与差异

- **Google Authenticator**：标准 TOTP，支持扫描 `otpauth://`，可选**账号云同步**（注意隐私权衡）。([Google 帮助][4])
- **Microsoft Authenticator**：同样支持 **OATH TOTP**（也有推送批准与“数字匹配”功能，和 TOTP 是两种形态）。([Microsoft Learn][5])

> 这两款在“扫描二维码 → 本地计算一次性验证码”的 **TOTP** 场景是**互通**的。

---

## 二、工作原理（够用但准确）

1. **HOTP（事件计数）**：`code = Truncate(HMAC(K, counter))`，每用一次计数+1。([IETF][6])
2. **TOTP（时间计数）**：把计数器换成时间片 `C = floor((now - T0)/period)`，常见 `period=30s`，默认 6 位数字。支持 SHA1/256/512。([IETF Datatracker][1])
3. **密钥分发**：用 `otpauth://TYPE/Label?secret=...&issuer=...&period=30&digits=6&algorithm=SHA1`，`secret` 为 **Base32** 编码。验证器扫二维码后就能开始计算。([GitHub][2])

---

## 三、你描述的“绑定流程”有个小修正

> “我把**码和密钥**发给后端完成绑定” —— **不建议**这样做。

**推荐安全流程**（后端早已生成并持有 secret）：

1. **后端**生成 `secret(Base32)`，构造 `otpauth://`，返回 **二维码（或明文 secret 供手输）**。
2. **用户**用验证器扫描 → 验证器本地算出 6 位码。
3. **用户只回填一次性验证码**（6 位码）到后端；
4. **后端**用已保存的 secret 验证这 6 位码（允许 ±1 时间片容差），通过则标记已绑定。
5. 保存与保护 secret（加密存储），并发放**恢复码**、开启风控策略（节流、重试限制等）。
   （规范与参数见 RFC/Key URI/OWASP）。([IETF Datatracker][1])

---

## 四、接口设计（REST 示例）

### 1）获取绑定二维码

- `POST /api/mfa/setup`
- **入参**：需要登录态（谁要开 2FA）
- **返回**：

```json
{
  "setupId": "uuid",
  "otpauthUri": "otpauth://totp/YourApp:alice@example.com?secret=JBSW...&issuer=YourApp&period=30&digits=6&algorithm=SHA1",
  "secret": "JBSW..." // 仅用于手动输入时显示，可视为敏感信息
}
```

> 服务器同时把 `setupId -> secret(加密)` 存为“待验证”状态。([GitHub][2])

### 2）确认绑定

- `POST /api/mfa/verify`
- **入参**：`{ "setupId": "uuid", "code": "123456" }`
- **逻辑**：根据 `setupId` 取回 secret，用 TOTP 校验 `code`（窗口 ±1），通过则把 secret 迁移到用户正式配置并标记 2FA 已启用。

### 3）登录二次校验

- `POST /api/mfa/challenge` 获取挑战态
- `POST /api/mfa/challenge/verify` 入参 `{code}`，通过即颁发登录态/刷新期。

---

## 五、前端实现要点

- **二维码渲染**：拿到 `otpauthUri` 后用前端库（如 `qrcode`）渲染为 `<img/>`；失败时提供明文 `secret` 供手输。
- **时间同步**：前端不参与计算（验证器自己会算），但要**清晰的错误提示**与**重试节流**。
- **隐私**：二维码只在 HTTPS 下展示，避免 DOM 截图/日志泄露。

**示例（React/TS）**：

```ts
// 复杂逻辑：把 otpauth:// 转成 DataURL 并渲染二维码
import QRCode from "qrcode";

export async function otpauthToDataUrl(otpauthUri: string) {
  // 复杂逻辑：qrcode 库异步生成 Base64 DataURL
  return await QRCode.toDataURL(otpauthUri);
}
```

---

## 六、后端实现（Node.js / TypeScript，基于 otplib）

> 库说明：`otplib` 同时支持 HOTP/TOTP，符合 RFC 4226/6238。([npm][7])

```ts
// 复杂逻辑：生成 Base32 secret、构造 otpauth URI
import { authenticator } from "otplib";
// 可选：全局参数（30 秒步长，±1 个时间片容差）
authenticator.options = { step: 30, window: [1, 1] };

export function createMfaSetup(email: string, issuer = "YourApp") {
  // 复杂逻辑：随机生成 Base32 secret（服务端保存加密后的密文）
  const secret = authenticator.generateSecret(); // Base32
  // 复杂逻辑：构造 otpauth:// URI（二维码内容）
  const otpauth = authenticator.keyuri(email, issuer, secret);
  return { secret, otpauth };
}

export function verifyMfaCode(secretBase32: string, code: string) {
  // 复杂逻辑：用同一 secret 校验 6 位码（允许 ±1 时间片）
  return authenticator.verify({ token: code, secret: secretBase32 });
}
```

---

## 七、后端实现（Python / FastAPI，基于 PyOTP）

> 库说明：`pyotp` 用于生成与校验 TOTP。([pyauth.github.io][8])

```py
# 复杂逻辑：生成 secret、构造 otpauth、校验验证码
import pyotp

def create_mfa_setup(email: str, issuer: str = "YourApp"):
    # 复杂逻辑：随机 Base32 secret
    secret = pyotp.random_base32()
    # 复杂逻辑：构造 otpauth:// URI
    otpauth = pyotp.totp.TOTP(secret).provisioning_uri(name=email, issuer_name=issuer)
    return secret, otpauth

def verify_mfa_code(secret_base32: str, code: str) -> bool:
    # 复杂逻辑：默认 30s 步长，可设置 valid_window=1 允许前后各一窗
    return pyotp.TOTP(secret_base32).verify(code, valid_window=1)
```

---

## 八、后端实现（Java / Spring Boot，基于 `java-otp`）

> `com.eatthepath:java-otp` 默认 **30s 步长、6 位、HmacSHA1**；如需 Base32 解码可用 `commons-codec`。([JChambers][9])

```java
// 复杂逻辑：用 java-otp 校验 TOTP（30s 步长，±1 时间片手动容忍）
import com.eatthepath.otp.TimeBasedOneTimePasswordGenerator;
import org.apache.commons.codec.binary.Base32;

import javax.crypto.spec.SecretKeySpec;
import java.time.Duration;
import java.time.Instant;
import java.security.Key;

public boolean verifyTotp(String base32Secret, String code) throws Exception {
    // 复杂逻辑：Base32 -> key（算法与生成器一致，默认 HmacSHA1）
    byte[] keyBytes = new Base32().decode(base32Secret);
    Key key = new SecretKeySpec(keyBytes, "HmacSHA1");

    TimeBasedOneTimePasswordGenerator totp =
        new TimeBasedOneTimePasswordGenerator(Duration.ofSeconds(30));

    // 复杂逻辑：当前时间片生成一次性密码
    int current = totp.generateOneTimePassword(key, Instant.now());

    // 复杂逻辑：容忍前后各一窗（手动再算前/后时间片）
    int prev = totp.generateOneTimePassword(key, Instant.now().minusSeconds(30));
    int next = totp.generateOneTimePassword(key, Instant.now().plusSeconds(30));

    return code.equals(String.format("%06d", current)) ||
           code.equals(String.format("%06d", prev)) ||
           code.equals(String.format("%06d", next));
}
```

---

## 九、关键安全实践清单

- **不要把 secret 回传**：后端生成并**安全保存**（建议加密存储，密钥托管/分区权限）。([OWASP Cheat Sheet Series][10])
- **加密传输**：二维码与手输 secret 仅在 **HTTPS** 下展示/传输。
- **时间同步**：服务器启用 **NTP**，校验窗口建议 **±1** 时间片。([IETF Datatracker][1])
- **速率限制**：验证码校验接口加 **节流/黑名单**（参考 OWASP 身份验证与 MFA 指南）。([OWASP Cheat Sheet Series][11])
- **恢复码**：提供一次性恢复码（建议哈希存储）；丢机/换机时用于解锁与重置。
- **最小展示**：二维码只展示一次；需要重扫需重新申请。
- **微软差异**：若采用 **推送+数字匹配** 是另一套流程；与 TOTP 并行存在，不同管控策略。([Microsoft Learn][12])
- **参数一致**：前后端 period/digits/algorithm 必须一致（Key URI 可显式声明，默认 period=30、digits=6）。([GitHub][2])

---

## 十、与官方/标准对齐的“广泛调研”要点

- **TOTP/HOTP 标准**：RFC 6238（TOTP）、RFC 4226（HOTP）。([IETF Datatracker][1])
- **Key URI（otpauth://）**：Base32 `secret`、`issuer`、`digits`、`period` 等参数定义与默认值。([GitHub][2])
- **Google 文档**：Authenticator 的 2 步验证与离线生成机制；近年新增“可选云同步”。([Google 帮助][4])
- **Microsoft 文档**：Authenticator 作为软件 **OATH TOTP** 令牌的说明；30s 周期；ASP.NET Core 生成二维码指南。([Microsoft Learn][5])
- **实现库**：Node.js `otplib`、Python `pyotp`、Java `java-otp`。([npm][7])
- **OWASP**：MFA 与机密管理实践。([OWASP Cheat Sheet Series][13])

---

## 十一、最简落地清单（按顺序做就能跑）

1. **后端**：选库（otplib/pyotp/java-otp），实现 `createMfaSetup()` + `verifyMfaCode()`；密钥**加密**入库。([npm][7])
2. **前端**：拿 `otpauthUri` 用 `qrcode` 渲染二维码，提供“我已扫码，输入 6 位验证码”表单。
3. **接口**：`/mfa/setup`（出二维码）→`/mfa/verify`（校验码，窗口 ±1）；失败次数上限与冷却。
4. **登录**：若用户已开启 2FA，密码通过后进入 `/mfa/challenge` 流程再校验一次码。
5. **运维**：NTP 校时；日志打点（不要记录 secret 与明文码）；WAF/节流；**恢复码**与**紧急解绑**流程。

---

## 十二、FAQ

- **Q：为什么非要 Base32？**
  A：因为 `otpauth://` 约定用 Base32 传递共享密钥，兼容主流验证器（Google 等）。([GitHub][2])

- **Q：能不能把 secret 只存在用户手机？**
  A：TOTP 是**对称**方案，服务端必须持有同一 secret 才能独立计算并比对；若不想让服务器持有密钥，考虑 **FIDO2/Passkeys** 之类的非对称方案。

- **Q：微软“数字匹配”和 TOTP 的关系？**
  A：数字匹配是**推送验证**的增强，与 TOTP 同在 Authenticator 里，但协议/交互不同；TOTP 仍是 6 位码输入式。([Microsoft Learn][12])

---

## 参考链接

- RFC 6238（TOTP）/ RFC 4226（HOTP）标准文本。([IETF Datatracker][1])
- Google：Authenticator 使用与 2 步验证说明。([Google 帮助][4])
- Key URI Format（otpauth）。([GitHub][2])
- Microsoft：Authenticator 作为 OATH TOTP 软件令牌、30 秒周期与二维码生成。([Microsoft Learn][5])
- OWASP：MFA/Secrets 管理的安全实践。([OWASP Cheat Sheet Series][13])

---

### 附：最小可用接口返回样例（便于对接）

```json
// /api/mfa/setup
{
  "setupId": "7a4f2b3c-8a7e-4d31-9b5e-2c6a1e...",
  "otpauthUri": "otpauth://totp/YourApp:alice@example.com?secret=KZXW6YTB...&issuer=YourApp&period=30&digits=6&algorithm=SHA1",
  "secret": "KZXW6YTB..." // 仅在“显示手动输入”时使用
}
```

```json
// /api/mfa/verify
{
  "ok": true,
  "enabledAt": "2025-09-12T08:00:00Z",
  "recoveryCodesIssued": 10
}
```

> 到这一步，你就能用 Google/Microsoft 验证器完成标准 TOTP 绑定与登录校验了。

[1]: https://datatracker.ietf.org/doc/html/rfc6238?utm_source=chatgpt.com "RFC 6238 - TOTP: Time-Based One-Time Password Algorithm"
[2]: https://github.com/google/google-authenticator/wiki/Key-Uri-Format "Key Uri Format · google/google-authenticator Wiki · GitHub"
[3]: https://otplib.yeojz.dev/?utm_source=chatgpt.com "Supports HOTP, TOTP and Google Authenticator"
[4]: https://support.google.com/accounts/answer/1066447?co=GENIE.Platform%3DAndroid&hl=en&utm_source=chatgpt.com "Get verification codes with Google Authenticator - Android"
[5]: https://learn.microsoft.com/en-us/entra/identity/authentication/concept-authentication-authenticator-app?utm_source=chatgpt.com "Authentication methods in Microsoft Entra ID"
[6]: https://www.ietf.org/rfc/rfc4226.txt?utm_source=chatgpt.com "RFC 4226 HOTP: An HMAC-Based One-Time Password ..."
[7]: https://www.npmjs.com/package/otplib?utm_source=chatgpt.com "otplib"
[8]: https://pyauth.github.io/pyotp/?utm_source=chatgpt.com "PyOTP documentation - GitHub Pages"
[9]: https://jchambers.github.io/java-otp/apidocs/latest/com/eatthepath/otp/TimeBasedOneTimePasswordGenerator.html?utm_source=chatgpt.com "TimeBasedOneTimePasswordG..."
[10]: https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html?utm_source=chatgpt.com "Secrets Management - OWASP Cheat Sheet Series"
[11]: https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html?utm_source=chatgpt.com "Authentication - OWASP Cheat Sheet Series"
[12]: https://learn.microsoft.com/en-us/entra/identity/authentication/how-to-mfa-number-match?utm_source=chatgpt.com "How number matching works in MFA push notifications for ..."
[13]: https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html?utm_source=chatgpt.com "Multifactor Authentication - OWASP Cheat Sheet Series"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vite+Vue3 无损引入“二次验证/Step-Up Authentication”的最佳实践]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/鉴权-登录/Vite+Vue3 无损引入“二次验证/Step-Up Authentication”的最佳实践</id>
        <link href="https://herongdev.github.io/blog/posts/前端/鉴权-登录/Vite+Vue3 无损引入“二次验证/Step-Up Authentication”的最佳实践"/>
        <updated>2025-09-13T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 为什么是“Step-Up”，而不是到处塞 MFA 弹窗？

“Step-Up Authentication（按需提升认证强度）”的核心思想：**只有在访问敏感资源或执行高风险操作时才触发更强认证**，其余场景保持无感体验。业界标准把这种“按需抬升”的需求讲得很清楚：

- OAuth 2.0 的 _Step-up Authentication Challenge Protocol（RFC 9470）_ 定义了**资源服务**如何向**客户端**发出“当前令牌强度/新鲜度不够，请抬升”的挑战机制。([IETF Datatracker][1])
- OpenID Connect 通过 `acr_values`（要求的认证保证级别）与 `max_age`（认证新鲜度）实现**按需重认证**。([openid.net][2])
- OWASP 与 NIST 建议：对**修改敏感设置、支付、提权**等操作启用额外验证，并优先使用抗钓鱼要素（如 WebAuthn/Passkeys）。([OWASP Cheat Sheet Series][3])
- FIDO 联盟给出了 _Passkeys_ 的落地与 UX 指南，强调**抗钓鱼、设备/生态无缝**。([FIDO Alliance][4])

> 结论：把“二次验证”作为**策略驱动**的“中间步骤”，由后端决定是否挑战、挑战什么；前端只负责**编排**与**体验**。

---

## 总体架构（前后端协同）

### 1) 后端：策略与挑战（Policy → Challenge）

- 后端根据**操作类型、用户风险、上下文**（IP/设备/金额/频率等）判定是否需要 Step-Up，返回**挑战描述**（类型、可选要素、过期时间、绑定的 actionId/nonce）。参考 RFC 9470 的思路，也可在 API 返回 `WWW-Authenticate`/业务错误码 `step_up_required`。([IETF Datatracker][1])
- 支持 OIDC 生态时，结合 `acr_values`/`max_age` 做**会话新鲜度**控制。([openid.net][2])
- **强绑定**：挑战签发应与**具体操作**与**参数摘要**绑定，服务端校验防重放。

### 2) 前端：编排与无侵入集成（Orchestrator）

- \*\*Orchestrator（编排器）\*\*接收挑战，**按策略动态加载对应验证器插件**（SMS/Email/TOTP/WebAuthn…），验证成功产出 `verificationToken` 或“短期抬升态”。
- **请求拦截与重放**：当 API 返回“需要 Step-Up”，拦截器暂停原请求 → 触发编排 → 携带验证结果**自动重试**，对各业务**零侵入**。
- **TTL（新鲜度）**：在前端维护**短期“已抬升”态**，与后端 `max_age`/服务端 TTL 对齐；超过 TTL 再次挑战。([openid.net][2])

---

## 引入模式对比与组合拳

### A. **HTTP 拦截器（首选：无侵入）**

- 对所有 API 统一处理 `step_up_required`（或 401 + `insufficient_authentication`）。
- 优点：**改动最小**；对“提交后补挑战”的场景尤其友好。
- 适合你现在“基本业务完成后”的**插入式改造**。

### B. **动作包装器/装饰器（细粒度）**

- 提供 `verifiedAction(policyKey, fn)`：在点击“转账”“删除”“导出敏感数据”前**先确保验证**。
- 优点：**显式**、便于审计与埋点；与指令/路由守卫可混用。

### C. **自定义指令 `v-verify`（模板友好）**

- 作用到按钮/链接，自动完成**拦截-挑战-放行**。

### D. **路由守卫 + meta**

- 对**进入敏感页面**或**离开页面触发关键提交**的路由，基于 `meta.requiresStepUp` 或 `meta.stepUpPolicy` 调用 Orchestrator。
- 注意：你提到的 `meta` 很合适，但**仍建议搭配拦截器**兜底（防绕过）。

> 组合拳：**拦截器兜底 + 动作包装器/指令标注关键按钮 + 路由守卫保护敏感视图**。

---

## 验证器插件化（Strategy + Adapter）

为后续“新增/调整验证方式”做到**无修改核心逻辑**：

**接口约束（示意）**

```ts
// 复杂逻辑：统一的验证器接口，便于动态加载与替换
export interface StepUpVerifier {
  type: "sms" | "email" | "totp" | "webauthn" | string;
  // 上一行：开始验证，返回验证结果（token/证明）；可能需要展示弹窗
  start(challenge: ChallengePayload): Promise<{ token: string }>;
}
```

**动态注册**

```ts
// 上一行：插件注册表，按类型选择具体验证器
const registry = new Map<string, () => Promise<StepUpVerifier>>();
registry.set(
  "webauthn",
  async () => (await import("./verifiers/webauthn")).webauthnVerifier
);
registry.set("sms", async () => (await import("./verifiers/sms")).smsVerifier);
// ... email, totp, etc.
```

> WebAuthn/Passkeys 是首选要素（抗钓鱼），NIST/OWASP 均建议**减少对短信 OTP 的依赖**。([pages.nist.gov][5])

---

## 与后端的“挑战”契约（建议草案）

```json
{
  "error": "step_up_required",
  "actionId": "transfer:create",
  "nonce": "b64u-abc...",
  "expiresIn": 180,
  "allowed": ["webauthn", "totp", "sms", "email"],
  "webauthnOptions": {
    "challenge": "b64u-...",
    "rpId": "example.com",
    "userVerification": "required"
  },
  "display": { "title": "二次验证", "hint": "本次操作金额 ¥10,000" }
}
```

- **actionId/nonce**：与具体操作和参数摘要绑定，成功后服务端只接受**一次性**使用。
- **allowed**：后端**发号施令**，前端只做编排；便于灰度/风控。
- **webauthnOptions**：与通行密钥交互时的公参。

> 若接 OIDC/OAuth：服务端也可通过 `acr`、`max_age` 判定是否“够强/够新鲜”。([openid.net][2])

---

## 最小落地代码（仅给**需要调整**的片段）

> 说明：以下片段为**插入式**改造，你可逐步替换具体实现。按你的偏好，对复杂逻辑我在**上一行加注释**。

### 1) Axios 拦截器（统一拦截并重试）

```ts
// 上一行：拦截 step_up_required，触发编排，拿到 token 后自动重试原请求
instance.interceptors.response.use(
  (r) => r,
  async (err) => {
    const res = err.response;
    if (res?.data?.error === "step_up_required") {
      const challenge = res.data as ChallengePayload;
      const token = await orchestrator.ensure(challenge);
      // 上一行：把验证 token 附加到原请求头并重试
      const cfg = {
        ...err.config,
        headers: {
          ...(err.config?.headers || {}),
          "X-Verification-Token": token,
        },
      };
      return instance.request(cfg);
    }
    throw err;
  }
);
```

### 2) 编排器 Orchestrator（核心最小实现）

```ts
// 上一行：根据挑战类型动态选择验证器，并缓存短期抬升态（TTL）
export const orchestrator = {
  lastElevatedAt: 0,
  ttlMs: 2 * 60 * 1000, // 与后端对齐
  async ensure(challenge: ChallengePayload): Promise<string> {
    const now = Date.now();
    if (now - this.lastElevatedAt < this.ttlMs) return "__ELEVATED__";
    const pick = challenge.allowed[0]; // 可加策略：优选 webauthn
    const loader = registry.get(pick);
    if (!loader) throw new Error("No verifier for " + pick);
    const verifier = await loader();
    const { token } = await verifier.start(challenge);
    this.lastElevatedAt = Date.now();
    return token;
  },
};
```

### 3) 动作包装器（按钮点击装饰）

```ts
// 上一行：包装敏感动作，先请求后端“可否直通”，若需抬升则自动挑战
export async function verifiedAction<T>(
  policyKey: string,
  action: () => Promise<T>
): Promise<T> {
  const pre = await api.verify.check(policyKey); // 返回 ok 或 step_up_required + challenge
  if (pre.ok) return action();
  const token = await orchestrator.ensure(pre.challenge);
  return actionWithToken(action, token); // 你的 action 内部或拦截器会带上 token
}
```

### 4) 指令 `v-verify`

```ts
// 上一行：在模板上用 v-verify="'transfer:create'" 包裹按钮点击
app.directive("verify", {
  mounted(el, binding) {
    const policyKey: string = binding.value;
    el.addEventListener("click", async (e: Event) => {
      e.preventDefault();
      await verifiedAction(policyKey, async () => {
        el.dispatchEvent(new CustomEvent("verified-click", { bubbles: true }));
      });
    });
  },
});
```

### 5) 路由守卫 + meta（可选强化）

```ts
// 上一行：进入敏感路由前检查新鲜度；不够新鲜则拉起挑战
router.beforeEach(async (to) => {
  const policyKey = to.meta?.stepUpPolicy as string | undefined;
  if (!policyKey) return true;
  const pre = await api.verify.check(policyKey);
  if (pre.ok) return true;
  const token = await orchestrator.ensure(pre.challenge);
  api.setVerificationToken(token);
  return true;
});
```

---

## 后端落地注意事项（要点）

- **响应语义**：使用统一错误码 `step_up_required`，或遵循 RFC 9470 的挑战头部（更标准化）。([IETF Datatracker][1])
- **一事一令牌**：`verificationToken` **与 actionId+参数摘要 绑定**，一次有效，过期即失效，服务端强校验重放与跨用。
- **新鲜度**：对抬升态设置 `max_age`（如 2–5 分钟），并在 ID/Access Token 的 `auth_time`/`acr` 中反映。([openid.net][2])
- **要素优先级**：优先 WebAuthn/Passkeys → TOTP → 邮箱 → 短信（NIST/OWASP 不鼓励短信作为唯一高保证要素）。([pages.nist.gov][5])
- **速率限制与风控**：挑战频控、验证码发送速率、设备指纹；与风控联动只影响**是否挑战/挑战强度**。
- **审计**：记录 `actionId / subject / acr / auth_time / challengeId / 结果`，支持追溯。
- **合规**：支付相关可参考 PSD2/SCA（如果涉欧）。([WIRED][6])

---

## SPA/前端工程的细节最佳实践

- **拦截器优先**：对“提交后才知道要二次验证”的路径最友好。
- **懒加载验证器**：以 `registry.set('webauthn', () => import(...))` 方式，减少首屏成本。
- **UI 独立**：一个统一的 `StepUpModal` 通过事件总线/Pinia 控制，**编排与 UI 分离**，便于换壳。
- **并发队列**：同一时刻只处理一个挑战；后续相同原因的请求**复用**验证结果（TTL 内）。
- **可观测性**：对每次挑战上报埋点（触发原因、耗时、放弃率），做 UX 调优。
- **灰度/开关**：用**特性开关**（env 或远程配置）控制“哪些 policy 生效、优先要素顺序”。
- **安全基线**：参考 OWASP ASVS 清单做验收。([OWASP][7])

---

## 业界资料（便于与你的后端/安全同学对齐）

- Auth0/Okta 的 Step-Up 实践与示例，理解**产品化语义**与**接入点**。([Auth0][8])
- NIST 800-63B 数字身份指南（AAL、OTP 要求等）与最新修订页。([pages.nist.gov][5])
- OWASP MFA/Authentication Cheat Sheets 与 ASVS。([OWASP Cheat Sheet Series][3])
- OAuth 2.0 Step-Up Challenge（RFC 9470），OpenID Connect `max_age`/`acr_values`。([IETF Datatracker][1])
- FIDO/Passkeys 与 UX 指南。([FIDO Alliance][4])
- SPA 安全最佳实践总览（token/重认证/前端风险面）。([Curity][9])

---

## 渐进式落地路线图（建议）

1. **第 1 天**：后端统一 `step_up_required` 响应语义；前端加 **Axios 拦截器**（空实现）。
2. **第 2–3 天**：实现 Orchestrator + 插件注册表；先接 **WebAuthn** 与 **TOTP** 两类验证器。
3. **第 4 天**：把**高风险按钮**替换为 `verifiedAction` 或 `v-verify`；对敏感路由加 `meta.stepUpPolicy`。
4. **第 5 天**：接通后端**短期抬升 TTL** 与绑定校验；完成**审计埋点**。
5. **第 6–7 天**：补充 **SMS/Email** 兜底，要素优先级策略；按 ASVS 走一轮安全自测。([OWASP][7])

---

## 你可以直接复制使用的“接口与约定”清单

- 前端入口：`verifiedAction(policyKey, fn)`、`v-verify` 指令、路由 `meta.stepUpPolicy`。
- 服务端约定：`step_up_required` 挑战载荷（含 `actionId/nonce/allowed/webauthnOptions/expiresIn`），成功返回 `verificationToken`。
- 传递方式：请求头 `X-Verification-Token` 或基于会话的“短期抬升”。
- TTL：2–5 分钟（与 `max_age` 对齐），超时重新挑战。([openid.net][2])

---

### 最后一句

**不要在每个页面硬塞 MFA**。把“二次验证”抽象成**策略 + 编排 + 验证器插件**三段式，再用**拦截器兜底**，你就能在现有 Vite+Vue3 项目中**低改动、高可维护**地完成“中间步骤”的无损引入。

[1]: https://datatracker.ietf.org/doc/rfc9470/?utm_source=chatgpt.com "RFC 9470 - OAuth 2.0 Step Up Authentication Challenge ..."
[2]: https://openid.net/specs/openid-connect-core-1_0.html?utm_source=chatgpt.com "OpenID Connect Core 1.0 incorporating errata set 2"
[3]: https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html?utm_source=chatgpt.com "Multifactor Authentication - OWASP Cheat Sheet Series"
[4]: https://fidoalliance.org/passkeys/?utm_source=chatgpt.com "Passkeys: Passwordless Authentication"
[5]: https://pages.nist.gov/800-63-3/sp800-63b.html?utm_source=chatgpt.com "NIST Special Publication 800-63B"
[6]: https://www.wired.com/story/online-shopping-psd2-strong-customer-authentication?utm_source=chatgpt.com "Your online shopping will soon require more than just a bank card"
[7]: https://owasp.org/www-project-application-security-verification-standard/?utm_source=chatgpt.com "OWASP Application Security Verification Standard (ASVS)"
[8]: https://auth0.com/docs/secure/multi-factor-authentication/step-up-authentication?utm_source=chatgpt.com "Add Step-up Authentication"
[9]: https://curity.io/resources/learn/spa-best-practices/?utm_source=chatgpt.com "Using OAuth for Single Page Applications | Best Practices"

好的，我按你们\*\*“由管理后台下发策略 → 前端在特定页面按策略执行多要素验证（MFA）→ 验证通过后继续流程”**的模式，给出**可无损接入**的最佳实现方案。以下只给到**需要新增/修改的关键代码片段\*\*（新文件我给最小完整实现），复杂逻辑我在**上一行加注释**。

---

## 一、核心思路（贴合你们现状）

1. **策略拉取**：在进入“需保护的页面/操作”时，调用
   `POST /api/security/begin`（可携带 `security_code`、`credential_type`、可选 `passage_key`）。
   返回的数据里包含：

- `status`：1 已验证，0 未验证
- `steps: Step[]`：**多步骤编排**；每个 Step 是一组 `conditions`，`operator` 为 **AND/OR**
- `passage_key`：本轮验证会话标识（后续各要素提交时携带）

2. **前端编排**：

- 以**编排器 Orchestrator**承接 `steps` 并驱动 UI：当 `AND` 时逐个做完；`OR` 时由用户**任选其一**完成。
- **验证器插件化**（Strategy）：`sms_validate`、`email_validate`、`app_validate`、`biometric_validate` 等各自封装调用**各自后端发送/校验接口**（你们已有或即将提供），统一产出 `{ ok, proof }`。
- 统一通过 `passage_key + security_code` 绑定，必要时调用 `/api/security/begin` **带回 `passage_key` 进行复核**，以拿到最新 `status=1`。
- **最小侵入**：提供 `verifiedAction(security_code, action)` 与 `v-verify` 指令；老业务只需在**关键按钮**或**提交前**套一层即可。

> 注：你们的 `begin` 返回已把“要验证什么、AND/OR 关系”表达清楚，前端只做**编排**与**展现**，这正是最佳职责边界。

---

## 二、类型与 API 封装（新增文件：`/src/security/types.ts`、`/src/security/api.ts`）

### `/src/security/types.ts`（新文件：完整最小实现）

```ts
// 上一行：与后端约定的类型（仅关键字段），供全局复用
export interface SecurityBeginReq {
  security_code: string;
  credential_type?: "1" | "2";
  passage_key?: string;
  [k: string]: any;
}

export interface SecurityBeginRes {
  code: number;
  message: string;
  data: {
    begin_time: string;
    expire_time: string;
    passage_key: string;
    security_code: string;
    status: "0" | "1";
    steps: Step[];
    use_cnt: string;
    [k: string]: any;
  };
}

export interface Step {
  operator: "AND" | "OR";
  conditions: Condition[];
  [k: string]: any;
}

export interface Condition {
  type:
    | "sms_validate"
    | "email_validate"
    | "app_validate"
    | "biometric_validate"
    | string;
  result: "pending" | "passed" | "failed" | string;
  failed_cnt: number;
  send_cnt: number;
  parameters: { length?: number; [k: string]: any };
  [k: string]: any;
}

export type VerifyProof = { ok: boolean; proof?: string; detail?: any };
```

### `/src/security/api.ts`（新文件：完整最小实现）

```ts
import axios from "axios";
import type { SecurityBeginReq, SecurityBeginRes } from "./types";

// 上一行：统一封装 begin 接口，后续可插入重试/鉴权
export async function apiSecurityBegin(payload: SecurityBeginReq) {
  const { data } = await axios.post<SecurityBeginRes>(
    "/api/security/begin",
    payload
  );
  if (data.code !== 0 && data.code !== 200)
    throw new Error(data.message || "security begin failed");
  return data.data;
}
```

> 说明：其它要素的**发送/校验接口**（例如 `/api/security/sms/send`、`/api/security/sms/verify`、`/api/security/webauthn/verify` 等）由**各验证器插件**各自调用，避免耦合。

---

## 三、编排器 Orchestrator（新增：`/src/security/orchestrator.ts`）

> 编排器职责：**拉策略 → 执行 AND/OR → 复核状态**；内部通过**注册表**调用各验证器插件。

```ts
import { apiSecurityBegin } from "./api";
import type { Condition, Step, VerifyProof } from "./types";

// 上一行：验证器接口，插件需实现 start()，自行完成发送/校验与 UI 交互
export interface Verifier {
  // 上一行：执行该要素的完整流程（含弹窗/输入/调用后端），返回是否成功与证明
  start(ctx: {
    condition: Condition;
    passageKey: string;
    securityCode: string;
  }): Promise<VerifyProof>;
}

// 上一行：插件注册表，按后端的 type 选择具体验证器
const registry = new Map<string, () => Promise<Verifier>>();
export function registerVerifier(
  type: string,
  loader: () => Promise<Verifier>
) {
  registry.set(type, loader);
}

// 上一行：核心编排：处理 AND/OR；支持 UI 选择 OR 内的要素（通过 onPick 回调）
export async function runSecurityFlow(input: {
  securityCode: string;
  credentialType?: "1" | "2";
  passageKey?: string;
  // 上一行：用于 OR 场景让用户选择具体要素（比如弹出选择器）
  onPick?: (conds: Condition[]) => Promise<Condition>;
}) {
  let { passageKey } = input;
  // 上一行：1) 拉取/刷新策略（可复用传入的 passageKey 提升并发体验）
  const begin = await apiSecurityBegin({
    security_code: input.securityCode,
    credential_type: input.credentialType,
    passage_key: passageKey,
  });
  passageKey = begin.passage_key;

  // 已验证直接放行
  if (begin.status === "1") return { ok: true, passageKey };

  // 上一行：2) 逐步执行 steps
  for (const step of begin.steps) {
    // AND：每个都要过
    if (step.operator === "AND") {
      for (const cond of step.conditions) {
        // 上一行：失败可允许重试或切换通道（此处最小实现为循环直到成功或抛错上层处理）
        const ok = await runOneCondition(cond, input.securityCode, passageKey);
        if (!ok) throw new Error("验证未通过");
      }
    } else {
      // OR：任选其一
      const choice = input.onPick
        ? await input.onPick(step.conditions)
        : preferChoice(step.conditions);
      const ok = await runOneCondition(choice, input.securityCode, passageKey);
      if (!ok) throw new Error("验证未通过");
    }
  }

  // 上一行：3) 复核状态，确保服务端已将 status 置为 1（对齐风控与新鲜度）
  const confirm = await apiSecurityBegin({
    security_code: input.securityCode,
    credential_type: input.credentialType,
    passage_key: passageKey,
  });
  if (confirm.status !== "1") throw new Error("服务端未确认验证通过");
  return { ok: true, passageKey };
}

// 上一行：执行单个条件（按 type 动态加载插件，失败时可在内部控制重试/错误提示）
async function runOneCondition(
  cond: Condition,
  securityCode: string,
  passageKey: string
) {
  const loader = registry.get(cond.type);
  if (!loader) throw new Error(`未注册验证器: ${cond.type}`);
  const verifier = await loader();
  const { ok } = await verifier.start({
    condition: cond,
    passageKey,
    securityCode,
  });
  return ok;
}

// 上一行：OR 默认优先选择更强抗钓鱼要素；你也可改为总是让用户选择
function preferChoice(conds: Condition[]) {
  const order = [
    "biometric_validate",
    "app_validate",
    "totp_validate",
    "email_validate",
    "sms_validate",
  ];
  const ranked = [...conds].sort(
    (a, b) => order.indexOf(a.type) - order.indexOf(b.type)
  );
  return ranked[0] || conds[0];
}
```

---

## 四、验证器插件（示例：短信与通行密钥）

> 你们的验证接口路径未给出，我用占位 `/api/security/sms/send|verify`、`/api/security/webauthn/verify` 示意；你只需把**请求路径和参数名**替换为后端实际实现即可。

### `/src/security/verifiers/sms.ts`（新文件：最小实现）

```ts
import axios from "axios";
import type { Verifier } from "../orchestrator";
import type { Condition } from "../types";

// 上一行：弹窗交互最小实现（请替换为你们的全局弹窗/表单组件）
async function promptCode(length = 6): Promise<string> {
  const input = window.prompt(`请输入短信验证码（${length}位）`) || "";
  return input.trim();
}

export default {
  // 上一行：发送验证码 + 输入 + 校验，最终返回 ok
  async start({ condition, passageKey, securityCode }) {
    await axios.post("/api/security/sms/send", {
      passage_key: passageKey,
      security_code: securityCode,
    });
    const code = await promptCode(condition.parameters?.length ?? 6);
    const { data } = await axios.post("/api/security/sms/verify", {
      passage_key: passageKey,
      security_code: securityCode,
      code,
    });
    return { ok: data?.code === 0 || data?.code === 200 };
  },
} satisfies Verifier;
```

### `/src/security/verifiers/webauthn.ts`（新文件：最小实现）

```ts
import axios from "axios";
import type { Verifier } from "../orchestrator";

// 上一行：调用 WebAuthn 验证（navigator.credentials.get），并提交给后端核验
export default {
  async start({ passageKey, securityCode }) {
    // 上一行：从后端获取 assertion options（含 challenge、rpId 等）
    const { data: optResp } = await axios.post(
      "/api/security/webauthn/options",
      {
        passage_key: passageKey,
        security_code: securityCode,
      }
    );
    const options = optResp.data;

    // 上一行：拉起通行密钥验证（浏览器原生框）
    const cred = (await navigator.credentials.get({
      publicKey: {
        challenge: base64urlToBuffer(options.challenge),
        timeout: options.timeout ?? 60000,
        rpId: options.rpId,
        allowCredentials: options.allowCredentials?.map((c: any) => ({
          id: base64urlToBuffer(c.id),
          type: "public-key",
          transports: c.transports,
        })),
        userVerification: options.userVerification ?? "required",
      },
    })) as PublicKeyCredential;

    // 上一行：把客户端证明发回后端校验
    const verification = await axios.post("/api/security/webauthn/verify", {
      passage_key: passageKey,
      security_code: securityCode,
      id: cred.id,
      type: cred.type,
      rawId: bufferToBase64url(cred.rawId),
      response: {
        clientDataJSON: bufferToBase64url(cred.response.clientDataJSON),
        authenticatorData: bufferToBase64url(
          (cred.response as any).authenticatorData
        ),
        signature: bufferToBase64url((cred.response as any).signature),
        userHandle: bufferToBase64url(
          (cred.response as any).userHandle || new ArrayBuffer(0)
        ),
      },
    });
    return {
      ok: verification.data?.code === 0 || verification.data?.code === 200,
    };
  },
} satisfies Verifier;

// 工具函数
function base64urlToBuffer(b64u: string) {
  const pad = "=".repeat((4 - (b64u.length % 4)) % 4);
  const b64 = (b64u + pad).replace(/-/g, "+").replace(/_/g, "/");
  const raw = atob(b64);
  const buf = new ArrayBuffer(raw.length);
  const view = new Uint8Array(buf);
  for (let i = 0; i < raw.length; ++i) view[i] = raw.charCodeAt(i);
  return buf;
}
function bufferToBase64url(buf: ArrayBuffer) {
  const bytes = new Uint8Array(buf);
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) s += String.fromCharCode(bytes[i]);
  return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
```

### **在入口处注册插件**（修改片段：`/src/security/register.ts`）

```ts
import { registerVerifier } from "./orchestrator";

// 上一行：按需懒加载（避免首屏体积）
registerVerifier(
  "sms_validate",
  async () => (await import("./verifiers/sms")).default
);
registerVerifier(
  "biometric_validate",
  async () => (await import("./verifiers/webauthn")).default
);
// 可继续：email_validate、app_validate ...
```

---

## 五、交互层：统一 StepUp 弹窗（任选其一/必须全部）

> 如果你已有全局弹窗系统（如基于 Ant Design Vue/Element Plus），只需在 **OR 场景**里提供**要素选择器**。我给一个**事件驱动**的最小示例。

### 选择器回调（修改片段：`/src/security/ui.ts`）

```ts
import type { Condition } from "./types";

// 上一行：弹出选择器，返回用户选中的 Condition；可替换为你们现有的 Modal
export async function pickOne(conds: Condition[]): Promise<Condition> {
  const label = (c: Condition) =>
    ((
      {
        sms_validate: "短信验证",
        email_validate: "邮箱验证",
        app_validate: "验证器 App",
        biometric_validate: "通行密钥",
      } as any
    )[c.type] || c.type);
  const names = conds.map(label).join(" / ");
  const ok =
    window.prompt(
      `本步骤可任选其一：${names}\n请输入你选择的方式（例如：短信验证）`
    ) || "";
  const found = conds.find((c) => label(c) === ok.trim());
  return found || conds[0];
}
```

---

## 六、对业务“无损”接入的两种方式

### A. **动作包装器**（推荐，用于按钮/提交）

**新增文件：**`/src/security/verifiedAction.ts`

```ts
import { runSecurityFlow } from "./orchestrator";
import { pickOne } from "./ui";

// 上一行：包装敏感动作；先执行二次验证，通过后再执行 action
export async function verifiedAction<T>(
  securityCode: string,
  action: () => Promise<T>
): Promise<T> {
  const { ok } = await runSecurityFlow({
    securityCode,
    onPick: async (conds) => pickOne(conds),
  });
  if (!ok) throw new Error("二次验证未通过");
  return action();
}
```

**使用处仅需改动一行**（示例：提交转账）：

```ts
// 上一行：用 verifiedAction 包一层，security_code 用管理后台配置的唯一值
await verifiedAction("transfer:create", async () => {
  await api.transfer.submit(form);
});
```

### B. **自定义指令 `v-verify`**（无需改动方法签名，模板友好）

**新增文件：**`/src/security/directive.ts`

```ts
import type { DirectiveBinding } from "vue";
import { runSecurityFlow } from "./orchestrator";
import { pickOne } from "./ui";

// 上一行：点击前触发验证，通过后再“转发一次 click”事件给业务层
export const vVerify = {
  mounted(el: HTMLElement, binding: DirectiveBinding<string>) {
    const securityCode = binding.value;
    el.addEventListener("click", async (e) => {
      e.preventDefault();
      const { ok } = await runSecurityFlow({ securityCode, onPick: pickOne });
      if (ok) {
        // 上一行：验证通过后模拟一次“已验证点击”，由业务层监听
        el.dispatchEvent(new CustomEvent("verified-click", { bubbles: true }));
      }
    });
  },
};
```

**使用处模板只需轻改**：

```vue
<!-- 上一行：在按钮上加 v-verify，并在业务里监听 verified-click -->
<button v-verify="'transfer:create'" @verified-click="onSubmit">转账</button>
```

---

## 七、可选兜底：Axios 响应拦截器（当后端在提交后才提示需验证）

> 许多时候，用户点了“提交”，后端此时才返回“需要验证”。为**无感**体验，可在响应拦截里识别约定的错误码（例如 `code=46001`），触发编排并**自动重放**原请求。

**修改片段：`/src/request/interceptor.ts`**

```ts
import axios from "axios";
import { runSecurityFlow } from "@/security/orchestrator";
import { pickOne } from "@/security/ui";

axios.interceptors.response.use(
  (r) => r,
  async (error) => {
    const res = error?.response;
    // 上一行：示例错误码/标识，请与你们后端约定（这里用 message=step_up_required 占位）
    if (
      res?.data?.message === "step_up_required" &&
      res?.data?.data?.security_code
    ) {
      const securityCode = res.data.data.security_code as string;
      const { ok } = await runSecurityFlow({ securityCode, onPick: pickOne });
      if (ok) {
        // 上一行：把验证态绑定到会话后，重放原请求（通常无需额外头）
        return axios.request(error.config);
      }
    }
    throw error;
  }
);
```

---

## 八、工程与体验要点（落地建议）

- **按需懒加载**验证器，避免首屏增重；失败可**退回选择器**改用其它通道（OR 步骤）。
- **统一弹窗容器**：推荐用你们现有的全局 Modal（我用 `window.prompt` 仅做最小演示）。
- **复核机制**：完成所有 Step 后再次 `begin(passage_key)` 确认 `status=1`，避免前端单边判断。
- **失败处理**：`failed_cnt`、`send_cnt` 用于 UI 提示与频控；连续失败时提供**改用其他要素**的入口。
- **可观测性**：在编排器各阶段打埋点（触发来源、用时、放弃率、切换通道），便于后续 UX 调优。
- **无损改造顺序**：
  1）落地 `runSecurityFlow + 注册表` →
  2）在关键按钮外层用 `verifiedAction` 包住 →
  3）必要时加 **拦截器兜底** →
  4）逐步替换为统一 Modal 交互与更友好的表单 UI。

---

如果你把**短信/邮箱/验证器 App**的**具体接口**路径与参数名给我，我可以把上面的插件示例改成**可直接调用**的版本；或者把你们的**全局弹窗组件**名字告诉我，我把 `window.prompt` 的占位实现替换成你们的 UI 组件调用即可。

你说得对：要“代码最少、好维护、好扩展、用起来顺手”，就该**把“启用判断 + 编排执行”封进一个外观（Facade）服务**，再在**入口层**提供三件套（**装饰器、指令、包装器**）——业务侧按喜好任选其一即可。
内部用**Strategy（验证器插件）+ Composite（AND/OR 组合）+ Decorator（方法装饰器）**。下面只给**需要新增/修改的片段**；复杂逻辑我在**上一行加注释**。

---

## 1) 外观服务（Facade）：`MFAService`（集中最小 API，10 个场景一处配置）

**新增片段：`/src/security/mfa.service.ts`**

```ts
// 上一行：统一外观：缓存 list、调用 begin、执行编排（对外只暴露 isRequired / ensure / run）
export const MFAService = {
  _map: new Map<string, true>(),
  _fetchedAt: 0,
  _ttlMs: 60_000,

  // 上一行：拉取并缓存 /api/security/list，O(1) 判断是否启用
  async isRequired(code: string) {
    const now = Date.now();
    if (this._map.size === 0 || now - this._fetchedAt > this._ttlMs) {
      const list = await apiSecurityList();
      this._map = new Map(list.map((i) => [i.model_value, true]));
      this._fetchedAt = now;
    }
    return this._map.has(code);
  },

  // 上一行：执行完整的“拉策略→按 AND/OR 执行→复核”并处理 OR 的选择
  async ensure(
    code: string,
    opts?: {
      credentialType?: "1" | "2";
      onPick?: (c: Condition[]) => Promise<Condition>;
    }
  ) {
    return runSecurityFlow({
      securityCode: code,
      credentialType:
        opts?.credentialType ??
        (/\b(iPhone|iPad|Mac|Safari)\b/i.test(navigator.userAgent) ? "1" : "2"),
      onPick: opts?.onPick ?? pickOne,
    });
  },
};
```

> 说明：`apiSecurityList`、`runSecurityFlow`、`pickOne` 你已按前文有基础实现，无需改结构。

---

## 2) **包装器**（函数式最少侵入，适合按钮/提交）

**新增/修改片段：`/src/security/verifiedAction.ts`**

```ts
// 上一行：用 Facade 收口：先看 list，启用才执行编排；否则直通
export async function verifiedAction<T>(
  securityCode: string,
  action: () => Promise<T>
): Promise<T> {
  if (!(await MFAService.isRequired(securityCode))) return action();
  const { ok } = await MFAService.ensure(securityCode);
  if (!ok) throw new Error("二次验证未通过");
  return action();
}
```

**使用处只改一行（示例）**：

```ts
// 上一行：把原有提交包一层即可
await verifiedAction("bind_auth", () => api.bindAuthApp(form));
```

---

## 3) **装饰器**（Decorator）：一行声明给方法加 MFA（Controller/Service 最好用）

**新增片段：`/src/security/decorators.ts`**

```ts
// 上一行：方法装饰器：自动在调用前执行 MFA，成功后再调用原方法
export function RequireMFA(code: string) {
  return function (_target: any, _key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = async function (...args: any[]) {
      if (await MFAService.isRequired(code)) {
        const { ok } = await MFAService.ensure(code);
        if (!ok) throw new Error("二次验证未通过");
      }
      // 上一行：验证通过后才执行原方法
      return original.apply(this, args);
    };
  };
}
```

**使用处（示例，仅改方法签名一行）**：

```ts
// 上一行：在页面/Store 方法上加装饰器即可
@RequireMFA('bind_auth')
async function onSubmit() {
  await api.bindAuthApp(form);
}
```

---

## 4) **自定义指令**（Directive）：模板最友好，零改业务事件签名

**新增/修改片段：`/src/security/directive.ts`**

```ts
// 上一行：点击前执行 MFA，通过后分发“verified-click”事件给原业务逻辑
export const vVerify = {
  mounted(el: HTMLElement, binding: { value: string }) {
    const code = binding.value;
    el.addEventListener("click", async (e) => {
      e.preventDefault();
      if (await MFAService.isRequired(code)) {
        const { ok } = await MFAService.ensure(code);
        if (!ok) return;
      }
      // 上一行：验证通过后再补发一次“已验证点击”事件
      el.dispatchEvent(new CustomEvent("verified-click", { bubbles: true }));
    });
  },
};
```

**使用处（模板只加指令与事件名）**：

```vue
<!-- 上一行：不改原方法，只把 @click 换成 @verified-click -->
<button v-verify="'bind_auth'" @verified-click="onSubmit">绑定验证器</button>
```

---

## 5) **验证器插件**（Strategy）：一次注册，全站可用

**新增/修改片段：`/src/security/register.ts`**

```ts
// 上一行：注册验证器策略；可懒加载，类型由后端 conditions.type 决定
registerVerifier(
  "sms_validate",
  async () => (await import("./verifiers/sms")).default
);
registerVerifier(
  "email_validate",
  async () => (await import("./verifiers/email")).default
);
registerVerifier(
  "app_validate",
  async () => (await import("./verifiers/app")).default
);
registerVerifier(
  "biometric_validate",
  async () => (await import("./verifiers/webauthn")).default
);
```

---

## 6) **组合模式**（Composite）：AND/OR 由编排器已实现，无需业务关心

> 你已有 `runSecurityFlow(steps)`，内部是**AND 全过 / OR 让用户选 1 个**。
> 如需“OR 时给默认推荐”，只改一处排序逻辑即可：
> **修改片段：`/src/security/orchestrator.ts`**

```ts
// 上一行：OR 优先级：通行密钥 > App/TOTP > 邮箱 > 短信
const order = [
  "biometric_validate",
  "app_validate",
  "totp_validate",
  "email_validate",
  "sms_validate",
];
```

---

## 7) **路由集成**（可选）：提示徽标 + 守卫预检（无需阻塞）

**修改片段：路由配置与守卫**

```ts
// 上一行：在敏感页面 meta 写上唯一 code（与后台 list 的 model_value 一致）
meta: {
  security_code: "bind_auth";
}
```

```ts
// 上一行：进入路由前标注 mfaRequired 供 UI 显示徽标（不强制挑战）
router.beforeResolve(async (to) => {
  const code = to.meta?.security_code as string | undefined;
  if (code) (to.meta as any).mfaRequired = await MFAService.isRequired(code);
  return true;
});
```

---

## 8) **提交后兜底**（拦截器）：策略临时变化仍然无感

**修改片段：`/src/request/interceptor.ts`**

```ts
// 上一行：当后端临时要求 Step-up 时，自动执行 MFA 并重放请求
if (
  res?.data?.message === "step_up_required" &&
  res?.data?.data?.security_code
) {
  const code = res.data.data.security_code as string;
  const { ok } = await MFAService.ensure(code);
  if (ok) return axios.request(error.config);
}
```

---

## 9) 你在 10 个场景里的“改动成本”对比

- 喜欢**最少改动**：用**装饰器** → 只在方法上加 `@RequireMFA('code')`。
- 喜欢**模板清晰**：用**指令** → 在按钮上加 `v-verify="'code'"`，把 `@click` 改为 `@verified-click`。
- 喜欢**函数式**：用**包装器** → `await verifiedAction('code', () => doSomething())`。

> 三者**共用同一个 Facade/编排/策略注册**，因此**维护点只有一处**；后续新增第 11、12 个场景，只是**填一个 code**，没有新样板代码。

---

## 10) 为什么这是“最佳做法”（结合你的诉求）

- **代码最少**：业务侧只写一个 `code`；其余都在 Facade/编排层。
- **易维护**：`/api/security/list`、`/api/security/begin` 的变化只改 `MFAService` 或 `orchestrator`。
- **易扩展**：新增验证方式只需 `registerVerifier('xxx', loader)`。
- **使用方便**：三种入口（装饰器/指令/包装器）覆盖 Controller、模板、函数三类习惯。
- **设计模式落地**：

  - Facade（`MFAService`）收口复杂度；
  - Strategy（`registerVerifier`）插拔验证器；
  - Composite（`runSecurityFlow` 的 AND/OR）；
  - Decorator（`@RequireMFA`）零侵入增强。

如果你确定采用**哪一种入口为主**（比如全用装饰器），我可以把对应那条链路再“打磨到 3 行就能用”的程度，并把你们实际的短信/邮箱/APP/通行密钥接口参数**替换进插件**。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/mediation 放在 credentials.get 顶层到底干嘛]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/mediation 放在 credentials.get 顶层到底干嘛</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/mediation 放在 credentials.get 顶层到底干嘛"/>
        <updated>2025-09-18T17:26:53.141Z</updated>
        <content type="html"><![CDATA[## 1）`mediation` 放在 `credentials.get` 顶层到底干嘛？

`navigator.credentials.get({ publicKey, mediation })` 的 `mediation` 是**取凭据的“介入方式”**，跟 WebAuthn 的 `publicKey` 选项是两块：

- **`'conditional'`（条件式 UI）**

  - 典型用法：页面一加载或输入框聚焦就发起 `get(...)`，浏览器在**输入框自动填充/下拉**里展示“用通行密钥登录”。
  - **不需要用户先点击按钮**；用户从下拉里点某个账号，Promise 才 resolve。
  - 适合“无用户名/可发现凭据（discoverable）”的直登体验。

- **`'optional'`（默认）**

  - 需要**按钮触发**（用户激活）后弹系统对话框。
  - 适合你现在“点击【使用通行密钥登录】”这类显式触发。

- **`'required'`**

  - 强制出现“选择/确认”的 UI，不走自动化；对 WebAuthn 实际体验上跟 `optional` 区别不大，更多用于“别走自动登录”的场景。

- **`'silent'`**

  - WebAuthn 基本不可用（不会静默给你断言），可忽略。

> 结论：
>
> - **自动填充场景** → 用 `'conditional'`。
> - **点击按钮场景** → 用 `'optional'`（或 `'required'`，差别很小）。

## 2）`mode: 'roaming_only'` 是什么？

这是**我们上文建议的自定义字段**，不是 WebAuthn 规范。
用途：告诉你的**前端/风控逻辑**“这次必须用**漫游安全密钥**（USB/NFC/BLE 的硬件钥）”。前端据此可以改变文案与兜底逻辑（例如失败就提示插入安全钥、给出备用登录方式等）。

> 标准层面真正起作用的是 `allowCredentials` 的**筛选集合**和 `userVerification` 的强度要求，`mode` 只是你系统内的**状态标签**。

## 3）为什么没看到“安全密钥选择列表”，只提示“使用某种介质”？

看你后端返回的 options：

```json
{
  "extensions": { "extensions": [] },
  "challenge": "1758013239513162",
  "timeout": null,
  "rpId": "www.52wukong.com",
  "allowCredentials": [
    { "type": "public-key", "id": "/NlEbL4Ozv4C+ZIig+td7Q==", "transports": [] }
  ],
  "userVerification": null
}
```

关键问题有三点：

1. **你把 `allowCredentials` 限定为“只有这一个 credentialId”**

   - 浏览器就会**直接走这个凭据**，不会给你“选择其它方式/设备”的列表（比如“附近的手机/iPhone/Google 管理器”）。
   - 如果这枚凭据是**硬件钥**，UI 就只会提示“插入/轻触/连接”（也就是你看到的“用介质”）。
   - 想要看到“用手机/用钥匙串/附近设备”的更多选项，**不要传 `allowCredentials`**（走可发现凭据），让浏览器自己找可用的 passkey 与跨设备选项。

2. **`transports: []` 是空的**

   - 这是**提示性信息**，空数组会让提示很“泛”（比如 Safari 就只说“使用安全密钥”，不显示 USB/NFC/BLE 的具体指引）。
   - 如果这是硬件钥，请把你保存的 `transports`（如 `["usb","nfc","ble"]`）**回填**进去，用户引导会更清晰。

3. **强度与超时未设置**

   - `userVerification: null` → 建议明确：

     - 普通登录用 `'preferred'`；
     - 高风险必须 `'required'`。

   - `timeout: null` → 建议设置具体毫秒（如 60000）。

> 额外提醒：
>
> - 你这份 `id` 看起来是 **Base64**（含 `+` `/` `=`），前端转换函数能兼容就行；规范常用 **base64url**。
> - `extensions` 里套了个 `extensions` 字段没意义，可以直接删掉或按需设置真正的扩展。

---

## 4）后端应该怎么回（只给必要片段）

### A. 通用登录（让用户可以用**本机或跨设备**的任何 passkey；适合 Safari/Chrome/iOS/Android 混合人群）

```ts
// 上一行：通用直登，不传 allowCredentials，交给浏览器发现
const options = await generateAuthenticationOptions({
  rpID: "www.52wukong.com",
  userVerification: "preferred", // 高风险可切 'required'
  timeout: 60000,
  // 不要传 allowCredentials
  // extensions: { /* 需要才加，如 devicePubKey */ }
});

// 上一行：把 mediation 发给前端放在 credentials.get 顶层（自动填充体验）
return { options, mediation: "conditional" as const };
```

效果：

- Safari 上即便用户只在 Android/Google 那边绑定过，仍可通过**跨设备**（二维码/附近设备）完成登录。
- Chrome 上能直接调起 Google Password Manager 的 passkey。
- iOS 上能调起 iCloud 钥匙串。
- 你不做“平台”限定，不会把用户锁死。

### B. 高风险 → **只允许“安全密钥（硬件钥）”**

```ts
// 上一行：从你库里筛出该用户“硬件钥”憑据（transports 包含 usb/nfc/ble）
const roamingCreds = userCreds.filter((c) =>
  c.transports?.some((t) => ["usb", "nfc", "ble"].includes(t))
);

if (roamingCreds.length > 0) {
  const options = await generateAuthenticationOptions({
    rpID: "www.52wukong.com",
    userVerification: "required", // 强制本地解锁
    timeout: 60000,
    allowCredentials: roamingCreds.map((c) => ({
      id: base64url.toBuffer(c.credentialId),
      type: "public-key",
      // 上一行：把已存的 transports 回填，改善提示（USB/NFC/BLE）
      transports: c.transports as any,
    })),
  });

  // 上一行：自定义标签，供前端 UI/风控使用（非 WebAuthn 规范）
  return {
    options,
    mediation: "required" as const,
    mode: "roaming_only" as const,
  };
}

// 上一行：没有硬件钥 → 回落通用直登但强 UV，并提示用户尽快绑定安全钥
const fallback = await generateAuthenticationOptions({
  rpID: "www.52wukong.com",
  userVerification: "required",
  timeout: 60000,
});
return {
  options: fallback,
  mediation: "optional" as const,
  mode: "any_passkey_fallback" as const,
};
```

---

## 5）前端只需改这两行（你已有按钮触发场景）

```diff
- const cred = await navigator.credentials.get({ publicKey })
+ // 上一行：把后端返回的 mediation 放到顶层（conditional/optional/required）
+ const cred = await navigator.credentials.get({ publicKey, mediation })
```

（自动填充场景才用 `'conditional'`；按钮点击可用 `'optional'` 或 `'required'`。）

---

## 6）一份“为什么不出现选择列表”的速查清单

- ✅ 想看到“附近设备 / 钥匙串 / Google 管理器” → **不传 `allowCredentials`**（discoverable）。
- ✅ 只想让硬件钥可用 → **传 `allowCredentials = 仅硬件钥的 credentialId 集合`**，并把 **`transports` 正确回填**。
- ✅ 高风险 → `userVerification: 'required'`。
- ✅ 自动填充体验（无需点击） → 顶层 `mediation: 'conditional'`。
- ⚠️ 传了单个 `allowCredentials` → 浏览器**直奔该凭据**，不会给你“选择其它方式”的 UI（你现在就是这个情况）。
- ⚠️ `transports: []` → 提示信息会很“泛”，尽量回填 `["usb","nfc","ble"]` 等。
- ⚠️ `rpId` 必须匹配当前页面域（或用 Related Origins 机制），否则 `SecurityError`。

结论：这是**注册（create）用的 options**，不是登录（get）。结构里有几处会导致体验或兼容性问题：`challenge` 低熵/格式不规范、`user.id` 类型不对、`pubKeyCredParams` 为空、`extensions` 形态不对、`timeout` 为 null、`authenticatorAttachment: 'platform'` 会强制仅平台认证器。下面只给**需要改的字段**（复杂点的上一行有注释）。

---

### 只改这些

```diff
- "challenge": "1758018552291119",
+ // 上一行：必须是 32-64 字节的随机值，后端生成后以 base64url 返回（前端再转 ArrayBuffer）
+ "challenge": "<base64url(randomBytes[32~64])>",

- "rp": {
-   "icon": null,
-   "name": "GtcApp",
-   "id": "www.52wukong.com"
- },
+ // 上一行：若登录页只在 www 子域，用 www.52wukong.com；若希望全子域通用，建议用根域 52wukong.com
+ "rp": { "name": "GtcApp", "id": "52wukong.com" },

- "user": {
-   "icon": null,
-   "name": "herongxhr11@gmail.com",
-   "id": "669876516",
-   "displayName": "herongxhr11@gmail.com"
- },
+ // 上一行：user.id 必须是字节串（1-64 字节）。后端把内部 userId 编成字节再 base64url 返回；
+ // 前端再 b64url→ArrayBuffer。不要直接给十进制/普通字符串。
+ "user": {
+   "name": "herongxhr11@gmail.com",
+   "id": "<base64url(userIdBytes)>",
+   "displayName": "herongxhr11@gmail.com"
+ },

- "pubKeyCredParams": [],
+ // 上一行：至少给出一种算法。最通用：ES256(-7)。如需兼容更多，可追加 RS256(-257)、EdDSA(-8)（按需）。
+ "pubKeyCredParams": [{ "type": "public-key", "alg": -7 }],

- "authenticatorSelection": {
-   "authenticatorAttachment": "platform",
-   "userVerification": "required",
-   "residentKey": "required"
- },
+ // 上一行：只做“平台 Passkey”（Windows Hello / Touch ID / Android 平台）就保留 attachment: platform；
+ // 若同时允许安全钥/跨设备注册，把 authenticatorAttachment 删掉，让浏览器自行选择。
+ "authenticatorSelection": {
+   "userVerification": "required",
+   "residentKey": "required"
+ },

- "attestation": null,
+ // 上一行：大多数场景用 "none"（隐私友好）；需要企业背书才考虑 "direct/enterprise"
+ "attestation": "none",

- "excludeCredentials": []
+ // 上一行：防重复注册：填入该用户已注册的所有 credentialId（base64url）
+ "excludeCredentials": [
+   { "type": "public-key", "id": "<credId1_base64url>" },
+   { "type": "public-key", "id": "<credId2_base64url>" }
+ ],

- "extensions": { "extensions": [] },
+ // 上一行：没用扩展就不要带；有就按键值对给，比如 { "credProps": true }
+ // "extensions": { "credProps": true },

- "timeout": null
+ // 上一行：给出合理超时（毫秒）
+ "timeout": 60000
```

---

### 说明要点（对应上面的改动）

- **challenge**：必须是一次性高熵随机字节（32–64B），并在服务端校验与会话中保存的挑战**严格相等**。
- **rp.id**：与当前页面域后缀匹配；要支持多个子域 → 用 `52wukong.com`。
- **user.id**：是**字节串**（前端最终是 `ArrayBuffer`）。SimpleWebAuthn v11+ 也要求 `Uint8Array`。
- **pubKeyCredParams**：不能为空；至少 `alg: -7 (ES256)`。
- **authenticatorSelection**：

  - 只做“平台 Passkey”→ 保留 `authenticatorAttachment: "platform"`；
  - 想允许**安全密钥/跨设备**注册 → 删掉该字段（让浏览器任选），`residentKey: "required"` 仍可保留以确保可发现凭据。

- **attestation**：常用 `"none"`；企业合规才用 `"direct"/"enterprise"`。
- **excludeCredentials**：避免同一用户重复注册同一把凭据。
- **extensions**：必须是对象；没用就删。
- **timeout**：建议 60s。

需要的话，我可以把你后端（NestJS + simplewebauthn v11+）的**生成注册 options**函数改成最小可用版本（支持把 `userId` 编码成 `Uint8Array`、`supportedAlgorithmIDs→pubKeyCredParams`、自动填充 `excludeCredentials`），只贴需要修改的行。
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[选了哪个认证器？能否区分「Google / Windows Hello / 安卓手机 / 苹果钥匙串」]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/选了哪个认证器</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/选了哪个认证器"/>
        <updated>2025-09-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 结论速答

- **浏览器不会把“品牌/提供方”直接告诉前端**（这是刻意的隐私设计）。你**无法**仅凭 `navigator.credentials.get()` 的返回结果直接断言“用户点的是 Google、Windows Hello、Android 手机还是 Apple 钥匙串”。([W3C][1])
- 你**能拿到**的是**认证器类别**：`credential.authenticatorAttachment` → `"platform"`（平台，如 Windows Hello/Touch ID/Android 平台密钥）或 `"cross-platform"`（漫游，如安全钥/YubiKey，或手机经 Hybrid/蓝牙/扫码）。但它**不是品牌级别**。([MDN Web Docs][2])
- 如需在 UI 中展示“来自 Google / Apple / Windows Hello”等，正确做法是：**在注册时记录 AAGUID → 服务端映射到提供方**；认证时根据 `rawId` 找回该凭据的“提供方标签”并返回给前端显示。注意：移动端大多用 **none attestation**，AAGUID 仅用于**展示**，不应作为安全决策。([web.dev][3])

## 能拿到的前端信号

### 1) 认证器“类别”

- `credential.authenticatorAttachment`：`"platform"` / `"cross-platform"`。仅代表**本机平台**还是**漫游/跨设备**，**不能**细化到“Google/Apple/Windows”。([MDN Web Docs][2])

> 例：若你想在“跨设备登录”后建议用户把凭据保存到本机，可用它来判断（Chrome 指南里就是这么建议的）。([web.dev][4])

### 2) 扩展结果（可选）

- `credential.getClientExtensionResults()`：如你在 `publicKey.extensions` 里请求了扩展，这里会返回结果对象。它**可能**用于风险/设备判别（如 `devicePubKey` 帮你识别**具体使用的那台设备**），但**仍不揭示“品牌”**。([MDN Web Docs][5])

### 3) 客户端能力/提示（非识别）

- `PublicKeyCredential.getClientCapabilities()` 可让你探知**是否支持 hybrid transport / 条件式自动填充**等，以便调整 UI，但**不是“用的是谁家”**。([MDN Web Docs][6])

---

## 想显示“Google/Apple/Windows”的正确方案（服务端主导）

### A. 注册时：记录 AAGUID → 映射“提供方”

- AAGUID 是“认证器型号/提供方”的 UUID。**注册时**（`create()`）在服务端解析并**保存到凭据表**，后续用于 UI 文案（例如“由 Google 密码管理器创建”）。官方示例与社区清单可直接映射 AAGUID → 提供方名称/图标。**注意**：无签名背书的场景仅用于展示。([web.dev][3])

> 复杂逻辑：提取 AAGUID 并存库
>
> ```ts
> // 上一行：SimpleWebAuthn 注册校验后，拿到 AAGUID 并持久化（仅展示用途）
> const { verified, registrationInfo } = await verifyRegistrationResponse(...);
> const aaguid = registrationInfo?.aaguid; // 可能为 '00000000-0000-0000-0000-000000000000'
> // 上一行：用官方推荐的社区清单将 AAGUID → 提供方标签（Google/Apple/…）
> const provider = mapAAGUIDToProvider(aaguid); // 例：'Google Password Manager' | 'iCloud Keychain' | ...
> await db.credentials.upsert({ credentialId, userId, aaguid, providerLabel: provider });
> ```
>
> 资料：如何用 AAGUID 判定提供方 & 社区清单链接（web.dev 文章）。([web.dev][3])

### B. 认证时：凭 `rawId` 找回“提供方标签”

- 登录 `get()` 成功后，前端把 `rawId` 发回；服务端校验通过后，**根据 `rawId` 查询凭据表**，把**保存的 `providerLabel`** 回传给前端用于 UI 展示。
- SimpleWebAuthn 还会告诉你**凭据类型/是否多设备**（`credentialDeviceType` / `credentialBackedUp`），可做补充标签（例如“多设备同步的 passkey”）。([简单网页认证][7])

---

## 仅做“类别”与“跨设备”判断时（无需品牌）

> 只改你现有前端**必要行**（按你的要求“只给改动”）：

```ts
// 上一行：读取认证器类别（platform/cross-platform），随 payload 发回，便于统计/风控/UI
const attachment = (cred as PublicKeyCredential).authenticatorAttachment as
  | "platform"
  | "cross-platform"
  | null;

// 上一行：如你启用了扩展，这里拿到客户端扩展结果（可能含 devicePubKey 等），可一并上传分析
const clientExt = (cred as PublicKeyCredential).getClientExtensionResults?.();

// 上一行：把两个“提示性”字段附在 payload 里（非安全必需，仅用于展示/分析）
payload.meta = {
  authenticatorAttachment: attachment,
  clientExtensionResults: clientExt,
};
```

---

## 为什么不能直接知道“Google / Apple / Windows Hello”

- **规范与浏览器刻意最小化披露**：避免把用户的设备/账户生态暴露给站点（隐私原则）。API 仅给“类别”（platform/cross-platform），**不会**告诉你“是 Google 还是 Apple”。([W3C][1])
- **AAGUID 仅在注册态可得且常为匿名化**：很多平台默认 `none attestation`，即便有 AAGUID，也**只适合做 UI 标签**，不应做强安全策略。([web.dev][3])

---

## 进阶：区分“手机（Hybrid）” vs “U 盘钥匙”

- **严格来说，结果里也不直接告诉你**。`"cross-platform"` 既可能是 **安全钥（USB/NFC/BLE）**，也可能是**手机经 Hybrid**。([MDN Web Docs][2])
- 可行的**推断**思路（仍非 100% 准确）：

  1. 检查**客户端能力**是否支持 `hybridTransport`（仅做 UI/流程分支）。([MDN Web Docs][6])
  2. 在请求里**开启 `devicePubKey` 扩展**并在服务端校验其输出，可用于**识别“这次是同一台手机/设备”**（设备指纹化的合规替代），但**仍不是品牌信息**。([GitHub][8])

---

## 小抄：你可以立刻加的最小改动

> 前端（认证）——只贴**需新增**行：

```ts
// 上一行：把 authenticatorAttachment 带回去，便于服务端记录这次是平台还是漫游
const attachment =
  (cred as PublicKeyCredential).authenticatorAttachment ?? null;

// 上一行：如你要研究扩展结果（例如 devicePubKey），连同其他字段一起上传
const ext = (cred as PublicKeyCredential).getClientExtensionResults?.() ?? {};
await loginByCredential({ ...payload, meta: { attachment, ext } });
```

> 服务端（注册验证后）——只贴**需新增**行：

```ts
// 上一行：注册成功后，提取 AAGUID 并映射“提供方标签”（仅显示用途）
const { aaguid } = verification.registrationInfo!;
const providerLabel = mapAAGUIDToProvider(aaguid); // 例：'Google Password Manager' | 'iCloud Keychain' | 'Windows Hello' | 'YubiKey' | 'Unknown'
await saveCredential({ credentialId, userId, aaguid, providerLabel });
```

> 服务端（认证成功后）——只贴**需新增**行：

```ts
// 上一行：用 rawId 找回凭据，连同 providerLabel 返回前端做 UI 展示
const cred = await getCredentialById(credentialId);
return { ok: true, providerLabel: cred?.providerLabel ?? "Unknown" };
```

---

## 参考

- `authenticatorAttachment` 仅提供**类别**（platform / cross-platform），不包含品牌。([MDN Web Docs][2])
- 用 AAGUID 在**注册时**标注“哪个提供方创建了该 passkey”（仅用于展示；无背书时不要做安全决策）。([web.dev][3])
- WebAuthn 的**隐私/最小披露**模型（无法直接知道品牌）。([W3C][1])
- 客户端能力探测（hybridTransport/conditional UI 等）。([MDN Web Docs][6])
- SimpleWebAuthn：注册/认证与 **multiDevice/credentialBackedUp** 语义，用于补充标签。([简单网页认证][7])

---

需要的话，我可以顺手给你一份**AAGUID→ 提供方**的 JSON 映射样例（含 Google/Apple/YubiKey/Windows Hello 的常见 AAGUID），以及**注册环节如何在 none attestation 下做“仅展示用途”的安全说明**。

[1]: https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com "An API for accessing Public Key Credentials - Level 3"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/authenticatorAttachment "PublicKeyCredential: authenticatorAttachment property - Web APIs | MDN"
[3]: https://web.dev/articles/webauthn-aaguid "Determine the passkey provider with AAGUID  |  Articles  |  web.dev"
[4]: https://web.dev/articles/passkey-form-autofill?utm_source=chatgpt.com "Sign in with a passkey through form autofill | Articles"
[5]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/WebAuthn_extensions "Web Authentication extensions - Web APIs | MDN"
[6]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/getClientCapabilities_static?utm_source=chatgpt.com "PublicKeyCredential: getClientCapabilities() static method"
[7]: https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com "Passkeys"
[8]: https://github.com/w3c/webauthn/issues/1691?utm_source=chatgpt.com "devicePubKey extension MUST be supported if multi- ..."

好嘞，给你一套**可直接用的 AAGUID → 提供方映射样例（JSON）**，再配**后端最小改动片段**（注册提取并存 AAGUID、登录返回 providerLabel）。我只给**必要片段**，复杂逻辑在上一行写中文注释，符合你的习惯。

---

## 1) AAGUID → 提供方映射（建议放到 `aaguid.providers.ts`）

> 说明：这只是**用于 UI 展示**的“友好标签”，**不要**据此做安全决策；Apple/Safari 常见全 0 AAGUID，无法唯一指向 Apple。Google/Windows/YubiKey 取值参考了权威与社区清单（见文末引用）。

```ts
// 上一行：AAGUID → 人类可读标签（仅展示用途）
export const AAGUID_PROVIDER_MAP: Record<string, string> = {
  // Google Password Manager（Chrome/Android 等）
  "ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4": "Google Password Manager", // :contentReference[oaicite:0]{index=0}

  // Windows Hello（多种形态）
  "6028b017-b1d4-4c02-b4b3-afcdafc96bb2": "Windows Hello (Software)", // :contentReference[oaicite:1]{index=1}
  "9ddd1817-af5a-4672-a2b9-3e3dd95000a9": "Windows Hello (VBS Hardware)", // :contentReference[oaicite:2]{index=2}
  "08987058-cadc-4b81-b6e1-30de50dcbe96": "Windows Hello (Hardware)", // :contentReference[oaicite:3]{index=3}

  // Apple iCloud Keychain：常见 none attestation → 全 0（仅提示用，不可靠）
  "00000000-0000-0000-0000-000000000000":
    "Unknown (可能是 iCloud Keychain / none attestation)", // :contentReference[oaicite:4]{index=4}

  // YubiKey（示例，型号/固件不同对应不同 AAGUID；更多见官方表）
  "ee882879-721c-4913-9775-3dfcce97072a": "YubiKey 5 (USB-A/5.2/5.4)", // :contentReference[oaicite:5]{index=5}
  "2fc0579f-8113-47ea-b116-bb5a8db9202a": "YubiKey 5 NFC / 5C NFC (5.2/5.4)", // :contentReference[oaicite:6]{index=6}
  "fa2b99dc-9e39-4257-8f92-4a30d23c4118": "YubiKey 5 NFC (5.1)", // :contentReference[oaicite:7]{index=7}
  "f8a011f3-8c0a-4d15-8006-17111f9edc7": "Security Key by Yubico (Blue/5.1)", // :contentReference[oaicite:8]{index=8}
};
```

> 可选增强：你也可以在启动时拉取**社区维护清单**（`passkeydeveloper/passkey-authenticator-aaguids`）缓存合并，用于展示；该清单不保证长期可用且**不是**安全来源。([GitHub][1])

---

## 2) 映射函数（空/未知兜底）

```ts
// 上一行：把 AAGUID 映射成“展示用标签”，未知或空值兜底
export function mapAAGUIDToProvider(aaguid?: string | null): string {
  if (!aaguid) return "Unknown";
  const key = aaguid.toLowerCase();
  return AAGUID_PROVIDER_MAP[key] ?? "Unknown";
}
```

---

## 3) 注册成功后，提取并持久化 AAGUID（NestJS + simplewebauthn v11+）

```ts
// 上一行：注册校验成功后，提取 aaguid，仅用于 UI 展示（不要做安全准入）
const { verified, registrationInfo } = await verifyRegistrationResponse(params);
if (!verified || !registrationInfo)
  throw new UnauthorizedException("Invalid attestation");

const aaguid = registrationInfo.aaguid ?? null;
const providerLabel = mapAAGUIDToProvider(aaguid);

// 上一行：把 aaguid / providerLabel 和 credentialId、公钥、counter 等一起存库
await credentialsRepo.upsert({
  userId,
  credentialId: base64url(credentialIDBuffer),
  publicKey: base64url(publicKeyBuffer),
  counter: registrationInfo.credential?.counter ?? 0,
  aaguid,
  providerLabel, // ← 认证时可直接回传做 UI 展示
});
```

> 注：很多平台/浏览器默认 **none attestation**，AAGUID 可能是全 0 或不可用；因此**只能展示**，**不要据此放行/拒绝**。([Stack Overflow][2])

---

## 4) 认证成功后，把 providerLabel 回给前端（方便 UI 显示“来自…”）

```ts
// 上一行：校验断言通过后，用 rawId 定位凭据
const cred = await credentialsRepo.findById(payload.rawId);

// 上一行：把之前存的 providerLabel 返回给前端，仅作展示
return {
  ok: true,
  providerLabel: cred?.providerLabel ?? "Unknown",
  // 也可以带上 credentialDeviceType/credentialBackedUp 做补充标签
};
```

---

## 5) 关键注意

- **Apple / Safari**：经常拿到**全 0 AAGUID**（或拿不到），这是隐私设计 + none attestation 的结果，**不能**唯一指向“Apple”。([Apple Developer][3])
- **Windows Hello**：存在**多个 AAGUID**（Software / Hardware / VBS Hardware），上面的三枚是公开常见值。([corbado.com][4])
- **Google Password Manager**：目前常见 AAGUID 为 `ea9b8d66-...`（历史上有过变化）。([谷歌集团][5])
- **YubiKey**：**型号 + 固件版本**不同会有不同 AAGUID，请以**官方表**为准（我在样例里只挑了几条常用）。([Yubico Support][6])
- **用途边界**：AAGUID 适合**给用户看**（“这把凭据来自 … ”），**安全策略**应以 FIDO MDS、证书链、政策（UV/UP、signCount 等）为主。([W3C][7])

---

## 参考

- Google Password Manager AAGUID（官方/社区多处一致）。([corbado.com][8])
- Windows Hello 常见 AAGUID。([corbado.com][4])
- YubiKey 官方 AAGUID 列表（持续更新）。([Yubico Support][6])
- Apple/iCloud Keychain 常见全 0 AAGUID（none attestation）。([Apple Developer][3])
- web.dev：用 AAGUID 仅做**展示**用途的最佳实践与社区清单。([web.dev][9])

需要的话我可以再给一版**带图标的映射**（顺手接入 `webauthn.passwordless.id` 的图标 CDN，命名为 `{aaguid}-light.png` / `{aaguid}-dark.png`），这样前端账号设置页能直接显示小图标。([webauthn.passwordless.id][10])

[1]: https://github.com/passkeydeveloper/passkey-authenticator-aaguids?utm_source=chatgpt.com "passkeydeveloper/passkey-authenticator-aaguids"
[2]: https://stackoverflow.com/questions/76815329/does-webauthn-support-finding-out-where-passkeys-are-stored?utm_source=chatgpt.com "Does WebAuthn support finding out where passkeys are ..."
[3]: https://developer.apple.com/forums/tags/passkeys-in-icloud-keychain/?page=2&sortBy=lastUpdated&utm_source=chatgpt.com "Passkeys in iCloud Keychain"
[4]: https://www.corbado.com/glossary/windows-hello?utm_source=chatgpt.com "What is Windows Hello? Definition, AAGUID and Role in ..."
[5]: https://groups.google.com/a/fidoalliance.org/g/fido-dev/c/o-wZ1LeWKIM?utm_source=chatgpt.com "Google Passkey AAGUID"
[6]: https://support.yubico.com/hc/en-us/articles/360016648959-YubiKey-hardware-FIDO2-AAGUIDs "YubiKey hardware FIDO2 AAGUIDs – Yubico"
[7]: https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com "Web Authentication: An API for accessing Public Key ..."
[8]: https://www.corbado.com/glossary/google-password-manager?utm_source=chatgpt.com "What is Google Password Manager? Definition, AAGUID ..."
[9]: https://web.dev/articles/webauthn-aaguid?utm_source=chatgpt.com "Determine the passkey provider with AAGUID | Articles"
[10]: https://webauthn.passwordless.id/demos/authenticators?utm_source=chatgpt.com "Passkeys authenticators list"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[https://herongdev.github.io/blog/posts/前端/算法技巧/高频行性合批/批量处理/合并处理]]></title>
        <id>https://herongdev.github.io/blog/posts/前端/算法技巧/高频行性合批/批量处理/合并处理</id>
        <link href="https://herongdev.github.io/blog/posts/前端/算法技巧/高频行性合批/批量处理/合并处理"/>
        <updated>2025-09-18T17:26:53.142Z</updated>
        <content type="html"><![CDATA[```ts
高频行情合批（如果需要）
// 在复杂逻辑上一行加注释：行情高频更新时合批后再换数组引用，降低重算与渲染频次
let scheduled = false
const pending: Record<string, Partial<Account>> = {}

function queueAccountPatch(loginid: string, patch: Partial<Account>) {
  pending[loginid] = { ...(pending[loginid] ?? {}), ...patch }
  if (scheduled) return
  scheduled = true
  requestAnimationFrame(() => {
    const list = accountList.value ?? []
    const next = list.slice()
    for (const [id, p] of Object.entries(pending)) {
      const idx = next.findIndex(a => a.loginid === id)
      if (idx !== -1) Object.assign(next[idx], p)
      delete pending[id]
    }
    accountList.value = next          // ← 一次性换引用
    scheduled = false
  })
}

```
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[完成 UTS 插件 iOS 端（ID 聚合：IDFA / IDFV / Keychain GUID）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/唯一标识/完成 UTS 插件 iOS 端（ID 聚合IDFA/IDFV/Keychain GUID</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/唯一标识/完成 UTS 插件 iOS 端（ID 聚合IDFA/IDFV/Keychain GUID"/>
        <updated>2025-09-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 一、实现思路总览

- **统一导出 API** 与 Android 保持一致：`register`、`setSalt`、`getBestId`、`getIdCodes` 等。
- **原生侧（Swift）提供最小能力**：

  - 读取 **IDFA**（可选触发 ATT 弹窗，未授权/受限返回 `nil`）。
  - 读取 **IDFV**。
  - 生成并**持久化 Keychain GUID**（删除 App 也尽量保留）。
  - 提供 **SHA-256**（用 CommonCrypto）供 UTS 侧做加盐哈希。

- **UTS 侧（app-ios/index.uts）**：

  - 维护 `_consent`、`_salt`、`_strict` 状态。
  - 按策略组合并挑选最佳 ID：

    - `global`：优先 `idfa`（若可用）→ `idfv` → `guid`
    - `cn`：优先 `idfv` → `guid`（不强依赖 IDFA）
    - `strict`：**禁用 `idfa`**，只用 `idfv` / `guid`

  - `exposeRaw` 控制是否返回原始值；默认只返回 `hash`。

## 二、关键原理（调研要点）

- **UTS iOS 插件结构与 Info.plist 合并**：`uni_modules/**/utssdk/app-ios/` 下可放 `Info.plist`、`UTS.entitlements`，打包时合并到原生工程。([en.uniapp.dcloud.io][1])
- **ATT 与 IDFA**：iOS 14.5+ 要先请求 ATT 才能使用 IDFA；未授权时不可访问或为全 0。([Apple Developer][2])
- **IDFV**：同一 vendor 的 App 共享；当**设备上该 vendor 的 App 全部卸载**后重装会变更。([Apple Developer][3])
- **Keychain 持久化**：Keychain 条目通常 **跨重装**保留（用户抹掉数据或系统重置例外，iOS 17+ 删除 App 时可选“连同数据”也会清除）。([Apple Developer][4])
- **iOS 侧 SHA-256 实现**：可用 CommonCrypto（系统库）。([Agnostic Development][5])
- **必须配置** `NSUserTrackingUsageDescription`（ATT 弹窗文案），可在插件 `app-ios/Info.plist` 中提供并合并到宿主。([Apple Developer][2])

---

## 三、需要修改 / 新增的代码

> 只给**变更片段**；复杂逻辑均在上一行加注释。

### 1）原生 Swift：`utssdk/app-ios/DeviceIdNative.swift`

**① 顶部 import 增加：**

```swift
// 复杂逻辑：使用 CommonCrypto 做 SHA-256
import CommonCrypto
```

**② 增加 SHA-256 能力（类内任意位置，建议与其他静态方法放一起）：**

```swift
// 复杂逻辑：原生侧提供 SHA-256，UTS 侧用于加盐哈希
@objc public static func sha256Hex(_ input: String) -> String {
    let data = input.data(using: .utf8) ?? Data()
    var hash = [UInt8](repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))
    data.withUnsafeBytes { buf in
        _ = CC_SHA256(buf.baseAddress, CC_LONG(data.count), &hash)
    }
    return hash.map { String(format: "%02x", $0) }.joined()
}
```

**③ 实现 IDFA 读取（补全 `getIDFAOrNull`）：**

```swift
// 复杂逻辑：仅在 requestATT=true 且状态未决定时，同步等待一次 ATT 请求
@objc public static func getIDFAOrNull(_ requestATT: Bool) -> String? {
    if #available(iOS 14, *), requestATT,
       ATTrackingManager.trackingAuthorizationStatus == .notDetermined {
        let sem = DispatchSemaphore(value: 0)
        ATTrackingManager.requestTrackingAuthorization { _ in sem.signal() }
        _ = sem.wait(timeout: .now() + 1.0)
    }
    guard ASIdentifierManager.shared().isAdvertisingTrackingEnabled else { return nil }
    let id = ASIdentifierManager.shared().advertisingIdentifier.uuidString
    // 复杂逻辑：全 0 视为不可用
    let stripped = id.replacingOccurrences(of: "-", with: "").replacingOccurrences(of: "0", with: "")
    return stripped.isEmpty ? nil : id
}
```

**④ 实现 IDFV 读取（补全 `getIDFVOrNull`）：**

```swift
// 复杂逻辑：IDFV 在同 vendor App 全卸载后重装会变化
@objc public static func getIDFVOrNull() -> String? {
    return UIDevice.current.identifierForVendor?.uuidString
}
```

**⑤ Keychain GUID 读写（补全 `getKeychainUUID` + `save`）：**

```swift
// 复杂逻辑：首次生成 UUID 写入 Keychain；跨重装尽量保留
@objc public static func getKeychainUUID() -> String {
    let service = "uts.sdk.modules.idKit"
    let account = "device.guid"
    if let data = read(service: service, account: account),
       let s = String(data: data, encoding: .utf8), !s.isEmpty {
        return s
    }
    let newVal = UUID().uuidString
    _ = save(service: service, account: account, data: Data(newVal.utf8))
    return newVal
}

// 复杂逻辑：若已存在则走 update
@discardableResult
static func save(service: String, account: String, data: Data) -> Bool {
    let query: [String: Any] = [
        kSecClass as String: kSecClassGenericPassword,
        kSecAttrService as String: service,
        kSecAttrAccount as String: account,
        kSecValueData as String: data,
        kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlock
    ]
    let status = SecItemAdd(query as CFDictionary, nil)
    if status == errSecDuplicateItem {
        let find: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: account
        ]
        let attrs: [String: Any] = [kSecValueData as String: data]
        return SecItemUpdate(find as CFDictionary, attrs as CFDictionary) == errSecSuccess
    }
    return status == errSecSuccess
}
```

> 说明：你文件里已有 `read(service:account:)`；上述与之配套即可。

---

### 2）UTS：`utssdk/app-ios/index.uts`

**① 扩展原生声明，增加 `sha256Hex`：**

```ts
// 复杂逻辑：调用 Swift 提供的 SHA-256
declare class DeviceIdNative {
  static getIDFAOrNull(requestATT: boolean): string | null;
  static getIDFVOrNull(): string | null;
  static getKeychainUUID(): string;
  static sha256Hex(input: string): string; // ← 新增
}
```

**② 改造 `register`：授权后“预热”一次 ATT（不强制弹窗）：**

```ts
// 复杂逻辑：同意隐私后尝试读取一次 IDFA（仅在未授权时会触发系统弹窗）
export async function register(
  _: UTSJSONObject | null = null
): Promise<UTSJSONObject> {
  _consent = true;
  try {
    DeviceIdNative.getIDFAOrNull(true);
  } catch {}
  return { consent: _consent } as UTSJSONObject;
}
```

**③ 新增/修正构建返回对象的同步方法（统一哈希）：**

```ts
// 复杂逻辑：统一加盐哈希；非 exposeRaw 不返回原文
function buildSync(
  source: string,
  value?: string | null,
  exposeRaw?: boolean = false,
  limited?: boolean | null = null,
  msg?: string | null = null
): IdValue {
  const val = value ?? null;
  const out: any = {
    source,
    available: !!val,
    limited: limited ?? null,
    value: null,
    hash: null,
    message: msg ?? null,
  };
  if (val) {
    const salted = _salt ? `${_salt}:${val}` : val;
    // 复杂逻辑：iOS 侧使用原生 SHA-256，避免 H5-only 的 crypto.subtle 依赖
    out.hash = DeviceIdNative.sha256Hex(salted);
    if (exposeRaw) out.value = val;
  }
  return out as IdValue;
}
```

**④ 在 `getIdCodes` 中完善策略与取值顺序：**

```ts
// 复杂逻辑：根据策略与 include 产出“有效顺序”
const policy = getPolicy();
let include: string[] = (options?.getArray<string>("include") ||
  []) as string[];
if (!include.length)
  include =
    policy === "global"
      ? ["idfa", "idfv", "guid"]
      : policy === "strict"
      ? ["idfv", "guid"]
      : /* cn */ ["idfv", "guid"];

// 复杂逻辑：读取各 ID（严格模式禁用 idfa；未同意时不弹窗）
const exposeRaw = (options?.getBoolean("exposeRaw") || false) as boolean;
const idfa = _strict
  ? null
  : _consent
  ? DeviceIdNative.getIDFAOrNull(false)
  : null;
const idfv = DeviceIdNative.getIDFVOrNull();
const guid = DeviceIdNative.getKeychainUUID();

const res: any = {
  idfa: buildSync(
    "idfa",
    idfa,
    exposeRaw,
    _strict ? true : _consent && !idfa ? true : null
  ),
  idfv: buildSync(
    "idfv",
    idfv,
    exposeRaw,
    null,
    idfv ? null : "no identifierForVendor"
  ),
  guid: buildSync("guid", guid, exposeRaw, null),
};

// 复杂逻辑：按 include 顺序挑第一个 available 作为 best
res.best = null;
for (const k of include) {
  /* @ts-ignore */
  if (res[k]?.available) {
    res.best = k;
    break;
  }
}
return res as IdCodesResult;
```

**⑤ 小增强：保留的严格模式开关（若你已有可忽略）：**

```ts
export function setStrictMode(strict: boolean): void {
  _strict = strict;
}
```

---

### 3）新增插件级 `Info.plist`（合并到宿主）

**路径**：`utssdk/app-ios/Info.plist`

**内容示例**（请按产品文案调整）：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <!-- 复杂逻辑：ATT 弹窗说明，必须提供非空文案 -->
    <key>NSUserTrackingUsageDescription</key>
    <string>为提供更相关的内容与体验，我们希望使用设备广告标识（IDFA）。</string>
  </dict>
</plist>
```

> UTS 插件放在 `app-ios/Info.plist` 会在云打包时**自动合并**到原生工程。([en.uniapp.dcloud.io][1])

---

## 四、使用与测试

1. **初始化（在合适时机，比如隐私协议同意后）**

   ```ts
   await register();
   setSalt("your-secret-salt"); // 建议设置，便于脱敏
   // 可选：开启严格模式（不使用 IDFA）
   // setStrictMode(true)
   ```

2. **获取最优 ID**

   ```ts
   const id = await getBestId({
     prefer: ["idfa", "idfv", "guid"],
     exposeRaw: false,
   } as any);
   // 正常返回：{ source, available: true, hash: '…' }
   ```

3. **校验 ATT 流程**：首次调用后应出现系统弹窗（若设备允许弹窗、且未决定）。([Apple Developer][2])
4. **卸载/重装**：验证 **Keychain GUID** 是否仍在（新系统“连同数据删除”会清除）。([Apple Developer][4])
5. **全卸载 vendor App 后**：观察 **IDFV** 是否变化。([Apple Developer][3])

---

## 五、常见坑位

- **未配置 `NSUserTrackingUsageDescription`**：ATT 请求会被拒或审核警告。([Apple Developer][2])
- **强拉 IDFA**：未授权直接读取会失败（或全 0）。务必在合适的时机触发 ATT。([Firebase][6])
- **仅依赖 IDFV**：业务需长期稳定标识时，建议同时保留 **Keychain GUID** 作为兜底。([Apple Developer][4])
- **哈希位置**：H5 可用 `crypto.subtle`，但原生侧建议走系统实现（本文用 CommonCrypto）。([Agnostic Development][5])

---

## 六、你现在需要做的事（最少步骤）

1. 粘贴上面 **Swift** 与 **UTS** 的变更片段到对应文件。
2. 在 `utssdk/app-ios/` 新增 **Info.plist**（ATT 文案）。
3. 重新云打包 iOS App 进行真机验证。

若你希望我继续：我可以把 **完整 iOS 目录的差异补丁（diff）** 或 **最小可运行 demo** 打包出来，方便你直接替换集成。

[1]: https://en.uniapp.dcloud.io/plugin/uts-for-ios.html?utm_source=chatgpt.com "uts for iOS | uni-app - DCloud"
[2]: https://developer.apple.com/documentation/apptrackingtransparency?utm_source=chatgpt.com "App Tracking Transparency"
[3]: https://developer.apple.com/documentation/uikit/uidevice/identifierforvendor?utm_source=chatgpt.com "identifierForVendor | Apple Developer Documentation"
[4]: https://developer.apple.com/documentation/security/secitemcopymatching%28_%3A_%3A%29?utm_source=chatgpt.com "SecItemCopyMatching(_:_:) | Apple ..."
[5]: https://www.agnosticdev.com/content/how-use-commoncrypto-apis-swift-5?utm_source=chatgpt.com "How to use CommonCrypto APIs in Swift 5"
[6]: https://firebase.google.com/docs/ios/supporting-ios-14?utm_source=chatgpt.com "Supporting iOS 14 | Firebase for Apple platforms - Google"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web 应用在「苹果/谷歌/不支持」之间选择要验证的通行密钥类型（含最佳实践调研）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Web 应用在「苹果/谷歌/不支持」之间选择要验证的通行密钥类型（含最佳实践调研）</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/Web 应用在「苹果/谷歌/不支持」之间选择要验证的通行密钥类型（含最佳实践调研）"/>
        <updated>2025-09-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 总览

你要的决策规则很清晰：

- Windows + Chrome（或 Chromium 家族）→ 优先谷歌（2），否则 -1；
- macOS + Safari → 苹果（1），否则 -1；
- macOS + Chrome → **优先谷歌（2）**，若未绑定谷歌则**回退苹果（1）**；
- 其它情况一律 -1；
- **前提**：用户 `credential` 数组里必须已绑定对应类型，否则直接 -1。

下面给你**最小变更代码片段**（TypeScript，带行前注释解释复杂逻辑），以及我对**最佳实践的广泛调研与改进建议**。

---

## 实现思路（最小可用）

1. 先看用户是否已绑定（有 1/2）；未绑定任何 → -1。
2. 通过 **User-Agent Client Hints**（`navigator.userAgentData`）优先识别平台与品牌，Safari 再用 UA 字符串兜底。([MDN Web Docs][1])
3. 根据你的规则在 Windows / macOS 不同浏览器上做选择，并在 macOS Chrome 支持**回退**。
4. 可选：在返回非 -1 前，用 `PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()` 做一次能力探测，若平台验证器不可用，也返回 -1（更稳）。([MDN Web Docs][2])

---

## 代码片段（只需新增/修改以下函数）

> 说明：按你的偏好，**仅提供需要添加/调整的片段**；对“复杂逻辑”已在上一行给注释。

```ts
// 放到你的前端 util 文件中，例如: src/utils/passkeyType.ts
export type PasskeyType = -1 | 1 | 2; // -1=不支持, 1=苹果, 2=谷歌

/**
 * 根据用户已绑定的 credential 类型 + 运行环境(平台/浏览器) 得出要验证的通行密钥类型
 * @param boundTypes 用户绑定的类型数组，如 [1,2]、[1]、[2]、[]
 * @param nav 可注入的 navigator（便于测试）
 */
export async function decidePasskeyType(
  boundTypes: number[],
  nav: Navigator = navigator
): Promise<PasskeyType> {
  // 复杂逻辑：先判断绑定情况，空则 -1
  const hasApple = boundTypes?.includes(1);
  const hasGoogle = boundTypes?.includes(2);
  if (!hasApple && !hasGoogle) return -1;

  // 复杂逻辑：优先用 UA-CH 获取平台与品牌，Safari 用 UA 兜底
  const anyNav = nav as any;
  const uaData = anyNav.userAgentData;
  const ua = nav.userAgent || "";
  const platform = (uaData?.platform || "").toLowerCase();

  const brands: string[] = uaData?.brands?.map((b: any) => b.brand) ?? [];
  const brandStr = brands.join(" ");

  // 复杂逻辑：判断是否 Chromium 家族（Chrome/Edge/Opera/Brave 等）
  const isChromium =
    /Chrom(e|ium)|Google Chrome|Microsoft Edge|Opera|OPR|Brave/i.test(
      brandStr
    ) || /Chrome|Chromium|Edg|OPR|Brave/i.test(ua);

  // 复杂逻辑：Safari 的 UA 识别，排除 Chromium 标记
  const isSafari =
    /Safari\//.test(ua) &&
    !/Chrome\//.test(ua) &&
    !/Chromium\//.test(ua) &&
    !/Edg\//.test(ua) &&
    !/OPR\//.test(ua);

  const isWindows = platform.includes("win") || /Windows NT/i.test(ua);
  const isMac = platform.includes("mac") || /Macintosh/i.test(ua);

  // 复杂逻辑（可选稳健性）：若平台验证器不可用，则直接判为不支持
  if (
    typeof (window as any).PublicKeyCredential
      ?.isUserVerifyingPlatformAuthenticatorAvailable === "function"
  ) {
    try {
      const uvpaa = await (
        window as any
      ).PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
      if (!uvpaa) return -1;
    } catch {
      // 探测失败不拦截，继续按规则判断
    }
  }

  // Windows 规则：仅当 Chromium 且已绑定谷歌时返回 2，否则 -1
  if (isWindows) {
    return isChromium && hasGoogle ? 2 : -1;
  }

  // macOS 规则：Safari 走苹果；Chrome(Chromium) 优先谷歌，若未绑谷歌但已绑苹果则回退苹果
  if (isMac) {
    if (isSafari) return hasApple ? 1 : -1;
    if (isChromium) return hasGoogle ? 2 : hasApple ? 1 : -1;
  }

  // 其它平台/浏览器：按你的要求一律不支持
  return -1;
}
```

> 备注：Chrome 在 **macOS** 上既能使用 **Google Password Manager**，也能使用 **iCloud Keychain**（取决于用户设置），因此在 macOS+Chrome 环境下的“**优先谷歌、无谷歌则回退苹果**”是有现实依据的。([Chrome for Developers][3])

---

## 广泛调研 & 我对这套实现的评估

### 这套“按平台/浏览器 + 绑定类型”来选提供方，合理吗？

- **可用，但偏脆弱**：依赖 UA/UA-CH 做供应商推断，受浏览器策略变化影响较大；Safari/Chrome 在 macOS 上与各自密码管理器/系统钥匙串的关系也在持续演进。([MDN Web Docs][1])
- **更稳的思路**是“**能力探测优先**”，例如：

  - `PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()` 判断是否有平台验证器；
  - `PublicKeyCredential.isConditionalMediationAvailable()` 判断是否可用**条件式 UI**（无感自动填充登录）；
  - `PublicKeyCredential.getClientCapabilities()`（WebAuthn L3）检测浏览器支持的能力集合。([MDN Web Docs][2])

### 业界更推荐的做法（最佳实践）

1. **不要“猜供应商”**，而是让浏览器/系统**根据 allowCredentials & Discoverable** 自动选择：

   - 若你**知道用户的 credentialId 列表**，把它们放进 `allowCredentials`，浏览器会在本机或外接密钥里**精确匹配**对应凭据；
   - 若做“**账号名免输入**/条件式 UI”场景，直接传空数组 `allowCredentials: []`，由浏览器列出可用 passkey 让用户选。([developers.yubico.com][4])

2. **在注册时记录 AAGUID → 供应商**（而非靠 UA 推断）：

   - WebAuthn 的 **AAGUID** 能标识创建该 passkey 的**提供方**（如 Google Password Manager、iCloud Keychain 等）；
   - 你可以在注册完成后，从 `attestation`/凭据信息中取 AAGUID，映射为“苹果/谷歌/其它”，存入数据库，后续无需再做 UA 猜测。
   - 注意：苹果出于隐私，很多情况下会返回 **全零 AAGUID** 或不提供可用 attestation，这点要在实现上容错（可归类为“Apple/iCloud（可能）”或“未知”）。([web.dev][5])

3. **优先用“条件式 UI（Conditional Mediation）”实现一键直登**，并在不支持时回退到按钮触发的标准 `get()` 流程：这也是目前 Web 平台推荐的用户体验路径。([web.dev][6])
4. **Chrome/macOS 的多提供方现实**：Chrome 既可用 Google Password Manager，也可调用 iCloud Keychain；因此与其在前端硬编码“选择谁”，不如**基于已绑定的具体 credentialId** 让浏览器匹配。([Chrome for Developers][3])
5. 参考规范与一线文档：WebAuthn L3 规范、MDN 指南、Google 开发者指南、Yubico 等，均强调**基于能力与凭据的流程**，而非供应商硬分支。([W3C][7])

---

## 更优实现范式（建议逐步替换）

> 目标：**不返回“供应商类型”**，而是让浏览器根据**真实的 credentialId** 去找可用的 passkey。

### A. 已知用户 → 精确匹配其凭据

```ts
// 复杂逻辑：把数据库里用户已绑定的 credentialId 映射为 allowCredentials
const allowCredentials = userCredentials.map((c) => ({
  type: "public-key",
  id: c.credentialIdUint8Array, // 服务器存的原始ID还原为 Uint8Array
  // transports 可选
}));

// 复杂逻辑：常规触发登录（非条件式），由浏览器在本机/外接密钥中匹配这些ID
const assertion = await startAuthentication({
  publicKey: {
    challenge, // 后端下发
    allowCredentials, // 关键在这
    timeout: 60000,
    userVerification: "preferred",
  },
});
```

这能**确保**只有用户已绑定的凭据会被使用，无需判断“苹果或谷歌”。([developers.yubico.com][4])

### B. 免输入登录（Conditional UI）

```ts
// 复杂逻辑：先做能力探测，只有支持条件式 UI 的浏览器才走 autofill
const isCond = await PublicKeyCredential.isConditionalMediationAvailable?.();
if (isCond) {
  const assertion = await startAuthentication({
    publicKey: {
      challenge,
      // 关键点：传空数组，让浏览器列出“可发现凭据”
      allowCredentials: [],
      userVerification: "required",
    },
    // 关键点：条件式 UI
    mediation: "conditional",
  });
}
```

这是目前 **Chrome/Safari 等**推荐的“表单自动填充式”登录体验。([MDN Web Docs][8])

### C. 注册时记录 AAGUID（标记供应商）

注册成功后的返回里读取 **AAGUID**，并映射成供应商枚举（如 `apple` / `google` / `other`），保存到你现在的 `passkey_credentials` 表。后续若你仍需要“类型”回传后端，也可据此生成，而**不再依赖 UA 推测**。([web.dev][5])

---

## 小结

- 以上给出的 `decidePasskeyType()` **满足你现有规则**，并考虑了绑定与回退；
- 但从长期维护与用户体验看，**更推荐迁移到“基于 allowCredentials / Discoverable / 条件式 UI / AAGUID”的范式**，把“选择哪家供应商”的问题交还给**浏览器与真实凭据**，这是**当前主流最佳实践**。([Google for Developers][9])

如果你愿意，我可以把上面的“更优范式”落成到你现有的 `@simplewebauthn/server` 四个路由（`/passkeys/{register|login}/{options|verify}`）里，补齐 `allowCredentials` 与 AAGUID 存取的最小改动清单。

[1]: https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API?utm_source=chatgpt.com "User-Agent Client Hints API - Web APIs - MDN - Mozilla"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isUserVerifyingPlatformAuthenticatorAvailable_static?utm_source=chatgpt.com "isUserVerifyingPlatformAuthentic..."
[3]: https://developer.chrome.com/blog/passkeys-on-icloud-keychain?utm_source=chatgpt.com "Chrome now supports passkeys on iCloud Keychain on macOS"
[4]: https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/WebAuthn_Client_Authentication.html?utm_source=chatgpt.com "WebAuthn Client Authentication"
[5]: https://web.dev/articles/webauthn-aaguid?utm_source=chatgpt.com "Determine the passkey provider with AAGUID | Articles"
[6]: https://web.dev/articles/passkey-form-autofill?utm_source=chatgpt.com "Sign in with a passkey through form autofill | Articles - web.dev"
[7]: https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com "An API for accessing Public Key Credentials - Level 3"
[8]: https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isConditionalMediationAvailable_static?utm_source=chatgpt.com "PublicKeyCredential: isConditionalMediationAvailable() static method"
[9]: https://developers.google.com/identity/passkeys/developer-guides/server-authentication?utm_source=chatgpt.com "Server-side passkey authentication | Web guides"
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebAuthn `transports` 的所有取值与含义（含新版 `smart-card` / `hybrid` / 历史 `cable`）]]></title>
        <id>https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/hybrid/历史 cable）</id>
        <link href="https://herongdev.github.io/blog/posts/需求实现/登录鉴权/WebAuthn transports 的所有取值与含义（含新版 smart-card/hybrid/历史 cable）"/>
        <updated>2025-09-16T00:00:00.000Z</updated>
        <content type="html"><![CDATA[
## 概览

`transports` 是**提示性（hint）字段**，告诉浏览器“这枚凭据对应的认证器通常通过什么介质可达”。它来自**注册时**的 `AuthenticatorAttestationResponse.getTransports()`，建议你把返回值存到数据库；**认证时**再放进 `allowCredentials[i].transports`，以便浏览器优先尝试合适的介质。该字段**不是安全校验的一部分**，浏览器可忽略未知值。([MDN Web Docs][1])

---

## 规范定义的取值（WebAuthn Level 3）

> WebAuthn L3 的 `AuthenticatorTransport` 枚举：`"usb" | "nfc" | "ble" | "smart-card" | "hybrid" | "internal"`。([W3C][2])

- **`usb`**
  可移除的 USB 安全密钥（如 YubiKey）。典型用于台式机有线插拔。([W3C][2])

- **`nfc`**
  通过近场通信（NFC）触达的漫游认证器；常见于手机轻触安全钥。([W3C][2])

- **`ble`**
  通过蓝牙低功耗（BLE）连接的漫游认证器。([W3C][2])

- **`smart-card`**
  通过 **接触式智能卡（ISO/IEC 7816）** 的认证器；适配某些企业/政务卡式设备。**这是 L3 新增枚举**。([W3C][2])

- **`hybrid`**
  混合传输：通常指**跨设备认证**（电脑上登录，拿手机确认），由**近距信道 + 云辅助**组合完成；是现代 **passkeys（CDA/caBLE）** 的核心通道。([W3C][2])

- **`internal`**
  平台认证器（设备内置，不可移除），如 Windows Hello、Touch ID、Android 平台密钥。([W3C][2])

> 说明：MDN 的 `getTransports()` 文档同样列举了 `ble / hybrid / internal / nfc / usb`，并建议把注册期获得的数组原样存储并在认证时回填为 `allowCredentials[*].transports`。([MDN Web Docs][1])

---

## 兼容与历史值

- **`cable`（历史/实现细节）**
  早期生态（尤其是 Chrome/DevTools 与部分库）里把“**cloud-assisted BLE**（caBLE）”直接写成 `cable`。在 L3 里正式名称为 **`hybrid`**；若你读取到 `cable`，可以把它**等价视作 `hybrid`**。([chromedevtools.github.io][3])

---

## 实务建议

1. **注册时保存**
   用 `response.getTransports()` 取到数组（如 `["internal"]` 或 `["usb","nfc"]`），**与凭据一起存库**。下次认证时作为 hint 提供，减少用户被动尝试的摩擦。([MDN Web Docs][1])
2. **认证时回填**
   为每个 `allowCredentials[i]` 设置 `transports: storedTransports`。如果做**无用户名/可发现凭据 + Conditional UI**，通常**不传 `allowCredentials`**（因此也没有 `transports`），由浏览器自行发现。([MDN Web Docs][1])
3. **忽略未知值**
   规范要求客户端忽略未知 `transports`，所以**直接存原值**是安全的。([W3C][2])
4. **与“提示（Hints）”配合**
   当你不提供 `allowCredentials`（比如做直登），可用 **PublicKeyCredentialHint**（如 `"security-key" | "client-device" | "hybrid"`）引导 UI，弥补没有 `transports` 的情况。([W3C][2])

---

## 一览速查表

| 取值         | 设备/场景                           | 典型例子                 |
| ------------ | ----------------------------------- | ------------------------ |
| `usb`        | 漫游钥，经 USB 连接                 | YubiKey USB-A/C          |
| `nfc`        | 漫游钥，经 NFC 轻触                 | 手机 NFC 读卡            |
| `ble`        | 漫游钥，经 BLE                      | 蓝牙安全钥               |
| `smart-card` | 接触式智能卡                        | PIV/CAC 卡座             |
| `hybrid`     | **跨设备 passkey**（近距 + 云辅助） | 用手机给电脑“确认登录”   |
| `internal`   | **平台认证器**（不可移除）          | Windows Hello / Touch ID |

（如遇到历史值 `cable`，按 `hybrid` 处理。）([chromedevtools.github.io][3])

如果你愿意，我可以**给出你项目里保存/回填 `transports` 的最小改动片段**（只贴需要改的行，复杂逻辑行会上方加中文注释），并顺手加一条\*\*`cable→hybrid` 兼容映射\*\*。

[1]: https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports "AuthenticatorAttestationResponse: getTransports() method - Web APIs | MDN"
[2]: https://www.w3.org/TR/webauthn-3/ "Web Authentication: An API for accessing Public Key Credentials - Level 3"
[3]: https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/?utm_source=chatgpt.com "WebAuthn domain - Chrome DevTools Protocol - GitHub Pages"
]]></content>
    </entry>
</feed>