{
    "version": "https://jsonfeed.org/version/1",
    "title": "我的技术分享",
    "home_page_url": "https://example.com",
    "feed_url": "https://example.com/feed.json",
    "description": "个人技术分享 RSS",
    "items": [
        {
            "id": "https://example.com/posts/AbortController-Api的使用",
            "content_html": "\r\n### 什么是 `AbortController`？\r\n\r\n`AbortController` 是一个 Web API，允许开发者在 JavaScript 中主动取消某些异步操作，例如网络请求（`fetch`）、定时器或其他可取消的操作。它是现代 Web 开发中处理异步任务的重要工具，特别是在需要中断或取消正在进行的操作时。`AbortController` 提供了简单、标准化的方式来实现取消功能，广泛用于浏览器环境。\r\n\r\n`AbortController` 是在 WHATWG 的 DOM 规范中定义的，最初主要与 `fetch` API 配合使用，但现在也被其他 API（如 `ReadableStream`）支持。它的核心思想是提供一个信号（`AbortSignal`），通过这个信号可以通知相关操作停止执行。\r\n\r\n---\r\n\r\n### 核心概念\r\n\r\n1. **AbortController**:\r\n\r\n   - `AbortController` 是一个构造函数，用于创建控制器对象。\r\n   - 它有一个 `signal` 属性，返回一个 `AbortSignal` 对象，用于监听取消信号。\r\n   - 它还有一个 `abort()` 方法，调用后会触发取消信号。\r\n\r\n2. **AbortSignal**:\r\n\r\n   - `AbortSignal` 是 `AbortController` 的信号对象，传递给支持取消的 API（如 `fetch`）。\r\n   - 当 `AbortController` 的 `abort()` 方法被调用时，`AbortSignal` 会触发 `abort` 事件，通知相关操作取消。\r\n\r\n3. **用途**:\r\n   - 取消网络请求（例如用户切换页面时取消未完成的 `fetch` 请求）。\r\n   - 中止某些异步任务（如文件读取、流操作）。\r\n   - 提高性能，避免不必要的资源消耗。\r\n   - 实现用户交互中的取消功能（如取消上传或下载）。\r\n\r\n---\r\n\r\n### 工作原理\r\n\r\n`AbortController` 的工作流程可以简单总结为以下步骤：\r\n\r\n1. 创建一个 `AbortController` 实例。\r\n2. 将其 `signal` 属性传递给支持取消的 API（如 `fetch`）。\r\n3. 在需要取消操作时，调用 `AbortController` 的 `abort()` 方法。\r\n4. 相关的 API 会接收到取消信号并停止操作，同时抛出 `AbortError` 异常。\r\n\r\n---\r\n\r\n### 使用示例\r\n\r\n以下是一个使用 `AbortController` 取消 `fetch` 请求的详细代码示例：\r\n\r\n```javascript\r\n// 创建 AbortController 实例\r\nconst controller = new AbortController();\r\nconst signal = controller.signal;\r\n\r\n// 发起一个 fetch 请求，传入 signal\r\nfetch(\"https://api.example.com/data\", { signal })\r\n  .then((response) => response.json())\r\n  .then((data) => console.log(data))\r\n  .catch((error) => {\r\n    if (error.name === \"AbortError\") {\r\n      console.log(\"请求被取消\");\r\n    } else {\r\n      console.error(\"请求失败:\", error);\r\n    }\r\n  });\r\n\r\n// 假设 2 秒后取消请求\r\nsetTimeout(() => {\r\n  controller.abort(); // 调用 abort() 方法取消请求\r\n}, 2000);\r\n```\r\n\r\n#### 代码解释：\r\n\r\n- `new AbortController()` 创建控制器。\r\n- `controller.signal` 获取信号对象，传递给 `fetch` 的 `signal` 选项。\r\n- `controller.abort()` 触发取消，`fetch` 请求会立即停止，并抛出 `AbortError`。\r\n- 使用 `catch` 捕获错误并判断是否为 `AbortError`。\r\n\r\n---\r\n\r\n### 实际应用场景\r\n\r\n1. **取消网络请求**:\r\n\r\n   - 用户在页面上点击“搜索”，但在结果返回前又切换到另一个页面，可以用 `AbortController` 取消未完成的请求，避免浪费带宽。\r\n   - 示例：用户在输入框快速输入时，取消之前的搜索请求，只处理最新的请求。\r\n\r\n2. **清理定时器或事件监听器**:\r\n\r\n   - 虽然 `AbortController` 本身不直接控制 `setTimeout` 或事件监听器，但可以通过监听 `AbortSignal` 的 `abort` 事件来实现类似功能。\r\n\r\n3. **流操作**:\r\n\r\n   - 在处理 `ReadableStream` 或 `WritableStream` 时，`AbortController` 可用于取消流传输。\r\n\r\n4. **用户交互**:\r\n   - 提供“取消”按钮，让用户手动中止上传、下载或其他耗时操作。\r\n\r\n---\r\n\r\n### 高级用法：监听 `AbortSignal` 事件\r\n\r\n`AbortSignal` 是一个 `EventTarget`，可以监听其 `abort` 事件，用于自定义取消逻辑。\r\n\r\n```javascript\r\nconst controller = new AbortController();\r\nconst signal = controller.signal;\r\n\r\n// 监听 abort 事件\r\nsignal.addEventListener(\"abort\", () => {\r\n  console.log(\"操作已被取消\");\r\n});\r\n\r\n// 模拟一个异步任务\r\nasync function doWork() {\r\n  try {\r\n    const response = await fetch(\"https://api.example.com/data\", { signal });\r\n    const data = await response.json();\r\n    console.log(data);\r\n  } catch (error) {\r\n    if (error.name === \"AbortError\") {\r\n      console.log(\"任务被取消\");\r\n    } else {\r\n      console.error(\"任务失败:\", error);\r\n    }\r\n  }\r\n}\r\n\r\ndoWork();\r\n\r\n// 3 秒后取消任务\r\nsetTimeout(() => {\r\n  controller.abort();\r\n}, 3000);\r\n```\r\n\r\n#### 说明：\r\n\r\n- `signal.addEventListener('abort', ...)` 监听取消事件。\r\n- 可以在取消时执行额外的清理逻辑，例如关闭资源或更新 UI。\r\n\r\n---\r\n\r\n### 注意事项\r\n\r\n1. **浏览器兼容性**:\r\n\r\n   - `AbortController` 在现代浏览器（如 Chrome、Firefox、Safari）中广泛支持，IE 不支持。\r\n   - 对于旧浏览器，可能需要使用 polyfill。\r\n\r\n2. **异常处理**:\r\n\r\n   - 调用 `abort()` 后，相关 API 会抛出 `AbortError`，需要在代码中捕获并处理。\r\n\r\n3. **不可恢复**:\r\n\r\n   - 一旦调用 `abort()`，`AbortController` 实例不可重用，必须创建新的实例。\r\n\r\n4. **支持的 API**:\r\n\r\n   - 目前主要与 `fetch` 和 `ReadableStream` 等 API 配合使用，其他场景需要开发者手动实现取消逻辑。\r\n\r\n5. **性能优化**:\r\n   - 使用 `AbortController` 可以减少不必要的资源消耗，尤其在高并发或频繁请求的场景下。\r\n\r\n---\r\n\r\n### 扩展：结合 React 示例\r\n\r\n在 React 中，`AbortController` 常用于组件卸载时取消请求，避免内存泄漏。\r\n\r\n```javascript\r\nimport { useEffect } from \"react\";\r\n\r\nfunction MyComponent() {\r\n  useEffect(() => {\r\n    const controller = new AbortController();\r\n    const signal = controller.signal;\r\n\r\n    async function fetchData() {\r\n      try {\r\n        const response = await fetch(\"https://api.example.com/data\", {\r\n          signal,\r\n        });\r\n        const data = await response.json();\r\n        console.log(data);\r\n      } catch (error) {\r\n        if (error.name === \"AbortError\") {\r\n          console.log(\"请求被取消\");\r\n        } else {\r\n          console.error(\"请求失败:\", error);\r\n        }\r\n      }\r\n    }\r\n\r\n    fetchData();\r\n\r\n    // 组件卸载时取消请求\r\n    return () => {\r\n      controller.abort();\r\n    };\r\n  }, []);\r\n\r\n  return <div>加载中...</div>;\r\n}\r\n```\r\n\r\n#### 说明：\r\n\r\n- 在 `useEffect` 中创建 `AbortController`。\r\n- 在组件卸载时（`return` 回调），调用 `abort()` 取消请求。\r\n- 防止因组件卸载而导致的内存泄漏或状态更新错误。\r\n\r\n---\r\n\r\n### 总结\r\n\r\n`AbortController` 是一个简单而强大的工具，用于在 Web 开发中取消异步操作。它通过 `AbortSignal` 提供了一种标准化的取消机制，广泛应用于 `fetch` 请求、流操作等场景。它的主要优点包括：\r\n\r\n- **简单易用**：只需要创建控制器并调用 `abort()` 即可。\r\n- **灵活性**：支持多种异步操作的取消。\r\n- **性能优化**：避免不必要的资源消耗。\r\n- **现代化**：符合现代 Web 开发的需求，特别是在用户交互和性能敏感的场景中。\r\n\r\n通过合理使用 `AbortController`，开发者可以更好地管理异步任务，提升 Web 应用的性能和用户体验。\r\n",
            "url": "https://example.com/posts/AbortController-Api的使用",
            "title": "什么是 `AbortController`？",
            "date_modified": "2025-09-06T11:18:10.000Z"
        },
        {
            "id": "https://example.com/posts/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）",
            "content_html": "\r\n````yaml\r\ntitle: Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）\r\ndate: 2025-09-06\r\ntags:\r\n  - Axios\r\n  - Vue3\r\n  - TypeScript\r\n  - Interceptor\r\n  - Auth\r\n---\r\n\r\n## 目标\r\n- 保留按前缀（如 `/api/pub`）**自动放行**的白名单机制；\r\n- 支持**逐请求显式关闭鉴权**（即便该接口不在白名单里）；\r\n- 避免与 Axios 自带的 `config.auth`（Basic Auth）混淆；\r\n- 兼容历史 `(req as any).auth` 写法，**渐进迁移**到 `useAuth`。\r\n\r\n## 方案总览\r\n1. **类型扩展**：给 `AxiosRequestConfig` 增加 `useAuth?: boolean`。\r\n2. **对象式入口透传**：`http.call({... useAuth })` 直达拦截器。\r\n3. **拦截器优先级**：优先读 `useAuth` → 回退老的 `auth` → 再按前缀与实例默认值判定。\r\n4. **显式移除头**：当不需要鉴权时，从请求头里**删除** `Authorization`，避免误带默认 token。\r\n5. **调用方式**：`http.get/post(..., { useAuth:false })` 或 `http.call({ useAuth:false })`。\r\n\r\n---\r\n\r\n## 关键改动（最小补丁）\r\n\r\n### 1) 扩展 Axios 配置\r\n> 避免与 Basic Auth 的 `config.auth` 冲突，用单独的 `useAuth`。\r\n\r\n```ts\r\n// src/types/http/axios.d.ts\r\ndeclare module 'axios' {\r\n  export interface AxiosRequestConfig {\r\n    /** 覆盖实例默认鉴权：true=强制带token；false=强制不带token */\r\n    useAuth?: boolean\r\n  }\r\n}\r\n````\r\n\r\n### 2) 对象式入口支持 `useAuth`\r\n\r\n```ts\r\n// src/lib/http/types.ts（RequestOptions 中新增）\r\nuseAuth?: boolean\r\n```\r\n\r\n```ts\r\n// src/lib/http/call.ts（buildAxiosConfigFromOptions 末尾透传）\r\nif (typeof (options as any).useAuth === \"boolean\") {\r\n  (cfg as any).useAuth = (options as any).useAuth;\r\n}\r\n```\r\n\r\n### 3) 请求拦截器：判定与显式移除头\r\n\r\n```ts\r\n// src/lib/http/client.ts（拦截器内替换判定片段）\r\n\r\n// 1) 优先 useAuth，回退旧的 auth\r\nconst explicitAuth =\r\n  typeof (req as any).useAuth === \"boolean\"\r\n    ? (req as any).useAuth\r\n    : typeof (req as any).auth === \"boolean\"\r\n    ? (req as any).auth\r\n    : undefined;\r\n\r\nconst needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);\r\nconst accToken = storage.get(ACCESS_TOKEN);\r\nconst tokenType = storage.get(TOKEN_TYPE) || \"Bearer\";\r\n\r\n// 2) 不需要鉴权：显式移除 Authorization，避免误带默认头\r\nif (!needAuth) {\r\n  const h = (req.headers || {}) as Record<string, any>;\r\n  delete h.Authorization;\r\n  delete h.authorization;\r\n  req.headers = h;\r\n} else {\r\n  // 需要鉴权但无 token：中断\r\n  if (!accToken) {\r\n    abortController.abort();\r\n    return Promise.reject(new Error(\"UNAUTHENTICATED\"));\r\n  }\r\n  // 需要鉴权且有 token：注入\r\n  req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };\r\n}\r\n```\r\n\r\n---\r\n\r\n## 调用方式示例\r\n\r\n### A) 传统 axios 三参（推荐）\r\n\r\n```ts\r\n// 公开接口（不走 /api/pub，但也不需要 token）\r\nawait http.get(\"/api/third/get_login_credential_code\", { useAuth: false });\r\n\r\n// POST 且不带 token\r\nawait http.post(\"/api/third/login_by_credential\", payload, { useAuth: false });\r\n```\r\n\r\n### B) 对象式入口\r\n\r\n```ts\r\nawait http.call({\r\n  url: \"/api/third/get_login_credential_code\",\r\n  method: \"GET\",\r\n  useAuth: false,\r\n});\r\n\r\nawait http.call({\r\n  url: \"/api/third/login_by_credential\",\r\n  method: \"POST\",\r\n  data: payload,\r\n  useAuth: false,\r\n});\r\n```\r\n\r\n---\r\n\r\n## 兼容与迁移\r\n\r\n- 旧代码里的 `(req as any).auth = false` 仍可用（拦截器已回退支持），但**建议逐步统一到 `useAuth`**。\r\n- 仍保留 `publicPrefixes`（如 `/api/pub`）自动放行；`useAuth:false` 仅在**个别不走白名单的公开接口**上使用。\r\n\r\n---\r\n\r\n## 常见坑\r\n\r\n- **不要**再用 `config.auth = false`：那是 Basic Auth，类型不对、语义也不对。\r\n- 如果调用过 `http.setAuthToken` 写了默认头，**不显式移除**就会误带 token；本方案在拦截器中已处理。\r\n- 确保 `tsconfig.json` 的 `include` 覆盖到 `src/types`，让编辑器识别 `useAuth` 类型。\r\n\r\n---\r\n\r\n## 验收清单\r\n\r\n- [ ] `src/types/http/axios.d.ts` 已生效（编辑器能识别 `useAuth`）。\r\n- [ ] `http.call` 能接收 `useAuth` 并透传到拦截器。\r\n- [ ] 拦截器在 `useAuth:false` 时**不发送 Authorization**；在需要鉴权但无 token 时**立即中断**。\r\n- [ ] 现网公开接口（不在 `/api/pub`）能通过 `{ useAuth:false }` 正常调用。\r\n\r\n> 结论：这套改动**小而稳**，语义清晰、类型安全，满足“前缀白名单 + 逐请求显式关闭鉴权”的企业级最佳实践。\r\n\r\n```\r\n::contentReference[oaicite:0]{index=0}\r\n```\r\n",
            "url": "https://example.com/posts/Axios-鉴权最佳实践：prefix-useAuth-显式开关（含最小改动补丁）",
            "title": "Axios 鉴权最佳实践：prefix + useAuth 显式开关（含最小改动补丁）",
            "date_modified": "2025-09-06T16:20:26.000Z"
        },
        {
            "id": "https://example.com/posts/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）",
            "content_html": "\r\n---\r\n\r\ntitle: GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）\r\ndate: 2025-09-05\r\ntags: \\[Vue3, Ant Design Vue, 组件封装, v-model]\r\n\r\n---\r\n\r\n## 思路概述\r\n\r\n- 用 `defineModel` 直接驱动 `a-checkbox-group` / `a-radio-group`，去掉中间层 `innerValue` 与 `watch`，减少响应式开销与同步复杂度。\r\n- 加上 `defineOptions({ inheritAttrs: false })`，避免 attrs 同时落在根节点与 `a-*group` 上导致副作用。\r\n- `Checkbox` 明确 `value` 为 **数组**，默认 `[]`；`Radio` 的 `value` 为任意，默认 `null`。\r\n\r\n---\r\n\r\n## 最简实现步骤\r\n\r\n1. 删除 `innerValue` 与所有 `watch`。\r\n2. 用 `const value = defineModel<...>('value', { default: ... })`，模板直接 `v-model:value=\"value\"`。\r\n3. 设置 `inheritAttrs: false`，并将 `attrs` 仅透传给 `a-*group`。\r\n\r\n---\r\n\r\n## 完整代码（Checkbox）\r\n\r\n```vue\r\n<template>\r\n  <div\r\n    class=\"gtc-checkbox\"\r\n    :class=\"[`gtc-checkbox-${size}`, disabled ? 'is-disabled' : '']\"\r\n  >\r\n    <a-checkbox-group v-model:value=\"value\" :disabled=\"disabled\" v-bind=\"attrs\">\r\n      <slot />\r\n    </a-checkbox-group>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { useAttrs } from \"vue\";\r\n\r\n// 复杂：避免 attrs 同时落到根节点与 a-checkbox-group\r\ndefineOptions({ inheritAttrs: false });\r\n\r\nconst attrs = useAttrs();\r\n\r\nconst props = defineProps({\r\n  size: { type: String, default: \"md\" },\r\n  disabled: { type: Boolean, default: false },\r\n});\r\n\r\n// 复杂：CheckboxGroup 期望数组；默认应为 []\r\nconst value = defineModel<any[]>(\"value\", { default: [] });\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.gtc-checkbox {\r\n  .ant-checkbox-wrapper {\r\n    color: var(--ink-950);\r\n  }\r\n  .ant-checkbox {\r\n    &-inner {\r\n      border-color: var(--rim-300);\r\n      background: none;\r\n      box-shadow: none;\r\n    }\r\n    &-checked .ant-checkbox-inner {\r\n      background-color: var(--blue-primary);\r\n      border-color: var(--blue-primary);\r\n    }\r\n    &:hover .ant-checkbox-inner {\r\n      border-color: var(--ink-400);\r\n    }\r\n  }\r\n}\r\n\r\n.gtc-checkbox-sm .ant-checkbox-inner {\r\n  width: 14px;\r\n  height: 14px;\r\n}\r\n.gtc-checkbox-md .ant-checkbox-inner {\r\n  width: 16px;\r\n  height: 16px;\r\n}\r\n.gtc-checkbox-lg .ant-checkbox-inner {\r\n  width: 18px;\r\n  height: 18px;\r\n}\r\n\r\n.is-disabled {\r\n  .ant-checkbox-inner {\r\n    background: var(--ground-50);\r\n    border-color: var(--rim-300);\r\n  }\r\n}\r\n</style>\r\n```\r\n\r\n---\r\n\r\n## 完整代码（Radio）\r\n\r\n```vue\r\n<template>\r\n  <div\r\n    class=\"gtc-radio\"\r\n    :class=\"[`gtc-radio-${size}`, disabled ? 'is-disabled' : '']\"\r\n  >\r\n    <a-radio-group v-model:value=\"value\" :disabled=\"disabled\" v-bind=\"attrs\">\r\n      <slot />\r\n    </a-radio-group>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { useAttrs } from \"vue\";\r\n\r\n// 复杂：避免 attrs 同时落到根节点与 a-radio-group\r\ndefineOptions({ inheritAttrs: false });\r\n\r\nconst attrs = useAttrs();\r\n\r\nconst props = defineProps({\r\n  size: { type: String, default: \"md\" },\r\n  disabled: { type: Boolean, default: false },\r\n});\r\n\r\n// 复杂：RadioGroup 接收单值；默认 null\r\nconst value = defineModel<any>(\"value\", { default: null });\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.gtc-radio {\r\n  .ant-radio-wrapper {\r\n    color: var(--ink-950);\r\n  }\r\n  .ant-radio-inner {\r\n    border-color: var(--rim-300);\r\n    background: none;\r\n    box-shadow: none;\r\n  }\r\n  .ant-radio-checked .ant-radio-inner {\r\n    border-color: var(--blue-primary);\r\n  }\r\n  .ant-radio-checked .ant-radio-inner::after {\r\n    background-color: var(--blue-primary);\r\n  }\r\n  .ant-radio:hover .ant-radio-inner {\r\n    border-color: var(--ink-400);\r\n  }\r\n}\r\n\r\n.gtc-radio-sm .ant-radio-inner {\r\n  width: 14px;\r\n  height: 14px;\r\n}\r\n.gtc-radio-md .ant-radio-inner {\r\n  width: 16px;\r\n  height: 16px;\r\n}\r\n.gtc-radio-lg .ant-radio-inner {\r\n  width: 18px;\r\n  height: 18px;\r\n}\r\n\r\n.is-disabled {\r\n  .ant-radio-inner {\r\n    background: var(--ground-50);\r\n    border-color: var(--rim-300);\r\n  }\r\n}\r\n</style>\r\n```\r\n\r\n---\r\n\r\n## 备注\r\n\r\n- 现在两个组件都是\\*\\*“零 watch、零中间层”\\*\\*：父表单直接通过 `v-model:value` 与 antd 组件对齐；\r\n- 与你表单规则的“复选框至少选一项”自定义校验配合使用即可（在 `getValidationRules` 里对 `checkbox` 做长度判断）。\r\n",
            "url": "https://example.com/posts/GTC-Checkbox-Radio-轻量化重构（支持-Ant-Design-Vue）",
            "title": "GTC Checkbox & Radio 轻量化重构（支持 Ant Design Vue）",
            "date_modified": "2025-09-05T16:25:03.000Z"
        },
        {
            "id": "https://example.com/posts/hello-world",
            "content_html": "Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\r\n\r\n## Quick Start\r\n\r\n### Create a new post\r\n\r\n``` bash\r\n$ hexo new \"My New Post\"\r\n```\r\n\r\nMore info: [Writing](https://hexo.io/docs/writing.html)\r\n\r\n### Run server\r\n\r\n``` bash\r\n$ hexo server\r\n```\r\n\r\nMore info: [Server](https://hexo.io/docs/server.html)\r\n\r\n### Generate static files\r\n\r\n``` bash\r\n$ hexo generate\r\n```\r\n\r\nMore info: [Generating](https://hexo.io/docs/generating.html)\r\n\r\n### Deploy to remote sites\r\n\r\n``` bash\r\n$ hexo deploy\r\n```\r\n\r\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\r\n",
            "url": "https://example.com/posts/hello-world",
            "title": "Hello World",
            "date_modified": "2025-09-08T15:29:09.265Z"
        },
        {
            "id": "https://example.com/posts/hexo技术分享分类分目录组织",
            "content_html": "\r\n> 目标：当文章**成千上万**时，既能在磁盘上**分目录管理**，又能在站点里以**目录树（分类层级）**浏览，并让 **URL 跟随分类层级**，同时保持 GitHub Project Pages 的子路径（`/blog/`）不乱。\r\n\r\n## 1 屏跑通\r\n\r\n1. **物理分目录**：`source/_posts/` 下建多级子目录；`hexo new post 路径/标题` 可直接写入对应子目录。\r\n2. **URL 跟随分类层级**：把 `permalink` 改成 `:categories/:title/`，并在每篇文章的 front-matter 写层级 `categories: [父, 子]`。\r\n3. **目录树页面**：确认有 `source/categories/index.md`（`type: categories`），NexT 会按层级展示。\r\n4. **脚手架（scaffolds）**：为高频目录建模板，一键新建时自动带好层级分类。\r\n5. **GitHub Pages 子路径**：你是项目页 → 继续保持 `url: https://<你>.github.io/<仓库名>` 与 `root: /<仓库名>/`。\r\n\r\n---\r\n\r\n## 一、物理分目录（递归扫描，直接可用）\r\n\r\nHexo 会**递归**读取 `source/_posts/` 的子目录，所以可以放心分层管理。\r\n\r\n```bash\r\n# 在 _posts 下建立层级目录\r\nmkdir -p source/_posts/GIS/GeoServer\r\nmkdir -p source/_posts/前端/NextJS\r\n\r\n# 新建文章时直接带路径（两种都行）\r\nhexo new post GIS/GeoServer/切片入门\r\nhexo new \"GIS/GeoServer/缓存与预热\"\r\n```\r\n\r\n```yaml\r\n# 复杂：建议开启“同名资源文件夹”，让每篇文章的图片等资产跟随文章文件夹\r\n# _config.yml（站点根配置）只需改这一行\r\npost_asset_folder: true\r\n```\r\n\r\n> 开启后，`hexo new post GIS/GeoServer/切片入门` 会生成\r\n> `source/_posts/GIS/GeoServer/切片入门.md` 与 `source/_posts/GIS/GeoServer/切片入门/`（放图）。\r\n\r\n## 二、URL & 页面跟“分类层级”走（而不是物理目录名）\r\n\r\n**关键点**：页面导航与 URL 建议依赖 **front-matter 的 categories**，而不是物理目录。\r\n这样**更可控**（物理目录可随时重构、不影响 URL）。\r\n\r\n```yaml\r\n# 复杂：让文章链接包含“分类层级”\r\n# _config.yml（站点根配置）\r\npermalink: :categories/:title/\r\n```\r\n\r\n> 你在 GitHub Project Pages（项目页），**继续保持子路径**（别动就对了）：\r\n\r\n```yaml\r\n# 复杂：站点部署在 /blog/ 子路径下\r\nurl: https://herongxhr-netizen.github.io/blog\r\nroot: /blog/\r\n```\r\n\r\n在每篇文章顶部写**层级分类**（数组顺序即层级）：\r\n\r\n```md\r\n---\r\ntitle: 切片入门\r\ndate: 2025-09-04\r\n# 复杂：层级分类会生成 /GIS/GeoServer/ 的目录层级与 URL\r\ncategories: [GIS, GeoServer]\r\ntags: [GeoServer, 切片, 缓存]\r\n# （可选）若想自定义更友好的英文链接\r\n# slug: geoserver-tiling-intro\r\n---\r\n```\r\n\r\n## 三、目录树页面与导航菜单\r\n\r\n确认你已有分类页与标签页（否则先创建）：\r\n\r\n```bash\r\nhexo new page categories\r\nhexo new page tags\r\n```\r\n\r\n编辑索引页 front-matter（**只需这几行**）：\r\n\r\n```md\r\n---\r\ntitle: 分类\r\ntype: categories\r\n---\r\n```\r\n\r\n```md\r\n---\r\ntitle: 标签\r\ntype: tags\r\n---\r\n```\r\n\r\n在 NexT 主题菜单里露出入口（`themes/next/_config.yml`）：\r\n\r\n```yaml\r\n# 复杂：在菜单里显示分类/标签\r\nmenu:\r\n  home: /\r\n  categories: /categories/\r\n  tags: /tags/\r\n```\r\n\r\n---\r\n\r\n## 四、批量高效新建：自定义脚手架（scaffolds）\r\n\r\n为高频目录做脚手架，自动带上层级分类与常用字段。\r\n\r\n**示例 1：GIS 系列脚手架**\r\n创建 `scaffolds/gis.md`：\r\n\r\n```md\r\n---\r\ntitle: { { title } }\r\ndate: { { date } }\r\n# 复杂：预置层级分类，后续文章自动套用\r\ncategories: [GIS, GeoServer]\r\ntags:\r\n---\r\n```\r\n\r\n使用（指定脚手架名）：\r\n\r\n```bash\r\n# 复杂：--s 指定使用自定义脚手架 \"gis\"\r\nhexo new --s gis \"瓦片缓存策略\"\r\n```\r\n\r\n**示例 2：NextJS 系列脚手架**\r\n`scaffolds/nextjs.md`：\r\n\r\n```md\r\n---\r\ntitle: { { title } }\r\ndate: { { date } }\r\ncategories: [前端, NextJS]\r\ntags:\r\n---\r\n```\r\n\r\n使用：\r\n\r\n```bash\r\nhexo new --s nextjs \"App Router 与 RBAC\"\r\n```\r\n\r\n> 贴士（可选）：在 `package.json` 里加脚本别名，敲更短：\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"new:gis\": \"hexo new --s gis\",\r\n    \"new:next\": \"hexo new --s nextjs\"\r\n  }\r\n}\r\n```\r\n\r\n使用：`npm run new:gis \"OpenLayers 点聚合最佳实践\"`\r\n\r\n---\r\n\r\n## 五、目录结构示例（仅供参考）\r\n\r\n```\r\nsource/_posts/\r\n├─ GIS/\r\n│  └─ GeoServer/\r\n│     ├─ 切片入门.md\r\n│     ├─ 切片入门/         # 文章同名资源文件夹（图片等）\r\n│     └─ 缓存与预热.md\r\n└─ 前端/\r\n   └─ NextJS/\r\n      └─ App Router 与 RBAC.md\r\n```\r\n\r\n> **注意**：物理目录**不会**自动变成 URL；URL 由 `permalink` + 文章的 `categories` 决定。\r\n\r\n---\r\n\r\n## 六、搜索与站点生成（与你现有配置兼容）\r\n\r\n你已使用 `hexo-generator-searchdb`（本地搜索），与分目录/层级分类**无冲突**，无需额外改动。\r\n每次发文后按旧流程即可：\r\n\r\n```bash\r\nhexo clean && hexo g && hexo s\r\n# 自动部署（GitHub Actions）仍是：git add . && git commit && git push\r\n```\r\n\r\n---\r\n\r\n## 七、常见坑位（快速定位）\r\n\r\n- **页面 404 / 样式丢失**：`_config.yml` 的 `url/root` 未按**项目页子路径**设置（应为 `/blog/`）。\r\n- **URL 没有层级**：缺少 `permalink: :categories/:title/` 或文章没写 `categories: [父, 子]`。\r\n- **分类页不展示树**：`source/categories/index.md` 的 `type` 不是 `categories`；或主题菜单未加入口。\r\n- **物理目录改变但 URL 想保持不变**：别动 front-matter 的 `categories`，URL 就不会变。\r\n- **想迁移到“用户页”（根路径）**：把仓库改名为 `<用户名>.github.io`，并把\r\n\r\n  ```yaml\r\n  # 复杂：用户页改为根路径部署\r\n  url: https://<用户名>.github.io\r\n  root: /\r\n  ```\r\n\r\n  重新部署即可。\r\n\r\n---\r\n\r\n## 复盘清单（照这个一项项核对）\r\n\r\n- [ ] `_config.yml` 已设置\r\n\r\n  ```yaml\r\n  permalink: :categories/:title/\r\n  url: https://herongxhr-netizen.github.io/blog\r\n  root: /blog/\r\n  post_asset_folder: true\r\n  ```\r\n\r\n- [ ] 文章 front-matter 用层级分类（`[父, 子]`）。\r\n- [ ] 有 `source/categories/index.md` 与 `type: categories`。\r\n- [ ] NexT 菜单里有 `/categories/` 与 `/tags/`。\r\n- [ ] 脚手架按需要创建（`scaffolds/*.md`），新建时用 `hexo new --s <脚手架> \"标题\"`。\r\n\r\n---\r\n\r\n### FAQ\r\n\r\n**Q：必须物理分目录吗？**\r\nA：不是必须，但**强烈建议**。这样 Git 与编辑器里都更可管理；而 URL/导航交给分类层级来控制，二者解耦。\r\n\r\n**Q：以后想批量重构目录怎么办？**\r\nA：直接移动文件夹即可；只要 front-matter 的 `categories` 不改，URL 不会变（避免 SEO 损失）。\r\n\r\n**Q：图片怎么引用？**\r\nA：启用 `post_asset_folder: true` 后，文章内用相对路径（如 `![](切片入门/示意图.png)`）即可。\r\n\r\n---\r\n",
            "url": "https://example.com/posts/hexo技术分享分类分目录组织",
            "title": "Hexo 千篇文章的“分目录存储 + 目录树导航”实战（含 URL、分类、脚手架）",
            "date_modified": "2025-09-04T00:00:00.000Z"
        },
        {
            "id": "https://example.com/posts/id-kit",
            "content_html": "\n棒～这个方向很实用。按你的节奏来：**先取名 → 再讲实现思路 → 之后我们再一步步落地**。\n\n---\n\n## 先取个名字（我给你几个风格不同的备选）\n\n**强推：`UniIdKit`（中文：一体设备 ID 工具包）**\n\n- 简洁、易记、和 uni-app 生态贴合（Uni 前缀）。\n- “Kit” 体现工具集合的定位（OAID/AAID/AndroidID/GUID…聚合）。\n\n其它好选项（任选其一也行）：\n\n- `UniDeviceID`（直白、上手即懂）\n- `IdFusion` / 中文：ID 融合（强调多源融合）\n- `OmniIdKit` / 中文：全域 ID 工具包（强调覆盖广泛）\n- `SignalID` / 中文：设备信标（更“概念化”，偏品牌感）\n\n> 没有特别诉求的话，我后续以 **`UniIdKit`** 为默认名继续讲实现与代码。\n\n---\n\n## 实现思路（先把“大图”画清楚）\n\n### 1) 目标与边界\n\n- **平台覆盖**：Android（App-Plus 原生）、iOS（可选：IDFV）、H5（本地持久 GUID）。\n- **能力聚合**：OAID、AAID、AndroidID、（可选）IMEI/MEID、WidevineID、PseudoID、GUID。\n- **合规优先**：\n\n  - 默认**不采集强隐私**（如 IMEI），需**显式同意**与**动态权限**才允许。\n  - 提供**哈希化输出**（SHA-256）选项，避免直传原始标识。\n  - 尊重系统/用户“广告追踪限制”（AAID/OAID 可能返回空或受限标志）。\n\n### 2) 能力分层（便于维护与扩展）\n\n```\nUniIdKit（JS/TS 封装与 API ）\n ├─ ConsentManager（隐私同意、选项管理、状态缓存）\n ├─ CacheLayer（本地缓存：uni.storage / iOS Keychain / Android MMKV）\n ├─ Aggregator（聚合各 Adapter 的结果、去重、优先级策略、哈希化）\n └─ Adapters\n     ├─ Android:\n     │   ├─ OAIDAdapter（MSA SDK）\n     │   ├─ AAIDAdapter（Google Play 服务）\n     │   ├─ AndroidIdAdapter（SSAID）\n     │   ├─ WidevineIdAdapter（DRM ID，有些机型/ROM可能不可用）\n     │   ├─ PseudoIdAdapter（Build 信息拼接的伪 ID，稳定性一般）\n     │   └─ IMEI/MEIDAdapter（需权限；默认关闭）\n     ├─ iOS:\n     │   └─ IDFVAdapter（IdentifierForVendor）\n     └─ H5:\n         └─ GuidAdapter（首访生成 UUID，localStorage/IndexedDB/Cookie 持久化）\n```\n\n### 3) API 设计（兼容回调，也提供 Promise 风格）\n\n与 Ba-IdCode 的 API 兼容，但**统一返回结构**、并补充 Promise 版本：\n\n- `register(options?)`：完成 SDK 初始化/权限请求/合规弹窗接入（**只有用户同意后才能继续**）。\n- `getIdCodes(options?)`：一次性返回所有可用标识（含哈希/明文二选一），并标出可用性/限制信息。\n- `getOAID()` / `getAAID()` / `getAndroidId()` / `getGuid()`：单项拉取。\n- `getBestId(options?)`：按优先级策略返回“一个最合适的设备标识”（例如：`OAID > AAID > AndroidID > IDFV > GUID`）。\n- `setSalt(salt: string)`：设置服务端协商的哈希盐（建议）；前端仅输出 hash 以降低风险。\n\n**统一返回结构（示例）**：\n\n```ts\ntype IdValue = {\n  value?: string; // 原始值（默认可关闭）\n  hash?: string; // SHA-256(value + salt) 的十六进制\n  available: boolean; // 是否成功获取\n  limited?: boolean; // 是否受限制（如关闭广告标识、受 ROM 策略限制）\n  source?: string; // 具体来源：oaid/aaid/androidId/idfv/guid/...\n  message?: string; // 失败/限制说明\n};\n\ntype IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue; // iOS\n  widevineId?: IdValue;\n  pseudoId?: IdValue;\n  imei?: IdValue; // 默认不返回，需开启 & 权限通过\n  guid?: IdValue; // H5/兜底\n  ts: number; // 时间戳\n  consent: boolean; // 是否已取得用户隐私同意\n};\n```\n\n**调用风格**：\n\n```ts\n// 回调\nidKit.getIdCodes((res) => {\n  /* ... */\n});\n\n// Promise（推荐）\nconst res = await UniIdKit.getIdCodes({\n  hashOnly: true,\n  include: [\"oaid\", \"aaid\", \"androidId\", \"guid\"],\n});\n```\n\n### 4) 平台实现要点\n\n- **Android**：\n\n  - OAID：集成 **MSA (移动安全联盟) SDK** 或厂商合规通道（插件市场常用做法）。\n  - AAID：Google Play 服务 `AdvertisingIdClient`（需处理“限制广告跟踪”返回）。\n  - AndroidID：`Settings.Secure.ANDROID_ID`。\n  - IMEI/MEID：`READ_PHONE_STATE` 动态权限 + Play 政策；**默认关闭**、强提醒不建议依赖。\n  - 缓存：优先使用 MMKV/SharedPreferences，配合有效期（如 24 小时）避免频繁拉取。\n\n- **iOS**：\n\n  - IDFV：`UIDevice.current.identifierForVendor`；卸载所有同一 Vendor 应用后可能变。\n  - 不建议用 IDFA（需要 ATT 授权且涉广告用途，与你目标不匹配）。\n\n- **H5**：\n\n  - 生成 `uuid`，持久化在 `localStorage` + `cookie` 双存；被清理会变，属于“弱设备 ID”。\n  - 返回 `guid` 字段；可选加“服务端长 Cookie dvc=xxx”作为辅助。\n\n### 5) 合规与配置\n\n- 插件默认只返回 **hash**；要返回原值需显式 `exposeRaw: true`。\n- 提供 `register()` 用于展示你的隐私弹窗（或与现有弹窗 SDK 对接），**未同意**则所有采集接口返回 `available=false`。\n- 允许配置 `include/exclude` 字段（避免不必要的请求/权限）。\n- 提供 `fallback: 'guid' | 'none'` 选项控制 H5 的兜底行为。\n\n---\n\n## 3) 先给你一份可直接用的 JS 封装（跨端 & 可渐进增强）\n\n> 先从 JS 层开始（不依赖原生插件也可工作），App 端等你绑定好原生插件后，再把 `native` 分支接上即可。\n\n```ts\n// src/utils/uni-id-kit.ts  —— 先做纯JS壳子，后续接原生\nfunction uuid4() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function sha256Hex(msg: string): Promise<string> {\n  if (typeof window !== \"undefined\" && window.crypto?.subtle) {\n    const enc = new TextEncoder().encode(msg);\n    const buf = await window.crypto.subtle.digest(\"SHA-256\", enc);\n    return Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n  // 非 H5（App 小程序）用简易实现或交给原生\n  // 这里先用最简单的占位：直接返回 msg（上线前请接真 SHA-256，如 plus.crypto / 原生）\n  return msg;\n}\n\ntype GetIdOptions = {\n  include?: Array<\n    | \"oaid\"\n    | \"aaid\"\n    | \"androidId\"\n    | \"idfv\"\n    | \"widevineId\"\n    | \"pseudoId\"\n    | \"imei\"\n    | \"guid\"\n  >;\n  exposeRaw?: boolean; // 默认 false，默认仅返回 hash\n  salt?: string; // 建议传服务端下发的盐\n  fallback?: \"guid\" | \"none\";\n  ttlMs?: number; // 缓存有效期，默认 1 天\n};\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: any } | null = null;\n\nexport const UniIdKit = {\n  setSalt(salt: string) {\n    _salt = salt || \"\";\n  },\n\n  async register(): Promise<{ consent: boolean }> {\n    // TODO: 这里接你的隐私弹窗或第三方隐私 SDK\n    _consent = true; // 演示先直接同意\n    return { consent: _consent };\n  },\n\n  async getIdCodes(opts: GetIdOptions = {}) {\n    const include = opts.include || [\n      \"oaid\",\n      \"aaid\",\n      \"androidId\",\n      \"idfv\",\n      \"guid\",\n    ]; // 先常用\n    const ttl = opts.ttlMs ?? 24 * 3600 * 1000;\n\n    // 简单缓存\n    if (_cache && Date.now() - _cache.ts < ttl) {\n      return _cache.data;\n    }\n\n    const data: any = { ts: Date.now(), consent: _consent };\n\n    // App 原生插件（占位），后续把 requireNativePlugin 接上\n    let native: any = null;\n    try {\n      // @ts-ignore\n      native = uni.requireNativePlugin && uni.requireNativePlugin(\"Uni-IdKit\");\n    } catch {}\n\n    // 工具：组装返回（含 hash）\n    const build = async (\n      source: string,\n      value?: string,\n      limited?: boolean,\n      msg?: string\n    ) => {\n      const available = !!value;\n      const raw = opts.exposeRaw ? value : undefined;\n      const hash = value ? await sha256Hex(value + (_salt || \"\")) : undefined;\n      return { value: raw, hash, available, limited, source, message: msg };\n    };\n\n    // Android / iOS / H5 分支（先写 H5 + 纯 JS 兜底，原生等你接上）\n    const isH5 =\n      typeof window !== \"undefined\" && typeof document !== \"undefined\";\n\n    // OAID / AAID / AndroidID / IDFV —— 占位：若未接原生，返回不可用\n    if (include.includes(\"oaid\"))\n      data.oaid = await build(\n        \"oaid\",\n        native?.getOAID ? await native.getOAID() : undefined\n      );\n    if (include.includes(\"aaid\"))\n      data.aaid = await build(\n        \"aaid\",\n        native?.getAAID ? await native.getAAID() : undefined\n      );\n    if (include.includes(\"androidId\"))\n      data.androidId = await build(\n        \"androidId\",\n        native?.getAndroidID ? await native.getAndroidID() : undefined\n      );\n    if (include.includes(\"idfv\"))\n      data.idfv = await build(\n        \"idfv\",\n        native?.getIDFV ? await native.getIDFV() : undefined\n      );\n    if (include.includes(\"widevineId\"))\n      data.widevineId = await build(\n        \"widevineId\",\n        native?.getWidevineID ? await native.getWidevineID() : undefined\n      );\n    if (include.includes(\"pseudoId\"))\n      data.pseudoId = await build(\n        \"pseudoId\",\n        native?.getPseudoID ? await native.getPseudoID() : undefined\n      );\n    if (include.includes(\"imei\"))\n      data.imei = await build(\n        \"imei\",\n        native?.getIMEI ? await native.getIMEI() : undefined\n      );\n\n    // H5 / 兜底 GUID\n    if (include.includes(\"guid\")) {\n      let guid = uni.getStorageSync(\"UNI_ID_KIT_GUID\");\n      if (!guid) {\n        guid = `web:${uuid4()}`;\n        uni.setStorageSync(\"UNI_ID_KIT_GUID\", guid);\n      }\n      data.guid = await build(\"guid\", guid);\n    }\n\n    // 如果要求有“最佳 ID”\n    data.best = (() => {\n      const order = [\"oaid\", \"aaid\", \"androidId\", \"idfv\", \"guid\"];\n      for (const k of order) {\n        if (data[k]?.available) return k;\n      }\n      return null;\n    })();\n\n    _cache = { ts: Date.now(), data };\n    return data;\n  },\n\n  async getBestId(opts: GetIdOptions = {}) {\n    const res = await this.getIdCodes(opts);\n    const key = res.best;\n    return key ? res[key] : { available: false, source: \"none\" };\n  },\n};\n```\n\n> 这份 JS 壳子**现在就能在 H5 返回一个稳定的 GUID**；等你把 Android/iOS 原生侧接上 `Uni-IdKit` 插件，就能自动获得 OAID/AAID/AndroidID/IDFV 等真实值，API 不变。\n\n---\n\n## 下一步怎么干？\n\n1. **确定名字**（默认我用 `UniIdKit` 继续）。\n2. 我给你 **Android 原生插件最小实现骨架（Kotlin）**：\n\n   - 暴露 `getOAID/getAAID/getAndroidID/...` 方法；\n   - 可先不接 MSA/AAID，返回占位，跑通桥接；\n   - 再逐个接入 MSA SDK、Google Play Advertising ID。\n\n3. 同步给 **iOS 原生插件（Swift）** 获取 IDFV；\n4. 最后在你的登录流程里，把 `const dvc = await UniIdKit.getBestId({ hashOnly: true })` 接上，作为 `x-device-id` 传后端。\n\n要不要我直接开始贴 **Android 插件骨架（可云打包）**？你点个头我就开写。\n\n太好了，我们就按 **UTS 插件**来落地。下面我先给出**项目结构 & API 设计（最佳实践版）**，然后直接给你**可运行的首版代码骨架**（先支持 Web；Android 提供可运行的基础实现 + OAID/AAID 预留点），后续你把 MSA/GP 的 SDK 接上即可。\n\n---\n\n# 一、插件命名 & 目录结构\n\n**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）\n\n- 英文：**UniIdKit**\n- 中文：**一体设备 ID 工具包**\n\n**目录（uni_modules 标准）**：\n\n```\nuni_modules/\n  uni-id-kit/\n    package.json\n    module.json\n    utssdk/\n      index.uts              # 聚合导出（按平台分发）\n      common/\n        types.uts            # 类型与常量定义（复用）\n        hash.uts             # SHA-256 工具（Web/Android 均可）\n        storage.uts          # 本地缓存工具（uni.storage封装）\n      web/\n        index.uts            # Web 实现（GUID、hash、缓存）\n      app-android/\n        index.uts            # Android 实现（AndroidID，OAID/AAID占位）\n        adapters/\n          android_id.uts     # ANDROID_ID\n          aaid.uts           # Google AAID（待接SDK）\n          oaid.uts           # MSA OAID  （待接SDK）\n          pseudo_id.uts      # 伪ID（可选）\n```\n\n> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。\n> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。\n\n---\n\n# 二、API 设计（Promise + 回调兼容）\n\n> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。\n\n## 公开方法\n\n```ts\n// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）\nexport function register(options?: {\n  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗\n}): Promise<{ consent: boolean }>;\n\n// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash\nexport function setSalt(salt: string): void;\n\n// 3) 一次性获取所有可用的 ID（聚合）\nexport function getIdCodes(options?: {\n  include?: Array<\n    | \"oaid\"\n    | \"aaid\"\n    | \"androidId\"\n    | \"idfv\"\n    | \"widevineId\"\n    | \"pseudoId\"\n    | \"imei\"\n    | \"guid\"\n  >;\n  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value\n  ttlMs?: number; // 缓存有效期，默认 24h\n}): Promise<IdCodesResult>;\n\n// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）\nexport function getBestId(options?: {\n  prefer?: Array<\"oaid\" | \"aaid\" | \"androidId\" | \"idfv\" | \"guid\">; // 可自定义优先级\n  exposeRaw?: boolean;\n  ttlMs?: number;\n}): Promise<IdValue>;\n\n// 5) 单项拉取（必要时）\nexport function getOAID(): Promise<IdValue>;\nexport function getAAID(): Promise<IdValue>;\nexport function getAndroidId(): Promise<IdValue>;\nexport function getGuid(): Promise<IdValue>;\n```\n\n## 返回类型（最佳实践）\n\n```ts\n// utssdk/common/types.uts\nexport type IdValue = {\n  value?: string; // 原始值（exposeRaw=true 才返回）\n  hash?: string; // SHA-256(value + salt) 十六进制\n  available: boolean; // 是否获取成功\n  limited?: boolean; // 是否受限（系统关闭广告跟踪等）\n  source: string; // oaid/aaid/androidId/idfv/guid/...\n  message?: string; // 失败或说明\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue; // 预留给 iOS\n  widevineId?: IdValue; // 可选\n  pseudoId?: IdValue; // 可选\n  imei?: IdValue; // 不建议默认启用\n  guid?: IdValue; // H5/兜底\n  best?: string | null; // 最佳项的 key\n  consent: boolean;\n  ts: number; // 生成时间戳\n};\n```\n\n---\n\n# 三、首版代码（可直接放进项目）\n\n> **说明**：以下代码为 **可运行骨架**。\n>\n> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。\n> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。\n> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。\n\n## 1）`uni_modules/uni-id-kit/module.json`\n\n```json\n{\n  \"id\": \"uni-id-kit\",\n  \"displayName\": \"UniIdKit - 一体设备ID工具包\",\n  \"version\": \"0.1.0\",\n  \"description\": \"聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出\",\n  \"keywords\": [\"deviceid\", \"oaid\", \"aaid\", \"androidid\", \"guid\", \"uts\"],\n  \"repository\": \"\",\n  \"engines\": {\n    \"HBuilderX\": \"^3.8.0\"\n  },\n  \"uni_modules\": {\n    \"platforms\": {\n      \"app-android\": {\n        \"utssdk\": {\n          \"kotlin\": \">=1.7.0\"\n        }\n      },\n      \"web\": {\n        \"utssdk\": {}\n      }\n    }\n  }\n}\n```\n\n## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`\n\n```ts\nexport type IdValue = {\n  value?: string;\n  hash?: string;\n  available: boolean;\n  limited?: boolean;\n  source: string;\n  message?: string;\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue;\n  widevineId?: IdValue;\n  pseudoId?: IdValue;\n  imei?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`\n\n```ts\n// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）\nexport async function sha256Hex(input: string): Promise<string> {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const enc = new TextEncoder().encode(input);\n    const buf = await g.crypto.subtle.digest(\"SHA-256\", enc);\n    const arr = Array.from(new Uint8Array(buf));\n    return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现\n  return input;\n}\n```\n\n## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`\n\n```ts\nexport function get(key: string): string | null {\n  try {\n    // @ts-ignore\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\n\nexport function set(key: string, val: string) {\n  try {\n    // @ts-ignore\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getAndroidId(): Promise<IdValue> {\n  // Web 没有 AndroidID\n  return await build(\n    \"androidId\",\n    undefined,\n    false,\n    false,\n    \"Not supported on Web\"\n  );\n}\n\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"androidId\") >= 0) res.androidId = await getAndroidId();\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n\n  // 国内默认优先级\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`\n\n```ts\n// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）\nexport function getAndroidIdRaw(): string | null {\n  try {\n    // @ts-ignore\n    const ctx = plus.android.runtimeMainActivity();\n    // @ts-ignore\n    const SettingsSecure = plus.android.importClass(\n      \"android.provider.Settings$Secure\"\n    );\n    // @ts-ignore\n    const contentResolver = ctx.getContentResolver();\n    // @ts-ignore\n    const id = SettingsSecure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch (e) {\n    return null;\n  }\n}\n```\n\n## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\n// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：\n// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现\nasync function sha256Hex(input: string): Promise<string> {\n  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256\n}\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 这里接入你的合规弹窗/SDK；同意前建议不采集\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  const v = getAndroidIdRaw();\n  return await build(\"androidId\", v || undefined, exposeRaw);\n}\n\n// 预留：接入 Google Advertising ID（AAID）\nexport async function getAAID(): Promise<IdValue> {\n  // TODO：集成 com.google.android.gms:play-services-ads-identifier\n  return await build(\"aaid\", undefined, false, true, \"AAID not integrated\");\n}\n\n// 预留：接入 MSA OAID（国内主流）\nexport async function getOAID(): Promise<IdValue> {\n  // TODO：接入 MSA/OAID SDK\n  return await build(\"oaid\", undefined, false, true, \"OAID not integrated\");\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  // 国内优先级：oaid > androidId > guid\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）\n\n```ts\n// 平台分发：同名导出，业务方 import 一处即可\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n```\n\n---\n\n# 四、在页面中使用（uni-app x）\n\n```ts\n// pages/login/index.uvue (示例)\nimport {\n  register,\n  setSalt,\n  getBestId,\n  getIdCodes,\n} from \"@/uni_modules/uni-id-kit/utssdk/index.uts\";\n\nonMounted(async () => {\n  await register(); // 视需求弹你的隐私协议\n  setSalt(\"server-salt-xxx\"); // 建议从服务端下发\n\n  const best = await getBestId({ exposeRaw: false });\n  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）\n  const dvc = best.hash || best.value || \"unknown\";\n\n  await uni.request({\n    url: `${baseUrl}/passkeys/login/options`,\n    method: \"POST\",\n    header: { \"x-device-id\": dvc },\n    data: {},\n  });\n});\n```\n\n---\n\n# 五、后续接入指引（Android OAID/AAID）\n\n- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。\n- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。\n- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。\n- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。\n- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。\n\n---\n\n如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。\n",
            "url": "https://example.com/posts/id-kit",
            "title": "id-kit",
            "date_modified": "2025-09-07T12:35:03.000Z"
        },
        {
            "id": "https://example.com/posts/id-kit开发",
            "content_html": "\n# 一、插件命名 & 目录结构\n\n**插件名**：`uni-id-kit`（简洁、易记、符合 uni 插件生态）\n\n- 英文：**UniIdKit**\n- 中文：**一体设备 ID 工具包**\n\n**目录（uni_modules 标准）**：\n\n```\nuni_modules/\n  uni-id-kit/\n    package.json\n    module.json\n    utssdk/\n      index.uts              # 聚合导出（按平台分发）\n      common/\n        types.uts            # 类型与常量定义（复用）\n        hash.uts             # SHA-256 工具（Web/Android 均可）\n        storage.uts          # 本地缓存工具（uni.storage封装）\n      web/\n        index.uts            # Web 实现（GUID、hash、缓存）\n      app-android/\n        index.uts            # Android 实现（AndroidID，OAID/AAID占位）\n        adapters/\n          android_id.uts     # ANDROID_ID\n          aaid.uts           # Google AAID（待接SDK）\n          oaid.uts           # MSA OAID  （待接SDK）\n          pseudo_id.uts      # 伪ID（可选）\n```\n\n> iOS（IDFV）可稍后补：`app-ios/index.uts` + `adapters/idfv.uts`。\n> 你让我们“先国内”，就先 **Web→Android**；Android 国内核心是 **AndroidID/OAID**，海外补 **AAID**。\n\n---\n\n# 二、API 设计（Promise + 回调兼容）\n\n> 统一 Promise 风格，另兼容回调（可选）；返回结构“可读 + 可扩展”。\n\n## 公开方法\n\n```ts\n// 1) 隐私合规：注册/初始化（未同意时一律返回 available=false）\nexport function register(options?: {\n  showPrivacyDialog?: boolean; // 需要时展示你自有的隐私弹窗\n}): Promise<{ consent: boolean }>;\n\n// 2) 配置哈希盐（建议服务端下发）；默认仅返回 hash\nexport function setSalt(salt: string): void;\n\n// 3) 一次性获取所有可用的 ID（聚合）\nexport function getIdCodes(options?: {\n  include?: Array<\n    | \"oaid\"\n    | \"aaid\"\n    | \"androidId\"\n    | \"idfv\"\n    | \"widevineId\"\n    | \"pseudoId\"\n    | \"imei\"\n    | \"guid\"\n  >;\n  exposeRaw?: boolean; // 默认 false（仅返回hash），开启后返回原值 value\n  ttlMs?: number; // 缓存有效期，默认 24h\n}): Promise<IdCodesResult>;\n\n// 4) 返回“最合适”的一个（按优先级：国内默认 oaid > androidId > guid）\nexport function getBestId(options?: {\n  prefer?: Array<\"oaid\" | \"aaid\" | \"androidId\" | \"idfv\" | \"guid\">; // 可自定义优先级\n  exposeRaw?: boolean;\n  ttlMs?: number;\n}): Promise<IdValue>;\n\n// 5) 单项拉取（必要时）\nexport function getOAID(): Promise<IdValue>;\nexport function getAAID(): Promise<IdValue>;\nexport function getAndroidId(): Promise<IdValue>;\nexport function getGuid(): Promise<IdValue>;\n```\n\n## 返回类型（最佳实践）\n\n```ts\n// utssdk/common/types.uts\nexport type IdValue = {\n  value?: string; // 原始值（exposeRaw=true 才返回）\n  hash?: string; // SHA-256(value + salt) 十六进制\n  available: boolean; // 是否获取成功\n  limited?: boolean; // 是否受限（系统关闭广告跟踪等）\n  source: string; // oaid/aaid/androidId/idfv/guid/...\n  message?: string; // 失败或说明\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue; // 预留给 iOS\n  widevineId?: IdValue; // 可选\n  pseudoId?: IdValue; // 可选\n  imei?: IdValue; // 不建议默认启用\n  guid?: IdValue; // H5/兜底\n  best?: string | null; // 最佳项的 key\n  consent: boolean;\n  ts: number; // 生成时间戳\n};\n```\n\n---\n\n# 三、首版代码（可直接放进项目）\n\n> **说明**：以下代码为 **可运行骨架**。\n>\n> - Web：已可直接返回 `guid`（localStorage/uni.storage 持久化），并做 SHA-256。\n> - Android：已可返回 **AndroidID**（无需额外权限），OAID/AAID 先返回占位（后续你把 SDK 接上）。\n> - 聚合导出：`utssdk/index.uts` 会按平台引导到对应实现。\n\n## 1）`uni_modules/uni-id-kit/module.json`\n\n```json\n{\n  \"id\": \"uni-id-kit\",\n  \"displayName\": \"UniIdKit - 一体设备ID工具包\",\n  \"version\": \"0.1.0\",\n  \"description\": \"聚合 OAID/AAID/AndroidID/GUID 等设备标识，合规&哈希化输出\",\n  \"keywords\": [\"deviceid\", \"oaid\", \"aaid\", \"androidid\", \"guid\", \"uts\"],\n  \"repository\": \"\",\n  \"engines\": {\n    \"HBuilderX\": \"^3.8.0\"\n  },\n  \"uni_modules\": {\n    \"platforms\": {\n      \"app-android\": {\n        \"utssdk\": {\n          \"kotlin\": \">=1.7.0\"\n        }\n      },\n      \"web\": {\n        \"utssdk\": {}\n      }\n    }\n  }\n}\n```\n\n## 2）`uni_modules/uni-id-kit/utssdk/common/types.uts`\n\n```ts\nexport type IdValue = {\n  value?: string;\n  hash?: string;\n  available: boolean;\n  limited?: boolean;\n  source: string;\n  message?: string;\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue;\n  widevineId?: IdValue;\n  pseudoId?: IdValue;\n  imei?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n## 3）`uni_modules/uni-id-kit/utssdk/common/hash.uts`\n\n```ts\n// Web 有 crypto.subtle；Android 走 Java MessageDigest（见安卓实现）\nexport async function sha256Hex(input: string): Promise<string> {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const enc = new TextEncoder().encode(input);\n    const buf = await g.crypto.subtle.digest(\"SHA-256\", enc);\n    const arr = Array.from(new Uint8Array(buf));\n    return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  // 无 WebCrypto 时，先退回原文（开发期），建议后续接原生或 JS 实现\n  return input;\n}\n```\n\n## 4）`uni_modules/uni-id-kit/utssdk/common/storage.uts`\n\n```ts\nexport function get(key: string): string | null {\n  try {\n    // @ts-ignore\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\n\nexport function set(key: string, val: string) {\n  try {\n    // @ts-ignore\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n## 5）`uni_modules/uni-id-kit/utssdk/web/index.uts`（Web 实现）\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // Web demo：默认视为已同意；你可以在这里弹你的隐私弹窗\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getAndroidId(): Promise<IdValue> {\n  // Web 没有 AndroidID\n  return await build(\n    \"androidId\",\n    undefined,\n    false,\n    false,\n    \"Not supported on Web\"\n  );\n}\n\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"androidId\") >= 0) res.androidId = await getAndroidId();\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n\n  // 国内默认优先级\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 6）`uni_modules/uni-id-kit/utssdk/app-android/adapters/android_id.uts`\n\n```ts\n// ANDROID_ID，无需额外权限（相对稳定，但可能因某些ROM策略变化）\nexport function getAndroidIdRaw(): string | null {\n  try {\n    // @ts-ignore\n    const ctx = plus.android.runtimeMainActivity();\n    // @ts-ignore\n    const SettingsSecure = plus.android.importClass(\n      \"android.provider.Settings$Secure\"\n    );\n    // @ts-ignore\n    const contentResolver = ctx.getContentResolver();\n    // @ts-ignore\n    const id = SettingsSecure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch (e) {\n    return null;\n  }\n}\n```\n\n## 7）`uni_modules/uni-id-kit/utssdk/app-android/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\n// Android 原生侧用 Java 的 MessageDigest 做 SHA-256 更稳，这里暂用 Web 版占位：\n// 你也可以在此通过 plus.android.importClass 使用 java.security.MessageDigest 实现\nasync function sha256Hex(input: string): Promise<string> {\n  return input; // TODO: 接入原生 MessageDigest 后返回真 SHA-256\n}\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 这里接入你的合规弹窗/SDK；同意前建议不采集\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  const v = getAndroidIdRaw();\n  return await build(\"androidId\", v || undefined, exposeRaw);\n}\n\n// 预留：接入 Google Advertising ID（AAID）\nexport async function getAAID(): Promise<IdValue> {\n  // TODO：集成 com.google.android.gms:play-services-ads-identifier\n  return await build(\"aaid\", undefined, false, true, \"AAID not integrated\");\n}\n\n// 预留：接入 MSA OAID（国内主流）\nexport async function getOAID(): Promise<IdValue> {\n  // TODO：接入 MSA/OAID SDK\n  return await build(\"oaid\", undefined, false, true, \"OAID not integrated\");\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"aaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  // 国内优先级：oaid > androidId > guid\n  const order = [\"oaid\", \"androidId\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const arr = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: arr as any, exposeRaw } as any);\n  if (r.best) {\n    // @ts-ignore\n    return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n## 8）`uni_modules/uni-id-kit/utssdk/index.uts`（聚合导出）\n\n```ts\n// 平台分发：同名导出，业务方 import 一处即可\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n```\n\n---\n\n# 四、在页面中使用（uni-app x）\n\n```ts\n// pages/login/index.uvue (示例)\nimport {\n  register,\n  setSalt,\n  getBestId,\n  getIdCodes,\n} from \"@/uni_modules/uni-id-kit/utssdk/index.uts\";\n\nonMounted(async () => {\n  await register(); // 视需求弹你的隐私协议\n  setSalt(\"server-salt-xxx\"); // 建议从服务端下发\n\n  const best = await getBestId({ exposeRaw: false });\n  // 携带 best.hash 作为 x-device-id（或 getIdCodes 的 best 项）\n  const dvc = best.hash || best.value || \"unknown\";\n\n  await uni.request({\n    url: `${baseUrl}/passkeys/login/options`,\n    method: \"POST\",\n    header: { \"x-device-id\": dvc },\n    data: {},\n  });\n});\n```\n\n---\n\n# 五、后续接入指引（Android OAID/AAID）\n\n- **OAID**：集成 **MSA/联运** SDK（各大国产厂商支持），在 `app-android/adapters/oaid.uts` 中封装 `getOAIDRaw()`，在 `index.uts` 调 `await build('oaid', v, ...)`。\n- **AAID**：添加 `com.google.android.gms:play-services-ads-identifier` 依赖，调用 `AdvertisingIdClient.getAdvertisingIdInfo(context)`。\n- **SHA-256**：Android 侧推荐用 `java.security.MessageDigest`，性能更稳定；把 web 占位换掉。\n- **权限**：AndroidID 不需要额外权限；IMEI/MEID 需要 READ_PHONE_STATE（**不推荐默认启用**）。\n- **合规**：未同意隐私协议前，一律返回 `available=false`；默认仅返回 `hash`，除非 `exposeRaw=true`。\n\n---\n\n如果你认可这个结构和 API，我可以继续把 **Android 的 OAID/AAID 具体适配代码**补上（带依赖、打包参数、权限说明），以及 **iOS 的 IDFV** 版本。\n\n# 参考实现\n\n太好了，我把你这两个现成插件解包看过了，简单总结下各自实现，然后给一套“最佳实践”的统一 API 和落地改造方案（含可以直接替换的 UTS 代码片段）。\n\n---\n\n## 现有两个插件的实现差异（速览）\n\n### 1) `android-deviceid`（UTS，App-Android）\n\n- **用到的库**：`com.github.gzuliyujiang.oaid`（常用 OAID SDK 聚合库），还打包了 3 个 AAR（`ads-identifier-*.aar`、`IDlibrary-release.aar`）。\n- **关键点**：\n\n  - 在 `register()` 里调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity().getApplication())` 完成 **OAID 初始化**。\n  - 暴露了一个 **监听器**（`IDManger.OnIOAIDListener`），把厂商返回的 JSON 结果转成你定义的 `Device` 对象回调出去。\n\n- **优点**：能拿到 **OAID**，并且是较为标准的做法；兼容多厂商。\n- **需要补强**：\n\n  - **统一 Promise API**（目前是回调），方便在页面里用 `await`。\n  - **AAID（Google 广告 ID）**、**AndroidID** 的兜底与优先级策略。\n  - **隐私合规**（register 同意前不采集）、**hash-only** 输出（默认只回传哈希，原值可开关）。\n  - **缓存**（ttl），防止频繁拉取。\n  - 错误/受限标记（例如用户关闭了广告跟踪）。\n\n### 2) `zws-uniqueid`（UTS，App-Android）\n\n- **实现**：拼接 `Build.*` 信息做一段文本，MD5 后作为“唯一 ID”。\n- **优点**：无需权限/SDK，易用。\n- **问题**：这是典型 **PseudoID**，**同型号/同批次设备可能相同**，也可能因 ROM/版本变更；不适合用来做**设备唯一绑定**或风控。\n- **建议**：可以作为 `pseudoId` 字段的**最末位兜底**，不要当主标识。\n\n---\n\n## 建议的统一方案（名字可用你之前认可的：**`uni-id-kit`**）\n\n**目标**：同一份 UTS 插件，覆盖 Web/H5 与 App-Android；API 一致、返回结构一致、默认合规（hash-only），国内优先级 `OAID > AndroidID > GUID > PseudoID`，海外可加 `AAID`。\n\n### 统一 API（Promise 风格）\n\n```ts\n// 注册/合规：未同意前一律 available=false\nexport function register(options?: {\n  showPrivacyDialog?: boolean;\n}): Promise<{ consent: boolean }>;\n\n// 配置哈希盐（建议服务端下发）\nexport function setSalt(salt: string): void;\n\n// 一次性获取所有（含可用性、受限说明、hash）\nexport function getIdCodes(options?: {\n  include?: Array<\"oaid\" | \"aaid\" | \"androidId\" | \"pseudoId\" | \"guid\">;\n  exposeRaw?: boolean; // 默认 false\n  ttlMs?: number; // 默认 24h\n}): Promise<IdCodesResult>;\n\n// 返回“最合适”的一个（按优先级，可定制）\nexport function getBestId(options?: {\n  prefer?: Array<\"oaid\" | \"androidId\" | \"guid\" | \"pseudoId\" | \"aaid\">;\n  exposeRaw?: boolean;\n  ttlMs?: number;\n}): Promise<IdValue>;\n\n// 单项\nexport function getOAID(): Promise<IdValue>;\nexport function getAAID(): Promise<IdValue>;\nexport function getAndroidId(): Promise<IdValue>;\nexport function getGuid(): Promise<IdValue>;\n```\n\n**统一返回结构**\n\n```ts\ntype IdValue = {\n  value?: string; // exposeRaw=true 才返回\n  hash?: string; // SHA-256(value + salt)\n  available: boolean;\n  limited?: boolean; // 例如系统关闭广告跟踪\n  source: string; // oaid/aaid/androidId/pseudoId/guid\n  message?: string;\n};\n\ntype IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  pseudoId?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n---\n\n## 如何改造你现有的两个插件\n\n> 下面给的都是 **直接能塞进工程** 的 UTS 代码。你可以新建一个 `uni_modules/uni-id-kit`，把这两个插件的“能力”合在一起；或者在你现有 `android-deviceid` 里重构导出，效果一致。\n\n### 1) 公共类型与工具（`common/types.uts`、`common/storage.uts`、`common/hash.uts`）\n\n```ts\n// common/types.uts\nexport type IdValue = {\n  value?: string;\n  hash?: string;\n  available: boolean;\n  limited?: boolean;\n  source: string;\n  message?: string;\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  pseudoId?: IdValue;\n  guid?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n```ts\n// common/storage.uts\nexport function get(key: string): string | null {\n  try {\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\nexport function set(key: string, val: string) {\n  try {\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n```ts\n// common/hash.uts（Web 有 crypto.subtle；Android 建议换成 MessageDigest）\nexport async function sha256Hex(input: string): Promise<string> {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const enc = new TextEncoder().encode(input);\n    const buf = await g.crypto.subtle.digest(\"SHA-256\", enc);\n    return Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n  return input; // Android 再换成原生 MessageDigest（见下）\n}\n```\n\n### 2) Web 实现（先把 H5 跑起来：GUID + hash + 缓存）\n\n```ts\n// web/index.uts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  _consent = true; // 你可在这里弹你的隐私协议\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\n\nexport async function getAndroidId(): Promise<IdValue> {\n  return await build(\n    \"androidId\",\n    undefined,\n    false,\n    false,\n    \"Not supported on Web\"\n  );\n}\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Not supported on Web\");\n}\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Not supported on Web\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  res.best = res.guid?.available ? \"guid\" : null;\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const r = await getIdCodes(options);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n### 3) Android 实现（融合你两个插件思路，Promise 化 + 兜底 + 可拓展）\n\n- **AndroidID**：直接取 `Settings.Secure.ANDROID_ID`（不需要权限）。\n- **OAID**：沿用你 `android-deviceid` 的库，包装为 Promise；初始化要在 `register()` 里做。\n- **AAID**：先留占位，后续加 `play-services-ads-identifier`。\n- **PseudoID**：把 `zws-uniqueid` 的思路做成可选兜底，不当主标识。\n- **SHA-256**：建议在 Android 侧用 `java.security.MessageDigest`，比 web 占位靠谱。\n\n```ts\n// app-android/adapters/android_id.uts\nexport function getAndroidIdRaw(): string | null {\n  try {\n    // @ts-ignore\n    const ctx = plus.android.runtimeMainActivity();\n    // @ts-ignore\n    const SettingsSecure = plus.android.importClass(\n      \"android.provider.Settings$Secure\"\n    );\n    // @ts-ignore\n    const contentResolver = ctx.getContentResolver();\n    // @ts-ignore\n    const id = SettingsSecure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch (e) {\n    return null;\n  }\n}\n```\n\n```ts\n// app-android/adapters/pseudo_id.uts（把 zws 的实现收编为兜底项）\nimport Build from \"android.os.Build\";\nimport MessageDigest from \"java.security.MessageDigest\";\nimport BigInteger from \"java.math.BigInteger\";\n\nexport function getPseudoIdRaw(): string | null {\n  try {\n    const text =\n      Build.BOARD +\n      Build.BRAND +\n      Build.DEVICE +\n      Build.DISPLAY +\n      Build.FINGERPRINT +\n      \"uni-id-kit\";\n    const md5s = MessageDigest.getInstance(\"MD5\").digest(\n      (text as any).toString().toByteArray()\n    );\n    return new BigInteger(1, md5s).toString(16);\n  } catch {\n    return null;\n  }\n}\n```\n\n```ts\n// app-android/index.uts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\nimport { getPseudoIdRaw } from \"./adapters/pseudo_id.uts\";\n\n// ==== 引入你 android-deviceid 插件用到的 OAID 库 ====\nimport DeviceIdentifier from \"com.github.gzuliyujiang.oaid.DeviceIdentifier\";\n// 你现有的监听器写法是 IDManger.OnIOAIDListener + JSON 回调，这里改 Promise 风格：\n// 如果库支持 IGetter 回调也可以（取决于版本），我这里按你包内的风格保留 register 初始化。\n\nlet _consent = false;\nlet _salt = \"\";\n\n// 使用 Android 的 MessageDigest 实现 SHA-256（优于 web 占位）\nfunction sha256HexSync(input: string): string {\n  try {\n    // @ts-ignore\n    const MessageDigest = plus.android.importClass(\n      \"java.security.MessageDigest\"\n    );\n    // @ts-ignore\n    const md = MessageDigest.getInstance(\"SHA-256\");\n    // @ts-ignore\n    const bytes = (input as any).toString().getBytes();\n    const out = md.digest(bytes);\n    let hex = \"\";\n    for (let i = 0; i < out.length; i++) {\n      const b = (out[i] as number) & 0xff;\n      hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n    }\n    return hex;\n  } catch {\n    return input;\n  }\n}\n\nfunction uuid4(): string {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = ((Math.random() * 16) as number) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nfunction buildSync(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): IdValue {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? sha256HexSync(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  try {\n    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);\n  } catch {}\n  _consent = true; // 这里接你的隐私弹窗\n  return { consent: _consent } as UTSJSONObject;\n}\n\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  const v = getAndroidIdRaw();\n  return buildSync(\"androidId\", v || undefined, exposeRaw);\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return buildSync(\"guid\", guid as string, exposeRaw);\n}\n\n// OAID：基于你现有库封装为 Promise（示例：如果库是同步 API 换成同步返回即可）\nexport async function getOAID(): Promise<IdValue> {\n  try {\n    // 你包里是通过监听器把结果 JSON 回调出来的；\n    // 这里建议写一个同步/异步包装（示意）：\n    // 假设库提供 DeviceIdentifier.getOAID(ctx) 或者 DeviceID.getOAID(...)\n    // 如果仅有回调形式，就 new Promise 包一下。\n    // 先占位为“未集成”，避免误用：\n    return buildSync(\n      \"oaid\",\n      undefined,\n      false,\n      true,\n      \"OAID not integrated to Promise wrapper\"\n    );\n  } catch (e) {\n    return buildSync(\"oaid\", undefined, false, false, (e as any).toString());\n  }\n}\n\n// AAID：等你接 play-services-ads-identifier，这里先占位\nexport async function getAAID(): Promise<IdValue> {\n  return buildSync(\"aaid\", undefined, false, true, \"AAID not integrated\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"pseudoId\") >= 0)\n    res.pseudoId = buildSync(\n      \"pseudoId\",\n      getPseudoIdRaw() || undefined,\n      exposeRaw\n    );\n\n  // 国内默认优先级：oaid > androidId > guid > pseudoId\n  const order = [\"oaid\", \"androidId\", \"guid\", \"pseudoId\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    // @ts-ignore\n    const v: IdValue | null = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const prefer = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n### 4) 平台聚合导出（`utssdk/index.uts`）\n\n```ts\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n```\n\n---\n\n## 要不要“调整现在的代码”？\n\n**要的**，但改动并不大，主要集中在 4 点：\n\n1. **Promise 化**：把回调/监听器的导出改为 Promise，页面里可以 `await`。\n2. **统一返回结构**：所有方法都返回 `IdValue/IdCodesResult`，好串联与埋点。\n3. **合规默认 & hash-only**：提供 `register()` 和 `setSalt()`，未同意前不采集；默认只回 `hash`。\n4. **兜底与优先级**：在拿不到 OAID 时，**自动回退**到 `AndroidID`、`GUID`、`pseudoId`，并清晰标出 `limited`/`message`。\n\n> 你的 `android-deviceid` 插件可以直接把库继续用；我在上面的安卓实现里已经把“桥接位”留好了。\n> `zws-uniqueid` 的算法我收编到 `pseudoId`，作为兜底，不再当主标识使用。\n\n---\n\n## 下一步\n\n- 你确认用 **`uni-id-kit`** 的方案我就把 **OAID Promise 包装**（基于你现有 `DeviceIdentifier` 监听回调）也给你写上，并且给出 **AAID 接入**（`play-services-ads-identifier`）的 `gradle` 依赖与 UTS 调用示例。\n- 如果需要，我也可以给 **iOS（IDFV）** 的 UTS 版本，一起并到这个套件里。\n\n没问题。我把你给的两个 UTS 插件（`android-deviceid` / `zws-uniqueid`）的可取之处吸收，做成一套\\*\\*“最佳实践版”统一插件\\*\\*：**`uni-id-kit`**。它满足：\n\n- 跨端（H5 / App-Android / App-iOS），统一 Promise API；\n- 默认合规：需先 `register()` 才采集；默认只回 **hash**（可开 `exposeRaw` 返回原值）；\n- 国内优先级（可自定义）：**OAID > AndroidID > GUID > PseudoID**，海外可加 **AAID**；\n- 安全版 UUID：多端用系统级安全随机（`crypto.getRandomValues` / `SecureRandom` / `SecRandomCopyBytes`），兜底 `Math.random`；\n- 缓存、错误与受限标记（如“限制广告跟踪”）；\n- 兼容你现有后端（请求头携带 `x-device-id` 即可）。\n\n> 下方给出**可直接落地**的文件结构与代码（可直接新建 `uni_modules/uni-id-kit`），Android 的 OAID/AAID 留好“可用的占位与接入点”；如果你确认要接哪套 SDK（MSA 官方/聚合库），我再把桥接也补全为可跑版本。\n\n---\n\n# 目录结构（放到项目的 `uni_modules/uni-id-kit`）\n\n```\nuni_modules/\n  uni-id-kit/\n    module.json\n    package.json\n    utssdk/\n      index.uts\n      common/\n        types.uts\n        uuid.uts\n        hash.uts\n        storage.uts\n      web/\n        index.uts\n      app-android/\n        index.uts\n        adapters/\n          android_id.uts\n          oaid.uts\n          aaid.uts\n          pseudo_id.uts\n      app-ios/\n        index.uts\n```\n\n---\n\n# 1) module.json\n\n```json\n{\n  \"id\": \"uni-id-kit\",\n  \"displayName\": \"UniIdKit - 一体设备ID工具包\",\n  \"version\": \"0.2.0\",\n  \"description\": \"聚合 OAID/AAID/AndroidID/GUID/IDFV 等设备标识，合规 & 哈希化输出，UTS 插件\",\n  \"keywords\": [\"deviceid\", \"oaid\", \"aaid\", \"androidid\", \"idfv\", \"guid\", \"uts\"],\n  \"engines\": { \"HBuilderX\": \">=3.8.0\" },\n  \"uni_modules\": {\n    \"platforms\": {\n      \"web\": { \"utssdk\": {} },\n      \"app-android\": { \"utssdk\": { \"kotlin\": \">=1.7.0\" } },\n      \"app-ios\": { \"utssdk\": {} }\n    }\n  }\n}\n```\n\n---\n\n# 2) 公共类型/工具\n\n## `utssdk/common/types.uts`\n\n```ts\nexport type IdValue = {\n  value?: string; // exposeRaw=true 才返回\n  hash?: string; // SHA-256(value + salt)\n  available: boolean; // 是否成功获取\n  limited?: boolean; // 广告跟踪受限/ROM限制\n  source: string; // oaid/aaid/androidId/idfv/guid/pseudoId\n  message?: string; // 说明/错误\n};\n\nexport type IdCodesResult = {\n  oaid?: IdValue;\n  aaid?: IdValue;\n  androidId?: IdValue;\n  idfv?: IdValue;\n  guid?: IdValue;\n  pseudoId?: IdValue;\n  best?: string | null;\n  consent: boolean;\n  ts: number;\n};\n```\n\n## `utssdk/common/hash.uts`\n\n```ts\n// Web 有 crypto.subtle；原生侧建议用平台 API（Android 代码里换成 MessageDigest；iOS 侧可换 CommonCrypto）\nexport async function sha256Hex(input: string): Promise<string> {\n  // #ifdef H5\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.subtle) {\n    const buf = await g.crypto.subtle.digest(\n      \"SHA-256\",\n      new TextEncoder().encode(input)\n    );\n    return Array.from(new Uint8Array(buf))\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n  // #endif\n  return input; // 非H5先返回原文；Android/iOS在各自实现中用系统哈希\n}\n```\n\n## `utssdk/common/storage.uts`\n\n```ts\nexport function get(key: string): string | null {\n  try {\n    return uni.getStorageSync(key) || null;\n  } catch {\n    return null;\n  }\n}\nexport function set(key: string, val: string) {\n  try {\n    uni.setStorageSync(key, val);\n  } catch {}\n}\n```\n\n## `utssdk/common/uuid.uts`（跨端安全 UUIDv4）\n\n```ts\nfunction toHex(): string[] {\n  const h: string[] = [];\n  for (let i = 0; i < 256; i++) h[i] = (i + 0x100).toString(16).substring(1);\n  return h;\n}\nfunction formatUuid(b: Uint8Array): string {\n  b[6] = (b[6] & 0x0f) | 0x40; // version=4\n  b[8] = (b[8] & 0x3f) | 0x80; // variant=10\n  const H = toHex();\n  return (\n    H[b[0]] +\n    H[b[1]] +\n    H[b[2]] +\n    H[b[3]] +\n    \"-\" +\n    H[b[4]] +\n    H[b[5]] +\n    \"-\" +\n    H[b[6]] +\n    H[b[7]] +\n    \"-\" +\n    H[b[8]] +\n    H[b[9]] +\n    \"-\" +\n    H[b[10]] +\n    H[b[11]] +\n    H[b[12]] +\n    H[b[13]] +\n    H[b[14]] +\n    H[b[15]]\n  );\n}\n\n// #ifdef H5\nfunction getRandom16(): Uint8Array {\n  // @ts-ignore\n  const g: any = globalThis;\n  if (g && g.crypto && g.crypto.getRandomValues)\n    return g.crypto.getRandomValues(new Uint8Array(16));\n  const a = new Uint8Array(16);\n  for (let i = 0; i < 16; i++) a[i] = Math.floor(Math.random() * 256);\n  return a;\n}\n// #endif\n\n// #ifdef APP-ANDROID\nfunction getRandom16(): Uint8Array {\n  const sr = new java.security.SecureRandom(); // UTS 原生：直接 Java 类\n  const arr: number[] = new Array<number>(16);\n  for (let i = 0; i < 16; i++) arr[i] = sr.nextInt(256);\n  return new Uint8Array(arr);\n}\n// #endif\n\n// #ifdef APP-IOS\n// 使用 Security 的 SecRandomCopyBytes（UTS 映射到 Swift）\nfunction getRandom16(): Uint8Array {\n  const bytes = new Uint8Array(16);\n  // @ts-ignore\n  const ok = SecRandomCopyBytes(kSecRandomDefault, 16, bytes);\n  if (ok === 0) return bytes;\n  // 兜底 arc4random_buf\n  // @ts-ignore\n  arc4random_buf(bytes, 16);\n  return bytes;\n}\n// #endif\n\nexport function uuid4(): string {\n  return formatUuid(getRandom16());\n}\n```\n\n---\n\n# 3) H5 实现\n\n## `utssdk/web/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { sha256Hex } from \"../common/hash.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { uuid4 } from \"../common/uuid.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: IdCodesResult } | null = null;\n\nasync function build(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): Promise<IdValue> {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? await sha256Hex(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 这里接你的隐私弹窗；Demo 直接视为同意\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `web:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return await build(\"guid\", guid as string, exposeRaw);\n}\nexport async function getAndroidId(): Promise<IdValue> {\n  return await build(\"androidId\", undefined, false, false, \"Web unsupported\");\n}\nexport async function getOAID(): Promise<IdValue> {\n  return await build(\"oaid\", undefined, false, false, \"Web unsupported\");\n}\nexport async function getAAID(): Promise<IdValue> {\n  return await build(\"aaid\", undefined, false, false, \"Web unsupported\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const ttl = (options?.getNumber(\"ttlMs\") || 24 * 3600 * 1000) as number;\n\n  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  res.best = res.guid?.available ? \"guid\" : null;\n  _cache = { ts: Date.now(), data: res };\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const r = await getIdCodes(options);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n---\n\n# 4) Android 实现（融合两插件思路）\n\n- **参考自** `android-deviceid`：OAID 初始化/拉取（此处给出 Promise 版接口占位，方便你把已购库接上）；\n- **参考自** `zws-uniqueid`：PseudoID 作为**兜底**而非主标识；\n- **AndroidID**：不需权限，稳定性较好；\n- **AAID**：留占位（接入 `play-services-ads-identifier` 后即可实现）；\n- **哈希**：用 `java.security.MessageDigest`（强于 H5 占位）。\n\n## `utssdk/app-android/adapters/android_id.uts`\n\n```ts\nexport function getAndroidIdRaw(): string | null {\n  try {\n    const contentResolver = uni.getContext().getContentResolver();\n    const id = android.provider.Settings$Secure.getString(\n      contentResolver,\n      \"android_id\"\n    ) as string;\n    return id ? `android:${id}` : null;\n  } catch {\n    return null;\n  }\n}\n```\n\n## `utssdk/app-android/adapters/pseudo_id.uts`\n\n```ts\nexport function getPseudoIdRaw(): string | null {\n  try {\n    const text =\n      android.os.Build.BOARD +\n      android.os.Build.BRAND +\n      android.os.Build.DEVICE +\n      android.os.Build.DISPLAY +\n      android.os.Build.FINGERPRINT +\n      \"uni-id-kit\";\n    const md = java.security.MessageDigest.getInstance(\"MD5\");\n    md.update((text as any).toString().getBytes(\"UTF-8\"));\n    const out = md.digest();\n    let hex = \"\";\n    for (let i = 0; i < out.length; i++) {\n      const b = (out[i] as number) & 0xff;\n      hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n    }\n    return hex;\n  } catch {\n    return null;\n  }\n}\n```\n\n## `utssdk/app-android/adapters/oaid.uts`（接入点）\n\n```ts\n// 这里封装你现有的 OAID 库调用（例如使用 com.github.gzuliyujiang.oaid）\n// 由于每家库的接口不完全一致，这里给 Promise 化占位；你把实际调用贴进来即可。\nexport async function getOAIDRaw(): Promise<{\n  value?: string;\n  limited?: boolean;\n  message?: string;\n}> {\n  try {\n    // TODO: 用你的库实际实现（初始化 register 在 index.uts 的 register() 里做）\n    // 例如：DeviceIdentifier.getOAID(context, callback) -> 在 callback 里 resolve\n    return {\n      value: undefined,\n      limited: true,\n      message: \"OAID not integrated yet\",\n    };\n  } catch (e) {\n    return { value: undefined, limited: false, message: (e as any).toString() };\n  }\n}\n```\n\n## `utssdk/app-android/adapters/aaid.uts`（接入点）\n\n```ts\nexport async function getAAIDRaw(): Promise<{\n  value?: string;\n  limited?: boolean;\n  message?: string;\n}> {\n  try {\n    // TODO: 接入 play-services-ads-identifier：\n    // AdvertisingIdClient.getAdvertisingIdInfo(context).getId()\n    return {\n      value: undefined,\n      limited: true,\n      message: \"AAID not integrated yet\",\n    };\n  } catch (e) {\n    return { value: undefined, limited: false, message: (e as any).toString() };\n  }\n}\n```\n\n## `utssdk/app-android/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { uuid4 } from \"../common/uuid.uts\";\nimport { getAndroidIdRaw } from \"./adapters/android_id.uts\";\nimport { getOAIDRaw } from \"./adapters/oaid.uts\";\nimport { getAAIDRaw } from \"./adapters/aaid.uts\";\nimport { getPseudoIdRaw } from \"./adapters/pseudo_id.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: IdCodesResult } | null = null;\n\nfunction sha256HexSync(input: string): string {\n  try {\n    const md = java.security.MessageDigest.getInstance(\"SHA-256\");\n    md.update((input as any).toString().getBytes(\"UTF-8\"));\n    const out = md.digest();\n    let hex = \"\";\n    for (let i = 0; i < out.length; i++) {\n      const b = (out[i] as number) & 0xff;\n      hex += (b < 16 ? \"0\" : \"\") + b.toString(16);\n    }\n    return hex;\n  } catch {\n    return input;\n  }\n}\n\nfunction buildSync(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): IdValue {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? sha256HexSync(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  // 1) OAID 库初始化（把你 android-deviceid 的 register 放到这里）\n  //    例：DeviceIdentifier.register(uni.getContext().getApplicationContext())\n  try {\n    // TODO: 调你的 OAID 库 register\n  } catch {}\n\n  // 2) 你的隐私弹窗/合规流程\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nexport async function getAndroidId(\n  exposeRaw: boolean = false\n): Promise<IdValue> {\n  return buildSync(\"androidId\", getAndroidIdRaw() || undefined, exposeRaw);\n}\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `app:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return buildSync(\"guid\", guid as string, exposeRaw);\n}\nexport async function getOAID(): Promise<IdValue> {\n  const r = await getOAIDRaw();\n  return buildSync(\"oaid\", r.value, false, r.limited, r.message);\n}\nexport async function getAAID(): Promise<IdValue> {\n  const r = await getAAIDRaw();\n  return buildSync(\"aaid\", r.value, false, r.limited, r.message);\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n    \"aaid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const ttl = (options?.getNumber(\"ttlMs\") || 24 * 3600 * 1000) as number;\n\n  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"oaid\") >= 0) res.oaid = await getOAID();\n  if (include.indexOf(\"androidId\") >= 0)\n    res.androidId = await getAndroidId(exposeRaw);\n  if (include.indexOf(\"aaid\") >= 0) res.aaid = await getAAID();\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n  if (include.indexOf(\"pseudoId\") >= 0)\n    res.pseudoId = buildSync(\n      \"pseudoId\",\n      getPseudoIdRaw() || undefined,\n      exposeRaw\n    );\n\n  // 国内默认优先级（可通过 getBestId 覆盖）\n  const order = [\"oaid\", \"androidId\", \"guid\", \"pseudoId\", \"aaid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  _cache = { ts: Date.now(), data: res };\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const prefer = (options?.getArray<string>(\"prefer\") || [\n    \"oaid\",\n    \"androidId\",\n    \"guid\",\n    \"pseudoId\",\n    \"aaid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n---\n\n# 5) iOS 实现（IDFV）\n\n> 你说先国内为主；这里把 **IDFV** 实现好，方便未来开 iOS 端复用。\n\n## `utssdk/app-ios/index.uts`\n\n```ts\nimport { IdCodesResult, IdValue } from \"../common/types.uts\";\nimport { get, set } from \"../common/storage.uts\";\nimport { uuid4 } from \"../common/uuid.uts\";\n\nlet _consent = false;\nlet _salt = \"\";\nlet _cache: { ts: number; data: IdCodesResult } | null = null;\n\nfunction sha256HexSync(input: string): string {\n  // TODO: 可换成 CommonCrypto(CC_SHA256)；演示先返回原文\n  return input;\n}\nfunction buildSync(\n  source: string,\n  value?: string,\n  exposeRaw?: boolean,\n  limited?: boolean,\n  msg?: string\n): IdValue {\n  const available = !!value;\n  const raw = exposeRaw ? value : undefined;\n  const hash = value ? sha256HexSync(value + _salt) : undefined;\n  return { value: raw, hash, available, limited, source, message: msg };\n}\n\nexport async function register(\n  _: UTSJSONObject | null = null\n): Promise<UTSJSONObject> {\n  _consent = true;\n  return { consent: _consent } as UTSJSONObject;\n}\nexport function setSalt(salt: string): void {\n  _salt = salt || \"\";\n}\n\nfunction getIDFVRaw(): string | null {\n  try {\n    const idfv = UIDevice.currentDevice.identifierForVendor?.UUIDString;\n    return idfv ? `idfv:${idfv}` : null;\n  } catch {\n    return null;\n  }\n}\nexport async function getGuid(exposeRaw: boolean = false): Promise<IdValue> {\n  let guid = get(\"UNIIDKIT_GUID\");\n  if (!guid) {\n    guid = `ios:${uuid4()}`;\n    set(\"UNIIDKIT_GUID\", guid);\n  }\n  return buildSync(\"guid\", guid as string, exposeRaw);\n}\nexport async function getAndroidId(): Promise<IdValue> {\n  return buildSync(\"androidId\", undefined, false, false, \"iOS unsupported\");\n}\nexport async function getOAID(): Promise<IdValue> {\n  return buildSync(\"oaid\", undefined, false, false, \"iOS unsupported\");\n}\nexport async function getAAID(): Promise<IdValue> {\n  return buildSync(\"aaid\", undefined, false, false, \"iOS unsupported\");\n}\n\nexport async function getIdCodes(\n  options?: UTSJSONObject | null\n): Promise<IdCodesResult> {\n  const include = (options?.getArray<string>(\"include\") || [\n    \"idfv\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const ttl = (options?.getNumber(\"ttlMs\") || 24 * 3600 * 1000) as number;\n\n  if (_cache && Date.now() - _cache.ts < ttl) return _cache.data;\n\n  const res: IdCodesResult = {\n    consent: _consent,\n    ts: Date.now(),\n  } as IdCodesResult;\n  if (!_consent) {\n    res.guid = { available: false, source: \"guid\", message: \"consent=false\" };\n    return res;\n  }\n\n  if (include.indexOf(\"idfv\") >= 0)\n    res.idfv = buildSync(\"idfv\", getIDFVRaw() || undefined, exposeRaw);\n  if (include.indexOf(\"guid\") >= 0) res.guid = await getGuid(exposeRaw);\n\n  const order = [\"idfv\", \"guid\"];\n  res.best = null;\n  for (let i = 0; i < order.length; i++) {\n    const k = order[i];\n    /* @ts-ignore */ const v: IdValue = (res as UTSJSONObject)[k] as any;\n    if (v && v.available) {\n      res.best = k;\n      break;\n    }\n  }\n  _cache = { ts: Date.now(), data: res };\n  return res;\n}\n\nexport async function getBestId(\n  options?: UTSJSONObject | null\n): Promise<IdValue> {\n  const prefer = (options?.getArray<string>(\"prefer\") || [\n    \"idfv\",\n    \"guid\",\n  ]) as string[];\n  const exposeRaw = (options?.getBoolean(\"exposeRaw\") || false) as boolean;\n  const r = await getIdCodes({ include: prefer as any, exposeRaw } as any);\n  if (r.best) {\n    /* @ts-ignore */ return (r as UTSJSONObject)[r.best] as IdValue;\n  }\n  return { available: false, source: \"none\", message: \"no id available\" };\n}\n```\n\n---\n\n# 6) 平台聚合导出\n\n## `utssdk/index.uts`\n\n```ts\n// #ifdef H5\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./web/index.uts\";\n// #endif\n\n// #ifdef APP-ANDROID\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-android/index.uts\";\n// #endif\n\n// #ifdef APP-IOS\nexport {\n  register,\n  setSalt,\n  getIdCodes,\n  getBestId,\n  getOAID,\n  getAAID,\n  getAndroidId,\n  getGuid,\n} from \"./app-ios/index.uts\";\n// #endif\n```\n\n---\n\n# 7) 使用示例（在你的登录页中）\n\n```ts\nimport {\n  register,\n  setSalt,\n  getBestId,\n} from \"@/uni_modules/uni-id-kit/utssdk/index.uts\";\n\nonMounted(async () => {\n  await register({}); // 你的隐私弹窗/合规逻辑\n  setSalt(\"server-salt-xyz\"); // 建议服务端下发；默认只回 hash\n\n  const best = await getBestId({\n    prefer: [\"oaid\", \"androidId\", \"guid\"],\n    exposeRaw: false,\n  });\n  const dvc = best.hash || best.value || \"unknown\";\n\n  await uni.request({\n    url: `${baseUrl}/passkeys/login/options`,\n    method: \"POST\",\n    header: { \"x-device-id\": dvc },\n    data: {},\n  });\n});\n```\n\n---\n\n# 8) 和你两个插件的关系（怎么“融合/替换”）\n\n- `android-deviceid`：\n\n  - **保留其 OAID 能力**，把初始化 `register()` 与获取流程**Promise 化**放到 `adapters/oaid.uts`；\n  - 如果你用的是 **gzu 的聚合库**（`com.github.gzuliyujiang.oaid`），我可按它的 IGetter/Client 回调写成可跑代码；你只需告诉我当前项目里的依赖坐标/使用方式即可（或把现有 `register/getOAID` 调用片段贴我）。\n\n- `zws-uniqueid`：\n\n  - 仅作为 **PseudoID 兜底**（`adapters/pseudo_id.uts` 已收编）；\n  - 不再把它当“设备唯一标识”，它稳定性不够（但当兜底是有意义的）。\n\n---\n\n# 9) 你可能需要的依赖与打包说明（Android）\n\n**OAID**\n\n- 如果用 **MSA 官方 SDK**：按其文档接入（添加 AAR、初始化、回调）。\n- 如果用 **gzu 聚合库**：在 `module.json` 的 `app-android -> utssdk` 里加配置，或在 HBuilderX 的原生配置里勾选对应依赖；随后把 `adapters/oaid.uts` 里按该库接口实现 `getOAIDRaw()` 即可。\n\n**AAID**（Google 广告 ID）\n\n- `com.google.android.gms:play-services-ads-identifier`（需要科学上网/可用镜像）；\n- 通过 `AdvertisingIdClient.getAdvertisingIdInfo(context).id` 获取；若用户限制广告跟踪，返回 limited=true。\n\n> 我可以根据你环境（国内私服/镜像）给出具体 Gradle 依赖配置方式。\n\n---\n\n## 总结\n\n- 这套 **`uni-id-kit`** 是把你两个 UTS 插件做了**统一封装、Promise 化、合规默认与安全加强（哈希/安全随机）**，并提供**清晰可扩展**的适配层。\n- 你现在就可以把上述文件落地，H5 和 Android 的 **AndroidID/GUID/PseudoID** 已可用；**OAID/AAID** 只需在 `adapters/*.uts` 里按你现有库补上调用即可（导出接口已经定好）。\n- 一旦接上 OAID，你就能在国内端得到优先使用的稳定设备标识；其余平台自动回退到 AndroidID/IDFV/GUID。\n\n需要的话，你把你现在 OAID 库的 **初始化 & 获取代码片段**贴我，我直接把 `adapters/oaid.uts` 写成可用实现版（不再占位）。\n",
            "url": "https://example.com/posts/id-kit开发",
            "title": "id-kit开发",
            "date_modified": "2025-09-07T12:57:14.000Z"
        },
        {
            "id": "https://example.com/posts/OAID-库的初始化与获取",
            "content_html": "\n# 一、国内主流 OAID 获取的两条路线\n\n1. **MSA 官方 SDK（闭源）**\n\n- 由“移动安全联盟/CAICT”提供。接入要放 `oaid_sdk_x.x.x.aar`（或早期 `miit_mdid_x.x.x.aar`）、`supplierconfig.json`、证书（`xxx.cert.pem`），并**先加载安全库**再 `MdidSdkHelper.InitSdk(...)` 获取 OAID。常见混淆与加载问题官方 FAQ 也有说明。([百度移动统计][1], [网站名称][2])\n\n2. **开源聚合库（Android_CN_OAID）**\n\n- 由 gzu-liyujiang 提供，统一封装**各厂商 OAID + 海外 AAID + 多种替代 ID**（AndroidID/WidevineID/GUID 等），API 友好。常用入口：`DeviceIdentifier.register(app)` 预取，或者 `DeviceID.getOAID(context, IGetter)` 异步获取。([李宇江的个人网站][3])\n\n> 额外：**华为设备**可直接通过 **HMS Ads Identifier** 获取 OAID（`AdvertisingIdClient.getAdvertisingIdInfo(context).getId()`），不依赖 MSA（很多三方 SDK 文档也这样说明）。([华为开发者][4], [Adjust][5])\n\n---\n\n# 二、你的两个 UTS 插件实际做法（我已解包查看）\n\n- **`android-deviceid`**（UTS for Android）\n\n  - 直接 `import com.github.gzuliyujiang.oaid.*`，调用 `DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!)` 进行预取；随后通过接口把结果回调出去。\n  - 插件内还自带 **华为 HMS ads-identifier AAR**（`ads-identifier-*.aar`），作为获取 OAID 的华为路径支撑。\n  - 这是一个\\*\\*标准的“开源聚合库 + （可选）HMS”\\*\\*实现范式。\n\n  片段（来自 `utssdk/app-android/index.uts`）：\n\n  ```ts\n  import DeviceIdentifier from \"com.github.gzuliyujiang.oaid.DeviceIdentifier\";\n  export const register = function () {\n    DeviceIdentifier.register(UTSAndroid.getUniActivity()!!.getApplication()!!);\n  };\n  ```\n\n  （随后通过自定义 `MyListener implements IDManger.OnIOAIDListener` 回传 JSON 结果）\n\n- **`zws-uniqueid`**\n\n  - 不取 OAID，仅根据 `android.os.Build` 若干字段计算 `MD5` 作为**伪标识**（PseudoID），没有广告/合规可重置特性，仅能用于弱追踪/灰度分配等**非广告**用途。\n\n---\n\n# 三、初始化 & 获取：可直接抄的代码片段库\n\n## 方案 A：开源 Android_CN_OAID（推荐起步用）\n\n**初始化（建议在用户同意隐私后再调用）**\n\n```kotlin\n// Application.onCreate 或隐私同意后\nDeviceIdentifier.register(application)  // 预取 clientId/OAID\n```\n\n**获取 OAID（两种）**\n\n- 同步拿预取结果（需先 register）：\n\n  ```kotlin\n  val oaid = DeviceID.getOAID()  // 若未预取会为空\n  ```\n\n- 异步获取（不需要 register）：\n\n  ```kotlin\n  DeviceID.getOAID(context, object : IGetter {\n      override fun onOAIDGetComplete(result: String) { /* result 即 OAID */ }\n      override fun onOAIDGetError(error: Exception) { /* 失败或不支持 */ }\n  })\n  ```\n\n这些方法签名、时机说明都在官方 javadoc 文档中有清晰描述：`register(...)` 预取、`getOAID(...)` 异步、`supportedOAID(context)` 判断支持性、以及 `getGUID`、`getAndroidID` 等替代项。([李宇江的个人网站][6])\n\n> **优点**：开源、快速落地；**缺点**：在个别厂商/系统组合上获取率可能不如官方 MSA；不过开源库会优先尝试 HMS、厂商通道，整体覆盖度已较好。([李宇江的个人网站][3])\n\n## 方案 B：MSA 官方 SDK（企业/上量后建议切换或并行）\n\n**准备**\n\n- `oaid_sdk_x.x.x.aar` 放 `libs/`\n- `supplierconfig.json`、`<package>.cert.pem` 放 `assets/`\n- Proguard：`-keep class com.bun.miitmdid.core.** { *; }`\n- **在 Init 前加载安全库**（不同版本库名可能不同，如 `msaoaidsec` 或文档示例里的 nllvm 加固库名），否则会出现 `No implementation found for ... InitCert` 之类错误。([百度移动统计][1], [网站名称][2])\n\n**初始化 & 获取**\n\n```java\n// 1) （可选但推荐）在 Application.onCreate 尝试加载安全库\ntry { System.loadLibrary(\"msaoaidsec\"); } catch(Throwable ignore) {}\n\n// 2) 在合适时机发起初始化与获取（不要在主线程里做耗时 I/O）\nMdidSdkHelper.InitSdk(\n  context.getApplicationContext(),\n  /* isCert = */ true,\n  new IIdentifierListener() {\n    @Override public void onSupport(IdSupplier supplier) {\n      if (supplier != null) {\n        String oaid = supplier.getOAID();\n        // supplier.isSupported() / isLimited() 等也可读\n      }\n    }\n  }\n);\n```\n\n上面这段 init 与回调写法，在各家第三方接入文档里都是类似范式（百度统计、Adjust、AppsFlyer 等均说明“MSA 或 HMS”两路径），并给出了混淆、AAR、`supplierconfig.json` 的标准放置方法。([百度移动统计][1], [Adjust][5], [AppsFlyer 支持中心][7])\n\n## 方案 C：华为设备走 HMS（若接入了 HMS Core）\n\n```java\n// 不依赖 MSA，在华为设备上直接拿 OAID\nAdvertisingIdClient.Info info =\n    com.huawei.hms.ads.identifier.AdvertisingIdClient.getAdvertisingIdInfo(context);\nString oaid = info.getId();\n// info.isLimitAdTrackingEnabled() 可读 “限制个性化广告” 状态\n```\n\nHMS 文档对 OAID / Identifier Service 的 API 有明确说明。([华为开发者][4])\n\n---\n\n# 四、UTS（uni-app x）里的**最佳实践**总方案\n\n> 目标：**一个 API 跨 H5 / Android**，Android 侧**优先 MSA/HMS**，没有则回退到 **Android_CN_OAID**，最后再降级 **AndroidID / GUID**；且**必须在取得隐私同意后**再初始化与获取。\n\n### 1) API 设计（简洁且可扩展）\n\n```ts\n// /uni_modules/uaid-kit/utssdk/index.uts\nexport type UaidInfo = {\n  oaid: string | null;\n  source: \"MSA\" | \"HMS\" | \"GZU\" | \"NONE\";\n  limitAdTracking?: boolean | null;\n  aaid?: string | null; // 海外广告标识，未来可补\n  androidId?: string | null; // 回退项\n  guid?: string | null; // 本地持久 GUID（Web/低版本回退）\n};\n\nexport function initAfterConsent(): void;\nexport function getUaid(callback: (info: UaidInfo) => void): void;\n```\n\n### 2) UTS 源码（**可直接用**；Android + Web 双端）\n\n> 说明：\n>\n> - **MSA** 部分需要你把 `oaid_sdk_x.x.x.aar` 放到 `utssdk/app-android/libs/`，并在 `manifest.json` 勾选 UTS 插件；否则请把 `// MSA 可选块` 注释掉再编译。\n> - **HMS** 部分需要 `ads-identifier` 依赖；没有就留开源库/回退路径。\n> - Web 端只能**生成/持久化 GUID**，OAID 是 Android 概念。\n\n```ts\n// /uni_modules/uaid-kit/utssdk/app-android/index.uts\n// #ifdef APP-ANDROID\nimport Context from \"android.content.Context\";\nimport Application from \"android.app.Application\";\nimport System from \"java.lang.System\";\n\n// 开源库（gzu-liyujiang）\nimport DeviceIdentifier from \"com.github.gzuliyujiang.oaid.DeviceIdentifier\";\nimport DeviceID from \"com.github.gzuliyujiang.oaid.DeviceID\";\nimport IGetter from \"com.github.gzuliyujiang.oaid.IGetter\";\n\n// HMS（若集成）\nimport AdvertisingIdClient from \"com.huawei.hms.ads.identifier.AdvertisingIdClient\";\n\n// MSA（若集成了 AAR，否则请注释下一行两行以及使用处）\nimport MdidSdkHelper from \"com.bun.miitmdid.core.MdidSdkHelper\";\nimport IIdentifierListener from \"com.bun.miitmdid.interfaces.IIdentifierListener\";\nimport IdSupplier from \"com.bun.miitmdid.interfaces.IdSupplier\";\n// #endif\n\n// #ifdef H5\nimport { ref } from \"vue\";\n// #endif\n\nexport type UaidInfo = {\n  oaid: string | null;\n  source: \"MSA\" | \"HMS\" | \"GZU\" | \"NONE\";\n  limitAdTracking?: boolean | null;\n  aaid?: string | null;\n  androidId?: string | null;\n  guid?: string | null;\n};\n\nexport function initAfterConsent(): void {\n  // #ifdef APP-ANDROID\n  try {\n    // 优先预取开源库的 clientId/OAID\n    DeviceIdentifier.register(\n      UTSAndroid.getUniActivity()!!.getApplication()!! as Application\n    );\n  } catch (e) {}\n\n  // （可选）若你计划走 MSA，尽早加载安全库，避免 InitCert 报错\n  try {\n    System.loadLibrary(\"msaoaidsec\");\n  } catch (e) {}\n  // #endif\n  // #ifdef H5\n  // nothing\n  // #endif\n}\n\nfunction buildGuid(): string {\n  // 128bit GUID，H5/Android 均可用，H5 存 localStorage 即可\n  const s = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\";\n  return s.replace(/[xy]/g, (c) => {\n    const r = (Math.floor(Math.random() * 16) as number) & 0xf;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport function getUaid(cb: (info: UaidInfo) => void): void {\n  // #ifdef APP-ANDROID\n  const ctx = UTSAndroid.getUniActivity()!! as Context;\n\n  // 1) 尝试 HMS（若集成）\n  try {\n    const info = AdvertisingIdClient.getAdvertisingIdInfo(ctx);\n    const id = info.getId();\n    if (id) {\n      cb({\n        oaid: id,\n        source: \"HMS\",\n        limitAdTracking: info.isLimitAdTrackingEnabled(),\n      });\n      return;\n    }\n  } catch (e) {\n    /* ignore */\n  }\n\n  // 2) 尝试 MSA 官方（若集成了 AAR）\n  try {\n    MdidSdkHelper.InitSdk(\n      ctx,\n      true,\n      new (class implements IIdentifierListener {\n        override onSupport(supplier: IdSupplier | null) {\n          if (supplier != null && supplier.getOAID() != null) {\n            cb({ oaid: supplier.getOAID(), source: \"MSA\" });\n          } else {\n            // 3) 回退：开源库异步\n            DeviceID.getOAID(\n              ctx,\n              new (class implements IGetter {\n                override onOAIDGetComplete(result: string) {\n                  cb({ oaid: result, source: \"GZU\" });\n                }\n                override onOAIDGetError(err: any) {\n                  const androidId = DeviceID.getAndroidID(ctx);\n                  cb({ oaid: null, source: \"NONE\", androidId });\n                }\n              })()\n            );\n          }\n        }\n      })()\n    );\n    return;\n  } catch (e) {\n    // 没集成 MSA 或运行异常，继续走开源库回退\n  }\n\n  // 3) 开源库异步（无预取也能用）\n  DeviceID.getOAID(\n    ctx,\n    new (class implements IGetter {\n      override onOAIDGetComplete(result: string) {\n        cb({ oaid: result, source: \"GZU\" });\n      }\n      override onOAIDGetError(err: any) {\n        const androidId = DeviceID.getAndroidID(ctx);\n        cb({ oaid: null, source: \"NONE\", androidId });\n      }\n    })()\n  );\n  // #endif\n\n  // #ifdef H5\n  try {\n    let guid = uni.getStorageSync(\"UAID_GUID\") as string;\n    if (!guid) {\n      guid = buildGuid();\n      uni.setStorageSync(\"UAID_GUID\", guid);\n    }\n    cb({ oaid: null, source: \"NONE\", guid });\n  } catch (e) {\n    cb({ oaid: null, source: \"NONE\", guid: buildGuid() });\n  }\n  // #endif\n}\n```\n\n**混淆/配置建议（Android）**\n\n- 若启用 **MSA**：\n\n  ```\n  -keep class com.bun.miitmdid.core.** { *; }\n  ```\n\n  同时把 `oaid_sdk_x.x.x.aar`、`supplierconfig.json`、`<pkg>.cert.pem` 放到对应目录（AAR: `libs/`，其余在 `assets/`）。初始化前加载安全库，避免 `InitCert` 报错。([百度移动统计][1], [网站名称][2])\n\n- 若启用 **HMS**：确保引入 `com.huawei.hms:ads-identifier`（你现有 `android-deviceid` 插件已内置两个 ads-identifier AAR）。华为 OAID API 文档参考。([华为开发者][4])\n- 若只用**开源库**：不需要证书，按上面 `DeviceID` / `DeviceIdentifier` 的调用即可（方法签名见官方 javadoc）。([李宇江的个人网站][6])\n\n**隐私合规关键点**\n\n- **必须在用户同意隐私政策后**再 `initAfterConsent()`；开源库文档也特别提示 register/获取前需获同意。([李宇江的个人网站][6])\n\n---\n\n# 五、再回答你“原来的插件中如何实现”的要点\n\n- 你的 **`android-deviceid`** 正是采用**开源库（Android_CN_OAID）+（可选）HMS**的组合：\n\n  - 预取：`DeviceIdentifier.register(...)`\n  - 异步获取：`DeviceID.getOAID(context, IGetter)`\n  - 附带 ad-identifier AAR，完善华为路径\n\n  > 这与文档推荐用法一致（register 预取、或异步获取；支持 `supportedOAID` 检查）。([李宇江的个人网站][6])\n\n- 你的 **`zws-uniqueid`** 只是**伪 ID**（基于 `Build.*` 拼接+MD5），**不属于 OAID**，适合作兜底标识，不可用于广告归因。\n\n---\n\n# 六、为什么推荐“先开源库 → 再视需要加 MSA/HMS”\n\n- **落地速度**：开源库无证书/厂商注册门槛，上线快；API 稳定，文档完整（还有 `GUID/AndroidID` 兜底）。([李宇江的个人网站][3])\n- **兼容与获取率**：有华为设备时可直接走 **HMS OAID**；大盘上量/商业化合规要求更高时，再**并行接入 MSA** 提升部分机型覆盖率。([华为开发者][4], [Adjust][5])\n- **合规**：始终把 OAID 获取放在**隐私同意之后**。([李宇江的个人网站][6])\n\n---\n\n## 附：权威/一手资料（便于你对照）\n\n- Android_CN_OAID 文档（`DeviceID.register/getOAID/supportedOAID/...` 方法签名）([李宇江的个人网站][6])\n- Android_CN_OAID 项目主页/文档导航（含包结构/实现原理）([李宇江的个人网站][3])\n- MSA 官方接入说明（AAR、`supplierconfig.json`、混淆、加载安全库/InitCert 问题）([百度移动统计][1], [网站名称][2])\n- Adjust / AppsFlyer 对 OAID 的总述与“MSA 或 HMS”两条路径的明确表述（帮助理解生态）([Adjust][5], [AppsFlyer 支持中心][7])\n- 华为 HMS Ads Identifier OAID 能力文档（API 参考）([华为开发者][4])\n\n---\n\n如果你同意这套方案，我可以把上面的 **UTS 插件源码**按你项目结构打包成 `uni_modules/uaid-kit`（含 `package.json`、`utssdk/app-android/config.json`、`README.md`、示例页），并给出在 **uni-app x** 项目里如何调用的示例页（含隐私弹窗 → 同意后初始化 → 展示结果）的完整代码。\n\n[1]: https://mtj.baidu.com/static/userguide/book/android/oaid.html?utm_source=chatgpt.com \"Android OAID 接入\"\n[2]: https://16054554.s21i.faiusr.com/61/ABUIABA9GAAgx5iGjgYo2_j-1AE.pdf?utm_source=chatgpt.com \"常见问题问答F&Q - 信息资源系统\"\n[3]: https://gzu-liyujiang.github.io/Android_CN_OAID/?utm_source=chatgpt.com \":library\"\n[4]: https://developer.huawei.com/consumer/en/doc/hmscore-references/overview-0000001050066887?utm_source=chatgpt.com \"Overview-com.huawei.hms.ads.identifier-Android-Java- ...\"\n[5]: https://dev.adjust.com/zh/sdk/android/plugins/oaid-plugin/?utm_source=chatgpt.com \"OAID\"\n[6]: https://gzu-liyujiang.github.io/Android_CN_OAID/com/github/gzuliyujiang/oaid/DeviceID.html \"DeviceID \"\n[7]: https://support.appsflyer.com/hc/en-us/articles/360006278797-Android-OAID-implementation-in-the-SDK?utm_source=chatgpt.com \"Android OAID implementation in the SDK\"\n",
            "url": "https://example.com/posts/OAID-库的初始化与获取",
            "title": "OAID 库的初始化与获取",
            "date_modified": "2025-09-07T15:44:21.000Z"
        },
        {
            "id": "https://example.com/posts/requirement-realization-1",
            "content_html": "\n---\n\ntitle: 已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）\ndate: 2025-09-05\ntags:\n\n- Passkeys\n- WebAuthn\n- 账号绑定\n- 设备唯一\n\n---\n\n## 摘要\n\n当**用户已经登录（本地有 JWT/token）**时，常见需求是“**再绑定一把通行密钥**”（或在新设备上补绑）。本文给出一个**稳妥的一次点击方案**：\n\n- 前端：带上 **Authorization: Bearer \\<token>** 与 **X-Device-Id（设备唯一码）** 请求 `/passkeys/register/options`。\n- 浏览器完成 `navigator.credentials.create(...)` 后，将结果 + `deviceIdentifier` 回传 `/passkeys/register/verify`。\n- 后端：从 **token 解析 userId**，生成/校验 challenge、**入库凭证**，并执行**设备唯一绑定**（`deviceId -> userId`）。\n\n> 关键点：**不要尝试枚举本地是否已有凭证**；隐私模型不允许。登录态下的“绑定”其实就是“已知用户的注册流程”。\n\n---\n\n## 设计要点\n\n- **用户唯一标识**：后端**不靠前端传 userId**，而是从 **JWT** 中解析（`sub`）→ 更安全。\n- **设备唯一**：前端生成/缓存 `deviceId`，通过 `X-Device-Id` 头传给后端；后端使用 `dvc:owner:${deviceId}` 在 Redis 做“一致性绑定”。\n- **防重复注册**：注册 options 中使用 `excludeCredentials`（由后端查询该用户已绑定的 credentialId）。\n- **风控与速率限制**：对 `deviceId` 做限流（如 1h/3 次），并在 verify 阶段二次校验。\n- **协议对齐**：保持与登录/JIT 注册完全相同的编码规范（字节字段统一 **base64url**）。\n\n---\n\n## 前端实现（Web）\n\n> 仅新增**一个按钮事件**用于“绑定通行密钥”。代码自包含；把 `BASE_URL` 改成你的后端地址即可。\n> 复杂逻辑均在上一行写注释。\n\n```html\n<!-- 你的页面按钮 -->\n<button id=\"btn-bind-passkey\">绑定通行密钥</button>\n<pre\n  id=\"log\"\n  style=\"background:#111;color:#9f9;padding:12px;white-space:pre-wrap\"\n></pre>\n\n<script type=\"module\">\n  // ========= 工具：设备ID与 base64url 转换 =========\n  function getDeviceId() {\n    let id = localStorage.getItem(\"device_id\");\n    if (!id) {\n      id =\n        crypto?.randomUUID?.() ||\n        \"dev-\" + Date.now() + \"-\" + Math.random().toString(16).slice(2);\n      localStorage.setItem(\"device_id\", id);\n    }\n    return id;\n  }\n  function b64urlToBuf(b64url) {\n    const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4);\n    const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const bin = atob(b64);\n    const buf = new ArrayBuffer(bin.length);\n    const view = new Uint8Array(buf);\n    for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);\n    return buf;\n  }\n  function bufToB64url(buf) {\n    const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;\n    let s = \"\";\n    for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);\n    return btoa(s).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n  }\n  // 复杂：把 CreationOptions 中的 base64url → ArrayBuffer\n  function toCreationOptions(serverOpts) {\n    const opts = structuredClone(serverOpts);\n    if (typeof opts.challenge === \"string\")\n      opts.challenge = b64urlToBuf(opts.challenge);\n    if (opts.user && typeof opts.user.id === \"string\")\n      opts.user.id = b64urlToBuf(opts.user.id);\n    if (Array.isArray(opts.excludeCredentials)) {\n      opts.excludeCredentials = opts.excludeCredentials.map((c) => ({\n        ...c,\n        id: b64urlToBuf(c.id),\n      }));\n    }\n    return opts;\n  }\n  // 复杂：将 create() 结果打包为后端可校验的 JSON（统一 base64url）\n  function packAttestation(cred) {\n    return {\n      id: cred.id,\n      rawId: bufToB64url(cred.rawId),\n      type: cred.type,\n      response: {\n        clientDataJSON: bufToB64url(cred.response.clientDataJSON),\n        attestationObject: bufToB64url(cred.response.attestationObject),\n      },\n      clientExtensionResults: cred.getClientExtensionResults?.() || {},\n    };\n  }\n  // 复杂：通用 POST，附带 token 与设备ID\n  async function postJSON(url, body, token) {\n    const res = await fetch(url, {\n      method: \"POST\",\n      credentials: \"include\",\n      headers: {\n        \"content-type\": \"application/json\",\n        \"X-Device-Id\": getDeviceId(), // 设备唯一\n        ...(token ? { Authorization: `Bearer ${token}` } : {}), // 已登录用户必带\n      },\n      body: JSON.stringify(body || {}),\n    });\n    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);\n    return res.json();\n  }\n\n  // ========= 绑定入口：用户已登录（本地有 token） =========\n  const BASE_URL = \"\"; // 同源可留空；跨域改成你的后端地址\n  function getToken() {\n    // 复杂：示例从 localStorage 取；实际按你的项目来源（Cookie/JWT 管理方案）\n    return localStorage.getItem(\"token\");\n  }\n  async function bindPasskey() {\n    const log = (m) =>\n      (document.getElementById(\n        \"log\"\n      ).textContent += `[${new Date().toLocaleTimeString()}] ${m}\\n`);\n    const token = getToken();\n    if (!token) {\n      log(\"未登录：请先登录再绑定\");\n      return;\n    }\n\n    try {\n      // 复杂：步骤1——向后端请求“注册（绑定）options”，后端将从 JWT 解析 userId\n      log(\"请求 /passkeys/register/options ...\");\n      const data = await postJSON(\n        `${BASE_URL}/passkeys/register/options`,\n        {},\n        token\n      );\n      const serverOptions = data.options || data; // 兼容返回形态\n      const publicKey = toCreationOptions(serverOptions);\n\n      // 复杂：步骤2——发起浏览器创建凭据\n      log(\"调用 navigator.credentials.create ...\");\n      const att = await navigator.credentials.create({ publicKey });\n\n      // 复杂：步骤3——打包 + 回传 verify，并带上 deviceIdentifier 以完成设备唯一绑定\n      log(\"提交 /passkeys/register/verify ...\");\n      const verifyBody = {\n        ...packAttestation(att),\n        deviceIdentifier: getDeviceId(),\n      };\n      const verifyResp = await postJSON(\n        `${BASE_URL}/passkeys/register/verify`,\n        verifyBody,\n        token\n      );\n\n      log(\"绑定完成 ✅ \" + JSON.stringify(verifyResp));\n      alert(\"通行密钥绑定成功\");\n    } catch (e) {\n      console.error(e);\n      alert(\"绑定失败：\" + (e?.message || e));\n    }\n  }\n\n  // 绑定按钮点击\n  document\n    .getElementById(\"btn-bind-passkey\")\n    ?.addEventListener(\"click\", bindPasskey);\n</script>\n```\n\n> 若你在 **uni-app**（H5）里使用，也可沿用同样逻辑；在 **App（UTS 插件）** 上只需把 `navigator.credentials.create` 替换为你的 `passkeys.createPasskey(optionsJson)` 即可，其余协议不变。\n\n---\n\n## 后端实现（NestJS，仅给“增量/改动片段”）\n\n> 你的工程里已有 JIT 与登录接口。这里**新增/完善**“**已登录的注册（绑定）**”两个端点，并对 Service 增强**按 token 解析 user** 与**设备唯一**。\n\n### 1）Controller 片段\n\n```ts\n// 复杂：新增“已登录绑定”端点；依赖 JWT 守卫把 user 注入 request.user\nimport { Controller, Post, Req, UseGuards, Body } from \"@nestjs/common\";\nimport { AuthGuard } from \"@nestjs/passport\";\nimport { PasskeysService } from \"../../services/passkeys.service\";\n\n@Controller(\"passkeys\")\nexport class PasskeysController {\n  constructor(private readonly passkeysService: PasskeysService) {}\n\n  // 复杂：注册（绑定）options——登录态\n  @UseGuards(AuthGuard(\"jwt\"))\n  @Post(\"register/options\")\n  getBindOptions(@Req() req: any) {\n    // 复杂：设备ID从 Header/Cookie/IP 提取，用于风控与后续绑定一致性\n    const deviceIdentifier =\n      req.headers[\"x-device-id\"] || req.cookies?.dvc || `ip:${req.ip}`;\n    const userId = req.user?.sub; // 复杂：从 JWT 解析出的 userId\n    return this.passkeysService.issueRegistrationOptionsForUser(\n      userId,\n      deviceIdentifier\n    );\n  }\n\n  // 复杂：注册（绑定）verify——登录态\n  @UseGuards(AuthGuard(\"jwt\"))\n  @Post(\"register/verify\")\n  verifyBind(@Req() req: any, @Body() body: any) {\n    const deviceIdentifier =\n      req.headers[\"x-device-id\"] ||\n      body.deviceIdentifier ||\n      req.cookies?.dvc ||\n      `ip:${req.ip}`;\n    const userId = req.user?.sub;\n    return this.passkeysService.verifyRegistrationForUser(\n      userId,\n      body,\n      deviceIdentifier\n    );\n  }\n}\n```\n\n### 2）Service 片段\n\n```ts\n// 复杂：为“已登录绑定”增加两个方法\n@Injectable()\nexport class PasskeysService {\n  // ... 省略已有依赖与构造\n\n  // 复杂：签发已登录用户的注册 options（含 excludeCredentials 与限流）\n  async issueRegistrationOptionsForUser(\n    userId: string,\n    deviceIdentifier?: string\n  ) {\n    if (!userId) throw new UnauthorizedException(\"未登录\");\n\n    // 复杂：限流（1h/3次）\n    if (deviceIdentifier) {\n      const rlKey = `rl:bind:${deviceIdentifier}`;\n      const n = await this.redisService.incrementKey(rlKey);\n      if (n === 1) await this.redisService.expireKey(rlKey, 3600);\n      if (n > 3) throw new BadRequestException(\"操作过于频繁，请稍后再试\");\n    }\n\n    const rpId = this.configService.get<string>(\"RP_ID\");\n\n    // 复杂：查询该用户已有凭证，构造 excludeCredentials 防重复注册\n    const existing = await this.staffService.findManyCredentialsByUserId(\n      userId\n    ); // 需要你实现查询\n    const exclude = (existing || []).map((c: any) => ({\n      id: Buffer.from(c.credentialId, \"base64url\"),\n      type: \"public-key\" as const,\n    }));\n\n    const options = await generateRegistrationOptions({\n      rpName: \"Your App\",\n      rpID: rpId,\n      // 复杂：v11+ 要求 userID 为字节；这里直接用 UTF-8 Buffer\n      userID: Buffer.from(String(userId), \"utf8\"),\n      userName: String(userId),\n      attestationType: \"none\",\n      // 复杂：兼容性更好（ES256 + RS256）\n      supportedAlgorithmIDs: [-7, -257],\n      authenticatorSelection: {\n        residentKey: \"required\", // 复杂：要求可发现凭证，便于后续一键直登\n        userVerification: \"preferred\",\n      },\n      excludeCredentials: exclude,\n      extensions: { credProps: true },\n    });\n\n    // 复杂：将 challenge(base64url) 与 user 绑定，TTL 5 分钟\n    const ch =\n      typeof options.challenge === \"string\"\n        ? options.challenge\n        : Buffer.from(options.challenge).toString(\"base64url\");\n    await this.redisService.setWithTimeToLive(\n      `webauthn:register:${userId}`,\n      ch,\n      300\n    );\n\n    return { options };\n  }\n\n  // 复杂：校验 attestation + 入库 + 设备唯一绑定（不重新发 token，也可选择刷新）\n  async verifyRegistrationForUser(\n    userId: string,\n    requestBody: any,\n    deviceIdentifier?: string\n  ) {\n    if (!userId) throw new UnauthorizedException(\"未登录\");\n\n    const rpId = this.configService.get<string>(\"RP_ID\");\n    const origin = this.configService.get<string>(\"ORIGIN\");\n    const cachedChallenge = await this.redisService.getValue(\n      `webauthn:register:${userId}`\n    );\n    if (!cachedChallenge)\n      throw new BadRequestException(\"注册挑战不存在或已过期\");\n\n    const verification = await verifyRegistrationResponse({\n      response: requestBody,\n      expectedRPID: rpId,\n      expectedOrigin: origin,\n      expectedChallenge: cachedChallenge,\n      requireUserVerification: true, // 复杂：绑定建议要求 UV\n    });\n    if (!verification.verified || !verification.registrationInfo) {\n      throw new UnauthorizedException(\"注册校验失败\");\n    }\n\n    const { credential } = verification.registrationInfo;\n    const credentialIdB64url = Buffer.from(credential.id).toString(\"base64url\");\n    const publicKey = Buffer.from(credential.publicKey); // 存二进制或 base64 皆可\n    const counter = credential.counter ?? 0;\n\n    // 复杂：入库（若同 credentialId 已存在且属同人，可忽略/幂等）\n    await this.staffService.upsertCredential({\n      userId,\n      credentialId: credentialIdB64url,\n      publicKey,\n      counter,\n      transports: credential.transports\n        ? JSON.stringify(credential.transports)\n        : null,\n    });\n\n    // 复杂：设备唯一绑定（若存在 deviceId 且已被他人占用，则拒绝）\n    if (deviceIdentifier) {\n      const key = `dvc:owner:${deviceIdentifier}`;\n      const existed = await this.redisService.getValue(key);\n      if (existed && existed !== String(userId)) {\n        throw new ForbiddenException(\"此设备已绑定其他账号\");\n      }\n      // 绑定一年（或不设 TTL）\n      await this.redisService.setWithTimeToLive(key, String(userId), 31536000);\n    }\n\n    await this.redisService.deleteKey(`webauthn:register:${userId}`);\n    // 已登录状态下可不必重签 token；如需刷新可在此签新 JWT\n    return { verified: true, userId, credentialId: credentialIdB64url };\n  }\n}\n```\n\n> 你只需要实现（或补齐）`staffService.findManyCredentialsByUserId` 与 `upsertCredential` 两个数据存取方法；字段即你现有的 `credentialId/publicKey/counter/transports/userId`。\n\n---\n\n## 时序对照（已登录绑定）\n\n1. 前端带 **Authorization** 与 **X-Device-Id** → `POST /passkeys/register/options`\n2. 后端从 **JWT** 取 `userId`，构造 **excludeCredentials**，保存 **challenge**\n3. 前端调用 **`navigator.credentials.create({ publicKey })`**\n4. 前端回传 **attestation + deviceIdentifier** → `/passkeys/register/verify`\n5. 后端 **verify + 入库 + 设备唯一绑定** → 返回 `{ verified: true, userId }`\n\n---\n\n## 常见问题\n\n- **为什么不让前端直接传 userId？**\n  防止伪造。登录态下应以 **Authorization** 为准，由后端解析身份。\n\n- **若用户已绑定过此设备，再次点击绑定会怎样？**\n  由于 `excludeCredentials` 与 `dvc:owner:*` 绑定同时生效，**不会重复写入**；可返回幂等成功或提示“已绑定”。\n\n- **如何与一键直登/JIT 流程共存？**\n\n  - **未登录**：走 `/login/options` → 失败回退 `/register-or-login/*`。\n  - **已登录**：走本文 `/register/*`（绑定专用）。两套互不冲突。\n\n---\n\n## 小结\n\n- **唯一标识传递**：已登录场景下，把 **用户身份交给 JWT**，把 **设备唯一交给 `X-Device-Id`**。\n- **绑定即注册**：本质是“已知用户”的注册流程；用 `excludeCredentials` 防重复，用 Redis 绑定 `deviceId -> userId`。\n- **最少交互**：一次点击完成整个绑定，协议与登录/JIT 完全一致，维护成本低。\n",
            "url": "https://example.com/posts/requirement-realization-1",
            "title": "已登录用户的“绑定通行密钥”最佳实践：把唯一标识安全传给后端（含前后端完整实现）",
            "date_modified": "2025-09-05T00:54:31.000Z"
        },
        {
            "id": "https://example.com/posts/requirement-realization-2",
            "content_html": "\n## 目标\n\n把我们讨论的“**先尝试通行密钥登录 → 失败自动回退到 JIT 注册并登录**”接到你这份 **uvue（uni-app x）页面** 上，**保留原有微信登录按钮**，新增一个“通行密钥登录”按钮。\n支持：\n\n- **App 端（Android/iOS）**：走你自定义的 **UTS 插件** `@/uni_modules/pass-keys`（`getPasskey`/`createPasskey`）。\n- **H5 端**：走浏览器 WebAuthn（`navigator.credentials.get/create`）。\n- **设备唯一**：用 `deviceIdentifier`（App 用 `plus.device.uuid`，H5 用本地生成）传后端，便于 `deviceId -> userId` 绑定。\n\n> 复杂逻辑均在代码**上一行加中文注释**。下面给出**整文件覆盖式代码**（符合你“Passkeys 项目优先给完整文件”的约定）。\n\n---\n\n## 完整代码（直接替换你当前页面）\n\n```vue\n<template>\n  <view class=\"container\">\n    <view class=\"header\">\n      <text class=\"title\">欢迎使用商户平台</text>\n    </view>\n\n    <view v-if=\"!baseUrl\" class=\"tip\">\n      <text class=\"tip-text\">未配置后端地址，请先配置</text>\n      <button size=\"mini\" @tap=\"openConfig\">去配置</button>\n    </view>\n\n    <view class=\"actions\">\n      <button\n        type=\"primary\"\n        :disabled=\"!baseUrl || loading\"\n        @tap=\"onWeChatLogin\"\n      >\n        {{\n          baseUrl\n            ? isWeChatInstalled\n              ? \"微信登录\"\n              : \"登录\"\n            : \"请先配置后端地址\"\n        }}\n      </button>\n\n      <!-- 新增：通行密钥一键登录（失败自动回退注册并登录） -->\n      <button\n        style=\"margin-top:12rpx\"\n        :disabled=\"!baseUrl || loading\"\n        @tap=\"onPasskeyLogin\"\n      >\n        {{ loading ? \"处理中...\" : \"通行密钥登录\" }}\n      </button>\n    </view>\n\n    <view v-if=\"loading\" class=\"loading-mask\">\n      <view class=\"loading-box\"><text>处理中...</text></view>\n    </view>\n\n    <view v-if=\"showConfig\" class=\"modal-mask\" @tap=\"closeConfig\">\n      <view class=\"modal\" @tap.stop>\n        <text class=\"modal-title\">配置后端地址</text>\n        <input\n          class=\"modal-input\"\n          type=\"text\"\n          v-model=\"configInput\"\n          placeholder=\"例如：https://api.example.com\"\n        />\n        <view class=\"modal-actions\">\n          <button size=\"mini\" @tap=\"closeConfig\">取消</button>\n          <button type=\"primary\" size=\"mini\" @tap=\"saveConfig\">保存</button>\n        </view>\n      </view>\n    </view>\n  </view>\n</template>\n\n<script>\n// #ifdef APP-PLUS\n// 复杂逻辑：App 端引入你的 UTS 插件（Android/iOS 调平台原生 Credential/AuthenticationServices）\nimport * as passkeys from \"@/uni_modules/pass-keys\";\n// #endif\n\nexport default {\n  data() {\n    return {\n      baseUrl: \"\",\n      loading: false,\n      isWeChatInstalled: true,\n      showConfig: false,\n      configInput: \"\",\n      // 复杂逻辑：设备唯一标识；App=plus.device.uuid；H5=本地生成并持久化\n      deviceId: \"\",\n    };\n  },\n  onLoad() {\n    this.baseUrl = uni.getStorageSync(\"BASE_URL\") || \"\";\n    // 复杂逻辑：初始化设备ID（用于 deviceId -> userId 绑定与风控）\n    // #ifdef APP-PLUS\n    this.deviceId =\n      plus && plus.device && plus.device.uuid\n        ? plus.device.uuid\n        : \"app-\" + Date.now();\n    // #endif\n    // #ifdef H5\n    const key = \"DEVICE_ID\";\n    this.deviceId = localStorage.getItem(key);\n    if (!this.deviceId) {\n      this.deviceId =\n        crypto?.randomUUID?.() ||\n        \"web-\" + Date.now() + \"-\" + Math.random().toString(16).slice(2);\n      localStorage.setItem(key, this.deviceId);\n    }\n    // #endif\n  },\n  methods: {\n    openConfig() {\n      this.configInput = this.baseUrl;\n      this.showConfig = true;\n    },\n    closeConfig() {\n      this.showConfig = false;\n    },\n    saveConfig() {\n      this.baseUrl = (this.configInput || \"\").trim();\n      uni.setStorageSync(\"BASE_URL\", this.baseUrl);\n      this.showConfig = false;\n      uni.showToast({ title: \"已保存\", icon: \"success\" });\n    },\n\n    // 复杂逻辑：统一 POST 封装；把 deviceIdentifier 一并传给后端（也可由 Header 传）\n    async post(path, body) {\n      return await new Promise((resolve, reject) => {\n        uni.request({\n          url: `${this.baseUrl}${path}`,\n          method: \"POST\",\n          data: { deviceIdentifier: this.deviceId, ...(body || {}) },\n          dataType: \"json\",\n          header: { \"content-type\": \"application/json\" },\n          success: (res) => resolve(res.data),\n          fail: reject,\n        });\n      });\n    },\n\n    // 保留原有：微信登录\n    async onWeChatLogin() {\n      if (!this.baseUrl) return;\n      this.loading = true;\n      try {\n        let code = \"\";\n        // 小程序端获取 code\n        // #ifdef MP-WEIXIN\n        const res = await new Promise((resolve, reject) => {\n          uni.login({ provider: \"weixin\", success: resolve, fail: reject });\n        });\n        code = res.code || \"\";\n        // #endif\n\n        // 其他端未集成微信登录，给出提示\n        // #ifndef MP-WEIXIN\n        throw new Error(\"当前平台未集成微信登录\");\n        // #endif\n\n        if (!code) throw new Error(\"获取登录凭证失败\");\n        const data = await this.post(\"/admin/wechat/login\", { code });\n        if (\n          data &&\n          data.success === true &&\n          data.userInfo &&\n          data.userInfo.approved === true &&\n          data.userInfo.token\n        ) {\n          uni.setStorageSync(\"TOKEN\", data.userInfo.token);\n          uni.showToast({ title: \"登录成功\", icon: \"success\" });\n          setTimeout(() => {\n            uni.reLaunch({ url: \"/pages/index/index\" });\n          }, 600);\n        } else {\n          throw new Error(data?.message || \"登录失败\");\n        }\n      } catch (e) {\n        uni.showToast({ title: e?.message || String(e), icon: \"none\" });\n      } finally {\n        this.loading = false;\n      }\n    },\n\n    // ================== 通行密钥一键登录入口（失败回退注册） ==================\n    async onPasskeyLogin() {\n      if (!this.baseUrl) return;\n      this.loading = true;\n      try {\n        // 复杂逻辑：步骤A——请求登录 options（无用户名直登；后端可按设备ID定向返回 allowCredentials）\n        const resp = await this.post(\"/passkeys/login/options\", {});\n        const options = resp.options || resp;\n\n        // #ifdef APP-PLUS\n        // 复杂逻辑：App 端调用 UTS 插件进行“使用通行密钥”\n        const requestOptionsJson = JSON.stringify(options);\n        const authRespJson = await passkeys.getPasskey(requestOptionsJson, {\n          conditional: true,\n        });\n        const verifyBody = JSON.parse(authRespJson);\n        // #endif\n\n        // #ifdef H5\n        // 复杂逻辑：H5 端使用 WebAuthn —— 将 base64url 字段转 ArrayBuffer\n        const publicKey = this.toWebAuthnRequestOptions(options);\n        // 复杂逻辑：若支持条件UI，mediation='conditional'，否则 'required'（需用户手势）\n        const mediation = (await this.isConditionalUI())\n          ? \"conditional\"\n          : \"required\";\n        const assertion = await navigator.credentials.get({\n          publicKey,\n          mediation,\n        });\n        const verifyBody = this.packAssertion(assertion);\n        // #endif\n\n        // 复杂逻辑：步骤B——提交登录 verify\n        const verify = await this.post(\"/passkeys/login/verify\", verifyBody);\n        this.onLoginSucceed(verify);\n      } catch (e) {\n        // 复杂逻辑：登录失败（无凭据/取消/过期）→ 步骤C——回退到 JIT 注册\n        try {\n          const jit = await this.post(\n            \"/passkeys/register-or-login/options\",\n            {}\n          );\n          const userId = jit.userId || jit?.user?.id;\n          const creationOptions = jit.options || jit;\n\n          // #ifdef APP-PLUS\n          // 复杂逻辑：App 端调用 UTS 插件“创建通行密钥”\n          const creationOptionsJson = JSON.stringify(creationOptions);\n          const regRespJson = await passkeys.createPasskey(creationOptionsJson);\n          const verifyRegBody = {\n            ...JSON.parse(regRespJson),\n            userId,\n            deviceIdentifier: this.deviceId,\n          };\n          // #endif\n\n          // #ifdef H5\n          // 复杂逻辑：H5 端 WebAuthn —— 转换 base64url → ArrayBuffer，发起 create\n          const publicKey = this.toWebAuthnCreationOptions(creationOptions);\n          const attestation = await navigator.credentials.create({ publicKey });\n          const verifyRegBody = {\n            ...this.packAttestation(attestation),\n            userId,\n            deviceIdentifier: this.deviceId,\n          };\n          // #endif\n\n          // 复杂逻辑：步骤D——提交注册 verify（完成入库+设备唯一绑定+签发会话）\n          const verify = await this.post(\n            \"/passkeys/register-or-login/verify\",\n            verifyRegBody\n          );\n          this.onLoginSucceed(verify, true);\n        } catch (e2) {\n          uni.showToast({ title: e2?.message || String(e2), icon: \"none\" });\n        }\n      } finally {\n        this.loading = false;\n      }\n    },\n\n    // 复杂逻辑：登录/注册成功后的统一处理（落 token + 跳转）\n    onLoginSucceed(verify, isRegister = false) {\n      if (verify?.verified) {\n        if (verify.token) {\n          uni.setStorageSync(\"TOKEN\", verify.token);\n        }\n        uni.showToast({\n          title: isRegister ? \"已注册并登录\" : \"登录成功\",\n          icon: \"success\",\n        });\n        setTimeout(() => {\n          uni.reLaunch({ url: \"/pages/index/index\" });\n        }, 600);\n      } else {\n        throw new Error(\"校验失败\");\n      }\n    },\n\n    // ================== H5 专用辅助：WebAuthn 转换与打包 ==================\n    // #ifdef H5\n    // 复杂逻辑：检测是否支持条件UI\n    async isConditionalUI() {\n      try {\n        return !!(await PublicKeyCredential.isConditionalMediationAvailable?.());\n      } catch {\n        return false;\n      }\n    },\n    // 复杂逻辑：base64url → ArrayBuffer\n    b64urlToBuf(b64url) {\n      const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4);\n      const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\");\n      const bin = atob(b64);\n      const buf = new ArrayBuffer(bin.length);\n      const view = new Uint8Array(buf);\n      for (let i = 0; i < bin.length; i++) view[i] = bin.charCodeAt(i);\n      return buf;\n    },\n    // 复杂逻辑：ArrayBuffer/Uint8Array → base64url\n    bufToB64url(buf) {\n      const b = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;\n      let s = \"\";\n      for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);\n      return btoa(s)\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=+$/g, \"\");\n    },\n    // 复杂逻辑：将登录 options（服务端 base64url）转为 WebAuthn 可用结构\n    toWebAuthnRequestOptions(serverOpts) {\n      const opts = JSON.parse(JSON.stringify(serverOpts));\n      if (typeof opts.challenge === \"string\")\n        opts.challenge = this.b64urlToBuf(opts.challenge);\n      if (Array.isArray(opts.allowCredentials)) {\n        opts.allowCredentials = opts.allowCredentials.map((c) => ({\n          ...c,\n          id: typeof c.id === \"string\" ? this.b64urlToBuf(c.id) : c.id,\n        }));\n      }\n      return opts;\n    },\n    // 复杂逻辑：将注册 options 转为 WebAuthn 可用结构\n    toWebAuthnCreationOptions(serverOpts) {\n      const opts = JSON.parse(JSON.stringify(serverOpts));\n      if (typeof opts.challenge === \"string\")\n        opts.challenge = this.b64urlToBuf(opts.challenge);\n      if (opts.user && typeof opts.user.id === \"string\")\n        opts.user.id = this.b64urlToBuf(opts.user.id);\n      if (Array.isArray(opts.excludeCredentials)) {\n        opts.excludeCredentials = opts.excludeCredentials.map((c) => ({\n          ...c,\n          id: typeof c.id === \"string\" ? this.b64urlToBuf(c.id) : c.id,\n        }));\n      }\n      return opts;\n    },\n    // 复杂逻辑：将 get() 结果打包为后端可校验的 JSON（统一 base64url）\n    packAssertion(cred) {\n      const resp = cred.response;\n      return {\n        id: cred.id,\n        rawId: this.bufToB64url(cred.rawId),\n        type: cred.type,\n        response: {\n          clientDataJSON: this.bufToB64url(resp.clientDataJSON),\n          authenticatorData: this.bufToB64url(resp.authenticatorData),\n          signature: this.bufToB64url(resp.signature),\n          userHandle: resp.userHandle\n            ? this.bufToB64url(resp.userHandle)\n            : null,\n        },\n        clientExtensionResults: cred.getClientExtensionResults?.() || {},\n      };\n    },\n    // 复杂逻辑：将 create() 结果打包为后端可校验的 JSON（统一 base64url）\n    packAttestation(cred) {\n      const resp = cred.response;\n      return {\n        id: cred.id,\n        rawId: this.bufToB64url(cred.rawId),\n        type: cred.type,\n        response: {\n          clientDataJSON: this.bufToB64url(resp.clientDataJSON),\n          attestationObject: this.bufToB64url(resp.attestationObject),\n        },\n        clientExtensionResults: cred.getClientExtensionResults?.() || {},\n      };\n    },\n    // #endif\n  },\n};\n</script>\n\n<style>\n.container {\n  padding: 24rpx;\n}\n.header {\n  margin-top: 40rpx;\n  margin-bottom: 24rpx;\n}\n.title {\n  font-size: 36rpx;\n  font-weight: 600;\n  text-align: center;\n}\n.tip {\n  display: flex;\n  align-items: center;\n  gap: 16rpx;\n  padding: 16rpx;\n  margin: 12rpx 0;\n  border: 1px solid #ffc107;\n  background: #fff8e1;\n  border-radius: 12rpx;\n}\n.tip-text {\n  color: #8d6e63;\n  font-size: 26rpx;\n}\n.actions {\n  margin-top: 24rpx;\n  display: flex;\n  flex-direction: column;\n}\n.loading-mask {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.2);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.loading-box {\n  padding: 20rpx;\n  background: #fff;\n  border-radius: 12rpx;\n}\n.modal-mask {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0.4);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.modal {\n  width: 80%;\n  background: #fff;\n  border-radius: 16rpx;\n  padding: 24rpx;\n}\n.modal-title {\n  font-size: 30rpx;\n  font-weight: 600;\n}\n.modal-input {\n  border: 1px solid #eee;\n  margin: 16rpx 0;\n  padding: 12rpx;\n  border-radius: 8rpx;\n}\n.modal-actions {\n  display: flex;\n  justify-content: flex-end;\n  gap: 12rpx;\n}\n</style>\n```\n\n---\n\n## 说明与对接要点\n\n- **后端路由**保持为：\n\n  - `/passkeys/login/options` → 返回 `PublicKeyCredentialRequestOptions`（`challenge`/`allowCredentials[].id` 为 **base64url**）。\n  - `/passkeys/login/verify` → 接收 `packAssertion` 结果。\n  - `/passkeys/register-or-login/options` → 返回 `{ userId, options }`（注册用，`challenge`/`user.id` 为 **base64url**）。\n  - `/passkeys/register-or-login/verify` → 接收 `packAttestation` + `{ userId, deviceIdentifier }`。\n\n- **设备唯一**：页面已在所有请求体中带上 `deviceIdentifier`（`this.deviceId`），你的服务端即可写入/校验 `dvc:owner:*`。\n- **H5 前置条件**：需 HTTPS 或 `localhost`；Safari/移动端有平台限制。\n- **App 端**：确保 `@/uni_modules/pass-keys` 已实现 `getPasskey`/`createPasskey` 且返回 **JSON 字符串**（与我们前面约定一致）。\n\n需要我把 **“已登录场景的绑定按钮”** 也加到这个页面吗（即 `/passkeys/register/options|verify`，走绑定而非 JIT）？如果要，加哪个位置，我按你“只给改动段”的规范再补。\n",
            "url": "https://example.com/posts/requirement-realization-2",
            "title": "在你现有 uvue 登录页集成“一键通行密钥登录”（含回退注册），完整代码可直接替换",
            "date_modified": "2025-09-05T00:00:00.000Z"
        },
        {
            "id": "https://example.com/posts/requirement-realization",
            "content_html": "\n---\n\ntitle: Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现\ndate: 2025-09-05\ntags:\n\n- Passkeys\n- WebAuthn\n- 前端实战\n- 一键直登\n\n---\n\n## 摘要\n\n本文给出 **Web 端** 的最小可用实现：**点击一个按钮 → 优先尝试登录（可发现凭证）→ 若无可用凭证或用户取消，则自动走 JIT 注册并直接登录**。\n重点说明：“**不能事先枚举本地是否存在凭据**”（浏览器出于隐私不允许），正确姿势是**拿到服务端的 options 再调用 WebAuthn**，并对失败分支做平滑回退。\n\n---\n\n## 背景与原则\n\n- 浏览器不会暴露“本地是否已有你家 RP 的通行密钥”的枚举 API（防侧信道追踪）。\n- 正确流程永远是：**后端发 options（含 challenge）→ 前端发起 `get()`/`create()` → 前端把回包交给后端 `verify`**。\n- 若想“先感知再决定”，只能做**能力探测**（如 `isConditionalMediationAvailable()`、`isUserVerifyingPlatformAuthenticatorAvailable()`），但这**不等于**“确有凭据”。\n- 因此，本实现直接：**先请求登录 options** → `navigator.credentials.get` → 失败则 **请求注册 options** → `navigator.credentials.create` → 验证成功后**注册即登录**。\n\n---\n\n## 交互时序（简述）\n\n1. 用户点击「一键登录」按钮\n2. 前端 `POST /passkeys/login/options`（携带 `X-Device-Id`）\n3. 浏览器 `navigator.credentials.get({ publicKey, mediation })`\n4. 成功 → 回传 `/passkeys/login/verify` → **登录完成**\n5. 失败（无匹配凭据/取消等）→ `POST /passkeys/register-or-login/options`\n6. `navigator.credentials.create({ publicKey })`\n7. 回传 `/passkeys/register-or-login/verify` → **注册并登录完成**\n\n---\n\n## 完整代码\n\n> 下面给出**可直接粘贴落地**的最小实现（HTML + JS）。\n> 复杂逻辑的上一行均有中文注释。\n> 假设你的后端路由与本文一致：\n>\n> - `/passkeys/login/options`、`/passkeys/login/verify`\n> - `/passkeys/register-or-login/options`、`/passkeys/register-or-login/verify`\n\n### 1）页面与按钮\n\n```html\n<!-- index.html 片段：按钮与日志面板 -->\n<button id=\"btn-passkey\">一键通行密钥</button>\n\n<pre\n  id=\"log\"\n  style=\"background:#111;color:#9f9;padding:12px;white-space:pre-wrap\"\n></pre>\n\n<script type=\"module\" src=\"./passkeys-web.js\"></script>\n```\n\n### 2）前端模块：`passkeys-web.js`\n\n```js\n// ======================= 基础工具 =======================\n\n// 复杂：生成稳定的设备ID（首访生成并持久化，用于设备→账号绑定与风控）\nfunction getDeviceId() {\n  const key = \"device_id\";\n  let id = localStorage.getItem(key);\n  if (!id) {\n    id =\n      crypto?.randomUUID?.() ||\n      \"dev-\" + Date.now() + \"-\" + Math.random().toString(16).slice(2);\n    localStorage.setItem(key, id);\n  }\n  return id;\n}\n\n// 复杂：base64url ↔ ArrayBuffer 转换，确保与后端统一\nfunction b64urlToBuf(b64url) {\n  const pad = \"=\".repeat((4 - (b64url.length % 4)) % 4);\n  const b64 = (b64url + pad).replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const str = atob(b64);\n  const buf = new ArrayBuffer(str.length);\n  const view = new Uint8Array(buf);\n  for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n  return buf;\n}\nfunction bufToB64url(buf) {\n  const bytes = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;\n  let str = \"\";\n  for (let i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);\n  return btoa(str).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\n\n// 复杂：把 AuthenticationOptions 中的 base64url 字段转 ArrayBuffer\nfunction toWebAuthnRequestOptions(serverOpts) {\n  const opts = structuredClone(serverOpts);\n  // challenge 需要转 ArrayBuffer\n  if (typeof opts.challenge === \"string\")\n    opts.challenge = b64urlToBuf(opts.challenge);\n  // allowCredentials 中的 id 也需要转 ArrayBuffer\n  if (Array.isArray(opts.allowCredentials)) {\n    opts.allowCredentials = opts.allowCredentials.map((c) => ({\n      ...c,\n      id: typeof c.id === \"string\" ? b64urlToBuf(c.id) : c.id,\n    }));\n  }\n  return opts;\n}\n\n// 复杂：把 RegistrationOptions 中的 base64url 字段转 ArrayBuffer/Uint8Array\nfunction toWebAuthnCreationOptions(serverOpts) {\n  const opts = structuredClone(serverOpts);\n  if (typeof opts.challenge === \"string\")\n    opts.challenge = b64urlToBuf(opts.challenge);\n  if (opts.user && typeof opts.user.id === \"string\")\n    opts.user.id = b64urlToBuf(opts.user.id);\n  if (Array.isArray(opts.excludeCredentials)) {\n    opts.excludeCredentials = opts.excludeCredentials.map((c) => ({\n      ...c,\n      id: typeof c.id === \"string\" ? b64urlToBuf(c.id) : c.id,\n    }));\n  }\n  return opts;\n}\n\n// 复杂：把 get() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）\nfunction packAssertion(cred) {\n  const resp = cred.response;\n  return {\n    id: cred.id,\n    rawId: bufToB64url(cred.rawId),\n    type: cred.type,\n    response: {\n      clientDataJSON: bufToB64url(resp.clientDataJSON),\n      authenticatorData: bufToB64url(resp.authenticatorData),\n      signature: bufToB64url(resp.signature),\n      userHandle: resp.userHandle ? bufToB64url(resp.userHandle) : null,\n    },\n    clientExtensionResults: cred.getClientExtensionResults?.() || {},\n  };\n}\n\n// 复杂：把 create() 结果打包成后端可验证的 JSON（按 WebAuthn 规范，全用 base64url）\nfunction packAttestation(cred) {\n  const resp = cred.response;\n  return {\n    id: cred.id,\n    rawId: bufToB64url(cred.rawId),\n    type: cred.type,\n    response: {\n      clientDataJSON: bufToB64url(resp.clientDataJSON),\n      attestationObject: bufToB64url(resp.attestationObject),\n    },\n    clientExtensionResults: cred.getClientExtensionResults?.() || {},\n  };\n}\n\n// 复杂：通用 POST 封装，自动带上设备ID\nasync function postJSON(url, body) {\n  const res = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/json\",\n      // 设备ID写入 Header，便于后端风控/设备绑定。后端也可从 body 读取。\n      \"X-Device-Id\": getDeviceId(),\n    },\n    body: JSON.stringify(body || {}),\n    credentials: \"include\",\n  });\n  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);\n  return res.json();\n}\n\n// 复杂：检测“条件UI”与平台验证器可用性（仅做能力判断，不代表一定有凭据）\nasync function detectSupport() {\n  const hasWebAuthn = \"PublicKeyCredential\" in window;\n  let conditional = false,\n    uvpa = false;\n  try {\n    conditional =\n      !!(await PublicKeyCredential.isConditionalMediationAvailable?.());\n  } catch {}\n  try {\n    uvpa =\n      !!(await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable?.());\n  } catch {}\n  return { hasWebAuthn, conditional, uvpa };\n}\n\n// ======================= 业务主流程 =======================\n\n// 复杂：优先尝试登录（可发现凭证/或定向 allowCredentials）；失败则自动转注册并登录\nexport async function oneTapPasskey(baseUrl = \"\") {\n  const log = (msg) => {\n    const pre = document.getElementById(\"log\");\n    if (pre) pre.textContent += `[${new Date().toLocaleTimeString()}] ${msg}\\n`;\n    console.log(msg);\n  };\n\n  const deviceId = getDeviceId();\n  const { hasWebAuthn, conditional, uvpa } = await detectSupport();\n  if (!hasWebAuthn) throw new Error(\"当前环境不支持 WebAuthn\");\n\n  log(`检测：conditional=${conditional}, uvpa=${uvpa}`);\n\n  try {\n    // ========== 步骤A：请求“登录 options” ==========\n    log(\"请求登录 options...\");\n    const loginOptsResp = await postJSON(`${baseUrl}/passkeys/login/options`, {\n      deviceIdentifier: deviceId,\n    });\n    const requestOptions = loginOptsResp.options || loginOptsResp; // 兼容你的返回结构\n    const publicKey = toWebAuthnRequestOptions(requestOptions);\n\n    // 复杂：若支持条件UI，则 mediation 设为 'conditional'；否则 'required'（需用户手势）\n    const mediation = conditional ? \"conditional\" : \"required\";\n\n    // ========== 步骤B：发起 credentials.get ==========\n    log(`调用 navigator.credentials.get (mediation=${mediation})...`);\n    const assertion = await navigator.credentials.get({ publicKey, mediation });\n\n    // ========== 步骤C：打包并回传后端校验 ==========\n    log(\"提交登录 verify...\");\n    const verifyBody = packAssertion(assertion);\n    const verifyResp = await postJSON(\n      `${baseUrl}/passkeys/login/verify`,\n      verifyBody\n    );\n\n    log(\"登录成功 ✅ \" + JSON.stringify(verifyResp));\n    return { mode: \"login\", result: verifyResp };\n  } catch (err) {\n    // 复杂：常见失败 1）用户取消 2）设备没有匹配凭据 3）options 过期\n    console.warn(\"登录失败，准备转注册：\", err);\n    // ========== 步骤D：请求“一键注册 options” ==========\n    const regOptsResp = await postJSON(\n      `${baseUrl}/passkeys/register-or-login/options`,\n      {\n        deviceIdentifier: deviceId,\n      }\n    );\n    const { userId, options: creationOptionsServer } = regOptsResp.userId\n      ? regOptsResp\n      : { userId: regOptsResp.userId, options: regOptsResp.options };\n\n    const publicKey = toWebAuthnCreationOptions(creationOptionsServer);\n\n    // ========== 步骤E：发起 credentials.create（注册） ==========\n    log(\"调用 navigator.credentials.create ...\");\n    const attestation = await navigator.credentials.create({ publicKey });\n\n    // ========== 步骤F：打包并回传后端，完成绑定+激活+登录 ==========\n    log(\"提交注册 verify...\");\n    const verifyBody = {\n      ...packAttestation(attestation),\n      userId, // 复杂：JIT 返回的临时/访客 userId\n      deviceIdentifier: deviceId, // 复杂：用于设备→账号唯一绑定\n    };\n    const verifyResp = await postJSON(\n      `${baseUrl}/passkeys/register-or-login/verify`,\n      verifyBody\n    );\n\n    log(\"注册并登录成功 ✅ \" + JSON.stringify(verifyResp));\n    return { mode: \"register-then-login\", result: verifyResp };\n  }\n}\n\n// ======================= 页面挂载：按钮点击即触发 =======================\ndocument.getElementById(\"btn-passkey\")?.addEventListener(\"click\", () => {\n  // 复杂：这里的 baseUrl 请改为你的后端地址；同源部署可留空\n  oneTapPasskey(\"\").catch((e) => {\n    const pre = document.getElementById(\"log\");\n    if (pre) pre.textContent += `❌ ${e?.message || e}\\n`;\n    console.error(e);\n  });\n});\n```\n\n---\n\n## 与后端契约（对齐要点）\n\n- `/passkeys/login/options`\n\n  - **入参**：`{ deviceIdentifier?: string }`（Header 也可）\n  - **返回**：`{ options: PublicKeyCredentialRequestOptions }`（`challenge`、`allowCredentials[].id` 为 **base64url** 字符串）\n\n- `/passkeys/login/verify`\n\n  - **入参**：上文 `packAssertion()` 的结果（所有字节字段 **base64url**）\n  - **返回**：`{ verified: true, token, userId }`\n\n- `/passkeys/register-or-login/options`\n\n  - **入参**：`{ deviceIdentifier?: string }`\n  - **返回**：`{ userId: string, options: PublicKeyCredentialCreationOptions }`（`challenge`、`user.id`、`excludeCredentials[].id` 为 **base64url**）\n\n- `/passkeys/register-or-login/verify`\n\n  - **入参**：`packAttestation()` + `{ userId, deviceIdentifier }`\n  - **返回**：`{ verified: true, token, userId }`\n\n> 以上与您现有的 `PasskeysService` 设计完全兼容。你也可以在“已绑定设备”场景下返回 `allowCredentials`，以提升命中率（文中已说明）。\n\n---\n\n## 常见问题（FAQ）\n\n- **能不能“先看一下本地有没有凭据”，有就登录、没有就不调后端？**\n  不能。浏览器不允许枚举凭据。你能做的只是能力探测与**尝试调用** `credentials.get`。而调用 `get/create` 都必须先有**服务端下发的 options（含 challenge）**。\n\n- **什么时候用条件 UI（conditional mediation）？**\n  页面加载即拿到 `login options` 后即可“无提示等候”；但为简化，这里在**按钮点击**后再调，用 `mediation='conditional'`（若可用）+ `required` 作为兜底。\n\n- **后端 challenge 过期怎么办？**\n  统一设置较短 TTL（如 300s），一旦 `get/create` 抛出 `InvalidStateError/NotAllowedError`，前端直接重拉 options 再试。\n\n---\n\n## 测试步骤\n\n1. **HTTPS 环境**部署（本地可用 `localhost`）\n2. **确保后端 RP_ID/ORIGIN 正确**、Redis 正常、四个路由可达\n3. 首次访问：点击按钮 → 预期走注册 → 后端 verify 成功后返回 token\n4. 再次访问：点击按钮 → 直接 `get()` 登录成功\n5. Android/Chrome 测试条件 UI：地址栏出现通行密钥提示；Safari 需同源 HTTPS\n\n---\n\n## 小结\n\n- “先判断本地是否有凭据”在浏览器上**不可行**；\n- **正确做法**是**每次先拿登录 options**，用 `credentials.get` 尝试登录；\n- **失败则无缝切到注册**（JIT 建号 + 可发现凭证 + 注册即登录）。\n- 上文代码开箱即用，你只需要把 `baseUrl` 指向你的后端即可。\n",
            "url": "https://example.com/posts/requirement-realization",
            "title": "Web 端一键通行密钥：点击按钮后“先登录，失败再注册”的完整实现",
            "date_modified": "2025-09-05T00:21:16.000Z"
        },
        {
            "id": "https://example.com/posts/user-会不会匹配根路由-‘-’？",
            "content_html": "\r\n---\r\n\r\ntitle: “/user 会不会匹配根路由 ‘/’？”\r\ndate: 2025-09-05\r\ntags: \\[Vue Router 4, 路由匹配, 懒加载]\r\n\r\n---\r\n\r\n## 结论\r\n\r\n不会。`/user` **不会**匹配到你定义的根路由 `{ path: '/' }`。它只会匹配到**自己**这条顶层路由 `{ path: '/user' }`，因此也**不会**渲染 `@/views/(public)/layout.vue`。\r\n\r\n## 为什么\r\n\r\n- Vue Router 使用基于 `path-to-regexp` 的**精确匹配**。`'/'` 不是“前缀匹配一切”，只匹配根路径本身，或作为**父路由**被命中的**相对子路由**所包含。\r\n- 你现在把 `/user` 定义为**顶层**路由（不在 `children` 里），所以跳转到 `/user` 时，`to.matched` 里只有 `/user` 这一条记录，不会包含 `'/'` 那个布局。\r\n\r\n## 什么时候会经过 `'/'` 布局？\r\n\r\n只有当你把 **子路由写成相对路径** 时，例如：\r\n\r\n```ts\r\n// 复杂逻辑：相对子路由会被拼成 /user，且会渲染父布局\r\n{\r\n  path: '/',\r\n  component: () => import('@/views/(public)/layout.vue'),\r\n  children: [\r\n    { path: 'user', component: () => import('@/views/user/page.vue') } // 注意没有前导斜杠\r\n  ]\r\n}\r\n```\r\n\r\n上面这种写法才会让 `/user` 经过 `layout.vue`。而你当前是：\r\n\r\n```ts\r\n{ path: '/user', component: () => import('@/views/user/page.vue') } // 顶层、绝对路径\r\n```\r\n\r\n两者行为不同。\r\n\r\n## 快速自检（可在控制台验证）\r\n\r\n```ts\r\n// 复杂逻辑：查看匹配链，确认是否包含根布局\r\nconsole.log(router.resolve(\"/user\").matched.map((r) => r.path));\r\n// 期望：['/user']，而不是 ['/', '/user']\r\n```\r\n",
            "url": "https://example.com/posts/user-会不会匹配根路由-‘-’？",
            "title": "/user 会不会匹配根路由 ‘/’？",
            "date_modified": "2025-09-05T19:00:06.000Z"
        },
        {
            "id": "https://example.com/posts/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）",
            "content_html": "\r\n---\r\n\r\ntitle: Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）\r\ndate: 2025-09-06\r\ntags:\r\n\r\n- Vue3\r\n- TanStack Vue Query\r\n- 分页\r\n- 无限滚动\r\n\r\n---\r\n\r\n## 前提\r\n\r\n已安装并在 `main.ts` 里注册了 `@tanstack/vue-query`（你之前那步已经完成）。下面示例直接复用你的 `http.call` 封装。\r\n\r\n---\r\n\r\n## 一、页码分页（page/pageSize）\r\n\r\n### 1) 组合式函数：`usePagedItems.ts`\r\n\r\n```ts\r\n// src/features/demo/usePagedItems.ts\r\n\"use client\";\r\n\r\nimport { ref } from \"vue\";\r\nimport { useQuery } from \"@tanstack/vue-query\";\r\nimport { http } from \"@/lib/http\";\r\n\r\n// 复杂逻辑上一行注释：后端返回 PageResp 结构（list/total/page/pageSize）\r\ntype Item = { id: string; title: string };\r\ntype PageResp<T> = { list: T[]; total: number; page: number; pageSize: number };\r\n\r\n// 复杂逻辑上一行注释：拉取某页数据的纯函数，便于测试与复用\r\nasync function fetchPage(\r\n  page: number,\r\n  pageSize: number\r\n): Promise<PageResp<Item>> {\r\n  return http.call<PageResp<Item>>({\r\n    url: \"/api/items\",\r\n    method: \"GET\",\r\n    params: { page, pageSize },\r\n  });\r\n}\r\n\r\nexport function usePagedItems(initialPageSize = 20) {\r\n  const page = ref(1);\r\n  const pageSize = ref(initialPageSize);\r\n\r\n  const query = useQuery({\r\n    // 复杂逻辑上一行注释：将页码作为 queryKey 的一部分，命中不同页的缓存\r\n    queryKey: () => [\"items\", page.value, pageSize.value],\r\n    // 复杂逻辑上一行注释：当 page 或 pageSize 改变时，自动按新 key 请求/复用缓存\r\n    queryFn: () => fetchPage(page.value, pageSize.value),\r\n    staleTime: 60_000,\r\n    keepPreviousData: true, // 复杂逻辑上一行注释：翻页时保留上一页数据，避免闪烁\r\n  });\r\n\r\n  // 复杂逻辑上一行注释：对外暴露翻页方法\r\n  const next = () => {\r\n    page.value += 1;\r\n  };\r\n  const prev = () => {\r\n    page.value = Math.max(1, page.value - 1);\r\n  };\r\n  const setPage = (p: number) => {\r\n    page.value = Math.max(1, p);\r\n  };\r\n\r\n  return { page, pageSize, ...query, next, prev, setPage };\r\n}\r\n```\r\n\r\n### 2) 组件示例：`PagedList.vue`\r\n\r\n```vue\r\n<!-- src/views/PagedList.vue -->\r\n<script setup lang=\"ts\">\r\nimport { usePagedItems } from \"@/features/demo/usePagedItems\";\r\n\r\nconst { data, isFetching, error, page, next, prev } = usePagedItems(10);\r\n</script>\r\n\r\n<template>\r\n  <div class=\"p-4 space-y-3\">\r\n    <div class=\"flex items-center gap-2\">\r\n      <button class=\"border px-3 py-1 rounded\" @click=\"prev\">上一页</button>\r\n      <span>第 {{ page }} 页</span>\r\n      <button class=\"border px-3 py-1 rounded\" @click=\"next\">下一页</button>\r\n    </div>\r\n\r\n    <div v-if=\"isFetching\">加载中...</div>\r\n    <div v-else-if=\"error\" class=\"text-red-600\">\r\n      出错：{{ (error as any)?.message }}\r\n    </div>\r\n\r\n    <ul v-else class=\"list-disc pl-5\">\r\n      <li v-for=\"it in data?.list ?? []\" :key=\"it.id\">{{ it.title }}</li>\r\n    </ul>\r\n  </div>\r\n</template>\r\n```\r\n\r\n---\r\n\r\n## 二、无限滚动（cursor/nextCursor）\r\n\r\n### 1) 组合式函数：`useInfiniteItems.ts`\r\n\r\n```ts\r\n// src/features/demo/useInfiniteItems.ts\r\n\"use client\";\r\n\r\nimport { computed } from \"vue\";\r\nimport { useInfiniteQuery } from \"@tanstack/vue-query\";\r\nimport { http } from \"@/lib/http\";\r\n\r\ntype Item = { id: string; title: string };\r\n// 复杂逻辑上一行注释：后端返回游标结构（items + nextCursor），没有更多时 nextCursor 为空/undefined\r\ntype CursorResp<T> = { items: T[]; nextCursor?: string | null };\r\n\r\nasync function fetchByCursor(\r\n  cursor: string | null,\r\n  limit: number\r\n): Promise<CursorResp<Item>> {\r\n  // 复杂逻辑上一行注释：第一页用 null/空串，后续带上 nextCursor\r\n  return http.call<CursorResp<Item>>({\r\n    url: \"/api/items/cursor\",\r\n    method: \"GET\",\r\n    params: { cursor, limit },\r\n  });\r\n}\r\n\r\nexport function useInfiniteItems(limit = 20) {\r\n  const q = useInfiniteQuery({\r\n    queryKey: [\"items-infinite\", limit],\r\n    // 复杂逻辑上一行注释：pageParam 是上一次 getNextPageParam 返回的值；第一页由 initialPageParam 提供\r\n    queryFn: ({ pageParam }) => fetchByCursor(pageParam ?? null, limit),\r\n    initialPageParam: null as string | null,\r\n    // 复杂逻辑上一行注释：从返回值中取下一页的游标；无则表示到底\r\n    getNextPageParam: (lastPage) => lastPage.nextCursor ?? undefined,\r\n    staleTime: 60_000,\r\n  });\r\n\r\n  // 复杂逻辑上一行注释：将多页的 items 扁平合并，便于组件直接渲染\r\n  const flatItems = computed(\r\n    () => q.data.value?.pages.flatMap((p) => p.items) ?? []\r\n  );\r\n\r\n  return { ...q, flatItems };\r\n}\r\n```\r\n\r\n### 2) 组件示例（IntersectionObserver 自动触底加载）：`InfiniteList.vue`\r\n\r\n```vue\r\n<!-- src/views/InfiniteList.vue -->\r\n<script setup lang=\"ts\">\r\nimport { ref, onMounted, onBeforeUnmount } from \"vue\";\r\nimport { useInfiniteItems } from \"@/features/demo/useInfiniteItems\";\r\n\r\nconst { flatItems, isFetchingNextPage, hasNextPage, fetchNextPage, error } =\r\n  useInfiniteItems(15);\r\n\r\nconst sentinel = ref<HTMLDivElement | null>(null);\r\nlet observer: IntersectionObserver | null = null;\r\n\r\nonMounted(() => {\r\n  // 复杂逻辑上一行注释：使用 IntersectionObserver 观察“页尾哨兵”，进入视口即加载下一页\r\n  observer = new IntersectionObserver(\r\n    (entries) => {\r\n      const e = entries[0];\r\n      if (e.isIntersecting && hasNextPage.value && !isFetchingNextPage.value) {\r\n        fetchNextPage();\r\n      }\r\n    },\r\n    { root: null, rootMargin: \"0px\", threshold: 0.1 }\r\n  );\r\n\r\n  if (sentinel.value) observer.observe(sentinel.value);\r\n});\r\n\r\nonBeforeUnmount(() => {\r\n  if (observer && sentinel.value) observer.unobserve(sentinel.value);\r\n  observer = null;\r\n});\r\n</script>\r\n\r\n<template>\r\n  <div class=\"p-4 space-y-3\">\r\n    <div v-if=\"error\" class=\"text-red-600\">\r\n      出错：{{ (error as any)?.message }}\r\n    </div>\r\n\r\n    <ul class=\"space-y-2\">\r\n      <li v-for=\"it in flatItems\" :key=\"it.id\" class=\"border rounded p-2\">\r\n        {{ it.title }}\r\n      </li>\r\n    </ul>\r\n\r\n    <!-- 复杂逻辑上一行注释：页尾“哨兵”元素，用于触发下一页加载 -->\r\n    <div\r\n      ref=\"sentinel\"\r\n      class=\"h-8 flex items-center justify-center text-gray-500\"\r\n    >\r\n      <span v-if=\"isFetchingNextPage\">加载更多...</span>\r\n      <span v-else-if=\"!hasNextPage\">没有更多了</span>\r\n      <span v-else>下拉加载</span>\r\n    </div>\r\n\r\n    <!-- 兜底：手动加载更多按钮（可选） -->\r\n    <div class=\"text-center\">\r\n      <button\r\n        class=\"mt-2 border px-3 py-1 rounded\"\r\n        :disabled=\"!hasNextPage || isFetchingNextPage\"\r\n        @click=\"fetchNextPage()\"\r\n      >\r\n        {{\r\n          isFetchingNextPage\r\n            ? \"加载中…\"\r\n            : hasNextPage\r\n            ? \"加载更多\"\r\n            : \"没有更多了\"\r\n        }}\r\n      </button>\r\n    </div>\r\n  </div>\r\n</template>\r\n```\r\n\r\n---\r\n\r\n## 关键点与小贴士\r\n\r\n- **keepPreviousData**：页码分页时避免闪屏；无限滚动用 `useInfiniteQuery` 不需要它。\r\n- **queryKey 设计**：把影响结果的入参（如 `page/pageSize`、`limit/filters`）放进 key，缓存才可命中。\r\n- **getNextPageParam**：返回 `undefined` 代表“没有下一页”；返回游标字符串（或对象）将作为下一次 `pageParam` 传入。\r\n- **触底加载**：`IntersectionObserver` 比 `scroll` 事件更稳、成本更低；确保有合理的 `rootMargin/threshold`。\r\n- **错误重试**：默认会自动重试 2 次（取决于你的全局设置）。对幂等读接口通常是安全的。\r\n\r\n需要我把这两个 Demo 接到你现有的某个真实接口（比如你“价格趋势”或“攻略列表”）上，我可以直接给**最小改动的代码片段**。\r\n",
            "url": "https://example.com/posts/Vue-3-最小可用示例：分页-无限滚动（-tanstack-vue-query）",
            "title": "Vue 3 最小可用示例：分页 & 无限滚动（@tanstack/vue-query）",
            "date_modified": "2025-09-06T14:49:38.000Z"
        },
        {
            "id": "https://example.com/posts/Vue项目请求处理优化",
            "content_html": "\r\n现在的我的 vue+vite+pinia 项目有个问题，我的有些请求，我在 store 中就直接调用，但 store 的执行时机很早，这时用户可能没有登录，发出这些需要 token 的请求是不合适的，但如果我们把请求放到具体页面中，那每个页面都要请求，违背了我们放入 store 中的初衷，如何处理？\r\n\r\n**核心结论**：\r\n\r\n> **把“请求放在 Store”与“何时触发请求”解耦**。\r\n> 数据仍由 Pinia Store 管，但所有“首次加载/刷新”的触发统一由**受保护布局(ProtectedLayout)**或**集中启动钩子**在“已登录且当前路由需要鉴权”时一次性触发。\r\n> 请求层（Axios 封装）负责：自动带 Token、401 统一刷新/重试、（可选）对标记 `auth` 的请求在无 Token 时直接拒绝。\r\n\r\n## 路由：只给受保护页面打上 `requiresAuth`\r\n\r\n**修改位置：`src/router/index.ts`**\r\n\r\n```ts\r\n// 在需要登录的路由上增加 meta.requiresAuth\r\n{\r\n  path: '/dashboard',\r\n  name: 'dashboard',\r\n  component: () => import('@/pages/dashboard/index.vue'),\r\n  meta: { requiresAuth: true }\r\n}\r\n```\r\n\r\n## 受保护布局：只在“已登录 && 受保护路由”时触发各 Store 的初始化\r\n\r\n**新增文件：`src/composables/useAppBootstrap.ts`**\r\n\r\n```ts\r\nimport { watch } from \"vue\";\r\nimport { useRouter } from \"vue-router\";\r\nimport { useAuthStore } from \"@/stores/auth\";\r\nimport { useUserStore } from \"@/stores/user\";\r\nimport { useXStore } from \"@/stores/x\"; // 你的其他数据模块按需引入\r\n\r\nexport function useAppBootstrap() {\r\n  const router = useRouter();\r\n  const auth = useAuthStore();\r\n  const user = useUserStore();\r\n  const x = useXStore();\r\n\r\n  // 复杂逻辑：仅在“已登录 && 当前路由需要鉴权”时做一次性初始化（可幂等）\r\n  watch(\r\n    [\r\n      () => auth.isAuthenticated,\r\n      () => router.currentRoute.value.meta.requiresAuth,\r\n    ],\r\n    async ([ok, need]) => {\r\n      if (ok && need) {\r\n        // 复杂逻辑：各 store 的 init() 必须“幂等”，重复调用不重复发请求\r\n        await Promise.all([user.init(), x.init()]);\r\n      }\r\n    },\r\n    { immediate: true }\r\n  );\r\n}\r\n```\r\n\r\n**在你的受保护布局/根布局里调用（例如 `src/layouts/ProtectedLayout.vue`）**：\r\n\r\n```ts\r\n// <script setup>\r\n// 复杂逻辑：在受保护布局挂载时调用集中引导\r\nimport { useAppBootstrap } from \"@/composables/useAppBootstrap\";\r\nuseAppBootstrap();\r\n// </script>\r\n```\r\n\r\n> 如果你没有单独的布局文件，可以在 `App.vue` 里根据 `route.meta.requiresAuth` 切出一个“受保护区域”再调用 `useAppBootstrap()`。\r\n\r\n---\r\n\r\n## Store：移除“定义即请求”的副作用，提供幂等 `init()`\r\n\r\n**修改位置：`src/stores/user.ts`（示例）**\r\n\r\n```ts\r\n// 删除：顶层的立即请求（例如 defineStore 里一创建就 fetch 的代码）\r\n\r\n// 新增：幂等 init()\r\nlet _initPromise: Promise<void> | null = null;\r\n\r\nexport const useUserStore = defineStore(\"user\", () => {\r\n  const profile = ref<User | null>(null);\r\n\r\n  // 复杂逻辑：单例 Promise，保证多处调用只触发一次真实请求\r\n  async function init() {\r\n    if (_initPromise) return _initPromise;\r\n    _initPromise = (async () => {\r\n      if (profile.value) return;\r\n      const { data } = await http.get(\"/me\", { meta: { auth: true } });\r\n      profile.value = data;\r\n    })();\r\n    return _initPromise;\r\n  }\r\n\r\n  // 可选：在登出时清理，便于下次重新 init\r\n  function reset() {\r\n    profile.value = null;\r\n    _initPromise = null;\r\n  }\r\n\r\n  return { profile, init, reset };\r\n});\r\n```\r\n\r\n> 你的其他 Store（如 `x.ts`、`projects.ts` 等）都按这个\\*\\*“删除副作用 + 提供幂等 init()”\\*\\*的模式改一遍。\r\n\r\n---\r\n\r\n## 请求层：自动带 Token、401 统一刷新并队列重试、无 Token 阻断受保护请求\r\n\r\n**修改位置：`src/http/axios.ts`（或你的请求封装文件）**\r\n\r\n**（1）扩展 Axios 类型，支持 `meta.auth` 与 `_retry`**\r\n\r\n```ts\r\n// 复杂逻辑：为请求增加自定义元信息与重试标记\r\ndeclare module \"axios\" {\r\n  export interface AxiosRequestConfig {\r\n    meta?: { auth?: boolean };\r\n    _retry?: boolean;\r\n  }\r\n}\r\n```\r\n\r\n**（2）请求拦截：自动加 Authorization；无 Token 且需要鉴权时直接拒绝**\r\n\r\n```ts\r\nimport axios from \"axios\";\r\nimport { useAuthStore } from \"@/stores/auth\";\r\nimport router from \"@/router\";\r\n\r\nexport const http = axios.create({ baseURL: import.meta.env.VITE_API_BASE });\r\n\r\nhttp.interceptors.request.use((config) => {\r\n  const auth = useAuthStore();\r\n\r\n  // 复杂逻辑：仅对标记了 meta.auth 的请求自动带 token\r\n  if (config.meta?.auth) {\r\n    if (!auth.token) {\r\n      // 复杂逻辑：阻断未登录时的鉴权请求（避免在 /user/login 等页面误发）\r\n      return Promise.reject(new Error(\"AUTH_REQUIRED\"));\r\n    }\r\n    config.headers = {\r\n      ...config.headers,\r\n      Authorization: `Bearer ${auth.token}`,\r\n    };\r\n  }\r\n  return config;\r\n});\r\n```\r\n\r\n**（3）响应拦截：统一处理 401，带刷新队列（避免并发多次刷新）**\r\n\r\n```ts\r\nlet refreshing = false;\r\nlet waitQueue: Array<() => void> = [];\r\n\r\nhttp.interceptors.response.use(\r\n  (r) => r,\r\n  async (error) => {\r\n    const auth = useAuthStore();\r\n    const { response, config } = error || {};\r\n    if (response?.status === 401 && config && !config._retry) {\r\n      // 复杂逻辑：给当前请求打 _retry，防止递归\r\n      config._retry = true;\r\n\r\n      if (!refreshing) {\r\n        refreshing = true;\r\n        try {\r\n          await auth.refreshToken(); // 你在 auth store 中实现这个方法\r\n          refreshing = false;\r\n          // 复杂逻辑：刷新成功后，放行所有队列中的请求\r\n          waitQueue.splice(0).forEach((fn) => fn());\r\n          return http(config);\r\n        } catch (e) {\r\n          refreshing = false;\r\n          // 复杂逻辑：刷新失败，清空队列并跳转登录\r\n          waitQueue.splice(0).forEach((fn) => fn());\r\n          auth.logout();\r\n          router.replace({\r\n            name: \"login\",\r\n            query: { redirect: router.currentRoute.value.fullPath },\r\n          });\r\n          return Promise.reject(e);\r\n        }\r\n      }\r\n\r\n      // 复杂逻辑：如果正在刷新，把当前请求加入队列，等待刷新完成后重试\r\n      return new Promise((resolve, reject) => {\r\n        waitQueue.push(() => http(config).then(resolve).catch(reject));\r\n      });\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n```\r\n\r\n---\r\n\r\n## Auth Store：提供 `isAuthenticated`、`refreshToken()`、`logout()`\r\n\r\n**修改位置：`src/stores/auth.ts`**\r\n\r\n```ts\r\nexport const useAuthStore = defineStore(\"auth\", () => {\r\n  const token = ref<string | null>(null);\r\n  const refresh = ref<string | null>(null);\r\n\r\n  // 复杂逻辑：派生登录态，集中判断是否有有效 token\r\n  const isAuthenticated = computed(() => !!token.value);\r\n\r\n  async function setToken(t: string, r?: string) {\r\n    token.value = t;\r\n    if (r) refresh.value = r;\r\n  }\r\n\r\n  async function refreshToken() {\r\n    // 复杂逻辑：用 refresh_token 换新 token，失败则抛错\r\n    const { data } = await axios.post(\"/auth/refresh\", {\r\n      refresh_token: refresh.value,\r\n    });\r\n    token.value = data.access_token;\r\n    refresh.value = data.refresh_token ?? refresh.value;\r\n  }\r\n\r\n  function logout() {\r\n    token.value = null;\r\n    refresh.value = null;\r\n    // 复杂逻辑：通知其他 store 清空并重置 init()\r\n    useUserStore().reset();\r\n    // 其他 store 同理按需 reset()\r\n  }\r\n\r\n  return { token, isAuthenticated, setToken, refreshToken, logout };\r\n});\r\n```\r\n\r\n---\r\n\r\n## 登录成功后：只需设置 token 并跳转，初始化会自动发生\r\n\r\n**修改位置：`/user/login` 提交成功回调处**\r\n\r\n```ts\r\n// 复杂逻辑：写入 token 并跳到受保护路由；受保护布局会自动触发所有 store.init()\r\nawait authStore.setToken(res.access_token, res.refresh_token);\r\nrouter.replace((route.query.redirect as string) || \"/\");\r\n```\r\n\r\n---\r\n\r\n## 为什么这是“最佳做法”\r\n\r\n1. **单一职责清晰**：Store 只做“状态与方法”，不在定义期发请求；“什么时候发”交给受保护布局的引导钩子统一触发。\r\n2. **避免重复请求**：`init()` 使用**单例 Promise**，多次调用只会发一次请求。\r\n3. **页面无侵入**：页面无需关心是否登录、是否首发，页面只消费 Store 的 state。\r\n4. **错误集中处理**：401 统一刷新与队列重试，避免因并发导致多次刷新或脏状态。\r\n5. **登录页零干扰**：登录页不再误发需要 Token 的请求；即使误调，Axios 层也会拦截并拒绝。\r\n6. **易扩展**：新增数据域时，只需在受保护引导中 `store.init()` 一行接入。\r\n\r\n---\r\n\r\n如果你愿意，我可以基于你当前的目录结构，把上述“幂等 init + 受保护布局引导 + Axios 刷新队列”的改动**逐个落到你的具体文件**（只贴需要改的片段）。你把相关文件名和关键片段贴给我就行。\r\n",
            "url": "https://example.com/posts/Vue项目请求处理优化",
            "title": "Vue项目pinia中的Store中的请求时机管理",
            "date_modified": "2025-09-05T18:07:15.000Z"
        },
        {
            "id": "https://example.com/posts/Web-Push-推送简介",
            "content_html": "\r\n---\r\n\r\ntitle: Web Push 推送简介\r\ndate: 2025-09-05\r\ncategories: \\[Web 实时通讯, 浏览器推送]\r\ntags: \\[Web Push, Service Worker, PWA, VAPID, 离线通知, 实时消息]\r\ndescription: 全面介绍 Web Push 技术的原理、特点、实现步骤和典型应用场景，帮助前端/全栈开发者理解并快速落地。\r\n\r\n---\r\n\r\n# 什么是 Web Push？\r\n\r\n**Web Push** 是浏览器层面的 **推送通知机制**。与 WebSocket 或 SSE 不同，它不依赖页面是否处于前台，甚至用户没有打开网页也能收到通知。核心依赖：\r\n\r\n- **Service Worker**：浏览器的后台脚本，常驻运行。\r\n- **Push API**：浏览器与推送服务（FCM、APNs 等）之间的推送通道。\r\n- **Notification API**：展示系统级通知。\r\n\r\n特点：\r\n\r\n- **跨平台**：Chrome、Firefox、Edge、Safari（部分版本）均支持。\r\n- **后台可达**：即使网页未激活或浏览器最小化也能收到。\r\n- **需用户授权**：必须 HTTPS，且用户点击“允许通知”。\r\n- **带有身份机制**：通过 VAPID（Voluntary Application Server Identification for Web Push）实现应用级认证。\r\n\r\n---\r\n\r\n# 工作流程\r\n\r\n```mermaid\r\nsequenceDiagram\r\n  participant User as 用户浏览器\r\n  participant SW as Service Worker\r\n  participant PushSrv as 浏览器厂商推送服务(FCM等)\r\n  participant Server as 应用服务端\r\n\r\n  User->>Server: 注册并获取 VAPID 公钥\r\n  User->>SW: 注册 Service Worker\r\n  User->>PushSrv: 订阅推送 (PushSubscription)\r\n  User->>Server: 上报订阅信息 (endpoint+keys)\r\n\r\n  Server->>PushSrv: 使用 VAPID 私钥加密并发送消息\r\n  PushSrv->>SW: 转发推送\r\n  SW->>User: Notification API 展示通知\r\n```\r\n\r\n---\r\n\r\n# 核心实现步骤\r\n\r\n## 1. 生成 VAPID 密钥对\r\n\r\n```bash\r\nnpx web-push generate-vapid-keys\r\n```\r\n\r\n会得到 **公钥 / 私钥**，公钥发给前端，私钥保存在服务端。\r\n\r\n---\r\n\r\n## 2. 前端注册 Service Worker\r\n\r\n```js\r\nconst reg = await navigator.serviceWorker.register(\"/sw.js\");\r\n\r\n// 申请通知权限\r\nconst permission = await Notification.requestPermission();\r\nif (permission === \"granted\") {\r\n  // 订阅推送\r\n  const sub = await reg.pushManager.subscribe({\r\n    userVisibleOnly: true,\r\n    applicationServerKey: \"<VAPID_PUBLIC_KEY_BASE64URL>\",\r\n  });\r\n  // 上报给服务端保存\r\n  await fetch(\"/push/subscribe\", { method: \"POST\", body: JSON.stringify(sub) });\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3. Service Worker 处理推送\r\n\r\n```js\r\n// sw.js\r\nself.addEventListener(\"push\", (event) => {\r\n  const data = event.data?.json() ?? {};\r\n  event.waitUntil(\r\n    self.registration.showNotification(data.title || \"通知\", {\r\n      body: data.body,\r\n      icon: \"/icon.png\",\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n---\r\n\r\n## 4. 服务端发送推送\r\n\r\n以 Node.js 为例：\r\n\r\n```js\r\nimport webpush from \"web-push\";\r\n\r\n// 设置 VAPID\r\nwebpush.setVapidDetails(\r\n  \"mailto:admin@example.com\",\r\n  process.env.VAPID_PUBLIC,\r\n  process.env.VAPID_PRIVATE\r\n);\r\n\r\n// subs 存储用户的 PushSubscription\r\nexport async function sendPush(sub, payload) {\r\n  await webpush.sendNotification(sub, JSON.stringify(payload));\r\n}\r\n```\r\n\r\n---\r\n\r\n# 典型应用场景\r\n\r\n- **消息提醒**：聊天应用收到新消息。\r\n- **电商营销**：用户未登录页面也能收到促销信息。\r\n- **系统告警**：后台监控推送紧急故障。\r\n- **PWA（渐进式 Web 应用）**：接近原生 App 的体验。\r\n\r\n---\r\n\r\n# 优缺点对比\r\n\r\n✅ 优点：\r\n\r\n- 浏览器级支持，后台可达。\r\n- 无需页面常驻，适合通知类消息。\r\n- 跨浏览器标准（W3C Push API）。\r\n\r\n⚠️ 缺点：\r\n\r\n- 依赖用户同意，存在拒绝率。\r\n- Safari 支持有限制（macOS 较晚才全面支持）。\r\n- 消息大小有限制（通常 4KB）。\r\n- 不适合大流量/高频推送（需 WebSocket/SSE）。\r\n\r\n---\r\n\r\n# 小结\r\n\r\n**Web Push** = **Service Worker + Push API + Notification API**\r\n适合“提醒/通知”类场景，不适合实时高频通信。生产实践里常和 **WebSocket/SSE** 组合：\r\n\r\n- **WebSocket**：前台实时互动。\r\n- **Web Push**：后台/离线通知兜底。\r\n\r\n---\r\n\r\n要不要我帮你写一个 **完整的最小 Web Push DEMO 项目（前端+后端）**，可以直接跑通并测试浏览器推送？\r\n",
            "url": "https://example.com/posts/Web-Push-推送简介",
            "title": "Web Push 推送简介",
            "date_modified": "2025-09-05T14:10:59.000Z"
        },
        {
            "id": "https://example.com/posts/web应用开发-前端-Web-应用如何做到实时消息通知",
            "content_html": "\r\n---\r\n\r\ntitle: Web 应用如何做到“实时消息通知”\r\ndate: 2025-09-05\r\ncategories: \\[Web 实时通讯, 架构设计]\r\ntags: \\[WebSocket, SSE, Web Push, 长轮询, 消息队列, Redis, 可用性, 安全]\r\ndescription: 面向前端/全栈开发者，从选型到最小可行代码，教你在 Web 应用中实现稳定的实时消息通知。\r\n\r\n---\r\n\r\n# 总览\r\n\r\n**目标**：在浏览器里第一时间看到来自服务端的新消息（聊天、新订单、系统告警等）。\r\n**常见方案**：\r\n\r\n- **WebSocket**：全双工、低延迟、最通用。\r\n- **SSE（Server-Sent Events）**：服务端到客户端的单向推送，轻量、易用。\r\n- **长轮询（Long Polling）**：兼容性最佳的兜底方案。\r\n- **Web Push（Service Worker）**：浏览器级推送，页面不在前台也能收到（需用户同意）。\r\n\r\n**快速选型**（简表）：\r\n\r\n| 需求/约束                | 推荐                         |\r\n| ------------------------ | ---------------------------- |\r\n| 双向通信（聊天/协作）    | **WebSocket**                |\r\n| 只下行推送、需超轻量     | **SSE**                      |\r\n| 公司网络/代理限制 WS     | **SSE 或 长轮询**            |\r\n| 需离线/后台通知          | **Web Push**                 |\r\n| 海量连接、水平扩展       | **WS + Redis Pub/Sub 或 MQ** |\r\n| 服务端易实现、兼容老后端 | **长轮询**                   |\r\n\r\n---\r\n\r\n# 实现思路（一图流）\r\n\r\n1. **连接层**：浏览器（WS/SSE/HTTP） ↔ 反向代理（Nginx/Ingress） ↔ **推送网关服务**\r\n2. **消息路由层**：**Redis Pub/Sub / Kafka / RabbitMQ** 做 fan-out 与广播\r\n3. **业务层**：订单/聊天/告警服务把事件写入 **消息总线**\r\n4. **状态与可靠性**：在线用户表、订阅关系、**Ack/重试/幂等**、**断线重连**、**心跳**、**权限校验**\r\n\r\n---\r\n\r\n# 分步实践\r\n\r\n## 方案一：WebSocket（最通用）\r\n\r\n### 最小可行后端（Node.js + `ws`）\r\n\r\n```js\r\n// 复杂逻辑：保存连接、鉴权、心跳、按用户分组转发\r\nimport { WebSocketServer } from \"ws\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nconst wss = new WebSocketServer({ port: 8080 });\r\nconst clients = new Map(); // userId -> Set<ws>\r\n\r\nwss.on(\"connection\", (ws, req) => {\r\n  // 复杂逻辑：从 ?token= 解析并校验用户身份\r\n  const token = new URL(req.url, \"http://x\").searchParams.get(\"token\");\r\n  let userId = null;\r\n  try {\r\n    userId = jwt.verify(token, process.env.JWT_SECRET).sub;\r\n  } catch {\r\n    ws.close();\r\n    return;\r\n  }\r\n\r\n  if (!clients.has(userId)) clients.set(userId, new Set());\r\n  clients.get(userId).add(ws);\r\n\r\n  // 复杂逻辑：心跳保活，清理僵尸连接\r\n  ws.isAlive = true;\r\n  ws.on(\"pong\", () => (ws.isAlive = true));\r\n\r\n  ws.on(\"message\", (buf) => {\r\n    // 这里可处理客户端上行，如已读回执/输入中状态\r\n  });\r\n\r\n  ws.on(\"close\", () => {\r\n    clients.get(userId).delete(ws);\r\n    if (clients.get(userId).size === 0) clients.delete(userId);\r\n  });\r\n});\r\n\r\n// 复杂逻辑：定时 ping\r\nsetInterval(() => {\r\n  wss.clients.forEach((ws) => {\r\n    if (!ws.isAlive) return ws.terminate();\r\n    ws.isAlive = false;\r\n    ws.ping();\r\n  });\r\n}, 30000);\r\n\r\n// 示例：向某用户推送\r\nexport function pushToUser(userId, payload) {\r\n  const set = clients.get(userId);\r\n  if (!set) return;\r\n  const msg = JSON.stringify(payload);\r\n  set.forEach((ws) => ws.readyState === ws.OPEN && ws.send(msg));\r\n}\r\n```\r\n\r\n### 前端最小连接封装（浏览器）\r\n\r\n```js\r\n// 复杂逻辑：自动重连、指数退避、前台/后台状态感知\r\nexport function createWsClient(urlWithToken, onMsg) {\r\n  let ws,\r\n    retry = 0,\r\n    timer;\r\n\r\n  const connect = () => {\r\n    ws = new WebSocket(urlWithToken);\r\n    ws.onopen = () => {\r\n      retry = 0;\r\n    };\r\n    ws.onmessage = (e) => onMsg(JSON.parse(e.data));\r\n    ws.onclose = () => scheduleReconnect();\r\n    ws.onerror = () => ws.close();\r\n  };\r\n\r\n  const scheduleReconnect = () => {\r\n    clearTimeout(timer);\r\n    const delay = Math.min(30000, 1000 * 2 ** retry++);\r\n    timer = setTimeout(connect, delay);\r\n  };\r\n\r\n  // 复杂逻辑：页面隐藏时减小重连频率\r\n  document.addEventListener(\"visibilitychange\", () => {\r\n    if (document.hidden && ws?.readyState !== WebSocket.OPEN) {\r\n      retry = Math.max(retry, 4); // 慢一些\r\n    }\r\n  });\r\n\r\n  connect();\r\n  return () => {\r\n    clearTimeout(timer);\r\n    ws?.close();\r\n  };\r\n}\r\n```\r\n\r\n### Nginx 反代（启用 WS 协议升级）\r\n\r\n```nginx\r\n# 复杂逻辑：确保 upgrade 头转发\r\nlocation /ws/ {\r\n  proxy_pass http://realtime:8080;\r\n  proxy_http_version 1.1;\r\n  proxy_set_header Upgrade $http_upgrade;\r\n  proxy_set_header Connection \"upgrade\";\r\n  proxy_read_timeout 60s;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 方案二：SSE（Server-Sent Events，轻量下行推送）\r\n\r\n### 后端（Node.js + Express）\r\n\r\n```js\r\n// 复杂逻辑：SSE 连接池、心跳注释行、按用户推送\r\nimport express from \"express\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nconst app = express();\r\nconst streams = new Map(); // userId -> res\r\n\r\napp.get(\"/sse\", (req, res) => {\r\n  const token = req.query.token;\r\n  let userId;\r\n  try {\r\n    userId = jwt.verify(token, process.env.JWT_SECRET).sub;\r\n  } catch {\r\n    return res.sendStatus(401);\r\n  }\r\n\r\n  res.set({\r\n    \"Content-Type\": \"text/event-stream\",\r\n    \"Cache-Control\": \"no-cache\",\r\n    Connection: \"keep-alive\",\r\n  });\r\n  res.flushHeaders();\r\n  streams.set(userId, res);\r\n\r\n  // 复杂逻辑：心跳，防止中间设备断开\r\n  const hb = setInterval(() => res.write(\":hb\\n\\n\"), 25000);\r\n\r\n  req.on(\"close\", () => {\r\n    clearInterval(hb);\r\n    streams.delete(userId);\r\n  });\r\n});\r\n\r\nexport function ssePush(userId, data) {\r\n  const res = streams.get(userId);\r\n  if (!res) return;\r\n  res.write(`data: ${JSON.stringify(data)}\\n\\n`);\r\n}\r\n\r\napp.listen(8081);\r\n```\r\n\r\n### 前端\r\n\r\n```js\r\n// 复杂逻辑：SSE 自动重连由浏览器原生完成\r\nconst ev = new EventSource(`/sse?token=${encodeURIComponent(token)}`);\r\nev.onmessage = (e) => {\r\n  const payload = JSON.parse(e.data);\r\n  // 渲染消息\r\n};\r\n```\r\n\r\n**何时用 SSE**：仅需服务端 → 浏览器推送（如系统广播、价格/进度更新），无需上行交互；在某些企业代理/防火墙下比 WS 更稳定。\r\n\r\n---\r\n\r\n## 方案三：长轮询（兼容兜底）\r\n\r\n### 后端（Koa/Express 任意）\r\n\r\n```js\r\n// 复杂逻辑：如果没有新消息就挂起请求，直到有消息或超时\r\nconst waiters = new Map(); // userId -> res[]\r\n\r\napp.get(\"/poll\", (req, res) => {\r\n  const userId = auth(req); // 自行实现鉴权\r\n  (waiters.get(userId) ?? waiters.set(userId, []).get(userId)).push(res);\r\n  req.setTimeout(65000); // 与前端超时一致\r\n  req.on(\"close\", () => cleanup(userId, res));\r\n});\r\n\r\nfunction notify(userId, payload) {\r\n  const list = waiters.get(userId) || [];\r\n  for (const res of list) res.json(payload);\r\n  waiters.set(userId, []);\r\n}\r\n```\r\n\r\n### 前端\r\n\r\n```js\r\n// 复杂逻辑：递归调用保持“长连接”效果\r\nasync function longPoll() {\r\n  try {\r\n    const r = await fetch(\"/poll\", { credentials: \"include\" });\r\n    if (r.ok) {\r\n      const data = await r.json();\r\n      // 处理消息\r\n    }\r\n  } catch (_) {\r\n    /* 忽略网络错误 */\r\n  } finally {\r\n    setTimeout(longPoll, 100);\r\n  } // 轻微间隔\r\n}\r\nlongPoll();\r\n```\r\n\r\n---\r\n\r\n## 方案四：Web Push（离线/后台通知）\r\n\r\n> 适合 **提醒类** 场景：即便用户没打开页面、浏览器在后台，仍可收到通知（需 HTTPS 与用户授权）。\r\n\r\n### 前端注册 Service Worker\r\n\r\n```js\r\n// 复杂逻辑：注册 SW 并申请通知权限，然后向后端上报订阅\r\nconst reg = await navigator.serviceWorker.register(\"/sw.js\");\r\nconst permission = await Notification.requestPermission();\r\nif (permission === \"granted\") {\r\n  const sub = await reg.pushManager.subscribe({\r\n    userVisibleOnly: true,\r\n    applicationServerKey: \"<VAPID_PUBLIC_KEY_BASE64URL>\",\r\n  });\r\n  await fetch(\"/push/subscribe\", { method: \"POST\", body: JSON.stringify(sub) });\r\n}\r\n```\r\n\r\n### Service Worker 接收\r\n\r\n```js\r\n// 复杂逻辑：展示系统级通知\r\nself.addEventListener(\"push\", (e) => {\r\n  const data = e.data?.json() ?? {};\r\n  e.waitUntil(\r\n    self.registration.showNotification(data.title || \"通知\", {\r\n      body: data.body,\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n### 后端发送（Node.js + web-push）\r\n\r\n```js\r\n// 复杂逻辑：使用 VAPID 签名向浏览器推送\r\nimport webpush from \"web-push\";\r\nwebpush.setVapidDetails(\r\n  \"mailto:admin@example.com\",\r\n  VAPID_PUBLIC,\r\n  VAPID_PRIVATE\r\n);\r\n\r\n// subs 为持久化的订阅列表\r\nexport async function sendPush(sub, payload) {\r\n  await webpush.sendNotification(sub, JSON.stringify(payload));\r\n}\r\n```\r\n\r\n---\r\n\r\n# 可扩展与高可用\r\n\r\n- **水平扩展**：WS/SSE 多实例时，用 **Redis Pub/Sub** 或 **消息队列（Kafka/RabbitMQ）** 做广播/定向投递。\r\n- **在线表/路由**：`userId -> connectionIds`（内存 + Redis）。\r\n- **可靠性**：业务消息落库 → 推送 → 客户端 **Ack** → 未 Ack 重试；**消息去重键** 防止重复渲染。\r\n- **断线重连**：客户端带 **上次 offset/lastId** 续传（SSE 原生有 `Last-Event-ID`）。\r\n- **背压控制**：批量合并（coalesce）、节流；超大消息用链接拉取。\r\n- **监控告警**：连接数、发送量、队列堆积、投递耗时、重试率、失败率。\r\n\r\n---\r\n\r\n# 安全与合规\r\n\r\n- **鉴权**：连接时附带 **短期 JWT**，服务端校验与续期；不同通道（WS/SSE/HTTP）统一鉴权层。\r\n- **权限**：服务端二次校验资源访问（不要把 topic 名称当权限）。\r\n- **限流**：IP / 用户 / 通道维度限速；异常断开与重连风暴保护。\r\n- **加密**：HTTPS/WSS；敏感字段服务端脱敏。\r\n- **审计**：关键通知落库，包含投递结果与阅读状态。\r\n\r\n---\r\n\r\n# 最简“端到端”范例清单\r\n\r\n> 你可以基于此快速拼装生产可用的实时通知：\r\n\r\n1. **连接层**：WebSocket（上面 Node + `ws` 代码）\r\n2. **消息总线**：Redis（`PUBLISH notifications:user:123 {...}`）\r\n3. **业务写入**：订单服务下单成功 → 发布事件\r\n4. **推送网关**：订阅 Redis 通道 → `pushToUser(userId, payload)`\r\n5. **前端**：`createWsClient` 接收 → 写入本地状态/弹出提醒\r\n6. **兜底**：前端检测 WS 不可用则回退 SSE/长轮询\r\n7. **离线补充**：允许用户开启 Web Push 作后台提醒\r\n\r\n---\r\n\r\n# 常见坑与排错\r\n\r\n- **公司代理挡 WS**：优先尝试 **SSE**；Nginx/Ingress 需正确配置 `Upgrade/Connection`。\r\n- **连接泄漏**：记得 **清理 close** 事件、设置 **心跳**。\r\n- **消息乱序/重复**：加入 **自增 offset / 事件时间戳 / 幂等键**。\r\n- **大房间广播**：用 **频道广播 + 客户端过滤** 或 **服务端分片广播**。\r\n- **移动网络切换**：重连后用 **lastId** 请求增量补齐。\r\n\r\n---\r\n\r\n# 结语\r\n\r\n- **单点小流量**：直接 **SSE 或 WS** 即可。\r\n- **中大型/海量**：**WS + Redis/MQ**，加上 **Ack/重试/幂等/监控**。\r\n- **提醒类**：配上 **Web Push**，覆盖离线/后台。\r\n\r\n需要我结合你现有技术栈（如 Next.js、Spring Boot、NestJS、Redis、Kafka）给出**最小改造的落地方案**和**只改动的代码片段**吗？我可以按你的项目结构直接贴可替换的文件/增量修改。\r\n",
            "url": "https://example.com/posts/web应用开发-前端-Web-应用如何做到实时消息通知",
            "title": "web应用开发/前端/Web 应用如何做到实时消息通知",
            "date_modified": "2025-09-05T14:10:20.000Z"
        },
        {
            "id": "https://example.com/posts/「请求层大重构」——从散乱到企业级：类型、目录与演进路线",
            "content_html": "\r\n## 目标与判断\r\n\r\n你的现状：页面里混着 `api.d.ts / axios.d.ts / common.ts` 等类型与封装，随着“对象入参 + 零破坏兼容”推进，类型边界和目录粘在一起，开始“乱”。\r\n\r\n**结论（大厂常用做法）**：保持 `axios` 原语义不覆写，新增对象式入口（如 `http.call`）；**类型集中管理**、**代码生成** 与 **运行时校验** 组合；请求层**分三层**（core/http、api/generated、api/modules），再用**查询层**（TanStack Query/Vue Query）管理缓存与重试；本地与集成测试统一用 **MSW** 拦截网络层。这些都是一线公司里稳定落地的模式。([axios-http.com][1], [orval.dev][2], [GitHub][3], [tanstack.com][4], [mswjs.io][5])\r\n\r\n---\r\n\r\n## 推荐目录（企业级分层）\r\n\r\n```txt\r\nsrc/\r\n  lib/\r\n    http/                      # Core 请求层（只做“通用能力”）\r\n      client.ts                # axios 实例与拦截器（不覆写 axios.request）\r\n      call.ts                  # 新增对象式入口：http.call(options)\r\n      interceptors.ts          # 拦截器拆分：auth、retry、logging\r\n      cancel.ts                # 取消池/AbortController 管理\r\n      types.ts                 # RequestOptions、HttpError、CodeResponse 等\r\n      index.ts                 # 统一导出 http 实例与类型\r\n  api/\r\n    __generated__/             # OpenAPI 代码生成产物（只读）\r\n      client.ts\r\n      schemas.ts               # 可选：导出 Zod/类型\r\n      README.md\r\n    modules/                   # 领域 API（手写，薄封装）\r\n      user.ts\r\n      order.ts\r\n      price.ts\r\n  features/                    # 业务功能（视框架而定：React/Vue）\r\n    price-trend/\r\n      queries.ts               # TanStack Query/Vue Query 的 hooks\r\n      components/...\r\n  types/\r\n    http/                      # 类型声明集中地（仅 .d.ts）\r\n      axios.d.ts               # module augmentation：扩展 AxiosInstance（如 .call）\r\n      api.d.ts                 # 全局响应范式、工具类型\r\n    common.ts                  # 与请求无关的通用类型\r\ntests/\r\n  msw/\r\n    server.ts                  # MSW 服务端/浏览器初始化\r\n    handlers/                  # 接口级别的 mock 处理器\r\n```\r\n\r\n- `lib/http` 只做“通用能力”（超时、重试、鉴权、取消、日志、错误规约），**不写任何“业务 URL”**；这能保证“可替换/可迁移”。拦截器是 axios 官方推荐扩展点。([axios-http.com][1])\r\n- `api/__generated__` 用 OpenAPI/Swagger **生成**强类型客户端，避免手写 drift；常见工具：**orval**、**openapi-typescript-codegen**、OpenAPI Generator。([orval.dev][2], [GitHub][3], [openapi-generator.tech][6])\r\n- `api/modules` 是“轻薄门面层”：把生成代码或 `http.call` 包一层，落地**统一的错误/返回范式**，方便埋点与切面。\r\n- `features/*/queries.ts` 将请求函数交给 **TanStack Query/Vue Query** 管理缓存、并发、重试、失效、SSR 等。([tanstack.com][7])\r\n- `tests/msw` 用 **MSW** 在浏览器/Node 统一拦截 HTTP，保证本地/CI 可重复。([mswjs.io][5])\r\n\r\n---\r\n\r\n## 类型与声明管理：收口与增量\r\n\r\n### 1) `.d.ts` **只放声明，不放实现**\r\n\r\n- 将你现有的 `api.d.ts / axios.d.ts` **合并/去重**后放到 `src/types/http/` 下，职责清晰：\r\n\r\n  - `axios.d.ts`：**module augmentation**（扩展 `AxiosInstance`，如新增 `call<T>()` 签名，不改原生 `get/post`）。TypeScript 官方建议通过声明合并做到“对第三方库的扩展”。([typescriptlang.org][8], [Stack Overflow][9], [futurestud.io][10])\r\n  - `api.d.ts`：与后端约定的响应外层、错误码、工具类型（如 `CodeResponse<T>`、`PageResp<T>`）。\r\n\r\n- `common.ts` 只保留**与请求无关**的通用类型/常量，避免耦合。\r\n\r\n> **示例（module augmentation）**：将 `.call` 加入 `AxiosInstance`（放 `src/types/http/axios.d.ts`）\r\n\r\n```ts\r\n// 在同名模块作用域内“声明合并”，不会改动运行时代码\r\ndeclare module \"axios\" {\r\n  export interface AxiosInstance {\r\n    // 简化：对象式入口\r\n    call<T = any, P = Record<string, any>>(options: {\r\n      url: string;\r\n      method?: import(\"axios\").Method;\r\n      params?: P;\r\n      data?: unknown;\r\n      requestConfig?: import(\"axios\").AxiosRequestConfig;\r\n      contentType?: \"json\" | \"urlencoded\" | \"formdata\";\r\n    }): Promise<T>;\r\n  }\r\n}\r\n```\r\n\r\n### 2) **运行时校验（可选但推荐）**\r\n\r\n- 对关键接口采用 **Zod**/生成器产出的 schema，做“入站/出站”校验，尽早暴露协议漂移。([Zod][11])\r\n- 如果你用 **Zodios**，可直接以 Zod 定义端点 → 生成强类型 axios 客户端。([zodios.org][12], [npm][13])\r\n\r\n---\r\n\r\n## 代码生成：把“类型维护成本”降到最低\r\n\r\n- **orval**：从 OpenAPI 生成 TS 客户端，内置 React/Vue Query 集成、缓存与 MSW mock 模板，工程化最佳。([orval.dev][2], [GitHub][14], [npm][15])\r\n- **openapi-typescript-codegen**：轻量、纯客户端生成，适合你已有 Query 层。([GitHub][16])\r\n\r\n> 建议：把生成产物放进 `src/api/__generated__`，并**加入 lint/tsc**，但**排除 format**（防止误改）。CI 里加“变更即失败”的 diff 检查，确保版本与后端规范同步。\r\n\r\n---\r\n\r\n## Core HTTP 的“硬规范”\r\n\r\n1. **不覆写** `axios.request`，新增 `http.call(options)`，保持 `http.get/post/...` 零破坏兼容（你已走在正确路线上）。\r\n2. **拦截器**：鉴权（注入 `Authorization`）、401 统一处理、取消池、日志/链路 ID、错误归一化。([axios-http.com][1])\r\n3. **FormData 正确处理**：\r\n\r\n   - **不要手动设置** `Content-Type: multipart/form-data`，让浏览器带 boundary；否则容易 4xx/网络错误。([axios-http.com][17], [GitHub][18])\r\n\r\n4. **错误范式**：将 `AxiosError` → 统一 `HttpError`（含 `status`、`code`、`message`、`traceId`、`isNetworkError`）。\r\n5. **请求命名与埋点**：在 `requestConfig` 中允许 `opName`、`skipAuth`、`retry` 等自定义键，统一日志与灰度。\r\n\r\n---\r\n\r\n## 查询层（React/Vue）：“把副作用交给专业工具”\r\n\r\n- 用 **TanStack Query / Vue Query** 管理缓存、并发去重、后台刷新、窗口聚焦重刷、错误边界、SSR/Hydration、离线等硬问题；你的 `http.call` / 生成客户端只需提供 **纯函数** 即可。([tanstack.com][19])\r\n- 典型封装（以 React 为例）：\r\n\r\n```ts\r\n// features/price-trend/queries.ts\r\nimport { useQuery } from \"@tanstack/react-query\";\r\nimport { priceApi } from \"@/api/modules/price\";\r\n\r\nexport const useGamePriceTrend = (gameId: string, stores: string[]) =>\r\n  useQuery({\r\n    queryKey: [\"priceTrend\", gameId, stores],\r\n    // 复杂逻辑上一行注释：调用领域 API，返回 Promise，交由 Query 管理缓存与失败重试\r\n    queryFn: () => priceApi.getTrend({ gameId, stores }),\r\n    staleTime: 5 * 60 * 1000,\r\n    gcTime: 60 * 60 * 1000,\r\n    retry: 2,\r\n  });\r\n```\r\n\r\n> TanStack 官方定位就是“声明式异步/服务端状态管理”，在大厂广泛使用。([tanstack.com][7])\r\n\r\n---\r\n\r\n## Mock 与测试：MSW 打通本地与 CI\r\n\r\n- **MSW** 在浏览器/Node 拦截真实网络层，mock 定义可复用到 Storybook/E2E/单元测试，减少“环境不可用”的波动。([mswjs.io][5])\r\n- 放到 `tests/msw/handlers`，与 `api/modules` 一一对应；生成器也能产出 mock 模板（如 orval）。([GitHub][14])\r\n\r\n---\r\n\r\n## 迁移策略（零停机）\r\n\r\n1. **先落地 core/http 与 `http.call`**（不动 `get/post`）。\r\n2. **挑 1 ～ 2 个模块**迁移到 `api/modules`（使用 `http.call` 或 `__generated__` 客户端），沉淀错误与重试策略。\r\n3. **接入 TanStack/Vue Query** 的“易变接口”（价格趋势、榜单、列表）以验证缓存收益。\r\n4. 稳定后再逐步 **把老的页面直连 http 的代码迁到 modules**；期间保留 `api.d.ts` 的兼容类型，避免一次性爆炸式改动。\r\n5. 接入 **MSW** 保障端到端可测。\r\n\r\n---\r\n\r\n## 你现有文件的落位建议\r\n\r\n- `/mnt/data/api.d.ts` → `src/types/http/api.d.ts`（保留响应范式与工具类型，去掉与 axios 的交叉声明）\r\n- `/mnt/data/axios.d.ts` → `src/types/http/axios.d.ts`（**只做 module augmentation**：为 `AxiosInstance` 增加 `.call` 的签名，不定义实现）\r\n- `/mnt/data/common.ts` → `src/types/common.ts`（与请求无关的类型保留在此；若有请求相关的工具类型，迁到 `lib/http/types.ts`）\r\n\r\n---\r\n\r\n## 最小代码约定（只列关键片段）\r\n\r\n```ts\r\n// lib/http/call.ts\r\nimport type { AxiosRequestConfig, Method } from \"axios\";\r\nimport http from \"./client\";\r\nimport { toFormData, toUrlencoded } from \"./utils\";\r\n\r\nexport type RequestContentType = \"json\" | \"urlencoded\" | \"formdata\";\r\nexport interface RequestOptions<P = Record<string, any>> {\r\n  url: string;\r\n  method?: Method;\r\n  params?: P;\r\n  data?: unknown;\r\n  requestConfig?: AxiosRequestConfig;\r\n  contentType?: RequestContentType;\r\n}\r\n\r\nexport async function call<T, P = Record<string, any>>(\r\n  opt: RequestOptions<P>\r\n): Promise<T> {\r\n  const {\r\n    url,\r\n    method = \"GET\",\r\n    params,\r\n    data,\r\n    requestConfig,\r\n    contentType = \"json\",\r\n  } = opt;\r\n  if (!url) throw new Error(\"Missing url\");\r\n\r\n  const cfg: AxiosRequestConfig = { ...(requestConfig || {}), url, method };\r\n  if (method === \"GET\" || method === \"HEAD\") {\r\n    cfg.params = params ?? requestConfig?.params;\r\n  } else {\r\n    // 复杂逻辑上一行注释：统一 body 选择并按 contentType 组织\r\n    const body = data ?? params ?? requestConfig?.data;\r\n    if (contentType === \"formdata\")\r\n      cfg.data = body instanceof FormData ? body : toFormData(body as any);\r\n    else if (contentType === \"urlencoded\")\r\n      cfg.data =\r\n        body instanceof URLSearchParams\r\n          ? body\r\n          : toUrlencoded((body ?? {}) as any);\r\n    else cfg.data = body;\r\n  }\r\n  return http.request(cfg) as Promise<T>;\r\n}\r\n```\r\n\r\n> `client.ts` 里注册拦截器与取消池；`index.ts` 里 `export { http }` 与 `export { call }`；FormData 时**别手动设置** `Content-Type`，让浏览器带 boundary（官方文档有说明，也有 issue 讨论）。([axios-http.com][17], [GitHub][18])\r\n\r\n---\r\n\r\n## 校验清单（落地前检查）\r\n\r\n- [ ] **不覆写** `axios.request`；保留 `http.get/post/...`\r\n- [ ] `.d.ts` **只放声明**；`axios.d.ts` 仅做 module augmentation\r\n- [ ] `http.call` **对象式入口**可用；FormData 不手设 `Content-Type`\r\n- [ ] 统一 `HttpError`；401/取消池/日志在拦截器层\r\n- [ ] 关键接口用 **Zod** 校验或生成器 schema\r\n- [ ] 接入 **TanStack/Vue Query** 管理缓存与重试\r\n- [ ] **MSW** 拦截器与 handlers 就位；本地/CI 可跑通\r\n\r\n---\r\n\r\n## 参考与延伸\r\n\r\n- Axios 拦截器官方文档（拦截请求/响应的标准扩展点）。([axios-http.com][1])\r\n- Axios Multipart/FormData 说明（自动序列化；不要手动 `Content-Type`）。([axios-http.com][17])\r\n- 不要手动设置 FormData 的 `Content-Type`（社区/issue 共识）。([GitHub][18], [Stack Overflow][20])\r\n- TypeScript **声明合并 / 模块增强**（官方手册）。([typescriptlang.org][8])\r\n- Orval（OpenAPI → TS 客户端、Query、MSW mock 一体化）。([orval.dev][2], [GitHub][14])\r\n- openapi-typescript-codegen（轻量生成 TS 客户端）。([GitHub][16])\r\n- TanStack Query（React/Vue 的服务端状态/数据获取）。([tanstack.com][4])\r\n- MSW（浏览器/Node 的网络层 API Mock）。([mswjs.io][5])\r\n\r\n---\r\n\r\n如果你愿意，我可以把你现有的 `api.d.ts / axios.d.ts / common.ts` **逐条清点**并给出**迁移 diff**（仅贴需要修改的片段，复杂处在上一行加注释），直接落到上面的目录结构里。\r\n\r\n[1]: https://axios-http.com/docs/interceptors?utm_source=chatgpt.com \"Interceptors | Axios Docs\"\r\n[2]: https://orval.dev/?utm_source=chatgpt.com \"orval - Restful client generator\"\r\n[3]: https://github.com/ferdikoomen/openapi-typescript-codegen/wiki?utm_source=chatgpt.com \"Home · ferdikoomen/openapi-typescript-codegen Wiki\"\r\n[4]: https://tanstack.com/query/docs?utm_source=chatgpt.com \"TanStack Query\"\r\n[5]: https://mswjs.io/docs/?utm_source=chatgpt.com \"Introduction - Mock Service Worker\"\r\n[6]: https://openapi-generator.tech/docs/generators/typescript/?utm_source=chatgpt.com \"Documentation for the typescript Generator\"\r\n[7]: https://tanstack.com/query/latest/docs?utm_source=chatgpt.com \"Overview | TanStack Query React Docs\"\r\n[8]: https://www.typescriptlang.org/docs/handbook/declaration-merging.html?utm_source=chatgpt.com \"Documentation - Declaration Merging\"\r\n[9]: https://stackoverflow.com/questions/52637028/how-can-i-use-typescripts-declaration-merging-with-an-interface-imported-from-a?utm_source=chatgpt.com \"How can I use Typescript's declaration merging with an ...\"\r\n[10]: https://futurestud.io/tutorials/typescript-module-augmentation-overwrites-declarations-instead-of-merging-them?utm_source=chatgpt.com \"TypeScript — Module Augmentation Overwrites Declarations ...\"\r\n[11]: https://zod.dev/?utm_source=chatgpt.com \"Zod: Intro\"\r\n[12]: https://www.zodios.org/?utm_source=chatgpt.com \"Zodios | Zodios\"\r\n[13]: https://www.npmjs.com/package/%40zodios/axios?activeTab=readme&utm_source=chatgpt.com \"zodios/axios\"\r\n[14]: https://github.com/orval-labs/orval?utm_source=chatgpt.com \"orval-labs/orval\"\r\n[15]: https://www.npmjs.com/package/orval?utm_source=chatgpt.com \"orval\"\r\n[16]: https://github.com/ferdikoomen/openapi-typescript-codegen?utm_source=chatgpt.com \"ferdikoomen/openapi-typescript-codegen\"\r\n[17]: https://axios-http.com/docs/multipart?utm_source=chatgpt.com \"Multipart Bodies | Axios Docs\"\r\n[18]: https://github.com/axios/axios/issues/5067?utm_source=chatgpt.com \"Content type changed from multipart/form-data to ...\"\r\n[19]: https://tanstack.com/query/v5/docs/react/guides/queries?utm_source=chatgpt.com \"TanStack Query React Docs\"\r\n[20]: https://stackoverflow.com/questions/75742226/cant-set-content-type-header-for-axios-with-formdata?utm_source=chatgpt.com \"Can't set Content-Type header for axios with FormData\"\r\n\r\n下面给你一套**可直接落地**的企业级请求层目录与**所有涉及文件的完整代码**（不使用 Hexo）。\r\n特点：不覆盖 `axios.request`、保留 `http.get/post/...` 零破坏；新增对象式入口 `http.call(options)`；类型集中在 `.d.ts` 与 `types.ts`；复杂逻辑行已在上一行加中文注释。\r\n\r\n---\r\n\r\n## 目录结构\r\n\r\n```\r\nsrc/\r\n  lib/\r\n    http/\r\n      client.ts\r\n      call.ts\r\n      types.ts\r\n      utils.ts\r\n      index.ts\r\n  api/\r\n    modules/\r\n      user.ts\r\n      price.ts\r\n  types/\r\n    http/\r\n      axios.d.ts\r\n      api.d.ts\r\n    common.ts\r\n  tests/\r\n    msw/\r\n      server.ts\r\n      handlers/\r\n        price.ts\r\n```\r\n\r\n> 说明：`api/__generated__`（OpenAPI 代码生成）在此略去，你可以后续接入 orval/openapi-typescript-codegen；当前示例定位为手写模块层。\r\n\r\n---\r\n\r\n## src/lib/http/types.ts\r\n\r\n```ts\r\nimport type {\r\n  AxiosInstance,\r\n  AxiosRequestConfig,\r\n  Method,\r\n  AxiosResponse,\r\n} from \"axios\";\r\n\r\n/** 请求体类型枚举 */\r\nexport type RequestContentType = \"json\" | \"urlencoded\" | \"formdata\";\r\n\r\n/** 对象式入参：与 axios 原生保持解耦 */\r\nexport interface RequestOptions<P = Record<string, any>> {\r\n  url: string;\r\n  method?: Method;\r\n  /** GET/HEAD 下作为查询串；非 GET/HEAD 下作为 body 的回退来源 */\r\n  params?: P;\r\n  /** 非 GET/HEAD 的首选请求体 */\r\n  data?: unknown;\r\n  /** 附加的 axios 配置（headers/timeout/signal 等） */\r\n  requestConfig?: AxiosRequestConfig;\r\n  contentType?: RequestContentType;\r\n}\r\n\r\n/** 统一的错误对象，可在拦截器里规约 */\r\nexport interface HttpError extends Error {\r\n  status?: number;\r\n  code?: number | string;\r\n  data?: unknown;\r\n  traceId?: string;\r\n  isNetworkError?: boolean;\r\n}\r\n\r\n/** 统一的响应解析器签名：返回 undefined 表示“跳过，让后续解析器或原始响应继续处理” */\r\nexport type ResponseParser<T = any, R = AxiosResponse<any>> = (\r\n  resp: R\r\n) => T | undefined;\r\n\r\n/** 为 http 实例扩展的方法（实现见 client.ts / call.ts） */\r\nexport interface HttpInstance extends AxiosInstance {\r\n  call<T = any, P = Record<string, any>>(\r\n    options: RequestOptions<P>\r\n  ): Promise<T>;\r\n  cancelAll(): void;\r\n  setAuthToken(token?: string | null, type?: string): void;\r\n  setGlobalParser(parsers: ResponseParser<any, any>[]): void;\r\n  setAuthorization(token: string, expires: number | Date, name?: string): void;\r\n  removeAuthorization(name?: string): void;\r\n  checkAuthorization(name?: string): boolean;\r\n}\r\n```\r\n\r\n---\r\n\r\n## src/lib/http/utils.ts\r\n\r\n```ts\r\n/** 将对象转为 FormData；数组按 key[] 追加；对象值 JSON.stringify */\r\nexport function toFormData(params?: Record<string | number, unknown>) {\r\n  const formData = new FormData();\r\n  if (!params) return formData;\r\n  Object.entries(params).forEach(([k, v]) => {\r\n    if (Array.isArray(v)) {\r\n      v.forEach((val) =>\r\n        formData.append(\r\n          `${k}[]`,\r\n          typeof val === \"object\" ? JSON.stringify(val) : String(val)\r\n        )\r\n      );\r\n    } else if (typeof v === \"object\" && v !== null) {\r\n      formData.append(k, JSON.stringify(v));\r\n    } else if (v !== null && v !== undefined) {\r\n      formData.append(k, String(v));\r\n    }\r\n  });\r\n  return formData;\r\n}\r\n\r\n/** 将对象转为 application/x-www-form-urlencoded（支持嵌套/数组） */\r\nexport function toUrlencoded(params: Record<string | number, unknown>) {\r\n  const urlencoded = new URLSearchParams();\r\n  function walk(obj: Record<string | number, unknown>, parent = \"\") {\r\n    for (const [k, v] of Object.entries(obj)) {\r\n      const key = parent ? `${parent}[${k}]` : k;\r\n      if (v === null || v === undefined) continue;\r\n      if (Array.isArray(v)) {\r\n        v.forEach((item) =>\r\n          urlencoded.append(\r\n            `${key}[]`,\r\n            typeof item === \"object\" ? JSON.stringify(item) : String(item)\r\n          )\r\n        );\r\n      } else if (typeof v === \"object\") {\r\n        walk(v as Record<string | number, unknown>, key);\r\n      } else {\r\n        urlencoded.append(key, String(v));\r\n      }\r\n    }\r\n  }\r\n  walk(params);\r\n  return urlencoded;\r\n}\r\n```\r\n\r\n---\r\n\r\n## src/lib/http/call.ts\r\n\r\n```ts\r\nimport type { AxiosRequestConfig } from \"axios\";\r\nimport qs from \"qs\";\r\nimport type { RequestOptions } from \"./types\";\r\nimport { toFormData, toUrlencoded } from \"./utils\";\r\n\r\n/** 复杂逻辑上一行注释：根据 contentType 组织 body 并设置 headers/paramsSerializer */\r\nexport function buildAxiosConfigFromOptions(\r\n  options: RequestOptions\r\n): AxiosRequestConfig {\r\n  const {\r\n    url,\r\n    method = \"GET\",\r\n    params,\r\n    data,\r\n    requestConfig,\r\n    contentType = \"json\",\r\n  } = options;\r\n\r\n  if (!url) throw new Error(\"Missing url\");\r\n\r\n  const cfg: AxiosRequestConfig = {\r\n    ...(requestConfig || {}),\r\n    url,\r\n    method,\r\n    headers: {\r\n      // 默认 Content-Type，稍后允许外部覆盖；formdata 会主动删除以让浏览器自动带 boundary\r\n      \"Content-Type\":\r\n        contentType === \"urlencoded\"\r\n          ? \"application/x-www-form-urlencoded\"\r\n          : \"application/json\",\r\n      ...(requestConfig?.headers || {}),\r\n    },\r\n  };\r\n\r\n  if (method === \"GET\" || method === \"HEAD\") {\r\n    cfg.params = params ?? requestConfig?.params;\r\n    // 复杂逻辑上一行注释：数组无索引、跳过 null\r\n    cfg.paramsSerializer = (d) =>\r\n      qs.stringify(d, { indices: false, skipNulls: true });\r\n  } else {\r\n    // 复杂逻辑上一行注释：优先 data，回退 params（兼容旧思路）\r\n    const body = data ?? params ?? requestConfig?.data;\r\n    if (contentType === \"formdata\") {\r\n      // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type\r\n      if (cfg.headers) delete (cfg.headers as any)[\"Content-Type\"];\r\n      cfg.data = body instanceof FormData ? body : toFormData(body as any);\r\n    } else if (contentType === \"urlencoded\") {\r\n      cfg.data =\r\n        body instanceof URLSearchParams\r\n          ? body\r\n          : toUrlencoded((body ?? {}) as Record<string, any>);\r\n      cfg.headers = {\r\n        ...cfg.headers,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      };\r\n    } else {\r\n      cfg.data = body;\r\n      cfg.headers = { ...cfg.headers, \"Content-Type\": \"application/json\" };\r\n    }\r\n  }\r\n  return cfg;\r\n}\r\n```\r\n\r\n---\r\n\r\n## src/lib/http/client.ts\r\n\r\n```ts\r\nimport axios from \"axios\";\r\nimport Cookie from \"js-cookie\";\r\nimport storage from \"store\";\r\nimport type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from \"axios\";\r\nimport type { HttpInstance, ResponseParser } from \"./types\";\r\nimport { buildAxiosConfigFromOptions } from \"./call\";\r\nimport { STORAGE_KEYS } from \"@/constants\";\r\nimport { LOGIN_ROUTE } from \"@/router/constants\";\r\n\r\nconst { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;\r\n\r\n/** —— 取消池：统一管理所有请求的 AbortController —— */\r\nconst abortPool = new Set<AbortController>();\r\n\r\n/** 对外暴露：集中取消所有未决请求（如退出登录时） */\r\nfunction cancelAll() {\r\n  abortPool.forEach((c) => c.abort());\r\n  abortPool.clear();\r\n}\r\n\r\n/** 创建 axios 实例并安装拦截器 */\r\nfunction createAxiosHttp(\r\n  config: AxiosRequestConfig,\r\n  opts: {\r\n    authDefault?: boolean;\r\n    publicPrefixes?: string[];\r\n  } = {}\r\n): HttpInstance {\r\n  const authDefault = opts.authDefault ?? true;\r\n  const publicPrefixes = opts.publicPrefixes ?? [\"/api/pub\"];\r\n\r\n  const _axios = axios.create(config) as AxiosInstance;\r\n\r\n  // —— 业务增强：全局解析器（按顺序尝试，返回 undefined 表示跳过） ——\r\n  (_axios as any).setGlobalParser = (parsers: ResponseParser<any, any>[]) => {\r\n    _axios.interceptors.response.use(\r\n      (resp: AxiosResponse) => {\r\n        for (const p of parsers) {\r\n          const r = p(resp);\r\n          if (r !== undefined) return r;\r\n        }\r\n        return resp;\r\n      },\r\n      (err) => {\r\n        if (err?.response) {\r\n          const e: any = new Error(err.response.statusText);\r\n          e.status = err.response.status;\r\n          e.code = err.response.data?.code;\r\n          e.data = err.response.data;\r\n          throw e;\r\n        }\r\n        // 网络层错误（超时/断网/跨域）\r\n        const e: any = new Error(err?.message || \"Network Error\");\r\n        e.isNetworkError = true;\r\n        throw e;\r\n      }\r\n    );\r\n  };\r\n\r\n  // —— cookie 鉴权工具方法（部分场景需要，同你原实现保持一致） ——\r\n  (_axios as any).setAuthorization = (\r\n    token: string,\r\n    expires: number | Date,\r\n    name?: string\r\n  ) => {\r\n    Cookie.set(name ?? _axios.defaults.xsrfCookieName!, token, { expires });\r\n  };\r\n  (_axios as any).removeAuthorization = (name?: string) => {\r\n    Cookie.remove(name ?? _axios.defaults.xsrfCookieName!);\r\n  };\r\n  (_axios as any).checkAuthorization = (name?: string) => {\r\n    return Boolean(Cookie.get(name ?? _axios.defaults.xsrfCookieName!));\r\n  };\r\n\r\n  // —— 请求拦截器：统一接入取消池/授权头/公开前缀 ——\r\n  _axios.interceptors.request.use((req) => {\r\n    // 复杂逻辑上一行注释：桥接外部 signal 与内部 AbortController，并加入取消池\r\n    const abortController = new AbortController();\r\n    if ((req as any).signal) {\r\n      const ext = (req as any).signal as AbortSignal;\r\n      if (ext.aborted) abortController.abort();\r\n      else ext.addEventListener?.(\"abort\", () => abortController.abort());\r\n    }\r\n    (req as any).signal = abortController.signal;\r\n    abortPool.add(abortController);\r\n    // 复杂逻辑上一行注释：把 controller 暂存在 config 上，响应阶段释放\r\n    (req as any).__abortController = abortController;\r\n\r\n    // 复杂逻辑上一行注释：根据前缀与开关决定是否附加 Authorization\r\n    const url = req.url || \"\";\r\n    const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));\r\n    // 优先使用 req.auth(boolean)；否则用实例默认值 + 前缀约定\r\n    const explicitAuth =\r\n      typeof (req as any).auth === \"boolean\" ? (req as any).auth : undefined;\r\n    const needAuth = explicitAuth ?? (authDefault && !isPublicByPrefix);\r\n    const accToken = storage.get(ACCESS_TOKEN);\r\n    const tokenType = storage.get(TOKEN_TYPE) || \"Bearer\";\r\n    if (needAuth && !accToken) {\r\n      ((req as any).__abortController as AbortController | undefined)?.abort();\r\n      return Promise.reject(new Error(\"UNAUTHENTICATED\"));\r\n    }\r\n    if (needAuth && accToken) {\r\n      req.headers = {\r\n        ...req.headers,\r\n        Authorization: `${tokenType} ${accToken}`,\r\n      };\r\n    }\r\n    return req;\r\n  });\r\n\r\n  // —— 响应拦截器：释放取消控制器；401 统一处理 ——\r\n  _axios.interceptors.response.use(\r\n    (res) => {\r\n      const abortController = (res.config as any).__abortController as\r\n        | AbortController\r\n        | undefined;\r\n      if (abortController) abortPool.delete(abortController);\r\n      return res;\r\n    },\r\n    (err) => {\r\n      if (err?.response?.status === 401) {\r\n        storage.remove(ACCESS_TOKEN);\r\n        storage.remove(TOKEN_TYPE);\r\n        if (window.location.pathname !== LOGIN_ROUTE.path) {\r\n          window.location.replace(LOGIN_ROUTE.path);\r\n        }\r\n      }\r\n      const abortController = (err?.config as any)?.__abortController as\r\n        | AbortController\r\n        | undefined;\r\n      if (abortController) abortPool.delete(abortController);\r\n      return Promise.reject(err);\r\n    }\r\n  );\r\n\r\n  // —— 实例级取消 ——\r\n  (_axios as any).cancelAll = cancelAll;\r\n\r\n  // —— 实例级鉴权头设置（与本地存储联动） ——\r\n  (_axios as any).setAuthToken = (token?: string | null, type = \"Bearer\") => {\r\n    if (token) {\r\n      _axios.defaults.headers.common.Authorization = `${type} ${token}`;\r\n      storage.set(ACCESS_TOKEN, token);\r\n      storage.set(TOKEN_TYPE, type);\r\n    } else {\r\n      delete _axios.defaults.headers.common.Authorization;\r\n      storage.remove(ACCESS_TOKEN);\r\n      storage.remove(TOKEN_TYPE);\r\n    }\r\n  };\r\n\r\n  // —— 新增对象式入口：http.call(options) ——\r\n  (_axios as any).call = async function <T = any>(\r\n    options: Parameters<typeof buildAxiosConfigFromOptions>[0]\r\n  ): Promise<T> {\r\n    const cfg = buildAxiosConfigFromOptions(options);\r\n    return _axios.request(cfg) as Promise<T>;\r\n  };\r\n\r\n  return _axios as unknown as HttpInstance;\r\n}\r\n\r\nconst http = createAxiosHttp(\r\n  {\r\n    timeout: 10000,\r\n    baseURL: import.meta.env.VITE_API_URL as string,\r\n    withCredentials: true,\r\n    xsrfCookieName: \"Authorization\",\r\n    xsrfHeaderName: \"Authorization\",\r\n  },\r\n  { authDefault: true, publicPrefixes: [\"/api/pub\"] }\r\n);\r\n\r\nexport default http;\r\nexport { cancelAll };\r\n```\r\n\r\n---\r\n\r\n## src/lib/http/index.ts\r\n\r\n```ts\r\nexport { default as http, cancelAll } from \"./client\";\r\nexport * from \"./types\";\r\nexport * from \"./utils\";\r\nexport * from \"./call\";\r\n```\r\n\r\n---\r\n\r\n## src/api/modules/user.ts\r\n\r\n```ts\r\nimport { http } from \"@/lib/http\";\r\nimport type { RequestOptions } from \"@/lib/http/types\";\r\n\r\n/** 复杂逻辑上一行注释：领域 API 薄封装，避免页面直接感知 URL/方法/解析细节 */\r\nexport const userApi = {\r\n  getProfile() {\r\n    return http.get<{ id: string; name: string; roles: string[] }>(\r\n      \"/api/user/profile\"\r\n    );\r\n  },\r\n\r\n  updateProfile(input: { name?: string }) {\r\n    return http.call<void>({\r\n      url: \"/api/user/profile\",\r\n      method: \"PUT\",\r\n      data: input,\r\n      contentType: \"json\",\r\n    });\r\n  },\r\n\r\n  /** 演示：URLSearchParams */\r\n  search(params: { keyword?: string; page?: number }) {\r\n    const options: RequestOptions<typeof params> = {\r\n      url: \"/api/user/search\",\r\n      method: \"GET\",\r\n      params,\r\n      requestConfig: { timeout: 8000 },\r\n    };\r\n    return http.call<{ list: any[]; total: number }>(options);\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n## src/api/modules/price.ts\r\n\r\n```ts\r\nimport { http } from \"@/lib/http\";\r\n\r\n/** 复杂逻辑上一行注释：后端采用 CodeResponse 外包裹，交由全局解析器转换 */\r\nexport const priceApi = {\r\n  getTrend(input: { gameId: string; stores: string[] }) {\r\n    return http.call<Array<{ store: string; date: string; price: number }>>({\r\n      url: \"/api/price/trend\",\r\n      method: \"POST\",\r\n      data: input,\r\n      contentType: \"json\",\r\n      requestConfig: { timeout: 15000 },\r\n    });\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n## src/types/http/axios.d.ts\r\n\r\n```ts\r\n// 声明合并：扩展 AxiosInstance，而不改动运行时代码\r\nimport type { AxiosRequestConfig } from \"axios\";\r\n\r\ndeclare module \"axios\" {\r\n  export interface AxiosInstance {\r\n    call<T = any, P = Record<string, any>>(options: {\r\n      url: string;\r\n      method?: Method;\r\n      params?: P;\r\n      data?: unknown;\r\n      requestConfig?: AxiosRequestConfig;\r\n      contentType?: \"json\" | \"urlencoded\" | \"formdata\";\r\n    }): Promise<T>;\r\n\r\n    cancelAll(): void;\r\n    setAuthToken(token?: string | null, type?: string): void;\r\n    setGlobalParser(parsers: Array<(resp: any) => any | undefined>): void;\r\n    setAuthorization(\r\n      token: string,\r\n      expires: number | Date,\r\n      name?: string\r\n    ): void;\r\n    removeAuthorization(name?: string): void;\r\n    checkAuthorization(name?: string): boolean;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## src/types/http/api.d.ts\r\n\r\n```ts\r\n// 与后端约定的通用响应外壳\r\nexport interface CodeResponse<T = any> {\r\n  code: number;\r\n  data: T;\r\n  message?: string;\r\n}\r\n\r\n// 常见分页返回\r\nexport interface PageResp<T> {\r\n  list: T[];\r\n  total: number;\r\n  page: number;\r\n  pageSize: number;\r\n}\r\n\r\n// 解析器（如果你希望有全局类型）\r\nexport type ResponseParser<T = any, R = any> = (resp: R) => T | undefined;\r\n```\r\n\r\n---\r\n\r\n## src/types/common.ts\r\n\r\n```ts\r\n// 放与请求无关的通用类型\r\nexport type ID = string | number;\r\n\r\nexport interface Dict<T = any> {\r\n  [key: string]: T;\r\n}\r\n```\r\n\r\n---\r\n\r\n## （可选）全局解析器：将 CodeResponse<T> 解开\r\n\r\n> 你可以把它放到任意初始化位置（如 `src/app.ts` 或 `src/main.ts`）并在启动时挂载。\r\n\r\n```ts\r\n// src/app.setup-http.ts\r\nimport type { AxiosResponse } from \"axios\";\r\nimport { http } from \"@/lib/http\";\r\nimport { LOGIN_ROUTE } from \"@/router/constants\";\r\nimport storage from \"store\";\r\nimport { STORAGE_KEYS } from \"@/constants\";\r\nimport type { CodeResponse } from \"@/types/http/api\";\r\n\r\nconst { ACCESS_TOKEN, TOKEN_TYPE } = STORAGE_KEYS;\r\n\r\n/** 复杂逻辑上一行注释：仅处理符合 CodeResponse 形状的响应，其他透传 */\r\nfunction isCodeResp<T>(d: unknown): d is CodeResponse<T> {\r\n  return (\r\n    !!d && typeof d === \"object\" && \"code\" in (d as any) && \"data\" in (d as any)\r\n  );\r\n}\r\n\r\nexport const codeResponseParser = <T, R = CodeResponse<T>>(\r\n  res: AxiosResponse<R>\r\n): T | undefined => {\r\n  const payload = res.data as any;\r\n  if (!isCodeResp<T>(payload)) return undefined;\r\n  const { code, data, message = \"\" } = payload;\r\n\r\n  if (code === 401) {\r\n    storage.remove(ACCESS_TOKEN);\r\n    storage.remove(TOKEN_TYPE);\r\n    if (window.location.pathname !== LOGIN_ROUTE.path) {\r\n      window.location.replace(LOGIN_ROUTE.path);\r\n    }\r\n    throw new Error(\"未授权，请重新登录\");\r\n  }\r\n  if (code === 200) return (data ?? null) as T;\r\n  throw new Error(message || \"后端错误\");\r\n};\r\n\r\n// 启动时挂载\r\nhttp.setGlobalParser([codeResponseParser]);\r\n```\r\n\r\n---\r\n\r\n## tests/msw/server.ts\r\n\r\n```ts\r\nimport { setupServer } from \"msw/node\";\r\nimport { handlers } from \"./handlers/price\";\r\n\r\nexport const server = setupServer(...handlers);\r\n\r\n// 在测试框架的 setup 中调用：\r\n// beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }))\r\n// afterEach(() => server.resetHandlers())\r\n// afterAll(() => server.close())\r\n```\r\n\r\n---\r\n\r\n## tests/msw/handlers/price.ts\r\n\r\n```ts\r\nimport { http, HttpResponse } from \"msw\";\r\n\r\n// 示例：与你的 priceApi.getTrend 匹配\r\nexport const handlers = [\r\n  http.post(\"/api/price/trend\", async ({ request }) => {\r\n    const body = (await request.json()) as any;\r\n    // 复杂逻辑上一行注释：模拟后端的 CodeResponse 外壳\r\n    return HttpResponse.json({\r\n      code: 200,\r\n      data: [\r\n        { store: \"Steam\", date: \"2025-09-01\", price: 199 },\r\n        { store: \"Epic\", date: \"2025-09-01\", price: 189 },\r\n      ],\r\n      message: \"ok\",\r\n    });\r\n  }),\r\n];\r\n```\r\n\r\n---\r\n\r\n# 使用要点\r\n\r\n- 老代码：`http.get/post/...` **完全不受影响**。\r\n- 新写法：`http.call({ url, method, data/params, contentType, requestConfig })` 更可读/可扩展。\r\n- `FormData` 场景不要手设 `Content-Type`，已在实现里处理。\r\n- 推荐在应用初始化处挂载 `codeResponseParser`，让模块层拿到的就是“已解壳”的数据。\r\n\r\n如果你要把你现有的 `api.d.ts / axios.d.ts / common.ts` 内容**原封不动**迁入以上文件名，也可以把原定义贴出来，我帮你对齐/去重并完善类型冲突的 diff。\r\n\r\n下面把你要的 **`cancel.ts` 完整代码**给出，并说明如何在 `client.ts` 接入；最后把 “FormData 自动带 boundary，需移除手动设置的 Content-Type” 的含义讲清楚。\r\n\r\n---\r\n\r\n## 1) `src/lib/http/cancel.ts`（完整代码）\r\n\r\n```ts\r\n// src/lib/http/cancel.ts\r\n\r\n/**\r\n * 维护一个全局取消池，用于集中取消所有尚未完成的请求。\r\n * 注意：只存放“活跃中的” AbortController；请求结束后要及时释放。\r\n */\r\nconst abortPool = new Set<AbortController>();\r\n\r\n/** 复杂逻辑上一行注释：把外部 signal（若有）与内部 controller 绑定，外部取消时联动内部取消 */\r\nfunction linkExternalSignal(\r\n  external?: AbortSignal,\r\n  controller?: AbortController\r\n) {\r\n  if (!external || !controller) return;\r\n  if (external.aborted) {\r\n    // 外部已取消则立即同步内部取消\r\n    controller.abort();\r\n    return;\r\n  }\r\n  // 外部后续取消时，触发内部取消\r\n  external.addEventListener(\"abort\", () => controller.abort());\r\n}\r\n\r\n/**\r\n * 创建一个“已纳入取消池管理”的 AbortController。\r\n * - 会自动与外部 signal（如果传入）联动；\r\n * - 会自动加入全局 abortPool，方便统一取消；\r\n * - 调用方需在请求完成/失败时调用 releaseController 释放。\r\n */\r\nexport function makeTrackedController(\r\n  externalSignal?: AbortSignal\r\n): AbortController {\r\n  const controller = new AbortController();\r\n  linkExternalSignal(externalSignal, controller);\r\n  abortPool.add(controller);\r\n  return controller;\r\n}\r\n\r\n/** 将 controller 从取消池释放（请求完成/失败时务必调用，避免内存泄漏） */\r\nexport function releaseController(controller?: AbortController) {\r\n  if (controller) abortPool.delete(controller);\r\n}\r\n\r\n/** 退出登录或全局重置时：集中取消所有未决请求 */\r\nexport function cancelAll() {\r\n  abortPool.forEach((c) => c.abort());\r\n  abortPool.clear();\r\n}\r\n```\r\n\r\n---\r\n\r\n## 2) 在 `client.ts` 中的**最小改动**\r\n\r\n> 按你的偏好，这里**只给需要改的片段**，并在复杂逻辑上一行加注释。\r\n\r\n**2.1 顶部引入：**\r\n\r\n```ts\r\n// + 新增\r\nimport { makeTrackedController, releaseController, cancelAll } from \"./cancel\";\r\n```\r\n\r\n**2.2 删除原本在 client.ts 里的这两段：**\r\n\r\n```ts\r\n// - 删除\r\nconst abortPool = new Set<AbortController>();\r\nfunction cancelAll() {\r\n  /* ...原实现... */\r\n}\r\n```\r\n\r\n**2.3 请求拦截器里替换创建/管理 controller 的逻辑：**\r\n\r\n```ts\r\n// —— 将外部 signal 与内部 AbortController 关联，并纳入统一取消池 ——\r\nconst abortController = makeTrackedController(\r\n  (req as any).signal as AbortSignal | undefined\r\n);\r\n(req as any).signal = abortController.signal;\r\n(req as any).__abortController = abortController;\r\n```\r\n\r\n**2.4 响应与异常分支里释放 controller：**\r\n\r\n```ts\r\n// —— 请求完成：释放与该请求关联的 AbortController ——\r\nreleaseController(\r\n  (res.config as any).__abortController as AbortController | undefined\r\n);\r\n\r\n// —— 异常完成：同样需要释放 AbortController ——\r\nreleaseController(\r\n  (err?.config as any)?.__abortController as AbortController | undefined\r\n);\r\n```\r\n\r\n**2.5 保持对外暴露实例方法：**\r\n\r\n```ts\r\n// 实例级的取消功能依然可用\r\n(_axios as any).cancelAll = cancelAll;\r\n```\r\n\r\n> 这样，取消逻辑就从 `client.ts` 拆分到了独立的 `cancel.ts`，便于复用与测试；`client.ts` 里只保留“如何在拦截器中使用”的胶水代码。\r\n\r\n---\r\n\r\n## 3) “FormData 自动带 boundary，需移除手动设置的 Content-Type” 是啥意思？\r\n\r\n- 当你在**浏览器环境**用 `FormData` 作为请求体时，真正发请求的是浏览器（或者 fetch/XHR），它会自动把请求头 `Content-Type` 设置成：\r\n\r\n  ```\r\n  Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXyz...\r\n  ```\r\n\r\n  这里的 `boundary` 是一段**分隔符**，用来把每个字段/文件的二进制块分割开。**这个 boundary 是浏览器动态生成的**。\r\n\r\n- **如果你手动把 `Content-Type` 固定写成 `multipart/form-data`**（没有 `boundary=...`），服务端收到的内容就**无法正确分段解析**，经常出现 400/422 或 “Unexpected end of form / Missing boundary” 之类错误。\r\n\r\n- 因此，在我们封装里（`contentType === 'formdata'` 分支）会：\r\n\r\n  ```ts\r\n  // 复杂逻辑上一行注释：FormData 让浏览器自动带 boundary，需移除手动设置的 Content-Type\r\n  if (cfg.headers) delete (cfg.headers as any)[\"Content-Type\"];\r\n  cfg.data = body instanceof FormData ? body : toFormData(body as any);\r\n  ```\r\n\r\n  这么做是**故意**把 `Content-Type` 删除，让浏览器自己填上带 `boundary` 的正确值。\r\n\r\n> 小结：\r\n>\r\n> - **浏览器 + FormData**：不要手写 `Content-Type`，让它自动带 boundary（我们代码里已处理）。\r\n> - **Node.js 端（无浏览器）**：若用 `form-data`/`formdata-node` 等库，也应**让库自己设置**或通过库提供的方法拿到带 `boundary` 的 header，而不是手写。\r\n\r\n---\r\n\r\n需要我把 `client.ts` 根据上面的片段**整合成完整文件**再贴一次，也可以说一声；但如果你已经在用我之前给的版本，只要按上面的 4 处小改即可完成 `cancel.ts` 的接入。\r\n\r\n简短结论先给你：\r\n\r\n- **Axios 封装没有“唯一正确解”**，但大厂普遍遵循“**分层 + 零破坏 + 渐进演进**”三原则：\r\n  Core（http 客户端能力）→ Domain API（领域方法）→ View/State（查询层）。\r\n- **TanStack Query（React Query / Vue Query）不是必须**。当你的页面需要**缓存、并发去重、重试、后台刷新、预取、分页/无限滚动、乐观更新**中的多项时，它的价值非常高；否则可以先不用，等复杂度上来了再加。\r\n\r\n下面给你一套“可落地的选择题”，帮你快速拍板。\r\n\r\n---\r\n\r\n## 一、Axios 封装到底怎么选？\r\n\r\n### 方案 A：**极简封装（Core + 少量 Domain API）**\r\n\r\n适用：后端接口简单、页面少、交互不复杂，或以 **Server Actions/Route Handlers（Next.js 14）** 为主、客户端请求很少。\r\n要点：\r\n\r\n- Core 层：一个 `http` 实例（拦截器、取消池、统一错误、鉴权）、`http.call(options)` 对象式入口（你现在这版 ✅）。\r\n- Domain 层：在 `src/api/modules/*` 里写薄封装函数（避免在页面拼 URL/方法）。\r\n  优点：学习/维护成本最低；对现有代码**零破坏**。\r\n  缺点：项目一复杂，**缓存/并发/重试**容易重复造轮子。\r\n\r\n### 方案 B：**标准化封装（Core + Domain API + 代码生成）**\r\n\r\n适用：接口较多、多人协作、需要**强类型**对齐后端（避免“文档/实现漂移”）。\r\n要点：\r\n\r\n- 在 A 的基础上加 **OpenAPI 代码生成**（orval/openapi-typescript-codegen），产物放 `api/__generated__`，**只读、不手改**。\r\n- Domain 层再包一层“门面”，统一错误处理/埋点/灰度。\r\n  优点：类型和接口更新**自动跟进**；减少手抄 DTO。\r\n  缺点：引入生成链路，需要后端提供/维护 OpenAPI。\r\n\r\n### 方案 C：**企业级（Core + Domain + 代码生成 + 查询层 TanStack）**\r\n\r\n适用：**列表/详情很多**、需要**缓存/失效/后台刷新/并发去重/预取/SSR**等能力；或你已经遇到“重复请求、抖动、复杂 loading 状态”问题。\r\n要点：\r\n\r\n- 在 B 的基础上引入 **TanStack Query（React）/Vue Query（Vue3）** 做服务端状态管理。\r\n- 页面里不直接 `http.call`，而是用 `useQuery/useMutation` 调你封装好的 Domain API。\r\n  优点：把“**缓存/并发/重试/错误边界/重整化**”交给成熟库，页面只管渲染。\r\n  缺点：学习成本 ↑，需要 Provider 初始化与查询键设计。\r\n\r\n---\r\n\r\n## 二、到底要不要用 TanStack Query？（自测 8 题）\r\n\r\n请数一数你满足了多少条（≥3 条就**建议上**）：\r\n\r\n1. 同一数据被**多处页面/组件复用**，且你想要**共享缓存**。\r\n2. 同一接口在短时间内可能被**多次触发**（需要**请求去重**）。\r\n3. 希望**失败自动重试**、**退避**，或在**网络恢复**/**窗口聚焦**时自动**后台刷新**。\r\n4. 有**分页/无限滚动**，并且要处理**下一页预取**或**乐观更新**。\r\n5. 需要**预取数据**（用户悬停/路由即将跳转时先打请求）。\r\n6. 你在做 **Next.js 14** 前端页面，既有 **Server Components** 也有 **Client Components**，客户端数据要**SSR Hydration** 或 **延迟刷新**。\r\n7. 想**显式管理缓存过期（staleTime）** 与 **垃圾回收（gcTime）**，防止反复打接口。\r\n8. 现在已经在手写“请求缓存/合流/状态机”，感觉**心智负担**上来了。\r\n\r\n> 结合你的项目：有**价格趋势**、**多商店选择**、**首页与详情复用价格数据**、后续还要**图表/列表**，我建议：\r\n>\r\n> - 在**这些“读多写少”的模块**上用 TanStack Query；\r\n> - 其他简单页面（一次性拉取、无复杂刷新），继续用现在的 `http.call` 即可。\r\n>   这样“**按需引入**”，增量演进，不会一刀切。\r\n\r\n---\r\n\r\n## 三、你现在的最佳落地路线（最少折腾）\r\n\r\n1. **保留现有 http 层（你已完成）**\r\n\r\n   - `client.ts + cancel.ts + call.ts + types.ts + utils.ts`，不覆盖 `axios.request`，**零破坏**保留 `get/post`。\r\n\r\n2. **Domain API 薄封装**\r\n\r\n   - 在 `src/api/modules/*` 暴露语义化函数（`priceApi.getTrend`等），页面不拼 URL。\r\n\r\n3. **对“需要缓存/并发去重”的模块上 TanStack Query**\r\n\r\n   - 只在“价格趋势、榜单、列表”这些位置用 Query，其它模块不强求。\r\n\r\n4. **后续再接 OpenAPI 代码生成**（可选）\r\n\r\n   - 先让 Query 跑顺，再把类型维护成本转移给生成器，逐步替换手写 DTO。\r\n\r\n5. **MSW 做联调与测试**（可选）\r\n\r\n   - 本地/CI 统一拦截，减少后端不可用带来的卡点。\r\n\r\n---\r\n\r\n## 四、常见误区（避免踩坑）\r\n\r\n- **覆写 `axios.request`** → 破坏 `get/post` 的语义（你已经改成 `.call`，很对）。\r\n- **手写 `Content-Type: multipart/form-data`** → FormData 的 `boundary` 会丢（我们已在 `formdata` 分支删除该头，让浏览器自动带）。\r\n- **在组件里定义 DTO/类型** → 类型四散；建议集中到 `types/http/*` 与 `api/__generated__`。\r\n- **重复写缓存/重试/去重** → 已有成熟轮子（TanStack Query）；自己写容易遗漏边角。\r\n- **取消控制器不释放** → 造成内存泄漏；我们用 `releaseController` 在响应/异常两侧都释放。\r\n\r\n---\r\n\r\n## 五、如果暂时不用 TanStack Query，也能稳住吗？\r\n\r\n可以。你的 `http.call + modules` 架构，配合\\*\\*轻量的自定义缓存（Map + 过期时间）\\*\\*也能顶一阵子。但一旦出现“**相同查询在多处使用**”、“**滚动列表/分页**”、“**需要重试与后台刷新**”的需求，**切到 TanStack Query 成本更低**（只需把 Domain API 包进 `useQuery`），没必要造大轮子。\r\n\r\n---\r\n\r\n### 你现在可以怎么做（两步）：\r\n\r\n- **短期**：继续用现有封装；把价格趋势这块接入 Query（仅此一处），体会收益。\r\n- **中期**：如果感觉不错，再把“新闻列表/攻略列表”等也迁到 Query；并考虑引入 OpenAPI 代码生成，降低类型维护成本。\r\n\r\n需要的话，我可以基于你现有的模块，直接给出**一个最小的 TanStack Query 集成示例**（包含 Provider、`useQuery` 的示例调用、SSR Hydration 的注意点），只贴**必要的代码片段**，不改你现有文件结构。\r\n\r\n结论：**你的“核心响应拦截器”（释放 AbortController + 401 跳转）先执行，`setGlobalParser` 里注册的“全局解析器”后执行**。\r\n\r\n原因（Axios 规则）：\r\n\r\n- **response 拦截器是 FIFO**：谁**先注册**，谁**先执行**。\r\n- **request 拦截器是 LIFO**：谁**后注册**，谁**先执行**。（顺带一提）\r\n\r\n在你这份代码里：\r\n\r\n1. `createAxiosHttp` 里先注册了“核心响应拦截器”。\r\n2. 应用启动时再调用 `http.setGlobalParser([...])`，此时**追加**一个响应拦截器。\r\n   → 因为 response 是 FIFO，所以**核心拦截器先跑**，**全局解析器后跑**。\r\n\r\n执行顺序具体是：\r\n\r\n- **成功响应路径 (`fulfilled`)**\r\n  ① 核心响应拦截器：`releaseController(...)` → `return res`\r\n  ② 全局解析器：遍历 parsers，可能把 `AxiosResponse` 解包成你的业务数据（或继续返回原响应）\r\n\r\n- **失败响应路径 (`rejected`)**\r\n  ① 核心响应拦截器：遇到 `401` 清 token + 跳登录；不管什么错误都先 `releaseController(...)`；`return Promise.reject(err)`\r\n  ② 全局解析器：拿到上一步抛出的 `err`，再做标准化/改写错误对象（如果你这么实现）\r\n\r\n> 小提示：如果你**想让全局解析器先执行**，就必须**更早注册**它（例如把 `setGlobalParser` 的安装逻辑挪到 `createAxiosHttp` 里、并放在核心拦截器之前），或者在核心拦截器内部先调用解析器再做释放/跳转。但你当前这种“先释放/401，再解析”的顺序其实更稳：能确保无论成功还是失败，**先释放资源**再做业务级处理，避免泄漏。\r\n",
            "url": "https://example.com/posts/「请求层大重构」——从散乱到企业级：类型、目录与演进路线",
            "title": "「请求层大重构」——从散乱到企业级：类型、目录与演进路线",
            "date_modified": "2025-09-06T11:58:07.000Z"
        },
        {
            "id": "https://example.com/posts/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）",
            "content_html": "\r\n## 需求背景\r\n\r\n- 有的文件**公开直链**，直接点就能下；\r\n- 有的需要**携带 Cookie/Token、自定义 Header 或用 POST** 才能拿到二进制流；\r\n- 我们希望**一个函数**即可应对两类场景，并自动选择最优策略。\r\n\r\n## 设计要点\r\n\r\n- **优先直链（a.click）**：不加 header/body/credentials 时，直接跳转下载；\r\n- **按需请求（fetch→Blob）**：当需要鉴权/自定义 Header/POST，先拿 Blob，再用 Object URL 触发下载；\r\n- **文件名解析**：未显式传 `fileName` 时，尝试从 `Content-Disposition` 读取；\r\n- **内存友好**：使用 Object URL 并及时 `URL.revokeObjectURL`。\r\n\r\n## 代码\r\n\r\n```ts\r\nexport type DownloadOptions = Omit<RequestInit, \"signal\"> & {\r\n  fileName?: string;\r\n  forceRequest?: boolean;\r\n};\r\n\r\nfunction _pickNameFromContentDisposition(\r\n  cd: string | null\r\n): string | undefined {\r\n  if (!cd) return;\r\n  const star = cd.match(/filename\\*=(?:UTF-8'')?([^;]+)/i);\r\n  const norm = cd.match(/filename=([^;]+)/i);\r\n  const raw = (star?.[1] ?? norm?.[1])?.trim().replace(/^[\"']|[\"']$/g, \"\");\r\n  try {\r\n    return raw ? decodeURIComponent(raw) : undefined;\r\n  } catch {\r\n    return raw;\r\n  }\r\n}\r\n\r\nexport async function downloadFile(url: string, options: DownloadOptions = {}) {\r\n  const { fileName, forceRequest, ...req } = options;\r\n  const needRequest =\r\n    !!forceRequest ||\r\n    (req.method && req.method.toUpperCase() !== \"GET\") ||\r\n    !!req.headers ||\r\n    !!req.body ||\r\n    !!req.credentials;\r\n\r\n  if (!needRequest) {\r\n    const a = document.createElement(\"a\");\r\n    a.href = url;\r\n    if (fileName) a.download = fileName; // 跨域直链可能被忽略\r\n    a.style.display = \"none\";\r\n    document.body.appendChild(a);\r\n    a.click();\r\n    document.body.removeChild(a);\r\n    return;\r\n  }\r\n\r\n  const res = await fetch(url, req);\r\n  if (!res.ok)\r\n    throw new Error(`Download failed: ${res.status} ${res.statusText}`);\r\n\r\n  let name =\r\n    fileName ??\r\n    _pickNameFromContentDisposition(res.headers.get(\"content-disposition\"));\r\n  const blob = await res.blob();\r\n  const href = URL.createObjectURL(blob);\r\n  const a = document.createElement(\"a\");\r\n  a.style.display = \"none\";\r\n  a.href = href;\r\n  if (name) a.download = name;\r\n  document.body.appendChild(a);\r\n  a.click();\r\n  document.body.removeChild(a);\r\n  URL.revokeObjectURL(href);\r\n}\r\n```\r\n\r\n## 使用示例\r\n\r\n### 直链（公开资源）\r\n\r\n```ts\r\nawait downloadFile(\"https://cdn.example.com/file.pdf\", {\r\n  fileName: \"文档.pdf\",\r\n});\r\n```\r\n\r\n### 携带 Cookie/Token\r\n\r\n```ts\r\nawait downloadFile(\"/api/report/export\", {\r\n  credentials: \"include\",\r\n  headers: { Authorization: \"Bearer xxx\" },\r\n  fileName: \"报表.xlsx\",\r\n});\r\n```\r\n\r\n### POST 导出\r\n\r\n```ts\r\nawait downloadFile(\"/api/export\", {\r\n  method: \"POST\",\r\n  headers: { \"Content-Type\": \"application/json\", Authorization: \"Bearer xxx\" },\r\n  body: JSON.stringify({ range: \"2025-01-01~2025-09-01\" }),\r\n  fileName: \"导出.csv\",\r\n});\r\n```\r\n\r\n## 注意事项\r\n\r\n- **跨域直链**时，浏览器可能**忽略 `download` 文件名**，以服务器或默认名为准；\r\n- 如需强制走请求分支，可传 `forceRequest: true`；\r\n- 服务器若返回 `Content-Disposition`，无需传 `fileName` 也能自动命名；\r\n- 大文件下载建议结合服务端分片/断点续传方案（本函数仅负责触发下载）。\r\n",
            "url": "https://example.com/posts/一个-downloadFile-就够了：直链与鉴权下载自动切换（Vue-TS）",
            "title": "一个 downloadFile 就够了：直链与鉴权下载自动切换（Vue/TS）",
            "date_modified": "2025-09-06T15:13:25.000Z"
        },
        {
            "id": "https://example.com/posts/仍有请求与401统一处理）",
            "content_html": "\r\n> 只给**需要改的代码片段**；复杂逻辑我都在上一行加了**中文注释**。以下改动基于你贴的这份 `http` 封装。\r\n\r\n## 1) 请求可“集中取消”& 退出后不再飞行\r\n\r\n**位置：请求拦截器内（`_axios.interceptors.request.use`）头部插入**\r\n\r\n```ts\r\n// 复杂逻辑：为每个请求创建可集中取消的 AbortController，并桥接外部 signal\r\nconst ac = new AbortController();\r\nif (req.signal) {\r\n  const ext = req.signal as AbortSignal;\r\n  if (ext.aborted) ac.abort();\r\n  else ext.addEventListener?.(\"abort\", () => ac.abort());\r\n}\r\nreq.signal = ac.signal;\r\nabortPool.add(ac);\r\n// 复杂逻辑：把本次请求的 controller 暂存到 config 上，方便响应阶段释放\r\n(req as any).__ac = ac;\r\n```\r\n\r\n**位置：响应成功拦截器（`res` 分支）里，`return res` 之前插入**\r\n\r\n```ts\r\n// 复杂逻辑：请求完成后，从取消池中释放 controller\r\nconst ac = (res.config as any).__ac as AbortController | undefined;\r\nif (ac) abortPool.delete(ac);\r\n```\r\n\r\n**位置：响应失败拦截器（`err` 分支）里，`return Promise.reject(err)` 之前插入**\r\n\r\n```ts\r\n// 复杂逻辑：请求失败同样释放 controller，避免池子泄漏\r\nconst ac = (err?.config as any)?.__ac as AbortController | undefined;\r\nif (ac) abortPool.delete(ac);\r\n```\r\n\r\n> 这样就和你现有的 `cancelAll()` 打通了：登出时执行 `cancelAll()`，所有在途请求立刻中止。\r\n\r\n---\r\n\r\n## 2) “未登录硬拦”鉴权请求（默认需要鉴权）\r\n\r\n**位置：请求拦截器内，给你现有的加 Token 逻辑**改为如下\\*\\*\r\n\r\n```ts\r\n// 复杂逻辑：统一鉴权开关——默认需要鉴权，白名单或显式 { auth:false } 不需要\r\nconst needAuth =\r\n  (req as any).auth !== false && !noAuthPaths.includes(req.url || \"\");\r\n\r\n// 复杂逻辑：无 Token 且需要鉴权时，直接阻断请求，避免未登录拉数据\r\nconst at = storage.get(ACCESS_TOKEN);\r\nconst tt = storage.get(TOKEN_TYPE) || \"Bearer\";\r\nif (needAuth && !at) {\r\n  // 同时中止本次请求，确保不会真正发出\r\n  ((req as any).__ac as AbortController | undefined)?.abort();\r\n  return Promise.reject(new Error(\"UNAUTHENTICATED\"));\r\n}\r\n\r\n// 复杂逻辑：有 Token 再注入 Authorization 头\r\nif (needAuth && at) {\r\n  req.headers = { ...req.headers, Authorization: `${tt} ${at}` };\r\n}\r\n```\r\n\r\n> 使用方式：需要鉴权的 API **不用写任何额外配置**（默认会拦），公开 API（或登录/注册）**明确**加上 `{ auth: false }` 即可。\r\n\r\n---\r\n\r\n## 3) 统一 401 处理（去掉 `useRouter` 的非法使用）\r\n\r\n**位置：你的 `codeResponseParser` 内，将 401 分支替换为：**\r\n\r\n```ts\r\n// 复杂逻辑：统一未授权处理（不在解析器里用 useRouter）\r\nif (code === 401) {\r\n  storage.remove(ACCESS_TOKEN);\r\n  storage.remove(TOKEN_TYPE);\r\n  // 复杂逻辑：避免组合式 API 环境限制，使用硬跳转到登录页\r\n  if (window.location.pathname !== LOGIN_ROUTE.path) {\r\n    window.location.replace(LOGIN_ROUTE.path);\r\n  }\r\n  throw new Error(\"未授权，请重新登录\");\r\n}\r\n```\r\n\r\n**位置：响应失败拦截器（`err` 分支）里，加入 HTTP 401 fallback**\r\n\r\n```ts\r\n// 复杂逻辑：后端直接返回 HTTP 401 时的兜底处理\r\nif (err?.response?.status === 401) {\r\n  storage.remove(ACCESS_TOKEN);\r\n  storage.remove(TOKEN_TYPE);\r\n  if (window.location.pathname !== LOGIN_ROUTE.path) {\r\n    window.location.replace(LOGIN_ROUTE.path);\r\n  }\r\n}\r\n```\r\n\r\n> 说明：`useRouter()` 不能在解析器（组件外）调用，上面用 `window.location.replace` 做了上下文无关的重定向。\r\n\r\n---\r\n\r\n## 4) 实例方法：供登出调用（清鉴权头 & 集中取消）\r\n\r\n**位置：`createAxiosHttp` 末尾、`return _axios as unknown as AxiosInstance` 前插入**\r\n\r\n```ts\r\n// 复杂逻辑：向实例挂载工具方法，供外部优雅下线使用\r\n(_axios as any).cancelAll = cancelAll;\r\n(_axios as any).setAuthToken = (token?: string | null, type = \"Bearer\") => {\r\n  if (token) {\r\n    _axios.defaults.headers.common.Authorization = `${type} ${token}`;\r\n    storage.set(ACCESS_TOKEN, token);\r\n    storage.set(TOKEN_TYPE, type);\r\n  } else {\r\n    delete _axios.defaults.headers.common.Authorization;\r\n    storage.remove(ACCESS_TOKEN);\r\n    storage.remove(TOKEN_TYPE);\r\n  }\r\n};\r\n```\r\n\r\n> 这样在 `logout()` 里可以写：`http.cancelAll?.(); http.setAuthToken?.(null)`。\r\n\r\n---\r\n\r\n## 5) （可选）请求方法支持 `formdata` 与 `auth` 透传\r\n\r\n**位置：你重写的 `(_axios as any).request = async function ...` 的**函数签名**与**组装 `cfg`**部分替换为：**\r\n\r\n```ts\r\n// 复杂逻辑：扩展 contentType，支持 formdata；透传 { auth?: boolean, signal?: AbortSignal }\r\n(_axios as any).request = async function <T, P = RequestParams>(\r\n  url: string,\r\n  method: Method = \"GET\",\r\n  params?: P,\r\n  reqCfg?: AxiosRequestConfig & { auth?: boolean; signal?: AbortSignal },\r\n  contentType: \"json\" | \"urlencoded\" | \"formdata\" = \"json\"\r\n): Promise<T> {\r\n  const cfg: AxiosRequestConfig & { auth?: boolean } = {\r\n    url,\r\n    method,\r\n    ...reqCfg,\r\n    headers: { ...reqCfg?.headers },\r\n  };\r\n\r\n  if (method === \"GET\" || method === \"HEAD\") {\r\n    cfg.params = params;\r\n    cfg.paramsSerializer = (d) =>\r\n      qs.stringify(d, { indices: false, skipNulls: true });\r\n  } else {\r\n    // 复杂逻辑：根据 contentType 选择编码方式\r\n    if (contentType === \"formdata\") cfg.data = toFormData(params as any);\r\n    else if (contentType === \"urlencoded\")\r\n      cfg.data = toUrlencoded(params ?? ({} as any));\r\n    else cfg.data = params;\r\n\r\n    if (contentType === \"urlencoded\")\r\n      cfg.headers = {\r\n        ...cfg.headers,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      };\r\n    if (contentType === \"json\")\r\n      cfg.headers = { ...cfg.headers, \"Content-Type\": \"application/json\" };\r\n    // formdata 让浏览器自动带 boundary，不手动设 Content-Type\r\n  }\r\n\r\n  return nativeRequest(cfg) as Promise<T>;\r\n};\r\n```\r\n\r\n> 有了 `{ auth?: boolean }`，你在公开接口（如 `/api/pub/get_feednews`）调用时可以：\r\n\r\n```ts\r\nhttp.request(\"/api/pub/get_feednews\", \"GET\", undefined, { auth: false });\r\n```\r\n\r\n---\r\n\r\n## 6) （配合改动）登出时的两行调用（在你的 `authStore.logout()` 里加）\r\n\r\n```ts\r\n// 复杂逻辑：登出时立即中止所有在途请求 + 清鉴权头\r\nhttp.cancelAll?.();\r\nhttp.setAuthToken?.(null);\r\n```\r\n\r\n---\r\n\r\n## 7) （可选）类型补充，便于在项目里显式写 `auth`\r\n\r\n**新建：`types/axios.d.ts`**\r\n\r\n```ts\r\n// 复杂逻辑：为 AxiosRequestConfig 增加自定义字段 auth\r\nimport \"axios\";\r\ndeclare module \"axios\" {\r\n  interface AxiosRequestConfig {\r\n    auth?: boolean;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 验证 Checklist\r\n\r\n- 退出登录瞬间 Network 面板**无新的业务请求**（只有静态资源预取不算）。\r\n- 任何标记 `{ auth: true | 默认 }` 的请求在**无 Token**时不会发出。\r\n- 后端返回 **HTTP 401** 或 **业务码 401**，都能统一清理并跳到登录页。\r\n- `cancelAll()` 能把“已发起未完成”的请求**立即中断**。\r\n\r\n以上改完，你截图里“跳转后还发请求”的现象就会消失；即使有极短时序触发，也会被 **AbortController** 和 **未登录硬拦**兜住。\r\n",
            "url": "https://example.com/posts/仍有请求与401统一处理）",
            "title": "Axios 封装优化（登出后“仍有请求”与 401 统一处理）",
            "date_modified": "2025-09-05T20:15:05.000Z"
        },
        {
            "id": "https://example.com/posts/体积分布分析图",
            "content_html": "\r\n## 总览\r\n\r\n想在 **Vite + Vue3** 打包后看到类似 Webpack Bundle Analyzer 的交互式“依赖体积分布图”，最简单稳妥的方法是接入 `rollup-plugin-visualizer`。本文给出**最小改动**方案：按需启用分析模式、构建、自动打开 `stats.html`。\r\n\r\n---\r\n\r\n## 实现思路\r\n\r\n- 使用 Rollup 可视化插件（Vite 打包底层是 Rollup）。\r\n- 仅在“分析模式”挂载插件，避免影响日常构建速度。\r\n- 构建完成自动生成并打开 `stats.html`（Treemap/Sunburst 可选）。\r\n- 可选：开启 `sourcemap` 便于二次分析。\r\n\r\n---\r\n\r\n## 分步操作\r\n\r\n### 1）安装依赖\r\n\r\n```bash\r\n# 任选包管理器\r\npnpm add -D rollup-plugin-visualizer\r\n# 或\r\nnpm i -D rollup-plugin-visualizer\r\n# 或\r\nyarn add -D rollup-plugin-visualizer\r\n```\r\n\r\n### 2）修改 `vite.config.ts`（只给需要改的片段）\r\n\r\n> 说明：以下片段为**增量修改**，请在你的 `vite.config.ts` 里按位置插入即可。\r\n\r\n```ts\r\n// ① 顶部新增一行：导入可视化插件\r\nimport { visualizer } from \"rollup-plugin-visualizer\";\r\n```\r\n\r\n```ts\r\n// ② 在 defineConfig 回调里按需启用（若你当前不是回调形式，可改为回调：defineConfig(({ mode }) => ({ ... }))）\r\nconst enableAnalyze = process.env.ANALYZE === \"true\" || mode === \"analyze\";\r\n\r\n// 复杂逻辑：仅在分析模式下挂载插件，避免常规构建受影响\r\nenableAnalyze &&\r\n  plugins.push(\r\n    visualizer({\r\n      // 复杂逻辑：输出 treemap 到项目根目录，并在构建结束自动打开\r\n      filename: \"stats.html\",\r\n      template: \"treemap\", // 可选：'treemap' | 'sunburst' | 'network'\r\n      open: true,\r\n      gzipSize: true,\r\n      brotliSize: true,\r\n    })\r\n  );\r\n```\r\n\r\n```ts\r\n// ③（可选）为了配合二次分析或排查问题，开启源码映射\r\nbuild: {\r\n  // 复杂逻辑：仅在分析模式下开启 sourcemap（若你已有 build 配置，请合并到其中）\r\n  sourcemap: enableAnalyze;\r\n}\r\n```\r\n\r\n> 小贴士：若你的 `plugins` 是直接字面量数组，改成先声明 `const plugins = [vue(/*...*/)]` 再 `.push(...)`，最后 `return { plugins }`。不想改结构也行：`plugins: [vue(), enableAnalyze && visualizer({...})].filter(Boolean)`。\r\n\r\n### 3）新增构建脚本（二选一）\r\n\r\n**方案 A（推荐，跨平台零依赖）：用 `--mode analyze` 触发**\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"build\": \"vite build\",\r\n    \"build:analyze\": \"vite build --mode analyze\"\r\n  }\r\n}\r\n```\r\n\r\n**方案 B：用环境变量触发（类 Unix 系统方便）**\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"build\": \"vite build\",\r\n    // 复杂逻辑：通过环境变量开启分析模式；Windows 可用 cross-env 做兼容\r\n    \"build:analyze\": \"ANALYZE=true vite build\"\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 使用方法\r\n\r\n```bash\r\n# 触发分析构建（使用你选择的方案）\r\npnpm run build:analyze\r\n\r\n# 构建完成后会自动打开 stats.html\r\n# 若未自动打开，可手动在项目根目录双击/用浏览器打开 stats.html\r\n```\r\n\r\n---\r\n\r\n## 进阶玩法（可选）\r\n\r\n### A. 自定义输出位置/图表类型\r\n\r\n```ts\r\n// 复杂逻辑：将报告输出到 dist 目录下并改为 sunburst 风格\r\nvisualizer({\r\n  filename: \"dist/bundle-report.html\",\r\n  template: \"sunburst\",\r\n  open: true,\r\n});\r\n```\r\n\r\n### B. 快速“拆包”以便观察效果\r\n\r\n> 仅示例，按你实际依赖调整：\r\n\r\n```ts\r\n// 复杂逻辑：演示常见手动分包，便于在图里更清晰地区分\r\nbuild: {\r\n  rollupOptions: {\r\n    output: {\r\n      manualChunks: {\r\n        vue: ['vue', 'vue-router', 'pinia'],\r\n        // 如果你用到 Ant Design Vue / ECharts / AntV 等，可分别拆\r\n        // antdv: ['ant-design-vue'],\r\n        // echarts: ['echarts'],\r\n        // antv: ['@antv/g2', '@antv/g2plot'],\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### C. 二次分析（Source Map）\r\n\r\n```bash\r\n# 可选：安装 source-map-explorer 做“按文件”体积分析\r\npnpm add -D source-map-explorer\r\n# 构建（确保 sourcemap 已开启）\r\npnpm run build:analyze\r\n# 生成 HTML 报告（路径按你的 dist 实际文件调整）\r\nnpx source-map-explorer \"dist/assets/*.js\" --html dist/sme.html\r\n```\r\n\r\n---\r\n\r\n## 常见问题\r\n\r\n- **stats.html 是空白/打不开？**\r\n  多半是构建被缓存或浏览器拦截了本地文件。先清理 `dist` 再构建；或换个浏览器打开，必要时关闭浏览器的本地文件限制。\r\n\r\n- **报告没自动打开？**\r\n  CI/无头环境不会自动打开。把 `open: false`，直接到输出目录找报告 HTML 即可。\r\n\r\n- **Windows 下 `ANALYZE=true` 不生效？**\r\n  用方案 A（`--mode analyze`），或安装 `cross-env`：\r\n  `cross-env ANALYZE=true vite build`。\r\n\r\n- **体积异常大但定位不到模块？**\r\n  开启 `sourcemap` 后再看 `stats.html`；若仍不清晰，配合 `source-map-explorer` 交叉验证。\r\n\r\n---\r\n\r\n## 小结\r\n\r\n- 装一个 `rollup-plugin-visualizer`，按需启用分析模式，构建即得可交互分析图。\r\n- 报告默认 `stats.html`，Treemap/Sunburst 随选。\r\n- 需要更深入排查时，打开 `sourcemap` + `source-map-explorer` 双管齐下。\r\n",
            "url": "https://example.com/posts/体积分布分析图",
            "title": "Vite + Vue3 打包后如何查看“体积分布分析图”",
            "date_modified": "2025-09-06T16:59:20.000Z"
        },
        {
            "id": "https://example.com/posts/使用-hexo-在-github-部署个人技术分享",
            "content_html": "\r\n# 整体实现思路\r\n\r\n- **写作方式**：本地写 Markdown（VSCode/Typora），利用 Hexo 生成静态文件。\r\n- **站点能力**：front-matter 实现**分类/标签**；装 `hexo-generator-searchdb` 提供**本地搜索**（纯静态，无后端）。\r\n- **部署方式**：用 **GitHub Actions** 在每次 `push main` 时自动构建，把 `public/` 发布到 **`gh-pages`** 分支；**Pages** 指向该分支即可上线。\r\n- **路径模式**：你当前是**项目页**（仓库名不是 `<用户名>.github.io`），所以站点路径是 `https://<用户名>.github.io/<仓库名>/`，Hexo 里必须设置 `url` 和 `root`。\r\n\r\n---\r\n\r\n# 分步实现过程\r\n\r\n## 1）环境与初始化（已有可跳过）\r\n\r\n```bash\r\nnpm i -g hexo-cli\r\nhexo init blog && cd blog\r\nnpm i\r\nhexo s   # 本地预览 http://localhost:4000\r\n```\r\n\r\n## 2）启用主题与“分类/标签/搜索”\r\n\r\n```bash\r\n# 安装 NexT（已安装可跳过）\r\nnpm i hexo-theme-next\r\n\r\n# 生成分类与标签页面\r\nhexo new page categories\r\nhexo new page tags\r\n```\r\n\r\n在两个索引页文件顶部加 front-matter（**只需新增这几行**）：\r\n\r\n```md\r\n---\r\ntitle: 分类\r\ntype: categories\r\n---\r\n```\r\n\r\n```md\r\n---\r\ntitle: 标签\r\ntype: tags\r\n---\r\n```\r\n\r\n安装本地搜索索引插件（**一次性**）：\r\n\r\n```bash\r\nnpm i hexo-generator-searchdb --save\r\n```\r\n\r\n**站点配置 `_config.yml` 里新增（或确认存在）**：\r\n\r\n```yaml\r\n# 复杂：生成 search.json，供主题读取（静态搜索，无后端）\r\nsearch:\r\n  path: search.json\r\n  field: post\r\n  content: true\r\n```\r\n\r\n**主题配置 `themes/next/_config.yml` 里开启**：\r\n\r\n```yaml\r\n# 复杂：在 NexT 主题中开启本地搜索\r\nlocal_search:\r\n  enable: true\r\n```\r\n\r\n## 3）Hexo 站点路径设置（项目页必改）\r\n\r\n打开根目录的 **`_config.yml`**，**只改这两行**：\r\n\r\n```yaml\r\n# 复杂：GitHub Project Pages 部署在 /blog/ 子路径（用你的用户名和仓库名）\r\nurl: https://<你的GitHub名>.github.io/<你的仓库名>\r\nroot: /<你的仓库名>/\r\n```\r\n\r\n> 你当前仓库是 `herongxhr-netizen/blog`，因此应为：\r\n> `url: https://herongxhr-netizen.github.io/blog` > `root: /blog/`\r\n\r\n## 4）把项目推到 GitHub（已有仓库可跳过初始化）\r\n\r\n```bash\r\ngit init\r\ngit add .\r\ngit commit -m \"init blog\"\r\ngit branch -M master\r\ngit remote add origin https://github.com/<你的GitHub名>/<你的仓库名>.git\r\ngit push -u origin master\r\n```\r\n\r\n## 5）创建自动部署（GitHub Actions）\r\n\r\n在仓库中新建文件 **`.github/workflows/deploy.yml`**，内容如下：\r\n\r\n```yaml\r\n# 复杂：构建 Hexo 并把生成的 public/ 发布到 gh-pages\r\nname: Deploy Hexo to GitHub Pages\r\non:\r\n  push:\r\n    # 注意检查这个分支是否存在，另外还要注意master|main 两种默认主分支\r\n    branches: [master]\r\npermissions:\r\n  contents: write\r\njobs:\r\n  build-deploy:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v4\r\n      - uses: actions/setup-node@v4\r\n        with:\r\n          node-version: 20\r\n      - run: npm i\r\n      - run: npx hexo clean && npx hexo g\r\n      - uses: peaceiris/actions-gh-pages@v3\r\n        with:\r\n          github_token: ${{ secrets.GITHUB_TOKEN }}\r\n          publish_dir: ./public\r\n          publish_branch: gh-pages\r\n```\r\n\r\n> 作用：每次推送到 `master`，自动构建 Hexo 并把 `public/` 发布到 `gh-pages` 分支。\r\n\r\n## 6）打开 GitHub Pages（指向 `gh-pages`）\r\n\r\n仓库 → **Settings → Pages**：\r\n\r\n- **Source** 选 **Deploy from a branch**\r\n- **Branch** 选 **`gh-pages`**，**Folder** 选 **`/(root)`** → Save\r\n  访问：`https://<你的GitHub名>.github.io/<你的仓库名>/`\r\n\r\n## 7）写第一篇/后续文章（固定节奏）\r\n\r\n```bash\r\nhexo new post \"我的第一篇文章\"\r\n# 编辑 source/_posts/我的第一篇文章.md，增加分类/标签 front-matter\r\nhexo s                 # 本地预览确认\r\ngit add . && git commit -m \"post: 第一篇\" && git push\r\n# -> Actions 自动构建 -> Pages 自动更新\r\n```\r\n\r\n## 故障排查（按频率排序）\r\n\r\n1. **页面样式丢失或 404**\r\n\r\n   - 九成是 `_config.yml` 的 `url/root` 不匹配“项目页子路径”。\r\n   - 修复：按上面的两行改好 → `git push` 触发重建。\r\n\r\n2. **推送成功但没自动发布**\r\n\r\n   - 检查 **Actions** 是否执行、是否报“权限不足”。\r\n   - 修复：打开 **Read and write permissions** 或在 workflow 增加 `permissions: contents: write`。\r\n\r\n3. **Pages 仍显示旧内容**\r\n\r\n   - 浏览器缓存或 GitHub Pages 缓存未刷新。\r\n   - 修复：改动任意文件再推一次，或等几分钟刷新。\r\n\r\n4. **找不到搜索框/搜索无结果**\r\n\r\n   - 主题未开启 `local_search.enable` 或站点未生成 `search.json`。\r\n   - 修复：确认两处配置；本地 `hexo clean && hexo g` 看 `public/search.json` 是否存在。\r\n\r\n5. **想改成“用户页”根路径**\r\n\r\n   - 把仓库改名为 `<你的GitHub名>.github.io`；\r\n   - `_config.yml` 改为：\r\n\r\n     ```yaml\r\n     # 复杂：用户页部署在根路径\r\n     url: https://<你的GitHub名>.github.io\r\n     root: /\r\n     ```\r\n\r\n   - Pages 的 Source 仍选 `gh-pages`。\r\n\r\n---\r\n\r\n需要的话，把你当前 `themes/next/_config.yml` 里想开的功能（目录、代码复制、文章 TOC、暗色主题）告诉我；我会**只列需要修改的那几行**，并在复杂行上面加注释。\r\n",
            "url": "https://example.com/posts/使用-hexo-在-github-部署个人技术分享",
            "title": "使用 hexo 在 github 部署个人技术分享",
            "date_modified": "2025-09-04T18:04:44.000Z"
        },
        {
            "id": "https://example.com/posts/动态表单「已勾选仍提示必填」的两处修复",
            "content_html": "\r\n---\r\n\r\ntitle: 动态表单「已勾选仍提示必填」的两处修复\r\ndate: 2025-09-05\r\ntags: \\[Vue3, Ant Design Vue, 表单校验, 组件封装]\r\n\r\n---\r\n\r\n## 问题概述\r\n\r\n复选框（`a-checkbox-group`）在 **必填** 时，即使勾选了第一项仍提示“请选择”。根因有两点：\r\n\r\n1. 你的 `Checkbox` 包装组件把 `v-model:value` **定义成了 boolean**（默认 `false`），而 `a-checkbox-group` 需要 **数组**；\r\n2. 通用的 `required: true` 规则对 **数组长度** 不做判断，需要为复选框补一条“至少选一项”的自定义校验。\r\n\r\n下面给出**最小修改**代码片段（仅展示需要调整的部分）。\r\n\r\n> 说明：按你的偏好，复杂逻辑的代码段我在**上一行加了注释**。\r\n\r\n---\r\n\r\n## 修改 1：`Checkbox` 组件把模型改为数组\r\n\r\n把 `defineModel<boolean>` 改为 **`defineModel<any[]>`**，默认值设为 `[]`，并确保内部状态是数组。\r\n\r\n```ts\r\n// 复杂：CheckboxGroup 期望数组类型；默认值必须为 []，否则 antd 校验无法判定“是否已选择”\r\nconst model = defineModel<any[]>(\"value\", { default: [] });\r\nconst innerValue = ref<any[]>(Array.isArray(model.value) ? model.value : []);\r\n\r\nwatch(model, (v) => (innerValue.value = Array.isArray(v) ? v : []));\r\nwatch(innerValue, (v) => (model.value = Array.isArray(v) ? v : []));\r\n```\r\n\r\n---\r\n\r\n## 修改 2：为复选框补充“至少选一项”的校验规则\r\n\r\n在 `getValidationRules` 中，为 `controlType === 'checkbox'` 增加自定义校验（**在你现有的特殊控件分支里添加一段即可**）。\r\n\r\n```ts\r\n// 复杂：CheckboxGroup 的必填校验——至少选择 1 项\r\n} else if (field.controlType === 'checkbox') {\r\n  rules.push({\r\n    validator: async (_: any, v: any[]) => {\r\n      const ok = Array.isArray(v) && v.length > 0\r\n      if (!ok && field.required)\r\n        return Promise.reject(t('files.form.rule.required', { label: field.label }))\r\n      return Promise.resolve()\r\n    },\r\n    trigger: ['change', 'blur'],\r\n  })\r\n```\r\n\r\n> 放置位置建议：就放在你现有的 `/* 特殊控件校验 */` 分支里，和 `stockholder / image / file` 同级。\r\n\r\n---\r\n\r\n## 可选增强：初始化把错误类型矫正为数组\r\n\r\n若后端历史数据里该字段可能是 `false/null/''/单值`，可以在你已有的 `watch(_fields, ...)` 预处理里顺手矫正为数组，避免初始值导致“已选中但校验失败”。\r\n\r\n```ts\r\n// 复杂：把历史/异常初始值统一矫正为 CheckboxGroup 需要的数组\r\n} else if (f.controlType === 'checkbox') {\r\n  const v = formData[f.name]\r\n  if (!Array.isArray(v)) formData[f.name] = v == null || v === false ? [] : [v]\r\n}\r\n```\r\n\r\n---\r\n\r\n## 结论\r\n\r\n- **关键修复**在于：复选框的 `v-model` 类型必须是 **数组**；\r\n- **规则层面**补充“至少一项”的自定义校验，避免通用 `required` 漏判。\r\n\r\n应用以上两处修改后，勾选第一项即可通过校验，不再提示“请选择”。\r\n",
            "url": "https://example.com/posts/动态表单「已勾选仍提示必填」的两处修复",
            "title": "动态表单「已勾选仍提示必填」的两处修复",
            "date_modified": "2025-09-05T16:22:47.000Z"
        },
        {
            "id": "https://example.com/posts/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）",
            "content_html": "\n---\n\ntitle: 在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）\ndate: 2025-09-07\ntags:\n\n- NestJS\n- Redis\n- ioredis\n- 教程\n  categories:\n- 后端\n  description: 手把手带你在 NestJS 中集成 Redis（基于 ioredis），涵盖安装、配置、Provider、全局模块封装、业务实践（限流/一次性令牌）、Docker、本地调试与常见报错排查。\n\n---\n\n# 目标与适用读者\n\n- 目标：在 **NestJS** 项目中稳定接入 **Redis**，通过 **ioredis** 驱动，提供可复用的 `RedisService`（封装 `set/get/del/incr/expire`、NX 写入等），并支持 **全局模块**、**环境配置**、**本地/生产** 两套部署。\n- 适用：会基本 NestJS 模块/依赖注入的同学；数据库用 TypeORM/Prisma 均可（与本教程无冲突）。\n\n---\n\n# 技术栈选型\n\n- Redis 客户端：**ioredis**（成熟、支持集群/哨兵、TypeScript 友好）。\n- Nest 集成方式：自定义 **Provider + 全局模块**，暴露 `REDIS_CLIENT` 与 `RedisService`。\n- 配置：`.env` 中支持 `REDIS_URL` 或 `REDIS_HOST/PORT/PASSWORD/DB`。\n\n---\n\n# 目录结构（建议）\n\n```\nsrc/\n  common/\n    redis/\n      redis.module.ts       # 全局模块（@Global）\n      redis.service.ts      # 业务友好封装（依赖 REDIS_CLIENT）\n  app.module.ts             # 或各业务模块，引入 RedisModule 一次即可\n```\n\n---\n\n# 第一步：安装依赖\n\n```bash\n# 使用 pnpm（推荐）\npnpm add ioredis\n# 或者 npm\n# npm i ioredis\n```\n\n---\n\n# 第二步：准备环境变量\n\n建议在 `.env`（或 `.env.dev`）中添加 **二选一**：\n\n```ini\n# 方式 A：URL 一行式（含密码与 DB 索引，推荐）\nREDIS_URL=redis://:password@localhost:6379/0\n\n# 方式 B：分散式\nREDIS_HOST=127.0.0.1\nREDIS_PORT=6379\nREDIS_PASSWORD=\nREDIS_DB=0\n```\n\n---\n\n# 第三步：编写 `RedisService`\n\n> 放在 `src/common/redis/redis.service.ts`\n> 命名**清晰可读**，复杂逻辑上方有中文注释。\n\n```ts\nimport { Injectable, Inject } from \"@nestjs/common\";\nimport type { Redis } from \"ioredis\";\n\n// 复杂：作为底层连接的注入令牌；项目全局唯一\nexport const REDIS_CLIENT = \"REDIS_CLIENT\";\n\n@Injectable()\nexport class RedisService {\n  constructor(@Inject(REDIS_CLIENT) private readonly redisClient: Redis) {}\n\n  // 复杂：统一封装写入并设置过期时间，便于存挑战/一次性令牌\n  async setWithTimeToLive(\n    key: string,\n    value: string,\n    timeToLiveSeconds = 300\n  ): Promise<void> {\n    await this.redisClient.set(key, value, \"EX\", timeToLiveSeconds);\n  }\n\n  async getValue(key: string): Promise<string | null> {\n    return this.redisClient.get(key);\n  }\n\n  async deleteKey(key: string): Promise<void> {\n    await this.redisClient.del(key);\n  }\n\n  // 复杂：自增计数用于限流（第一次返回 1）\n  async incrementKey(key: string): Promise<number> {\n    return this.redisClient.incr(key);\n  }\n\n  // 复杂：给键设置过期时间，配合 incrementKey 实现简单窗口限流\n  async expireKey(key: string, seconds: number): Promise<void> {\n    await this.redisClient.expire(key, seconds);\n  }\n\n  // 复杂：仅当键不存在时写入并设置 TTL（一次性令牌/幂等防重放）\n  async setIfAbsentWithTimeToLive(\n    key: string,\n    value: string,\n    timeToLiveSeconds: number\n  ): Promise<boolean> {\n    // 复杂：NX 确保不存在才写入；避免并发下的重复写入\n    const result = await this.redisClient.set(\n      key,\n      value,\n      \"NX\",\n      \"EX\",\n      timeToLiveSeconds\n    );\n    return result === \"OK\";\n  }\n}\n```\n\n---\n\n# 第四步：编写 `RedisModule`（全局模块，一次引入处处可用）\n\n> 放在 `src/common/redis/redis.module.ts`，标记 `@Global()`，自动对全局开放。\n\n```ts\nimport { Global, Module } from \"@nestjs/common\";\nimport * as IORedis from \"ioredis\";\nimport { RedisService, REDIS_CLIENT } from \"./redis.service\";\n\n@Global()\n@Module({\n  providers: [\n    {\n      provide: REDIS_CLIENT,\n      // 复杂：通过工厂读取 .env，创建 ioredis 客户端\n      useFactory: () => {\n        const url = process.env.REDIS_URL;\n        const host = process.env.REDIS_HOST ?? \"127.0.0.1\";\n        const port = parseInt(process.env.REDIS_PORT ?? \"6379\", 10);\n        const password = process.env.REDIS_PASSWORD || undefined;\n        const db = parseInt(process.env.REDIS_DB ?? \"0\", 10);\n\n        const client: IORedis.Redis = url\n          ? new (IORedis as any)(url)\n          : new (IORedis as any)({ host, port, password, db });\n\n        // 复杂：记录连接错误，便于排查\n        client.on(\"error\", (err: any) => {\n          // eslint-disable-next-line no-console\n          console.error(\"[Redis] connection error:\", err?.message || err);\n        });\n\n        return client;\n      },\n    },\n    RedisService,\n  ],\n  exports: [REDIS_CLIENT, RedisService],\n})\nexport class RedisModule {}\n```\n\n---\n\n# 第五步：在应用中引入 `RedisModule`\n\n> 只需在**任意一个模块**引入一次（例如 `AppModule`），因为它是 `@Global()`。\n\n```ts\n// src/app.module.ts（或你任一根模块）\nimport { Module } from \"@nestjs/common\";\nimport { ConfigModule } from \"@nestjs/config\";\nimport { RedisModule } from \"./common/redis/redis.module\";\nimport { AppController } from \"./app.controller\";\nimport { AppService } from \"./app.service\";\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    RedisModule, // 复杂：全局模块，仅需引入一次\n    // ... 你的其它模块\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n---\n\n# 第六步：业务中使用示例\n\n### 6.1 限流（每分钟最多 10 次）\n\n```ts\nimport { Injectable, TooManyRequestsException } from \"@nestjs/common\";\nimport { RedisService } from \"src/common/redis/redis.service\";\n\n@Injectable()\nexport class LoginService {\n  constructor(private readonly redisService: RedisService) {}\n\n  // 复杂：按 IP 做 60 秒/10 次 限流\n  async limitByIp(ipAddress: string) {\n    const rateLimitKey = `rl:login:${ipAddress}`;\n    const currentCount = await this.redisService.incrementKey(rateLimitKey);\n    if (currentCount === 1) {\n      await this.redisService.expireKey(rateLimitKey, 60);\n    }\n    if (currentCount > 10) {\n      throw new TooManyRequestsException(\"请求过于频繁，请稍后再试\");\n    }\n  }\n}\n```\n\n### 6.2 一次性令牌（幂等/防重放）\n\n```ts\n// 复杂：仅当 key 不存在时写入，5 分钟有效\nconst ok = await this.redisService.setIfAbsentWithTimeToLive(\n  `once:${token}`,\n  \"1\",\n  300\n);\nif (!ok) {\n  throw new Error(\"令牌已使用或失效\");\n}\n```\n\n### 6.3 短期会话/挑战值（例如 WebAuthn）\n\n```ts\nawait this.redisService.setWithTimeToLive(\n  `webauthn:register:${userId}`,\n  challengeBase64Url,\n  300\n);\nconst cached = await this.redisService.getValue(`webauthn:register:${userId}`);\n// ... 验证后删除\nawait this.redisService.deleteKey(`webauthn:register:${userId}`);\n```\n\n---\n\n# 第七步：Docker Compose（本地起 Redis）\n\n> `docker-compose.yml`（项目根目录）\n\n```yaml\nversion: \"3.9\"\nservices:\n  redis:\n    image: redis:7-alpine\n    container_name: demo-redis\n    ports:\n      - \"6379:6379\"\n    command: [\"redis-server\", \"--appendonly\", \"yes\"]\n    volumes:\n      - redis-data:/data\nvolumes:\n  redis-data:\n```\n\n启动：\n\n```bash\ndocker compose up -d\n# .env 示例\n# REDIS_URL=redis://localhost:6379\n```\n\n---\n\n# 第八步：生产环境注意事项\n\n- **连接池与超时**：ioredis 默认复用单连接；高并发可根据需要创建多个客户端或使用 `cluster`/`sentinel`。\n- **密码与 ACL**：生产务必启用密码或 ACL；不要暴露无鉴权实例。\n- **键名规范**：`<领域>:<用途>:<实体>`（如 `webauthn:auth:ch:<challenge>`），可读性与清理都更好。\n- **TTL 策略**：短期挑战/令牌务必设置 TTL，并在验证后删除，避免重放。\n- **监控**：监控 `connected clients`、`keyspace hits/misses`、`latency`；必要时加慢日志。\n- **持久化**：默认 RDB；根据业务考虑 AOF（`appendonly yes`）与混合持久化。\n\n---\n\n# 第九步：常见报错与排查\n\n- **Nest can't resolve dependencies of the RedisService (REDIS_CLIENT)**\n  说明：未注册 `REDIS_CLIENT` Provider。\n  解决：确保 `RedisModule`（或 `AppModule` 的 `providers`）里 **provide: REDIS_CLIENT** 已配置，并且模块被应用引入。\n- **ECONNREFUSED / getaddrinfo ENOTFOUND**\n  说明：Redis 未启动或地址错误。\n  解决：检查 `REDIS_URL/REDIS_HOST/REDIS_PORT`，本地起容器或服务端口是否 6379。\n- **WRONGPASS invalid username-password pair**\n  说明：密码有误或未配置。\n  解决：核对 `REDIS_URL` 中 `:password@` 或 `REDIS_PASSWORD`。\n- **Ready check failed**\n  说明：网络/权限/ACL 问题或连接尚未可用。\n  解决：检查安全组/防火墙；对云服务需配置白名单。\n\n---\n\n# 第十步：单元测试（Mock Redis）\n\n> 不在测试中连真实 Redis，可用 `ioredis-mock` 或手写假对象。\n\n```ts\nimport { Test } from \"@nestjs/testing\";\nimport { RedisService, REDIS_CLIENT } from \"src/common/redis/redis.service\";\n\ndescribe(\"RedisService\", () => {\n  it(\"set/get works\", async () => {\n    // 复杂：用最小可用的假客户端满足接口\n    const fakeClient = {\n      storage: new Map<string, string>(),\n      set: function (k: string, v: string) {\n        this.storage.set(k, v);\n        return Promise.resolve(\"OK\");\n      },\n      get: function (k: string) {\n        return Promise.resolve(this.storage.get(k) ?? null);\n      },\n      del: function (k: string) {\n        this.storage.delete(k);\n        return Promise.resolve();\n      },\n      incr: function (k: string) {\n        const next = Number(this.storage.get(k) ?? \"0\") + 1;\n        this.storage.set(k, String(next));\n        return Promise.resolve(next);\n      },\n      expire: function () {\n        return Promise.resolve();\n      },\n    } as any;\n\n    const moduleRef = await Test.createTestingModule({\n      providers: [\n        { provide: REDIS_CLIENT, useValue: fakeClient },\n        RedisService,\n      ],\n    }).compile();\n\n    const redis = moduleRef.get(RedisService);\n    await redis.setWithTimeToLive(\"foo\", \"bar\", 60);\n    expect(await redis.getValue(\"foo\")).toBe(\"bar\");\n  });\n});\n```\n\n---\n\n# 结语\n\n至此，你已经完成了 **NestJS × Redis（ioredis）** 的完整接入：\n\n- 全局模块提供底层连接与服务封装；\n- 业务中可轻松完成 **限流**、**一次性令牌**、**短期会话/挑战** 等高频需求；\n- 本地用 Docker 起 Redis，生产注意密码、ACL、监控与 TTL 策略。\n\n需要我把你的现有项目改造为 **全局 `RedisModule` 方案** 或 **在 `AppModule` 直接注册 Provider** 的最小改动 **完整文件**，就把相关文件发我（或让我复用你上面的 `AppModule` 路径）。\n",
            "url": "https://example.com/posts/在-NestJS-中引入-Redis——从-0-到可用（ioredis-版）",
            "title": "在 NestJS 中引入 Redis——从 0 到可用（ioredis 版）",
            "date_modified": "2025-09-07T20:40:23.000Z"
        },
        {
            "id": "https://example.com/posts/显式覆盖",
            "content_html": "\r\n## 结论（一句话）\r\n\r\n**不要维护 `noAuthPaths` 白名单数组。**\r\n大厂常用是**约定式路径前缀**（如 `/api/pub/**` 全部公开，其余默认鉴权）+ **显式 `auth:false` 覆盖**个别特殊接口（如登录/注册）。必要时再做**双实例**（`authHttp`/`pubHttp`）隔离。\r\n\r\n## 你只需做的最小改动（片段）\r\n\r\n### 1) 用“前缀约定”替换白名单数组\r\n\r\n> 复杂逻辑：将“是否需要鉴权”收敛为**实例级默认值** + **URL 前缀** + **每次请求的显式覆盖**。\r\n\r\n**删除：**\r\n\r\n```ts\r\n// 删除这行\r\nconst noAuthPaths = [\r\n  \"/login\",\r\n  \"/register\",\r\n  \"/public-endpoint\",\r\n  \"/api/pub/get_feednews\",\r\n];\r\n```\r\n\r\n**在 `createAxiosHttp` 定义处新增第二个参数（不改已有调用方也能有默认值）：**\r\n\r\n```ts\r\n// 复杂逻辑：通过 opts 控制默认鉴权与公开前缀\r\nfunction createAxiosHttp(\r\n  config: AxiosRequestConfig,\r\n  opts: { authDefault?: boolean; publicPrefixes?: string[] } = {},\r\n) {\r\n  const authDefault = opts.authDefault ?? true\r\n  const publicPrefixes = opts.publicPrefixes ?? ['/api/pub']  // 仅维护“前缀”，而非逐个接口\r\n  // ...\r\n```\r\n\r\n**在请求拦截器里替换 needAuth 判定：**\r\n\r\n```ts\r\n_axios.interceptors.request.use((req) => {\r\n  // ...（保留你已有的 AbortController 代码）\r\n\r\n  // 复杂逻辑：先按前缀判定是否公开，再由显式 req.auth 覆盖\r\n  const url = req.url || \"\";\r\n  const isPublicByPrefix = publicPrefixes.some((p) => url.startsWith(p));\r\n\r\n  // 复杂逻辑：优先使用 req.auth（true/false），否则用实例默认值 + 前缀约定\r\n  const needAuth = (req as any).auth ?? (authDefault && !isPublicByPrefix);\r\n\r\n  const accToken = storage.get(ACCESS_TOKEN);\r\n  const tokenType = storage.get(TOKEN_TYPE) || \"Bearer\";\r\n  if (needAuth && !accToken) {\r\n    ((req as any).__abortController as AbortController | undefined)?.abort();\r\n    return Promise.reject(new Error(\"UNAUTHENTICATED\"));\r\n  }\r\n  if (needAuth && accToken) {\r\n    req.headers = { ...req.headers, Authorization: `${tokenType} ${accToken}` };\r\n  }\r\n  return req;\r\n});\r\n```\r\n\r\n**创建实例时传入前缀约定（一次配置，全局生效）：**\r\n\r\n```ts\r\n// 复杂逻辑：默认需要鉴权，唯独 /api/pub/** 前缀走公开\r\nconst http = createAxiosHttp(\r\n  {\r\n    timeout: 10000,\r\n    baseURL: API_BASE,\r\n    withCredentials: true,\r\n    xsrfCookieName: \"Authorization\",\r\n    xsrfHeaderName: \"Authorization\",\r\n  },\r\n  { authDefault: true, publicPrefixes: [\"/api/pub\"] }\r\n);\r\n```\r\n\r\n### 2) 显式覆盖个别公开接口（例如登录/注册）\r\n\r\n> 复杂逻辑：无需继续维护数组；在调用时给 `{ auth:false }`。\r\n\r\n```ts\r\n// 复杂逻辑：显式声明无需鉴权\r\nhttp.request(\"/auth/login\", \"POST\", body, { auth: false });\r\nhttp.request(\"/auth/register\", \"POST\", body, { auth: false });\r\n```\r\n\r\n### 3) 小修 bug：统一释放键，避免内存泄露\r\n\r\n> 你在请求里写的是 `__abortController`，但错误拦截里读取的是 `__ac`。统一成同一个键。\r\n\r\n**在错误拦截器里替换：**\r\n\r\n```ts\r\n// 复杂逻辑：统一用 __abortController\r\nconst abortController = (err?.config as any)?.__abortController as\r\n  | AbortController\r\n  | undefined;\r\nif (abortController) abortPool.delete(abortController);\r\n```\r\n\r\n---\r\n\r\n## 为什么这是“更像大厂”的做法\r\n\r\n- **约定 > 配置**：接口分层（`/api/pub/**` 公开，其他默认鉴权）是**稳定、低维护**的组织方式；新增公开接口只需放在该前缀下。\r\n- **按需覆盖**：极少数“路径不在公开前缀但仍需公开”的接口，用 `auth:false` **显式声明**，可读性强。\r\n- **可扩展**：未来要拆网关/多后端时，可用**双实例**进一步隔离（见下方“进阶”）。\r\n- **类型友好**：`AxiosRequestConfig` 扩展 `auth?: boolean`，IDE 自动提示，避免遗漏。\r\n\r\n---\r\n\r\n## 进阶可选（按需采纳）\r\n\r\n### 方案 B：双实例隔离（最常见于中大型前端）\r\n\r\n> 公有与鉴权接口**不同实例**，互不影响，拦截器更简单。\r\n\r\n```ts\r\n// 复杂逻辑：一个实例默认鉴权，一个实例默认公开\r\nexport const authHttp = createAxiosHttp(config, {\r\n  authDefault: true,\r\n  publicPrefixes: [],\r\n});\r\nexport const pubHttp = createAxiosHttp(config, {\r\n  authDefault: false,\r\n  publicPrefixes: [\"/api/pub\"],\r\n});\r\n\r\n// 使用时不再传 auth:false\r\npubHttp.request(\"/api/pub/get_feednews\", \"GET\");\r\nauthHttp.request(\"/api/secure/profile\", \"GET\");\r\n```\r\n\r\n### 方案 C：API 分层封装（类型安全）\r\n\r\n> 给每个后端接口包一层函数：在函数里固定 `auth:true/false`，业务层不再关心 `auth`。\r\n\r\n```ts\r\n// 复杂逻辑：在 API 层固定鉴权语义\r\nexport const Api = {\r\n  getFeedNews: () =>\r\n    http.request<Feed[]>(\"/api/pub/get_feednews\", \"GET\", undefined, {\r\n      auth: false,\r\n    }),\r\n  getProfile: () => http.request<Profile>(\"/api/secure/profile\", \"GET\"), // 默认为鉴权\r\n};\r\n```\r\n\r\n---\r\n\r\n## 小结\r\n\r\n- **最佳实践**：**前缀约定 + 显式覆盖**，别再维护接口白名单数组。\r\n- 这样新增公开接口只要放到 `/api/pub/**`，其余默认鉴权；个别例外 `auth:false` 即可。\r\n- 若项目更复杂，进一步采用**双实例**或**API 分层**，把鉴权语义固化到“调用入口”，彻底杜绝分散判断。\r\n",
            "url": "https://example.com/posts/显式覆盖",
            "title": "鉴权判定“最佳实践”：别维护白名单数组，用“前缀约定 + 显式覆盖”",
            "date_modified": "2025-09-05T21:13:27.000Z"
        },
        {
            "id": "https://example.com/posts/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）",
            "content_html": "\r\n---\r\n\r\ntitle: 最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）\r\ndate: 2025-09-06\r\ntags:\r\n\r\n- TanStack Query\r\n- React Query\r\n- Next.js 14\r\n- TypeScript\r\n\r\n---\r\n\r\n## 目标\r\n\r\n在**不改动你现有 http 封装**（`http.call` + `api/modules/price.ts`）前提下，最小成本接入 TanStack Query，用于价格趋势这类“读多写少”的数据获取与缓存。\r\n\r\n---\r\n\r\n## 步骤总览\r\n\r\n1. 安装依赖\r\n2. 新增 `QueryProvider` 并在 `app/layout.tsx` 注入\r\n3. 写一个最小的 `usePriceTrend` 查询 Hook\r\n4. 在一个客户端组件里调用展示\r\n\r\n> 说明：只给**新增/变更**的文件内容；复杂逻辑在上一行加注释。\r\n\r\n---\r\n\r\n## 1) 安装\r\n\r\n```bash\r\npnpm add @tanstack/react-query\r\n# 可选：开发工具\r\npnpm add -D @tanstack/react-query-devtools\r\n```\r\n\r\n---\r\n\r\n## 2) Provider：在全局注入 QueryClient\r\n\r\n**新增：`src/lib/query/QueryProvider.tsx`**\r\n\r\n```tsx\r\n\"use client\";\r\n\r\nimport { PropsWithChildren, useState } from \"react\";\r\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\r\n// 可选：开发时打开\r\n// import { ReactQueryDevtools } from '@tanstack/react-query-devtools'\r\n\r\nexport default function QueryProvider({ children }: PropsWithChildren) {\r\n  // 复杂逻辑上一行注释：用 useState 确保在客户端持久化一个 QueryClient 单例\r\n  const [client] = useState(\r\n    () =>\r\n      new QueryClient({\r\n        defaultOptions: {\r\n          queries: {\r\n            // 复杂逻辑上一行注释：避免频繁重复请求，数据 5 分钟内视为新鲜\r\n            staleTime: 5 * 60 * 1000,\r\n            // 复杂逻辑上一行注释：失败最多重试 2 次，指数退避\r\n            retry: 2,\r\n            refetchOnWindowFocus: false,\r\n          },\r\n        },\r\n      })\r\n  );\r\n\r\n  return (\r\n    <QueryClientProvider client={client}>\r\n      {children}\r\n      {/* <ReactQueryDevtools initialIsOpen={false} /> */}\r\n    </QueryClientProvider>\r\n  );\r\n}\r\n```\r\n\r\n**修改：`src/app/layout.tsx`（只贴需要插入的代码）**\r\n\r\n```tsx\r\n// ➊ 新增这一行\r\nimport QueryProvider from \"@/lib/query/QueryProvider\";\r\n\r\n// ... 省略你的现有代码\r\nexport default function RootLayout({\r\n  children,\r\n}: {\r\n  children: React.ReactNode;\r\n}) {\r\n  return (\r\n    <html lang=\"zh-CN\">\r\n      <body>\r\n        {/* ➋ 用 Provider 包裹全局 */}\r\n        <QueryProvider>{children}</QueryProvider>\r\n      </body>\r\n    </html>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n## 3) 查询 Hook：封装价格趋势获取\r\n\r\n**新增：`src/features/price-trend/queries.ts`**\r\n\r\n```ts\r\n\"use client\";\r\n\r\nimport { useQuery } from \"@tanstack/react-query\";\r\nimport { priceApi } from \"@/api/modules/price\";\r\n\r\n// 复杂逻辑上一行注释：以业务语义定义查询 Hook，统一 queryKey 与调用的 API 函数\r\nexport function usePriceTrend(gameId: string, stores: string[]) {\r\n  return useQuery({\r\n    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参\r\n    queryKey: [\"priceTrend\", gameId, stores],\r\n    // 复杂逻辑上一行注释：交给领域 API，返回 Promise<any>\r\n    queryFn: () => priceApi.getTrend({ gameId, stores }),\r\n    // 复杂逻辑上一行注释：没有必要参数时不发起请求\r\n    enabled: Boolean(gameId) && stores.length > 0,\r\n    // 可选：覆盖全局默认值\r\n    staleTime: 5 * 60 * 1000,\r\n    gcTime: 60 * 60 * 1000,\r\n  });\r\n}\r\n```\r\n\r\n> 你之前已经有 `priceApi.getTrend`，这里直接复用即可。\r\n\r\n---\r\n\r\n## 4) 页面示例：客户端组件中使用\r\n\r\n**新增：`src/app/price-trend-demo/page.tsx`（最小可跑 Demo 页）**\r\n\r\n```tsx\r\n\"use client\";\r\n\r\nimport { useState } from \"react\";\r\nimport { usePriceTrend } from \"@/features/price-trend/queries\";\r\n\r\nexport default function PriceTrendDemoPage() {\r\n  const [gameId, setGameId] = useState(\"wukong\");\r\n  const [stores, setStores] = useState<string[]>([\"Steam\", \"Epic\"]);\r\n\r\n  const { data, isLoading, error, refetch } = usePriceTrend(gameId, stores);\r\n\r\n  return (\r\n    <div className=\"p-4 space-y-3\">\r\n      <div className=\"flex gap-2 items-center\">\r\n        <input\r\n          value={gameId}\r\n          onChange={(e) => setGameId(e.target.value)}\r\n          placeholder=\"gameId\"\r\n          className=\"border px-2 py-1 rounded\"\r\n        />\r\n        <button\r\n          // 复杂逻辑上一行注释：演示手动刷新（一般可不需要，TanStack 会按策略自动刷新）\r\n          onClick={() => refetch()}\r\n          className=\"px-3 py-1 rounded border\"\r\n        >\r\n          Refresh\r\n        </button>\r\n      </div>\r\n\r\n      {isLoading && <div>加载中...</div>}\r\n      {error && (\r\n        <div className=\"text-red-600\">出错了：{(error as any)?.message}</div>\r\n      )}\r\n\r\n      <pre className=\"bg-gray-100 p-3 rounded text-sm overflow-auto\">\r\n        {JSON.stringify(data, null, 2)}\r\n      </pre>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n> 想接上图表时，把 `data` 交给你的图表组件即可；后续可以把 `stores` 做成可搜索多选，与你主页筛选一致。\r\n\r\n---\r\n\r\n## 可选：SSR 预取（以后再加）\r\n\r\n最小集成里我们**不做 SSR**，直接用客户端渲染即可；若将来需要 SSR/Hydration，可用 `@tanstack/react-query` 的 `dehydrate/hydrate` 在 Server Component 里预取数据、在 Client 端复水。等你需要时我再给“最小 SSR 版本”的差异补丁即可。\r\n\r\n下面给你**Vue 3 最小可用示例**（基于 `@tanstack/vue-query`，不改你的 http 封装与 `priceApi`）。只包含**必要的新文件/改动**；复杂逻辑已在上一行加注释。\r\n\r\n---\r\n\r\n### 1) 安装\r\n\r\n```bash\r\npnpm add @tanstack/vue-query\r\n# 可选：开发工具\r\npnpm add -D @tanstack/vue-query-devtools\r\n```\r\n\r\n---\r\n\r\n### 2) 全局注册 Vue Query 插件\r\n\r\n**新增：`src/plugins/vue-query.ts`**\r\n\r\n```ts\r\n// 复杂逻辑上一行注释：创建全局 QueryClient，设定默认缓存/重试策略\r\nimport {\r\n  QueryClient,\r\n  VueQueryPlugin,\r\n  type VueQueryPluginOptions,\r\n} from \"@tanstack/vue-query\";\r\n\r\nexport const queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      // 复杂逻辑上一行注释：5 分钟内视为新鲜，避免频繁请求\r\n      staleTime: 5 * 60 * 1000,\r\n      // 复杂逻辑上一行注释：失败自动重试 2 次，指数退避\r\n      retry: 2,\r\n      // 聚焦窗口时不强制刷新（按需可改为 true）\r\n      refetchOnWindowFocus: false,\r\n    },\r\n  },\r\n});\r\n\r\nexport function installVueQuery(app: import(\"vue\").App) {\r\n  const options: VueQueryPluginOptions = { queryClient };\r\n  app.use(VueQueryPlugin, options);\r\n  // 可选：开发工具\r\n  // if (import.meta.env.DEV) {\r\n  //   const { VueQueryDevtools } = await import('@tanstack/vue-query-devtools')\r\n  //   app.use(VueQueryDevtools, { initialIsOpen: false })\r\n  // }\r\n}\r\n```\r\n\r\n**修改：`src/main.ts`（只贴需要新增的行）**\r\n\r\n```ts\r\nimport { createApp } from \"vue\";\r\nimport App from \"./App.vue\";\r\n\r\n// + 新增：注册 Vue Query 插件\r\nimport { installVueQuery } from \"@/plugins/vue-query\";\r\n\r\nconst app = createApp(App);\r\ninstallVueQuery(app);\r\napp.mount(\"#app\");\r\n```\r\n\r\n---\r\n\r\n### 3) 查询 Hook（Composable）\r\n\r\n**新增：`src/features/price-trend/usePriceTrend.ts`**\r\n\r\n```ts\r\n// 复杂逻辑上一行注释：以业务语义封装 useQuery，统一 queryKey 与调用的 API\r\nimport { useQuery } from \"@tanstack/vue-query\";\r\nimport { priceApi } from \"@/api/modules/price\";\r\n\r\nexport function usePriceTrend(gameId: string, stores: string[]) {\r\n  return useQuery({\r\n    // 复杂逻辑上一行注释：queryKey 决定缓存命中；包含关键入参\r\n    queryKey: [\"priceTrend\", gameId, stores],\r\n    // 复杂逻辑上一行注释：交给领域 API，返回 Promise\r\n    queryFn: () => priceApi.getTrend({ gameId, stores }),\r\n    // 复杂逻辑上一行注释：参数不全时不发起请求\r\n    enabled: Boolean(gameId) && stores.length > 0,\r\n    // 可选：覆盖默认策略\r\n    staleTime: 5 * 60 * 1000,\r\n    gcTime: 60 * 60 * 1000,\r\n  });\r\n}\r\n```\r\n\r\n> 这里直接复用你已有的 `priceApi.getTrend`（基于 `http.call`）。\r\n\r\n---\r\n\r\n### 4) 最小页面示例（组件中使用）\r\n\r\n**新增：`src/views/PriceTrendDemo.vue`**\r\n\r\n```vue\r\n<script setup lang=\"ts\">\r\nimport { ref } from \"vue\";\r\nimport { usePriceTrend } from \"@/features/price-trend/usePriceTrend\";\r\n\r\nconst gameId = ref(\"wukong\");\r\nconst stores = ref<string[]>([\"Steam\", \"Epic\"]);\r\n\r\nconst { data, isLoading, error, refetch } = usePriceTrend(\r\n  gameId.value,\r\n  stores.value\r\n);\r\n</script>\r\n\r\n<template>\r\n  <div class=\"p-4 space-y-3\">\r\n    <div class=\"flex gap-2 items-center\">\r\n      <input\r\n        v-model=\"gameId\"\r\n        placeholder=\"gameId\"\r\n        class=\"border px-2 py-1 rounded\"\r\n      />\r\n      <button class=\"px-3 py-1 rounded border\" @click=\"refetch()\">\r\n        Refresh\r\n      </button>\r\n    </div>\r\n\r\n    <div v-if=\"isLoading\">加载中...</div>\r\n    <div v-else-if=\"error\" class=\"text-red-600\">\r\n      出错了：{{ (error as any)?.message }}\r\n    </div>\r\n\r\n    <pre class=\"bg-gray-100 p-3 rounded text-sm overflow-auto\"\r\n      >{{ JSON.stringify(data ?? null, null, 2) }}\r\n    </pre>\r\n  </div>\r\n</template>\r\n```\r\n\r\n> 路由按你的项目来：例如在 `vue-router` 里把该组件挂到 `/price-trend-demo`。\r\n\r\n---\r\n\r\n#### 可选：当 `gameId/stores` 在页面中会变更时\r\n\r\n把 `usePriceTrend(gameId.value, stores.value)` 改成**侦听式**：\r\n\r\n```ts\r\nconst { data, isLoading, error, refetch } = usePriceTrend(\r\n  // 复杂逻辑上一行注释：传入原始值即可；依赖变化时 useQuery 会按 key 缓存/重取\r\n  gameId.value,\r\n  stores.value\r\n);\r\n```\r\n\r\n若你希望**自动**随着 `gameId/stores` 的变更而刷新，可在外层 `watch([gameId, stores], refetch)`；不过通常让 `queryKey` 变化即可自动生效（会根据 key 命中缓存或重新请求）。\r\n\r\n---\r\n\r\n### 5) 与你现有封装的关系\r\n\r\n- **无需修改** `http.call` / `client.ts` / `cancel.ts`；Vue Query 只是把“请求何时发起、如何缓存/重试/并发合并”的**状态机**托管出去。\r\n- 其他简单页面仍可直接用 `http.get/post` 或 `http.call`。把 **“读多写少、复用度高”的接口**（比如价格趋势、列表）逐步迁到 Vue Query 即可，**按需引入**、零破坏。\r\n\r\n如果你需要 **SSR（Nuxt 3）** 的最小示例或 **分页/无限滚动** 的 Query 示例，我也可以在此基础上给出只含必要代码的增量补丁。\r\n",
            "url": "https://example.com/posts/最小可用的-TanStack-Query-集成（Next-js-14-·-App-Router-·-TS）",
            "title": "最小可用的 TanStack Query 集成（Next.js 14 · App Router · TS）",
            "date_modified": "2025-09-06T14:41:39.000Z"
        },
        {
            "id": "https://example.com/posts/登录后初始化的双阶段启动（增量修改）",
            "content_html": "\r\n## 思路\r\n\r\n- 把**不需要登录**的请求抽成“公共初始化（public bootstrap）”，在应用进入时就触发（只触发一次）。\r\n- 把**需要登录**且**命中鉴权路由**时才需要的数据，保留在你现有的 `watch` 分支里，但也确保只跑一次。\r\n- 用**模块级 once 标记**避免多组件重复调用；必要时可加 `online` 事件进行弱网重试（可选）。\r\n\r\n---\r\n\r\n## 需要调整的代码（仅片段）\r\n\r\n> 放在你这个 composable 文件里，**按位置插入**即可；复杂逻辑我已在上一行加中文注释。\r\n\r\n### 1）导入（在文件顶部补充）\r\n\r\n```ts\r\n// 复杂逻辑：公私两段初始化需要生命周期/事件\r\nimport { watch, onMounted } from \"vue\";\r\n```\r\n\r\n### 2）模块级 once 标记（在文件顶部、`export function useAppBootstrap` 外面）\r\n\r\n```ts\r\n// 复杂逻辑：模块级“只执行一次”标记，防止多组件重复初始化\r\nlet __BOOT_PUBLIC_ONCE__ = false;\r\nlet __BOOT_PRIVATE_ONCE__ = false;\r\n```\r\n\r\n### 3）在 `useAppBootstrap` 内部新增“公共初始化”方法与调用（建议贴在你定义完各个 store 之后）\r\n\r\n```ts\r\n// 复杂逻辑：公共初始化——无需登录的数据，进入站点即预取，且只执行一次\r\nconst bootstrapPublic = async () => {\r\n  if (__BOOT_PUBLIC_ONCE__) return;\r\n  __BOOT_PUBLIC_ONCE__ = true;\r\n\r\n  await Promise.all([\r\n    // ⬇️ 把“无需 token 的初始化”放这里；按你项目实际取舍\r\n    country.init().catch(() => {}),\r\n    exchange.init({ keyword: \"\" }).catch(() => {}),\r\n    marketCalendar.init().catch(() => {}),\r\n    // 如果 server.init() 不依赖用户态，也可放到公共初始化\r\n    server.init().catch(() => {}),\r\n    // …你还有其它完全公开的数据，也可加进来\r\n  ]);\r\n};\r\n```\r\n\r\n```ts\r\n// 复杂逻辑：进入应用即触发公共初始化（SSR/CSR 兼容性考虑，放到 onMounted 最稳妥）\r\nonMounted(() => {\r\n  bootstrapPublic();\r\n});\r\n```\r\n\r\n### 4）给你原来的 `watch` 回调加“私有初始化只跑一次”的保护\r\n\r\n```ts\r\n// 复杂逻辑：仅在“已登录 && 路由需要鉴权 && 未跑过私有初始化”时执行\r\nif (ok && need && !__BOOT_PRIVATE_ONCE__) {\r\n  __BOOT_PRIVATE_ONCE__ = true;\r\n  await Promise.all([\r\n    user.fetchUserInfo().catch(() => {}),\r\n    account.init({ withCategory: true, withExternal: true }).catch(() => {}),\r\n    leverage.init().catch(() => {}),\r\n    accountCurrency.init().catch(() => {}),\r\n    externalServer.init().catch(() => {}),\r\n    payChannel.init({ opt_type: \"deposit\" }).catch(() => {}),\r\n    verifyStore.initVerifyInfo().catch(() => {}),\r\n    inviteStore.getInviteGroupOptions().catch(() => {}),\r\n    // ⚠️ server.init()/country/exchange/marketCalendar 已在公共初始化里跑过的可移除，避免重复\r\n  ]);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 可选增强\r\n\r\n### A. 弱网场景“上线即补跑”\r\n\r\n```ts\r\n// 复杂逻辑：若用户初次进入时离线，恢复网络后自动补跑公共初始化（最多触发一次）\r\nonMounted(() => {\r\n  const handler = () => {\r\n    bootstrapPublic();\r\n  };\r\n  window.addEventListener(\"online\", handler, { once: true });\r\n});\r\n```\r\n\r\n### B. Store 级幂等（示例片段，放到各自的 Pinia store 里）\r\n\r\n```ts\r\n// 复杂逻辑：在每个 init() 入口加幂等保护，彻底避免重复请求\r\nif ((this as any)._inited) return;\r\n(this as any)._inited = true;\r\n```\r\n\r\n---\r\n\r\n## 小结\r\n\r\n- 公共数据：`onMounted` 里 **立刻预取一次**，全站可复用。\r\n- 私有数据：沿用你的 `watch`，但加一次性保护，避免路由/状态抖动造成的重复请求。\r\n- 若存在弱网：监听 `online` 事件，**一次性**补跑公共初始化即可。\r\n\r\n---\r\n\r\ntitle: useAppBootstrap 放在哪？给你一份可直接复制的完整文件（含用法）\r\ndate: 2025-09-06\r\ntags:\r\n\r\n- Vue3\r\n- Vite\r\n- Pinia\r\n- composable\r\n  categories:\r\n- 前端工程化\r\n\r\n---\r\n\r\n## 位置推荐\r\n\r\n把文件放到：\r\n\r\n```\r\nsrc/composables/useAppBootstrap.ts\r\n```\r\n\r\n理由：可复用的启动逻辑属于“组合式函数（composable）”，与业务无关的初始化也方便在这里统一管理。\r\n\r\n---\r\n\r\n## 完整代码（可直接替换 `src/composables/useAppBootstrap.ts`）\r\n\r\n```ts\r\n// src/composables/useAppBootstrap.ts\r\nimport { onMounted, watch } from \"vue\";\r\nimport { useRouter } from \"vue-router\";\r\nimport {\r\n  useAuthStore,\r\n  useUserStore,\r\n  useAccountStore,\r\n  useServerStore,\r\n  useLeverageStore,\r\n  useAccountCurrencyStore,\r\n  useCountryStore,\r\n  useExchangeStore,\r\n  useExternalServerStore,\r\n  useMarketCalendarStore,\r\n  usePayChannelStore,\r\n} from \"@/store\";\r\nimport { useVerifyStore } from \"@/store/verify\";\r\nimport { useInviteStore } from \"@/store/invite\";\r\n\r\n// 复杂逻辑：模块级“只执行一次”标记，避免多组件/多次进入页面重复请求\r\nlet __BOOT_PUBLIC_ONCE__ = false;\r\nlet __BOOT_PRIVATE_ONCE__ = false;\r\n\r\nexport function useAppBootstrap() {\r\n  const router = useRouter();\r\n  const auth = useAuthStore();\r\n  const user = useUserStore();\r\n  const account = useAccountStore();\r\n  const server = useServerStore();\r\n  const leverage = useLeverageStore();\r\n  const accountCurrency = useAccountCurrencyStore();\r\n  const country = useCountryStore();\r\n  const exchange = useExchangeStore();\r\n  const externalServer = useExternalServerStore();\r\n  const marketCalendar = useMarketCalendarStore();\r\n  const payChannel = usePayChannelStore();\r\n  const verifyStore = useVerifyStore();\r\n  const inviteStore = useInviteStore();\r\n\r\n  // 复杂逻辑：公共初始化——无需登录可获取的数据，进入站点即预取，且只执行一次\r\n  const bootstrapPublic = async () => {\r\n    if (__BOOT_PUBLIC_ONCE__) return;\r\n    __BOOT_PUBLIC_ONCE__ = true;\r\n\r\n    await Promise.all([\r\n      // ⬇️ 放“无需 token”的初始化\r\n      country.init().catch(() => {}),\r\n      exchange.init({ keyword: \"\" }).catch(() => {}),\r\n      marketCalendar.init().catch(() => {}),\r\n      server.init().catch(() => {}),\r\n      // 如有其它公开数据，也可加在这里\r\n    ]);\r\n  };\r\n\r\n  // 复杂逻辑：进入应用即触发公共初始化；若首次访问时离线，恢复网络后补跑一次（仅一次）\r\n  onMounted(() => {\r\n    bootstrapPublic();\r\n    const handler = () => {\r\n      bootstrapPublic();\r\n    };\r\n    window.addEventListener(\"online\", handler, { once: true });\r\n  });\r\n\r\n  // 复杂逻辑：仅在“已登录 && 目标路由需要鉴权 && 未跑过私有初始化”时执行一次性私有初始化\r\n  watch(\r\n    [\r\n      () => auth.isAuthenticated,\r\n      () => router.currentRoute.value.meta?.requiresAuth,\r\n    ],\r\n    async ([ok, need]) => {\r\n      if (ok && need && !__BOOT_PRIVATE_ONCE__) {\r\n        __BOOT_PRIVATE_ONCE__ = true;\r\n\r\n        await Promise.all([\r\n          user.fetchUserInfo().catch(() => {}),\r\n          account\r\n            .init({ withCategory: true, withExternal: true })\r\n            .catch(() => {}),\r\n          leverage.init().catch(() => {}),\r\n          accountCurrency.init().catch(() => {}),\r\n          externalServer.init().catch(() => {}),\r\n          payChannel.init({ opt_type: \"deposit\" }).catch(() => {}),\r\n          verifyStore.initVerifyInfo().catch(() => {}),\r\n          inviteStore.getInviteGroupOptions().catch(() => {}),\r\n          // ⚠️ 已在公共初始化中完成的 server/country/exchange/marketCalendar 无需重复\r\n        ]);\r\n      }\r\n    },\r\n    { immediate: true }\r\n  );\r\n}\r\n\r\n// （可选）测试/登出时重置标记\r\nexport function __resetBootstrapFlagsForTestOnly() {\r\n  __BOOT_PUBLIC_ONCE__ = false;\r\n  __BOOT_PRIVATE_ONCE__ = false;\r\n}\r\n```\r\n\r\n---\r\n\r\n## 如何使用（最小改动）\r\n\r\n> 你**不需要**在每个页面手动调用，只需在 **App.vue** 顶层调用一次即可。\r\n\r\n在 `src/App.vue` 的 `<script setup>` 里加入一行（**增量修改**）：\r\n\r\n```ts\r\n// 复杂逻辑：顶层调用一次，注册 watch + onMounted，即可全局生效\r\nimport { useAppBootstrap } from \"@/composables/useAppBootstrap\";\r\nuseAppBootstrap();\r\n```\r\n\r\n> 如果你的项目还没在 `main.ts` 里安装 Pinia/Router，请确认已安装（一般你已经有了）：\r\n\r\n```ts\r\n// 仅供核对：main.ts 应该已包含这些\r\n// import { createApp } from 'vue'\r\n// import { createPinia } from 'pinia'\r\n// import router from './router'\r\n// import App from './App.vue'\r\n// createApp(App).use(createPinia()).use(router).mount('#app')\r\n```\r\n\r\n---\r\n\r\n## 小结\r\n\r\n- 文件放在：`src/composables/useAppBootstrap.ts`。\r\n- 在 `App.vue` 顶层调用一次 `useAppBootstrap()` 即全局生效。\r\n- 公共初始化：站点进入即跑；私有初始化：登录且命中鉴权路由时只跑一次。\r\n",
            "url": "https://example.com/posts/登录后初始化的双阶段启动（增量修改）",
            "title": "在 composable 里“公共初始化 + 登录后初始化”的双阶段启动（增量修改）",
            "date_modified": "2025-09-06T18:30:01.000Z"
        },
        {
            "id": "https://example.com/posts/退出登录后跳转与请求是否会发出",
            "content_html": "\r\n---\r\n\r\ntitle: 退出登录后跳转与请求是否会发出？（Vue Router 4 实战）\r\ndate: 2025-09-05\r\ntags: \\[Vue, Vue Router, Pinia, Axios, 登录, 退出]\r\n\r\n---\r\n\r\n## TL;DR（先给结论）\r\n\r\n- `router.push('/user')` **不会**去加载 `@/views/(public)/layout.vue`；`/user` 是独立的**公开路由**，全局前置守卫会**先**跑，再决定是否进入目标路由，受保护布局组件不会被解析/执行。\r\n- 真正会“误发请求”的常见来源是：① 旧页中**已发起但未取消**的请求；② `<keep-alive>` 相关的激活/停用副作用；③ 你在 HTTP 层没有对“无 Token 的鉴权请求”做**硬性拦截**。\r\n- 给你三道保险：**彻底清 Token + 取消未决请求 + 请求层强拦**（可选再加根路由 `beforeEnter`）。\r\n\r\n---\r\n\r\n## 最小修改（仅给需要改的代码片段）\r\n\r\n> 说明：按你的偏好，只给**需修改**片段；复杂逻辑在上一行加注释。\r\n\r\n### 1) `auth` Store：退出时同时清理本地存储 Token、取消所有请求、清默认头\r\n\r\n**文件：** `useAuthStore` 所在文件\r\n\r\n```ts\r\n// 新增导入\r\nimport storage from \"store\";\r\nimport { STORAGE_KEYS } from \"@/constants\";\r\nconst { ACCESS_TOKEN } = STORAGE_KEYS;\r\n```\r\n\r\n```ts\r\n// 新增：统一清空本地 Token（Pinia + 本地存储）\r\nfunction clearToken() {\r\n  // 复杂逻辑：双通道清理，避免路由守卫误判已登录\r\n  token.value = null;\r\n  refresh.value = null;\r\n  storage.remove(ACCESS_TOKEN);\r\n}\r\n```\r\n\r\n```ts\r\n// 调整 logout 函数（仅贴需要增加的片段）\r\nasync function logout() {\r\n  try {\r\n    await http.post(\"/api/pub/loginOut\").catch(() => {});\r\n    // 复杂逻辑：优雅下线——取消所有还在飞行中的请求，防止“未登录也发请求”\r\n    http.cancelAll?.();\r\n    // 复杂逻辑：清掉默认鉴权头，防止后续请求夹带旧 Token\r\n    http.setAuthToken?.(null);\r\n\r\n    clearToken();\r\n    resetAllStores();\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  }\r\n}\r\n```\r\n\r\n> 你现在的调用 `await authStore.logout(); router.push('/user')` 没问题；若不想留下历史记录，可换成：\r\n\r\n```ts\r\n// 可选：避免回退到已登录页\r\nawait router.replace({ name: \"user\" });\r\n```\r\n\r\n---\r\n\r\n### 2) `http` 工具：加“全局取消池 + 无 Token 时硬拦需要鉴权的请求”\r\n\r\n**文件：** 你的 `@/utils/http`（或创建一个轻量封装）\r\n\r\n```ts\r\n// 新增：全局取消池\r\nconst abortPool = new Set<AbortController>();\r\n\r\nexport function cancelAll() {\r\n  // 复杂逻辑：退出登录时集中取消所有未决请求\r\n  abortPool.forEach((c) => c.abort());\r\n  abortPool.clear();\r\n}\r\n\r\nexport function setAuthToken(token?: string | null) {\r\n  // 复杂逻辑：动态设置/清除默认鉴权头\r\n  if (token) {\r\n    axios.defaults.headers.common.Authorization = `Bearer ${token}`;\r\n  } else {\r\n    delete axios.defaults.headers.common.Authorization;\r\n  }\r\n}\r\n```\r\n\r\n```ts\r\n// 在请求拦截里增加以下片段（保留你已有逻辑）\r\nhttp.interceptors.request.use((config) => {\r\n  // 复杂逻辑：为每个请求绑定 AbortController，纳入全局取消池\r\n  const ac = new AbortController();\r\n  (config as any).signal = ac.signal;\r\n  abortPool.add(ac);\r\n\r\n  // 复杂逻辑：对标记了 { auth: true } 的请求做硬性校验，无 Token 直接终止\r\n  const needAuth = (config as any).auth === true;\r\n  const token = storage.get(ACCESS_TOKEN);\r\n  if (needAuth && !token) {\r\n    ac.abort();\r\n    // 用标准错误中断；也可自定义错误码\r\n    throw new axios.Cancel(\"UNAUTHENTICATED\");\r\n  }\r\n  return config;\r\n});\r\n```\r\n\r\n```ts\r\n// 在响应/错误拦截里释放对应的 controller（保持池干净）\r\nconst detach = (cfg?: any) => {\r\n  if (!cfg?.signal) return;\r\n  for (const ac of abortPool) {\r\n    if (cfg.signal === ac.signal) {\r\n      abortPool.delete(ac);\r\n      break;\r\n    }\r\n  }\r\n};\r\nhttp.interceptors.response.use(\r\n  (resp) => {\r\n    detach(resp.config);\r\n    return resp;\r\n  },\r\n  (err) => {\r\n    detach(err?.config);\r\n    return Promise.reject(err);\r\n  }\r\n);\r\n```\r\n\r\n> 使用方式：**凡是需要登录才能访问的接口**，在调用时带上 `{ auth: true }`：\r\n\r\n```ts\r\n// 复杂逻辑：打上鉴权标记，无 Token 时在请求层被硬拦\r\nhttp.get(\"/api/secure/profile\", { auth: true });\r\n```\r\n\r\n---\r\n\r\n### 3) 根布局路由（可选加固）：未登录禁止进入，阻止懒加载 `layout.vue`\r\n\r\n> 这是“冗余但稳”的**第四道锁**：即使有人误配了守卫，根布局也进不去。\r\n\r\n**文件：** 路由表所在文件\r\n\r\n```ts\r\n// 新增导入（如果本文件里还没有）\r\nimport storage from \"store\";\r\nimport { STORAGE_KEYS } from \"@/constants\";\r\nimport { LOGIN_ROUTE } from \"./constants\";\r\nconst { ACCESS_TOKEN } = STORAGE_KEYS;\r\n```\r\n\r\n```ts\r\n// 在 path: '/' 那个根路由对象上新增 beforeEnter（只贴新增的属性）\r\nbeforeEnter: (to, from, next) => {\r\n  // 复杂逻辑：未登录直接拒绝进入受保护根布局，避免解析/执行 layout.vue\r\n  const token = storage.get(ACCESS_TOKEN)\r\n  if (!token) return next({ name: LOGIN_ROUTE.name, replace: true })\r\n  next()\r\n},\r\n```\r\n\r\n---\r\n\r\n## 为什么你会怀疑 `layout.vue` 被加载？\r\n\r\n常见场景有三种（任选对号入座）：\r\n\r\n1. **旧页未决请求**：你还在“受保护页面”时就发出了请求，`push('/user')` 后这些请求仍会完成，除非你**主动取消**（上面第 2 步已解决）。\r\n2. **`<keep-alive>` 激活/停用副作用**：离开/进入时有数据拉取，需要在未登录时短路。\r\n3. **预加载 Chunk**：如果手动开启过 `webpackPrefetch` 等，会看到静态资源拉取，但这不等同于“业务请求”发出。\r\n\r\n---\r\n\r\n## 排查清单（按优先级）\r\n\r\n1. 退出后 `localStorage`/`store` 里是否还残留 `ACCESS_TOKEN`？（第 1 步已处理）\r\n2. 所有**需要登录**的接口是否统一加了 `{ auth: true }` 并被请求拦截器“硬拦”？（第 2 步）\r\n3. 页面里有没有在 `onMounted` **直接拉数据**但无 Token 校验的逻辑？（在组件中加早返回）\r\n4. 是否使用了 `<keep-alive>` 并在 `activated`/`deactivated` 发请求？（同样做登录短路）\r\n5. 仍担心懒加载？给根布局加 `beforeEnter`（第 3 步“加固锁”）。\r\n\r\n---\r\n\r\n## 你最关心的那句直白话\r\n\r\n- **不会**：`router.push('/user')` 不会去跑 `@/views/(public)/layout.vue` 里的业务请求。\r\n- **会**：如果**旧页**的请求已经发出且你没有取消，它们**会继续完成**。上面给的三段修改能把这类“该停的请求”全部截住。\r\n",
            "url": "https://example.com/posts/退出登录后跳转与请求是否会发出",
            "title": "退出登录后跳转与请求是否会发出",
            "date_modified": "2025-09-05T18:55:38.000Z"
        },
        {
            "id": "https://example.com/posts/退出登录要不要-resetAllStores",
            "content_html": "\r\n## 结论\r\n\r\n- **应该保留 `resetAllStores()`**（避免残留用户数据/权限态），但**直接在登出时先重置**会触发一堆 `watchEffect` / `watch` 的依赖变化，从而在组件卸载前**又发出请求**。\r\n- 正确做法：**先撤鉴权与在途请求 → 跳公开页卸载组件 → 最后再 `resetAllStores()`**；同时在页面副作用里用 `isAuthenticated`/`isLoggingOut` 做**登录短路**。\r\n\r\n## 推荐顺序（一眼抄）\r\n\r\n1. **标记登出中**（`isLoggingOut = true`）\r\n2. **取消所有在途请求**（`http.cancelAll()`）\r\n3. **清鉴权**（`http.setAuthToken(null)` + 清本地 `ACCESS_TOKEN/TOKEN_TYPE` + 清内存 `token`）\r\n4. **跳到公开路由**（`router.replace('/user')`）\r\n5. **最后** `resetAllStores()`\r\n6. **清掉登出标记**（`isLoggingOut = false`）\r\n\r\n## 仅需修改的代码片段\r\n\r\n### A) `auth` Store：按顺序登出（在 store 内部做跳转，保证顺序）\r\n\r\n```ts\r\n// 新增\r\nimport { useRouter } from \"vue-router\";\r\n\r\n// 新增\r\nconst isLoggingOut = ref(false);\r\n```\r\n\r\n```ts\r\n// 调整 logout（顺序：撤鉴权→跳公开页→reset）\r\nasync function logout() {\r\n  const router = useRouter();\r\n  try {\r\n    isLoggingOut.value = true;\r\n    await http.post(\"/api/pub/loginOut\").catch(() => {});\r\n\r\n    // 复杂逻辑：统一掐断飞行中的请求，避免“卸载前再打一次”\r\n    http.cancelAll?.();\r\n\r\n    // 复杂逻辑：清鉴权（默认头 + 本地存储 + 内存）\r\n    http.setAuthToken?.(null);\r\n    storage.remove(ACCESS_TOKEN);\r\n    storage.remove(TOKEN_TYPE);\r\n    token.value = null;\r\n    refresh.value = null;\r\n\r\n    // 复杂逻辑：先跳到公开页，卸载受保护组件，阻断其副作用\r\n    await router.replace({ name: \"user\" });\r\n\r\n    // 复杂逻辑：组件已卸载，再重置所有 store，安全不抖动\r\n    resetAllStores();\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw error;\r\n  } finally {\r\n    isLoggingOut.value = false;\r\n  }\r\n}\r\n```\r\n\r\n> 这样**无需**在组件里再 `router.push('/user')`；如果你保留组件层跳转，记得删除那一行以免重复。\r\n\r\n---\r\n\r\n### B) 页面副作用：加“登录短路”（防抖再保险）\r\n\r\n> 示例：你在 `public/dashboard` 页和分析卡片里原来用 `watchEffect` 拉数据。\r\n\r\n```ts\r\n// 复杂逻辑：登出过程/未登录时直接短路，不发请求\r\nimport { useAuthStore } from '@/plugins'\r\nimport { storeToRefs } from 'pinia'\r\nconst { isAuthenticated, isLoggingOut } = storeToRefs(useAuthStore())\r\n\r\nwatch(/* 精确依赖或 isAuthenticated */ , () => {\r\n  if (!isAuthenticated.value) return\r\n  if (isLoggingOut?.value) return\r\n  // 这里再发请求\r\n}, { immediate: true })\r\n```\r\n\r\n> 说明：**副作用短路 + A 部分的顺序**，两层兜底，基本杜绝“退出时还在请求”。\r\n\r\n---\r\n\r\n## 什么时候可以“不 resetAllStores”？\r\n\r\n- 仅在**演示/临时**场景；正式项目**不建议**。不重置会遗留：上一个用户的**列表数据、选择态、分页、缓存**等，存在隐私与越权风险。\r\n\r\n---\r\n\r\n## 小结\r\n\r\n- **不是不要 `resetAllStores()`，而是要把它放在最后**，并在副作用处加“登录短路”。\r\n- 真正能解决“跳转后还在请求”的，是**顺序**（撤鉴权 → 跳公开页 → 重置）+ **取消在途** + **副作用短路**。\r\n",
            "url": "https://example.com/posts/退出登录要不要-resetAllStores",
            "title": "退出登录要不要 resetAllStores",
            "date_modified": "2025-09-05T20:45:33.000Z"
        },
        {
            "id": "https://example.com/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案",
            "content_html": "\n结论先说：**可以把“登录+注册”做成一体化体验**。\n\n主流做法是 **“先尝试登录（可发现凭证）→ 如果用户或设备上没有可用通行密钥，再走 JIT 注册并在验证成功后直接登录”**。\n\n原因是 WebAuthn 天生是“**两步握手**”：\n**options**（服务端签发挑战）→ **客户端做凭证仪式** → **verify**（服务端校验）。\n所以无论登录还是注册，都至少要走这一来一回；想“完全无交互”是不可能的。但你可以把 **登录与注册的分支逻辑** 封装好，让前端只调用 1\\~2 次 API 就完成。\n\n你的代码里已经有这个形态了：\n\n- `/passkeys/login/options|verify`：**无用户名直登**（allowCredentials 留空 → 可发现凭证）\n- `/passkeys/register-or-login/options|verify`：**JIT 建号 + 设备唯一 + 注册即登录**\n\n这就是一体化的正确方向。下面给你**微调点**，让体验更顺滑，并回答“是否必须先绑定”的顾虑。\n\n## 推荐落地流程（与大厂一致的用户体验）\n\n1. **进入应用 → 前端先调用** `/passkeys/login/options`（不传 allowCredentials）。\n\n   - Android/iOS 原生会列出与 **RP ID** 匹配的“可发现凭证”(resident key)。\n   - 若用户设备上已有你的 RP 的通行密钥 → 用户点一下即返回 **assertion** → 你后端 `verifyAuthentication` → **直接登录**。\n\n2. **若返回“没有可用凭证/用户取消/NotFound”**：前端**立即**调用 `/passkeys/register-or-login/options`（带上 `deviceIdentifier`）。\n\n   - 后端 **JIT 建号**（或使用你已有的访客/待激活账号策略），签发 **registration options**（residentKey=required）。\n   - 前端发起注册仪式 → 拿到 **attestation** 回 `/register-or-login/verify`。\n   - 服务端 **校验 + 入库 + 绑定设备(可选) + 激活账号 + 签发 JWT** → **注册即登录**。\n\n> 是否必须先“绑定再登录”？\n> **不必须。**对已存在通行密钥的用户，第一步就能登录；对新设备/新用户，第二步完成**注册+登录**。\n> “设备唯一绑定”是**风控策略**（特别适合你的“仅内部员工”场景），不是通行密钥的强制要求。\n\n## 只给需要修改/新增的代码（复杂逻辑上一行有注释）\n\n### A) `PasskeysService.issueAuthenticationOptions`：若发现设备已绑定账号，则**定向登录**（加速成功率）\n\n```ts\n// 复杂逻辑：若 deviceIdentifier 已绑定 userId，则定向下发 allowCredentials（命中率更高，更快）\nasync issueAuthenticationOptions({ deviceIdentifier }: { deviceIdentifier?: string }) {\n  const relyingPartyId = this.configService.get<string>('RP_ID');\n\n  // 可选的速率限制（60s/5次）\n  if (deviceIdentifier) {\n    const rlKey = `rl:authpub:${deviceIdentifier}`;\n    const c = await this.redisService.incrementKey(rlKey);\n    if (c === 1) await this.redisService.expireKey(rlKey, 60);\n    if (c > 5) throw new BadRequestException('请求过于频繁，请稍后重试');\n  }\n\n  let allowCredentials: { id: Buffer; type: 'public-key' }[] | undefined;\n  let preferUserId: string | null = null;\n\n  if (deviceIdentifier) {\n    // 复杂逻辑：如果该设备已绑定过账号，优先走“定向登录”\n    preferUserId = await this.redisService.getValue(`dvc:owner:${deviceIdentifier}`);\n    if (preferUserId) {\n      // 复杂逻辑：查询该用户的所有凭证，拼出 allowCredentials（按你的持久层接口调整）\n      const creds = await this.staffService.findManyCredentialsByUserId(preferUserId);\n      allowCredentials = (creds || []).map((c: any) => ({\n        id: Buffer.from(c.credentialId, 'base64url'),\n        type: 'public-key' as const,\n      }));\n    }\n  }\n\n  const opts = await generateAuthenticationOptions({\n    rpID: relyingPartyId,\n    userVerification: 'preferred',\n    // 复杂逻辑：存在 allowCredentials → 定向登录；否则留空 = 可发现凭证\n    allowCredentials,\n  });\n\n  // 复杂逻辑：挑战转为 base64url，分别按“userId”或“challenge”做校验键\n  const ch = typeof opts.challenge === 'string'\n    ? opts.challenge\n    : Buffer.from(opts.challenge).toString('base64url');\n\n  if (preferUserId) {\n    // 定向登录：按 userId 存\n    await this.redisService.setWithTimeToLive(`webauthn:auth:${preferUserId}`, ch, 300);\n  } else {\n    // 无用户名直登：按 challenge 存\n    await this.redisService.setWithTimeToLive(`webauthn:auth:ch:${ch}`, '1', 300);\n  }\n\n  // 兼容前端：无需改协议，仍返回纯 AuthenticationOptions\n  return { options: opts };\n}\n```\n\n> 说明：\n>\n> - 这段逻辑**不改变你的路由与前端协议**，仅在“已绑定设备”的情况下给出 `allowCredentials`，成功率会更高，且仍保留“可发现凭证”的默认路径。\n> - `findManyCredentialsByUserId` 请在你的 `AdminStaffService` 或凭据仓库里补一个简单查询（只要返回 `credentialId` 列表即可）。\n\n---\n\n### B) 前端（你刚写的 `<script setup>` 页面）**登录按钮**增加“失败回退到注册”的兜底（只给改动段）\n\n```ts\n// 复杂逻辑：登录失败时自动回退到 JIT 注册（注册成功即登录）\nasync function onLogin() {\n  try {\n    appendLog(\"请求登录 options...\");\n    const { options } = await post(\"/passkeys/login/options\", {\n      deviceIdentifier: deviceId.value,\n    });\n    const requestOptionsJson = JSON.stringify(options);\n\n    // 复杂逻辑：先尝试登录（Android 支持 conditional UI；iOS 忽略该参数）\n    const authRespJson = await passkeys.getPasskey(requestOptionsJson, {\n      conditional: true,\n    });\n\n    appendLog(\"登录响应返回，提交后端 verify...\");\n    const verify = await post(\n      \"/passkeys/login/verify\",\n      JSON.parse(authRespJson)\n    );\n    appendLog(\"登录完成：\" + JSON.stringify(verify));\n    uni.showToast({ title: \"登录成功\", icon: \"success\" });\n  } catch (e: any) {\n    appendLog(\"未找到可用通行密钥或用户取消，转入一键注册...\");\n    // ===== 回退到 JIT 注册 =====\n    const { userId, options } = await post(\n      \"/passkeys/register-or-login/options\",\n      deviceId.value ? { deviceIdentifier: deviceId.value } : {}\n    );\n    const creationOptionsJson = JSON.stringify(options);\n    const regRespJson = await passkeys.createPasskey(creationOptionsJson);\n\n    appendLog(\"注册响应返回，提交后端 verify...\");\n    const verify = await post(\"/passkeys/register-or-login/verify\", {\n      ...JSON.parse(regRespJson),\n      userId,\n      deviceIdentifier: deviceId.value,\n    });\n    appendLog(\"注册并登录完成：\" + JSON.stringify(verify));\n    uni.showToast({ title: \"已注册并登录\", icon: \"success\" });\n  }\n}\n```\n\n---\n\n### C) 小修小补（可选但建议）\n\n```ts\n// ✅ 注册 options：建议同时允许 ES256 与 RS256，兼容性更好\nsupportedAlgorithmIDs: [-7, -257],  // ES256 + RS256\n\n// ✅ 注册时强制 residentKey=required 已很好；登录时建议 UV 至少 preferred（你已这么做）\n// 可对内网/高敏环境将 requireUserVerification 提升为 true\nrequireUserVerification: true, // 在 verify* 中按需要切换\n```\n\n---\n\n## 关键答疑\n\n- **“能不能只请求一次后端就完成登录？”**\n  不行。WebAuthn 必须由服务器先发“带签名挑战”的 **options**，客户端拿到后**本地安全硬件**完成签名/生成数据，再发给服务器 **verify**。这是设计使然，无法省略。\n\n- **“新用户是否必须先走‘绑定’页面？”**\n  不必须。你现在的 JIT 路线就是“**注册即登录**”。首次访问：登录失败 → 自动发起注册 → 验证成功后立刻签发会话即可。后续访问就直接“可发现凭证”一键登录了。\n\n- **“设备唯一绑定是必须的吗？”**\n  不是 WebAuthn 的硬性要求，但对**内部员工场景非常有用**（合规+风控）。你已经在 JIT 验证里写了 `dvc:owner:*` 的校验与写入，这就够了。\n\n---\n\n如果你愿意，我可以**补一个 `findManyCredentialsByUserId` 的最小实现**（Prisma/TypeORM 任一版）或把你的 `PasskeysController` 的“登录按钮”分支写成更干净的状态机。你说一声，我按你的“只给改动段”规范继续补。\n",
            "url": "https://example.com/posts/web应用开发/前端/passkeys-通行密钥-登录-注册一体化方案",
            "title": "passkeys 通行密钥 登录+注册一体化方案",
            "date_modified": "2025-09-04T23:29:49.000Z"
        },
        {
            "id": "https://example.com/posts/需求实现/登录鉴权/Passkeys：options",
            "content_html": "\n> 适用版本：**@simplewebauthn/server v11+**\n> 重点变化：`pubKeyCredParams` ➜ `supportedAlgorithmIDs`；注册验证结果中的 `credentialID/credentialPublicKey` ➜ 移到 `registrationInfo.credential`。\n\n# 一、两类 options 是什么？\n\n- **注册（Creation）**：发给前端 `navigator.credentials.create({ publicKey })` 的参数\n\n  - 服务器生成：`generateRegistrationOptions(opts)`\n  - 前端收到的是 **PublicKeyCredentialCreationOptions(JSON)**\n\n- **登录（Request/Assertion）**：发给前端 `navigator.credentials.get({ publicKey })` 的参数\n\n  - 服务器生成：`generateAuthenticationOptions(opts)`\n  - 前端收到的是 **PublicKeyCredentialRequestOptions(JSON)**\n\n> 前端 JSON 里的 `challenge` / `user.id` 等，通常是 **base64url** 字符串；服务端入参多数用 **Buffer/Uint8Array**。\n\n# 二、注册：服务端入参 & 前端 options 全量长相\n\n## 2.1 服务端入参（`generateRegistrationOptions(opts)`）\n\n```ts\nconst options = await generateRegistrationOptions({\n  // —— RP（你的站点） ——\n  rpName: \"Shop Thrive\", // 展示名（弹窗可见）\n  rpID: \"example.com\", // RP ID（域名，需与前端同源后缀匹配）\n\n  // —— 用户信息（必须） ——\n  // 注意：userID 必须是字节数组（Uint8Array/Buffer），不是 string\n  userID: Buffer.from(\"user-123\", \"utf8\"),\n  userName: \"user-123\", // 可读名（设备 UI 展示）\n  userDisplayName: \"Alice Zhang\", // 可选；不传时库会处理\n\n  // —— 安全策略 ——\n  // v11+：用 supportedAlgorithmIDs 指定算法（替代 pubKeyCredParams）\n  // 常用：-7=ES256；如需兼容更广，可加 -257=RS256/-8=EdDSA 等\n  supportedAlgorithmIDs: [-7, -257],\n\n  // 要求/偏好做本地用户验证（UV：指纹/人脸/PIN）\n  // 'required' | 'preferred' | 'discouraged'\n  userVerification: \"required\",\n\n  // 选择哪类认证器与凭证形态\n  authenticatorSelection: {\n    // 'platform'（本机/系统）| 'cross-platform'（外接/钥匙）| 不填（都可）\n    authenticatorAttachment: \"platform\",\n    // 要不要可发现凭证（resident key），用于“无用户名一键登录”\n    // 'required' | 'preferred' | 'discouraged'\n    residentKey: \"required\",\n    // 旧字段（某些库还在）：requireResidentKey: true,\n  },\n\n  // 证明链/隐私：'none' | 'indirect' | 'direct' | 'enterprise'\n  attestationType: \"none\",\n\n  // —— 体验/兼容 ——\n  timeout: 60_000, // 毫秒\n  excludeCredentials: [\n    // 防重复注册（可选）\n    {\n      id: Buffer.from(\"...\", \"base64url\"),\n      type: \"public-key\",\n      transports: [\"internal\", \"usb\"],\n    },\n  ],\n\n  // —— 扩展（按需） ——\n  extensions: {\n    credProps: true, // 要求返回“是否可发现凭证”等属性\n    // largeBlob: { support: 'required' | 'preferred' },\n    // hmacCreateSecret: true,\n    // // 老 FIDO 兼容场景：\n    // appidExclude: 'https://example.com'\n  },\n});\n```\n\n### COSE 算法常用映射\n\n| ID              | 名称                  | 说明                                        |\n| --------------- | --------------------- | ------------------------------------------- |\n| **-7**          | ES256                 | ECDSA w/ SHA-256（最常用，passkey 默认）    |\n| **-257**        | RS256                 | RSA w/ SHA-256（更广兼容）                  |\n| **-8**          | EdDSA                 | 常见为 Ed25519（浏览器/平台支持度差异较大） |\n| -35 / -36       | ES384 / ES512         | 更高位椭圆曲线                              |\n| -38 / -39 / -40 | PS256 / PS384 / PS512 | RSA-PSS 系列                                |\n\n> 生产一般 `[-7]` 足够；如有老设备需求，可加 `-257`。\n\n---\n\n## 2.2 前端收到的 **注册 options（完整 JSON 示例）**\n\n```json\n{\n  \"rp\": { \"name\": \"Shop Thrive\", \"id\": \"example.com\" },\n  \"user\": {\n    \"id\": \"dXNlci0xMjM\", // base64url（服务端 userID 的 JSON 形式）\n    \"name\": \"user-123\",\n    \"displayName\": \"Alice Zhang\"\n  },\n  \"challenge\": \"9P0mB1o0f1...Q\",\n  \"pubKeyCredParams\": [\n    // 注意：这是浏览器原生结构；simplewebauthn 已根据 supportedAlgorithmIDs 生成\n    { \"type\": \"public-key\", \"alg\": -7 },\n    { \"type\": \"public-key\", \"alg\": -257 }\n  ],\n  \"timeout\": 60000,\n  \"attestation\": \"none\",\n  \"authenticatorSelection\": {\n    \"authenticatorAttachment\": \"platform\",\n    \"residentKey\": \"required\",\n    \"userVerification\": \"required\"\n  },\n  \"excludeCredentials\": [\n    { \"type\": \"public-key\", \"id\": \"...\", \"transports\": [\"internal\", \"usb\"] }\n  ],\n  \"extensions\": {\n    \"credProps\": true\n  }\n}\n```\n\n> 实际上浏览器可能省略部分可选字段；**你看到的字段少，不代表“没生效”**，很多值有默认行为。\n\n# 三、登录：服务端入参 & 前端 options 全量长相\n\n## 3.1 服务端入参（`generateAuthenticationOptions(opts)`）\n\n```ts\nconst options = await generateAuthenticationOptions({\n  // —— 基本项 ——\n  rpID: \"example.com\",\n  timeout: 60_000,\n\n  // —— UV 要求 ——\n  // 'required' | 'preferred' | 'discouraged'\n  userVerification: \"preferred\",\n\n  // —— 可选：指定可用凭证（有用户名场景）\n  // 省略则启用“可发现凭证”（一键直登：浏览器列出该站点可用 passkey）\n  allowCredentials: [\n    {\n      id: Buffer.from(\"credential-id-base64url\", \"base64url\"),\n      type: \"public-key\",\n      transports: [\"internal\", \"usb\", \"nfc\", \"ble\", \"hybrid\"], // 按需\n    },\n  ],\n\n  // —— 扩展（按需） ——\n  extensions: {\n    // uvm: true,                    // 请求返回用户验证方式矩阵（支持时）\n    // appid: 'https://example.com' // 老 FIDO 兼容\n  },\n});\n```\n\n### `transports` 可能值\n\n- `usb` / `nfc` / `ble`：外接钥匙传输方式\n- `internal`：平台认证器（如 iOS/Android/Windows 内置）\n- `cable` / `hybrid`：跨设备传输（手机帮电脑解锁的流程）\n\n---\n\n## 3.2 前端收到的 **登录 options（完整 JSON 示例）**\n\n```json\n{\n  \"rpId\": \"example.com\",\n  \"challenge\": \"jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg\",\n  \"timeout\": 60000,\n  \"userVerification\": \"preferred\",\n  \"allowCredentials\": [\n    { \"type\": \"public-key\", \"id\": \"...\", \"transports\": [\"internal\", \"hybrid\"] }\n  ],\n  \"extensions\": {\n    \"uvm\": true\n  }\n}\n```\n\n> **条件式 UI（passkeys 一键直登）**：这是 `navigator.credentials.get()` 的**第二个参数**里的 `mediation: 'conditional'`，**不在** `publicKey` 这个 JSON 里。\n> 形如：\n>\n> ```ts\n> navigator.credentials.get({ publicKey: options, mediation: \"conditional\" });\n> ```\n\n---\n\n# 四、关键字段取值解释（速查表）\n\n## 4.1 `userVerification`\n\n| 值            | 含义                                                              | 推荐                   |\n| ------------- | ----------------------------------------------------------------- | ---------------------- |\n| `required`    | 必须进行本地用户验证（指纹/人脸/PIN）；不支持 UV 的认证器会被排除 | **后台/金融** 强烈推荐 |\n| `preferred`   | 优先进行 UV；不支持也可继续                                       | **通用登录** 默认      |\n| `discouraged` | 不鼓励 UV                                                         | 不推荐用于登录         |\n\n> **服务端也要对应开启**：`verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })` 才算真正强制。\n\n## 4.2 `authenticatorSelection`\n\n| 字段                      | 值                                       | 说明                                     |\n| ------------------------- | ---------------------------------------- | ---------------------------------------- |\n| `authenticatorAttachment` | `platform` / `cross-platform`            | 本机认证器 vs 外接钥匙；不填=都可        |\n| `residentKey`             | `required` / `preferred` / `discouraged` | 是否创建**可发现凭证**（一键直登的前提） |\n| `requireResidentKey`      | `boolean`                                | 旧字段；等价于 `residentKey: 'required'` |\n\n## 4.3 `attestationType`（simplewebauthn）\n\n| 值                    | 说明                     | 备注         |\n| --------------------- | ------------------------ | ------------ |\n| `none`                | 不收集证明链（隐私友好） | **最常用**   |\n| `indirect` / `direct` | 收集不同强度的证明链     | 较少用       |\n| `enterprise`          | 企业场景                 | 需要配套策略 |\n\n## 4.4 `allowCredentials` / `excludeCredentials`（描述符）\n\n```ts\n{\n  id: Uint8Array | Buffer,     // 凭证ID（服务端存 base64url，生成时转回二进制）\n  type: 'public-key',\n  transports?: ('usb'|'nfc'|'ble'|'internal'|'cable'|'hybrid')[]\n}\n```\n\n## 4.5 `supportedAlgorithmIDs`（替代 `pubKeyCredParams`）\n\n- 传 **COSE 算法 ID** 数组（见上表）。\n- 浏览器最终在前端 JSON 里仍会以 `pubKeyCredParams` 形式出现（这是 WebAuthn 原生结构），不冲突。\n\n---\n\n# 五、生产推荐模板\n\n### 注册（Creation）\n\n```ts\nawait generateRegistrationOptions({\n  rpName: \"Your App\",\n  rpID: \"yourdomain.com\",\n  userID: Buffer.from(userId, \"utf8\"),\n  userName: userNameOrEmail,\n  supportedAlgorithmIDs: [-7], // 如需更广：[-7, -257]\n  userVerification: \"required\",\n  authenticatorSelection: {\n    authenticatorAttachment: \"platform\",\n    residentKey: \"required\",\n    userVerification: \"required\",\n  },\n  attestationType: \"none\",\n  timeout: 60_000,\n  // excludeCredentials: [...],      // 防重复注册（可选）\n  extensions: { credProps: true },\n});\n```\n\n### 登录（Request）\n\n```ts\nawait generateAuthenticationOptions({\n  rpID: \"yourdomain.com\",\n  timeout: 60_000,\n  userVerification: \"required\",\n  // 省略 allowCredentials → 可发现凭证（推荐做“一键直登”）\n  // allowCredentials: [...],       // 指定账号登录时使用\n  // extensions: { uvm: true },\n});\n```\n\n> 核心校验与安全实践：\n>\n> 1. **challenge** 统一按 **base64url 字符串** 存/比；用后删除；短 TTL（≤5 分钟）。\n> 2. **requireUserVerification: true**（服务端）与前端的 `userVerification: 'required'` 配套。\n> 3. 注册时显式 `residentKey: 'required'`，保证后面能做“无用户名一键登录（conditional UI）”。\n\n---\n\n# 六、常见疑问\n\n- **为什么我的 `options` 字段很少？**\n  浏览器/库会省略默认字段；只要关键项（`rpId`、`challenge`、用户/算法/策略）正确，功能完全等价。\n- **`challenge` 看起来很短，安全吗？**\n  默认 32 字节随机数（base64url 后 ≈43 字符）已足够安全。\n- **字段大小写为何不一致？**\n  库的**入参**是 `rpID`、`userID`（TypeScript 结构）；前端 JSON 是 WebAuthn 原生的 `rpId`、`user.id`。库会正确映射。\n\n---\n\n如果你想把现有 NestJS 代码里的配置**替换为上面的“生产推荐模板”**，告诉我你文件里的具体几行；我只给“需要替换的片段”，并在复杂逻辑上一行加注释，符合你的改码规则。\n",
            "url": "https://example.com/posts/需求实现/登录鉴权/Passkeys：options",
            "title": "WebAuthn Passkeys：options 全字段长啥样？取值有哪些？（simplewebauthn v11+ 实战）",
            "date_modified": "2025-09-08T00:33:31.000Z"
        },
        {
            "id": "https://example.com/posts/需求实现/登录鉴权/preferred是啥",
            "content_html": "\n好，我逐条拆解你看到的这段响应，并把“该用什么值”“挑战长度”为啥看起来短、“大厂是不是也这样返回”讲清楚；最后给出**只需改几行**的建议（不贴整文件）。\n\n---\n\n# 1、`\"userVerification\": \"preferred\"` 是啥？\n\n**它告诉浏览器/认证器：是否必须做“本地用户验证（UV）”**（指纹/人脸/PIN）。可选值只有 3 个：\n\n| 值                            | 含义                                                     | 常见效果/场景                                                                                                |\n| ----------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| **`required`**                | **必须**进行本地用户验证（没有 UV 能力的认证器会被排除） | 金融、后台管理、提升安全性。旧 U2F 钥匙（无 PIN）会被拒。                                                    |\n| **`preferred`**（你现在的值） | **优先**做 UV，如果设备支持就做；不支持也可以继续        | 一般网站登录、降低失败率。绝大多数“平台 passkey”（Android/Apple）都会做 UV，所以体验和 `required` 基本一样。 |\n| **`discouraged`**             | **不鼓励**做 UV（允许仅“持有设备”就通过）                | 很少用；降低安全门槛，适合低风险二级操作（不建议用于登录）。                                                 |\n\n> 注意：这只是“**意愿**”。真正的**强制**要在**服务端验证**时也打开：\n> `verifyRegistrationResponse/verifyAuthenticationResponse({ requireUserVerification: true })`。\n> 否则前端说 `required`，服务端放宽为 `false`，就**没有被强制**。\n\n**给你的建议：**\n\n- 如果这是**员工后台**或敏感操作：前端设 `userVerification: 'required'`，服务端配套 `requireUserVerification: true`。\n- 如果是**大众登录**：`preferred` + 风控/设备指纹/异常登录再二次验证。\n\n# 2、这个 `challenge` 看起来“很短”，正常吗？\n\n**正常。**\n\n- simplewebauthn 默认生成 **32 字节**随机挑战（≈ **256 bit**）。\n- 32 字节用 **base64url** 表示通常是 **43\\~44 个字符**（无 `=` 填充）。\n- 你看到的：`jOr8QL_ExSr_7xsD2WUG1Kp8eM2lMiWNx8fFMg5wLyg`，长度 43，很标准。\n- 我们服务端已把 challenge 统一按 **base64url** 存/比（你代码里已处理），与前端 `clientDataJSON.challenge` 能**精确一致**。\n\n> 若你担心强度，也可以自定义更长挑战（例如 64 字节），但 32 字节已足够随机且是行业常见默认。\n\n# 3、大厂实践里返回的也是这种结构吗？\n\n**是的。**这就是 WebAuthn 规范的 **PublicKeyCredentialRequestOptions(JSON)** 的形态，各家（Google、Apple、微软、GitHub、PayPal…）都会返回类似结构。差异主要在**有没有 `allowCredentials`** 和某些可选字段：\n\n- 一键直登/可发现凭证：**省略 `allowCredentials`**（你现在就是），浏览器会弹出该 RP 的可用 passkey 列表。\n- 指定账号登录：会带 `allowCredentials: [{ id, type: 'public-key' }, ...]`。\n- 其他常见字段：`rpId`、`challenge`、`timeout`、`userVerification`、有时 `extensions`。\n- 前端会另外传 `mediation: 'conditional'`（这不是 options 里的字段，而是 `navigator.credentials.get` 的参数，用于条件式 UI）。\n\n所以你这个响应：\n\n```json\n{\n  \"options\": {\n    \"rpId\": \"localhost\",\n    \"challenge\": \"…\",\n    \"timeout\": 60000,\n    \"userVerification\": \"preferred\"\n  }\n}\n```\n\n**完全合理**、符合规范，也符合大厂常见做法（本地开发把 `rpId` 设为 `localhost` 没问题，上线要换为你的主域）。\n\n# 4、如果你要“更安全”，只改这几行（前后端各一处）\n\n**后端·验证时强制 UV（把 `false` 改为 `true`）**\n\n```ts\n// 复杂：强制需要本地用户验证（指纹/人脸/PIN）\nrequireUserVerification: true,\n```\n\n> 出现位置：\n>\n> - `verifyRegistrationResponse({...})`\n> - `verifyAuthenticationResponse({...})`\n\n**生成登录 options 时（可选）：把首选项也改为 required**\n\n```ts\n// 复杂：要求认证器执行 UV\nuserVerification: 'required',\n```\n\n> 这两处配合使用，才能做到“名副其实的强制 UV”。\n\n---\n\n# 5、小补充：别名/大小写别差异别担心\n\n- simplewebauthn（v11+）返回的 JSON 用 `rpId`（小写 d）；\n- 你传入 `generateAuthenticationOptions({ rpID: '…' })` 是库的入参写法；\n- **这是正常的**：入参/出参字段命名略有差异，但库会正确映射。\n",
            "url": "https://example.com/posts/需求实现/登录鉴权/preferred是啥",
            "title": "userVerification:",
            "date_modified": "2025-09-08T00:12:36.000Z"
        },
        {
            "id": "https://example.com/posts/需求实现/登录鉴权/test",
            "content_html": "",
            "url": "https://example.com/posts/需求实现/登录鉴权/test",
            "title": "test",
            "date_modified": "2025-09-08T00:19:02.000Z"
        }
    ]
}