import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.oqSrIbQK.js";const E=JSON.parse('{"title":"什么是闭包？——从直觉到 Swift 实战（顺带和 JS 对比）","description":"","frontmatter":{"title":"什么是闭包？——从直觉到 Swift 实战（顺带和 JS 对比）","date":"2025-09-16T00:00:00.000Z","tags":["Swift","闭包","语法","并发","语言基础","教程"]},"headers":[],"relativePath":"posts/swift-advanced-v2/指令/闭包.md","filePath":"posts/swift-advanced-v2/指令/闭包.md","lastUpdated":1758544231000}'),l={name:"posts/swift-advanced-v2/指令/闭包.md"};function h(k,s,p,e,r,d){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h2 id="一句话定义" tabindex="-1">一句话定义 <a class="header-anchor" href="#一句话定义" aria-label="Permalink to &quot;一句话定义&quot;">​</a></h2><p><strong>闭包（Closure）<strong>就是</strong>能“记住”其创建时所在环境的函数值</strong>。它不仅有代码，还<strong>捕获</strong>了周围用到的变量，因此即使这些变量所在的作用域已经结束，闭包仍能访问它们。</p><blockquote><p>换句话说：闭包 = 函数 + 被它用到的“外部变量的快照/引用”（捕获环境）。</p></blockquote><h2 id="swift-中闭包的基本语法" tabindex="-1">Swift 中闭包的基本语法 <a class="header-anchor" href="#swift-中闭包的基本语法" aria-label="Permalink to &quot;Swift 中闭包的基本语法&quot;">​</a></h2><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 完整形态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ (参数列表) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 返回类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 闭包体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简写（可省类型、返回、参数名）：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><blockquote><p>Swift 把<strong>函数也是一等公民</strong>，所以“函数”与“闭包表达式”本质上都是<strong>可以存到变量里、当参数传递、作为返回值</strong>的“可调用值”。</p></blockquote><h2 id="闭包做了什么-捕获-capture" tabindex="-1">闭包做了什么：<strong>捕获（Capture）</strong> <a class="header-anchor" href="#闭包做了什么-捕获-capture" aria-label="Permalink to &quot;闭包做了什么：**捕获（Capture）**&quot;">​</a></h2><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 将被捕获的“自由变量”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // 闭包持有对 n 的访问权</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> makeCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2  （即使 makeCounter 已经返回，n 仍然存在于闭包的捕获环境里）</span></span></code></pre></div><ul><li><strong>自由变量</strong>：在闭包体内使用、但不在闭包参数或局部定义的变量（上例中的 <code>n</code>）。</li><li><strong>生命周期延长</strong>：被捕获的变量会跟着闭包一起活得更久。</li></ul><h2 id="与-javascript-的快速对比" tabindex="-1">与 JavaScript 的快速对比 <a class="header-anchor" href="#与-javascript-的快速对比" aria-label="Permalink to &quot;与 JavaScript 的快速对比&quot;">​</a></h2><ul><li><p>JS 里 <code>function</code>/箭头函数天然是闭包，<strong>捕获的是词法作用域</strong>。</p></li><li><p>Swift 也一样是<strong>词法闭包</strong>，但有<strong>强类型系统</strong>和<strong>值/引用类型</strong>的区别：</p><ul><li>捕获 <code>struct</code> 值时拷贝语义更明确；</li><li>捕获 <code>class</code> 实例默认<strong>强引用</strong>，需要注意循环引用。</li></ul></li></ul><h2 id="swift-的捕获细节与内存管理" tabindex="-1">Swift 的捕获细节与内存管理 <a class="header-anchor" href="#swift-的捕获细节与内存管理" aria-label="Permalink to &quot;Swift 的捕获细节与内存管理&quot;">​</a></h2><h3 id="强-弱-无主引用-防循环引用" tabindex="-1">强/弱/无主引用（防循环引用） <a class="header-anchor" href="#强-弱-无主引用-防循环引用" aria-label="Permalink to &quot;强/弱/无主引用（防循环引用）&quot;">​</a></h3><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handler: (() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 复杂逻辑：异步闭包可能长期存活，这里用 weak 打破强引用环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">weak</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            self</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">doWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>默认<strong>强捕获</strong> <code>self</code> → 容易产生 <code>A -&gt; handler -&gt; 闭包 -&gt; A</code> 的<strong>环</strong>。</li><li>用 <code>[weak self]</code> 或 <code>[unowned self]</code>（更激进，要求生命周期保证）打破环。</li></ul><h3 id="值捕获-vs-引用捕获" tabindex="-1">值捕获 vs 引用捕获 <a class="header-anchor" href="#值捕获-vs-引用捕获" aria-label="Permalink to &quot;值捕获 vs 引用捕获&quot;">​</a></h3><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) }    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 捕获对 x 的访问（变量本身的存储位置）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { [x] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 捕获当时的“值快照”，后续外部修改不影响</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">c1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 42</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">c2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0</span></span></code></pre></div><h2 id="escaping-与非逃逸闭包" tabindex="-1"><code>@escaping</code> 与非逃逸闭包 <a class="header-anchor" href="#escaping-与非逃逸闭包" aria-label="Permalink to &quot;\`@escaping\` 与非逃逸闭包&quot;">​</a></h2><ul><li><strong>非逃逸（默认）</strong>：闭包在函数调用结束前就会执行完，不会被存起来。</li><li><strong>逃逸 <code>@escaping</code></strong>：闭包可能被<strong>异步保存并在稍后执行</strong>，如网络回调、GCD。</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> done: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@escaping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DispatchQueue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">done</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>是否尾随闭包<strong>与逃逸无关</strong>；<code>@escaping</code> 取决于<strong>函数如何使用</strong>闭包。</p></blockquote><h2 id="尾随闭包只是-写法糖-语义不变" tabindex="-1">尾随闭包只是“写法糖”，语义不变 <a class="header-anchor" href="#尾随闭包只是-写法糖-语义不变" aria-label="Permalink to &quot;尾随闭包只是“写法糖”，语义不变&quot;">​</a></h2><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 普通写法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">duration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 多尾随闭包（Swift 5.3+）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">duration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // animations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { finished </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // completion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><strong>尾随闭包</strong>只是把“最后一个闭包参数”移出 <code>()</code>，代码更好读；并不改变执行时机与线程模型。</p></blockquote><h2 id="典型用法" tabindex="-1">典型用法 <a class="header-anchor" href="#典型用法" aria-label="Permalink to &quot;典型用法&quot;">​</a></h2><ul><li><strong>回调/异步</strong>：网络请求、磁盘 IO、GCD。</li><li><strong>函数式链式处理</strong>：<code>map/filter/reduce</code>。</li><li><strong>资源管理</strong>：把“前后处理”打包成闭包式 API。</li><li><strong>构建 DSL</strong>：如 Auto Layout/动画/配置器风格。</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> doubled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 函数式闭包</span></span></code></pre></div><hr><h2 id="性能与可读性建议" tabindex="-1">性能与可读性建议 <a class="header-anchor" href="#性能与可读性建议" aria-label="Permalink to &quot;性能与可读性建议&quot;">​</a></h2><ul><li><strong>能用简写就简写</strong>（类型推断、<code>$0</code>）但别过度；长逻辑请起<strong>具名参数</strong>提升可读性。</li><li><strong>热点路径</strong>避免创建过多短生命周期闭包（尤其是捕获大对象时）。</li><li>异步长期存活的闭包<strong>总是考虑捕获列表</strong>（<code>[weak self]</code>）。</li><li>如需同步等待闭包回调（不推荐），务必<strong>不要在主线程</strong>执行等待。</li></ul><hr><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><ul><li>闭包是<strong>能带着上下文变量一起走的函数值</strong>；这使得<strong>回调、异步、函数式</strong>成为可能。</li><li>Swift 中闭包<strong>默认强捕获</strong>，要用<strong>捕获列表</strong>避免循环引用。</li><li><code>@escaping</code> 描述的是<strong>生命周期</strong>，尾随闭包只是<strong>语法糖</strong>。</li><li>理解“捕获”的本质，就能写出既<strong>优雅</strong>又<strong>安全</strong>的闭包代码。</li></ul>`,33)])])}const o=i(l,[["render",h]]);export{E as __pageData,o as default};
