import{_ as e,c as i,o as a,ag as r}from"./chunks/framework.oqSrIbQK.js";const g=JSON.parse('{"title":"Chrome 为何“一个标签 100% CPU 卡死，其他标签却很顺”？——多进程与调度的真相","description":"这一篇从官方文档出发，系统解释 Chrome 的多进程模型、渲染线程结构、事件循环与长任务、后台节流与冻结、GPU 共享进程等；并给出可复制的最小演示与排障步骤，帮助你从根因上理解“为何一个标签会卡死而不拖累其它标签”。","frontmatter":{"title":"Chrome 为何“一个标签 100% CPU 卡死，其他标签却很顺”？——多进程与调度的真相","date":"2025-11-10T00:00:00.000Z","tags":["浏览器内核与性能","性能","Chrome","多进程","渲染器"],"description":"这一篇从官方文档出发，系统解释 Chrome 的多进程模型、渲染线程结构、事件循环与长任务、后台节流与冻结、GPU 共享进程等；并给出可复制的最小演示与排障步骤，帮助你从根因上理解“为何一个标签会卡死而不拖累其它标签”。"},"headers":[],"relativePath":"posts/web应用开发/工具/Chrome 为何“一个标签 100% CPU 卡死，其他标签却很顺”？——多进程与调度的真相.md","filePath":"posts/web应用开发/工具/Chrome 为何“一个标签 100% CPU 卡死，其他标签却很顺”？——多进程与调度的真相.md","lastUpdated":1764331727000}'),t={name:"posts/web应用开发/工具/Chrome 为何“一个标签 100% CPU 卡死，其他标签却很顺”？——多进程与调度的真相.md"};function n(h,s,l,o,p,k){return a(),i("div",null,[...s[0]||(s[0]=[r(`<h2 id="概览-读者收益" tabindex="-1">概览（读者收益） <a class="header-anchor" href="#概览-读者收益" aria-label="Permalink to &quot;概览（读者收益）&quot;">​</a></h2><ul><li>明确 <strong>“一个标签卡死 ≠ 整机满核”</strong>：大多数卡顿是该标签 <strong>渲染进程的主线程</strong> 被长任务堵住，OS 不能把“一个线程里的活”拆给多核并行。其它标签在其它渲染进程里，互不阻塞。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li>了解 <strong>Chrome 多进程 + 站点隔离</strong> 如何实现跨标签/跨站的性能与故障隔离。(<a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/?utm_source=chatgpt.com" title="Multi-process Architecture" target="_blank" rel="noreferrer">chromium.org</a>)</li><li>掌握 <strong>后台标签节流/冻结</strong>、<strong>GPU 共享进程的影响</strong>、以及 <strong>开发者侧的避坑与优化手段</strong>（<code>scheduler.yield</code>、<code>scheduler.postTask</code>、Web Workers、OffscreenCanvas、WASM 线程）。(<a href="https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html?utm_source=chatgpt.com" title="Tab throttling and more performance improvements in ..." target="_blank" rel="noreferrer">Chromium Blog</a>)</li></ul><hr><h2 id="整体思路" tabindex="-1">整体思路 <a class="header-anchor" href="#整体思路" aria-label="Permalink to &quot;整体思路&quot;">​</a></h2><ol><li><strong>架构层面</strong>：Chrome 把浏览器拆成 Browser、GPU、Network 和「大量 Renderer」。默认一个站点（含跨站 iframe 时可能更多）对应一个或数个 <strong>渲染进程</strong>，从根上隔离卡顿与崩溃。(<a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/?utm_source=chatgpt.com" title="Multi-process Architecture" target="_blank" rel="noreferrer">chromium.org</a>)</li><li><strong>进程内侧</strong>：<strong>渲染进程只有一个主线程</strong> 负责 JS/样式/布局；还有 <strong>合成线程</strong>、<strong>栅格线程</strong>、V8 后台线程等，动画/滚动可在合成线程保持一定流畅，但遇到需要主线程参与的工作仍会卡。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>调度与限流</strong>：前台优先用户输入/动画；后台标签的定时器被强力节流（M87 起 <strong>每分钟 1 次唤醒</strong>），并可进一步 <strong>冻结</strong>。(<a href="https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html?utm_source=chatgpt.com" title="Tab throttling and more performance improvements in ..." target="_blank" rel="noreferrer">Chromium Blog</a>)</li></ol><hr><h2 id="原理详解" tabindex="-1">原理详解 <a class="header-anchor" href="#原理详解" aria-label="Permalink to &quot;原理详解&quot;">​</a></h2><h3 id="_1-多进程与站点隔离-为什么别的标签不受影响" tabindex="-1">1）多进程与站点隔离：为什么别的标签不受影响 <a class="header-anchor" href="#_1-多进程与站点隔离-为什么别的标签不受影响" aria-label="Permalink to &quot;1）多进程与站点隔离：为什么别的标签不受影响&quot;">​</a></h3><ul><li>Chrome 的 <strong>多进程架构</strong>：Browser（主控/UI/权限）、<strong>Renderer（每站点/站点实例）</strong>、<strong>GPU（全局共享）</strong>、Network（网络服务）。某个标签卡死，通常局限在它的渲染进程，不会拖垮其它标签的渲染进程。(<a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/?utm_source=chatgpt.com" title="Multi-process Architecture" target="_blank" rel="noreferrer">chromium.org</a>)</li><li><strong>站点隔离（Site Isolation）</strong> 进一步把跨站 iframe 拆到不同渲染进程，实现更强隔离与安全。(<a href="https://chromium.googlesource.com/chromium/src/%2B/main/docs/process_model_and_site_isolation.md?utm_source=chatgpt.com" title="Chromium Docs - Process Model and Site Isolation" target="_blank" rel="noreferrer">Chromium</a>)</li></ul><h3 id="_2-渲染器内部-主线程为何会把-cpu「吃满」" tabindex="-1">2）渲染器内部：主线程为何会把 CPU「吃满」 <a class="header-anchor" href="#_2-渲染器内部-主线程为何会把-cpu「吃满」" aria-label="Permalink to &quot;2）渲染器内部：主线程为何会把 CPU「吃满」&quot;">​</a></h3><ul><li><strong>主线程（Main thread）</strong>：执行 JS、样式计算、布局、部分绘制准备，是交互是否卡顿的关键。<strong>一个渲染进程只有一个主线程</strong>。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>合成线程（Compositor）</strong>：在不依赖主线程的情况下可处理输入、合成滚动、层合成，减轻卡顿表象；但遇到需要主线程参与的布局/脚本时依然卡。(<a href="https://www.chromium.org/developers/design-documents/compositor-thread-architecture/?utm_source=chatgpt.com" title="Compositor Thread Architecture" target="_blank" rel="noreferrer">chromium.org</a>)</li><li><strong>事件循环与长任务</strong>：超过 50ms 的任务记为 <strong>Long Task</strong>，会堵住输入、动画帧回调等，DevTools 有明确标注与定位方法。(<a href="https://developer.chrome.com/docs/devtools/performance?utm_source=chatgpt.com" title="Analyze runtime performance | Chrome DevTools" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li></ul><h3 id="_3-多核为什么救不了一个卡死的标签" tabindex="-1">3）“多核为什么救不了一个卡死的标签？” <a class="header-anchor" href="#_3-多核为什么救不了一个卡死的标签" aria-label="Permalink to &quot;3）“多核为什么救不了一个卡死的标签？”&quot;">​</a></h3><ul><li>OS 能把 <strong>线程</strong> 调度到任意核心，但<strong>无法把单个线程的同步计算自动拆分</strong>到多核并行；你的长 JS/布局任务若不主动拆分或并行化，就只能<strong>吃满一个核心</strong>。解决在于 <strong>把工作分出去</strong>（Worker/WASM 线程）或 <strong>切片让路</strong>（<code>scheduler.yield</code>/<code>postTask</code>）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Scheduler/postTask?utm_source=chatgpt.com" title="Scheduler: postTask() method - Web APIs - MDN Web Docs" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><h3 id="_4-后台标签的节流-冻结规则" tabindex="-1">4）后台标签的节流/冻结规则 <a class="header-anchor" href="#_4-后台标签的节流-冻结规则" aria-label="Permalink to &quot;4）后台标签的节流/冻结规则&quot;">​</a></h3><ul><li><strong>M87 起</strong>：后台标签 <strong>JS 定时器唤醒降到每分钟 1 次</strong>，实测可把 CPU 降至原来的 1/5，显著省电。(<a href="https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html?utm_source=chatgpt.com" title="Tab throttling and more performance improvements in ..." target="_blank" rel="noreferrer">Chromium Blog</a>)</li><li><strong>更激进的“链式定时器”节流</strong>：Chrome 88 对长时间隐藏页面的连续定时器进一步限制，防止“假活跃”。(<a href="https://developer.chrome.com/blog/timer-throttling-in-chrome-88?utm_source=chatgpt.com" title="Heavy throttling of chained JS timers beginning in Chrome 88" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li></ul><h3 id="_5-例外-gpu-共享进程可能造成跨标签抖动" tabindex="-1">5）例外：GPU 共享进程可能造成跨标签抖动 <a class="header-anchor" href="#_5-例外-gpu-共享进程可能造成跨标签抖动" aria-label="Permalink to &quot;5）例外：GPU 共享进程可能造成跨标签抖动&quot;">​</a></h3><ul><li><strong>GPU 进程是共享的</strong>。若某标签发起极重的 WebGL/Canvas/GPU 工作，GPU 排队与同步会让别的标签渲染任务等待，出现跨标签掉帧。(<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/?utm_source=chatgpt.com" title="GPU Accelerated Compositing in Chrome" target="_blank" rel="noreferrer">chromium.org</a>)</li></ul><hr><h2 id="典型-卡死-根因清单-对照排查" tabindex="-1">典型“卡死”根因清单（对照排查） <a class="header-anchor" href="#典型-卡死-根因清单-对照排查" aria-label="Permalink to &quot;典型“卡死”根因清单（对照排查）&quot;">​</a></h2><ul><li>主线程长任务（死循环、巨量同步计算、密集 DOM 操作）。(<a href="https://developer.chrome.com/docs/devtools/performance?utm_source=chatgpt.com" title="Analyze runtime performance | Chrome DevTools" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li>强制同步布局/大面积重排/重绘卡在主线程。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li>背景页仍在高频定时器/轮询（被节流但仍可能干扰唤醒时序）。(<a href="https://developer.chrome.com/blog/background_tabs?utm_source=chatgpt.com" title="Background tabs in chrome 57 | Blog" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li>GPU 侧的长栅格/绘制或 WebGL 调用导致的排队。(<a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome/?utm_source=chatgpt.com" title="GPU Accelerated Compositing in Chrome" target="_blank" rel="noreferrer">chromium.org</a>)</li></ul><hr><h2 id="最小演示-可拷贝-阻塞-vs-让路-vs-真并行" tabindex="-1">最小演示（可拷贝）：阻塞 vs. 让路 vs. 真并行 <a class="header-anchor" href="#最小演示-可拷贝-阻塞-vs-让路-vs-真并行" aria-label="Permalink to &quot;最小演示（可拷贝）：阻塞 vs. 让路 vs. 真并行&quot;">​</a></h2><blockquote><p>目标：体验“一个核被吃满”和“切片/并行化后恢复交互”的区别。</p></blockquote><h3 id="a-阻塞主线程-请勿在线上使用" tabindex="-1">A. 阻塞主线程（请勿在线上使用） <a class="header-anchor" href="#a-阻塞主线程-请勿在线上使用" aria-label="Permalink to &quot;A. 阻塞主线程（请勿在线上使用）&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;block&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;阻塞5秒&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;block&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> t0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 下面这行是“长任务”示例：忙等 5 秒，完全堵住主线程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阻塞事件循环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><blockquote><p>打开 DevTools Performance 录制，你会看到主线程一整条长任务，伴随红三角告警。(<a href="https://developer.chrome.com/docs/devtools/performance?utm_source=chatgpt.com" title="Analyze runtime performance | Chrome DevTools" target="_blank" rel="noreferrer">Chrome for Developers</a>)</p></blockquote><h3 id="b-切片让路-scheduler-yield-自动继承优先级" tabindex="-1">B. 切片让路（<code>scheduler.yield</code>，自动继承优先级） <a class="header-anchor" href="#b-切片让路-scheduler-yield-自动继承优先级" aria-label="Permalink to &quot;B. 切片让路（\`scheduler.yield\`，自动继承优先级）&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> heavyWorkChunked</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">total</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10_000_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    acc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在复杂逻辑前切片，让出主线程处理输入/渲染</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0x3fff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (self.scheduler?.yield</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scheduler.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">yield</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r)));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acc;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><code>scheduler.yield()</code> 由浏览器调度优先处理用户关键任务，再延续你的计算；不支持的浏览器回退到 <code>setTimeout</code>。(<a href="https://developer.chrome.com/blog/use-scheduler-yield?utm_source=chatgpt.com" title="Use scheduler.yield() to break up long tasks | Blog" target="_blank" rel="noreferrer">Chrome for Developers</a>)</p></blockquote><h3 id="c-真并行-把重计算丢进-worker-可配合-offscreencanvas" tabindex="-1">C. 真并行：把重计算丢进 Worker（可配合 OffscreenCanvas） <a class="header-anchor" href="#c-真并行-把重计算丢进-worker-可配合-offscreencanvas" aria-label="Permalink to &quot;C. 真并行：把重计算丢进 Worker（可配合 OffscreenCanvas）&quot;">​</a></h3><p><strong>main.js</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./worker.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：把大数组交给 worker 并传输所有权，避免拷贝</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> buf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5_000_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">w.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ buf }, [buf]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">w.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;结果&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, e.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><strong>worker.js</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> view</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint32Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.data.buf);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在 worker 线程里做重计算，不阻塞页面主线程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> view.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> view[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><strong>OffscreenCanvas（可选，主线程仍流畅滚动/输入）</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 把 &lt;canvas&gt; 控制权转移给 worker</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> offscreen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;canvas&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transferControlToOffscreen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">w.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ canvas: offscreen }, [offscreen]);</span></span></code></pre></div><blockquote><p>Web Workers 把 JS 任务搬到独立线程执行；OffscreenCanvas 允许在 worker 中绘图；两者组合能显著降低主线程压力。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API?utm_source=chatgpt.com" title="Web Workers API - Web APIs | MDN" target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></blockquote><h3 id="d-极限并行-wasm-线程-适合重数值-图像-视频" tabindex="-1">D. 极限并行：WASM 线程（适合重数值/图像/视频） <a class="header-anchor" href="#d-极限并行-wasm-线程-适合重数值-图像-视频" aria-label="Permalink to &quot;D. 极限并行：WASM 线程（适合重数值/图像/视频）&quot;">​</a></h3><blockquote><p>通过 Emscripten/工具链开启 <strong>WebAssembly Threads</strong>，借助 <code>SharedArrayBuffer + Atomics</code> 在多个 Worker 上真正并行执行。需满足跨域隔离头（COOP/COEP）。(<a href="https://web.dev/articles/webassembly-threads?utm_source=chatgpt.com" title="Using WebAssembly threads from C, C++ and Rust | Articles" target="_blank" rel="noreferrer">web.dev</a>)</p></blockquote><hr><h2 id="排障步骤-实战清单" tabindex="-1">排障步骤（实战清单） <a class="header-anchor" href="#排障步骤-实战清单" aria-label="Permalink to &quot;排障步骤（实战清单）&quot;">​</a></h2><ol><li><strong>录制性能</strong>：DevTools → Performance，确认是否为 <strong>主线程长任务</strong>；注意长任务红三角与火焰图热点。(<a href="https://developer.chrome.com/docs/devtools/performance?utm_source=chatgpt.com" title="Analyze runtime performance | Chrome DevTools" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>分离重活</strong>：能 Worker 的尽量 Worker；像素/绘制走 OffscreenCanvas；大对象用 <strong>可转移对象</strong>（ArrayBuffer/OffscreenCanvas）避免拷贝。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker?utm_source=chatgpt.com" title="Worker - Web APIs - MDN Web Docs" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><strong>切片让路</strong>：用 <code>scheduler.yield()</code> 或 <code>scheduler.postTask({ priority })</code> 把同步循环拆成微批次。(<a href="https://developer.chrome.com/blog/use-scheduler-yield?utm_source=chatgpt.com" title="Use scheduler.yield() to break up long tasks | Blog" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>检查 GPU 路径</strong>：WebGL/Canvas 动画掉帧时同时看 <strong>GPU 进程</strong> 与合成阶段（“Life of a Pixel”、“cc 流程”文档有助定位）。(<a href="https://www.chromium.org/developers/design-documents/chromium-graphics/?utm_source=chatgpt.com" title="Chromium Graphics // Chrome GPU" target="_blank" rel="noreferrer">chromium.org</a>)</li><li><strong>后台策略</strong>：确认是否被 <strong>后台节流/冻结</strong> 影响期望行为（例如依赖 setInterval 的后台轮询）。(<a href="https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html?utm_source=chatgpt.com" title="Tab throttling and more performance improvements in ..." target="_blank" rel="noreferrer">Chromium Blog</a>)</li></ol><hr><h2 id="faq" tabindex="-1">FAQ <a class="header-anchor" href="#faq" aria-label="Permalink to &quot;FAQ&quot;">​</a></h2><p><strong>Q：任务管理器里看到“CPU 100%”，为何还有别的核心空闲？</strong> A：这通常表示 <strong>某个线程</strong>（多为该标签渲染进程的主线程）把一个核心打满。OS 不会把单个线程的同步计算自动拆到多个核心上；要么切片（<code>scheduler.yield/postTask</code>），要么并行（Worker/WASM 线程）。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</p><p><strong>Q：为什么这个标签卡了，别的标签还流畅？</strong> A：因为它们在 <strong>不同的渲染进程</strong>，互不阻塞；只有共享的 <strong>GPU 进程</strong> 在极端情况下会造成跨标签抖动。(<a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/?utm_source=chatgpt.com" title="Multi-process Architecture" target="_blank" rel="noreferrer">chromium.org</a>)</p><p><strong>Q：后台页为什么“像睡着了一样”？</strong> A：Chrome 为省电与降噪，对后台标签的 <strong>JS 定时器</strong> 进行强节流（M87 起 <strong>1 分钟 1 次</strong>），并在更长时间后可能 <strong>冻结</strong>。这是浏览器层的策略，并非你的代码 bug。(<a href="https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html?utm_source=chatgpt.com" title="Tab throttling and more performance improvements in ..." target="_blank" rel="noreferrer">Chromium Blog</a>)</p><hr><h2 id="参考与延伸" tabindex="-1">参考与延伸 <a class="header-anchor" href="#参考与延伸" aria-label="Permalink to &quot;参考与延伸&quot;">​</a></h2><ul><li><strong>多进程架构 / 站点隔离</strong>：Chromium Design Docs；Process Model 与 Site Isolation 论文/说明；Chrome for Developers 站点隔离解读。(<a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/?utm_source=chatgpt.com" title="Multi-process Architecture" target="_blank" rel="noreferrer">chromium.org</a>)</li><li><strong>RenderingNG / 线程与合成</strong>：RenderingNG 架构、Compositor Thread、Life of a Pixel / cc 文档。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>长任务识别</strong>：DevTools Performance 指南、参考文档。(<a href="https://developer.chrome.com/docs/devtools/performance?utm_source=chatgpt.com" title="Analyze runtime performance | Chrome DevTools" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>任务调度 API</strong>：<code>scheduler.yield</code>（Chrome 官方博客）、<code>scheduler.postTask</code>（MDN）、长任务优化文章。(<a href="https://developer.chrome.com/blog/use-scheduler-yield?utm_source=chatgpt.com" title="Use scheduler.yield() to break up long tasks | Blog" target="_blank" rel="noreferrer">Chrome for Developers</a>)</li><li><strong>后台节流与冻结</strong>：M87 背景定时器“每分钟 1 次”公告、Chrome 88 定时器“密集节流”。(<a href="https://blog.chromium.org/2020/11/tab-throttling-and-more-performance.html?utm_source=chatgpt.com" title="Tab throttling and more performance improvements in ..." target="_blank" rel="noreferrer">Chromium Blog</a>)</li><li><strong>Workers / OffscreenCanvas / WASM 线程</strong>：MDN 文档与 web.dev 教程。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API?utm_source=chatgpt.com" title="Web Workers API - Web APIs | MDN" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><hr><h2 id="尾声" tabindex="-1">尾声 <a class="header-anchor" href="#尾声" aria-label="Permalink to &quot;尾声&quot;">​</a></h2><p>一句话打包：<strong>Chrome 用多进程把标签隔离；每个渲染进程只有一个主线程，卡顿多半是它被长任务堵住——这不是“多核不给力”，而是“你的活没拆开”</strong>。前台用 <strong>切片 + 优先级调度</strong> 保交互，后台有 <strong>节流/冻结</strong> 防滥用；重活交给 <strong>Worker/OffscreenCanvas/WASM 线程</strong>，才能真正把多核吃起来。(<a href="https://developer.chrome.com/docs/chromium/renderingng-architecture?utm_source=chatgpt.com" title="RenderingNG architecture | Chromium - Chrome for Developers" target="_blank" rel="noreferrer">Chrome for Developers</a>)</p>`,53)])])}const d=e(t,[["render",n]]);export{g as __pageData,d as default};
