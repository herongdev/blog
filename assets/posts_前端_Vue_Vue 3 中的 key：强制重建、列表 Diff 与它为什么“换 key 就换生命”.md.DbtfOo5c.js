import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.oqSrIbQK.js";const g=JSON.parse('{"title":"Vue 3 中的 key：强制重建、列表 Diff 与它为什么“换 key 就换生命”","description":"","frontmatter":{"title":"Vue 3 中的 `key`：强制重建、列表 Diff 与它为什么“换 key 就换生命”","date":"2025-09-12T00:00:00.000Z","tags":["Vue","Virtual DOM","Diff算法"]},"headers":[],"relativePath":"posts/前端/Vue/Vue 3 中的 key：强制重建、列表 Diff 与它为什么“换 key 就换生命”.md","filePath":"posts/前端/Vue/Vue 3 中的 key：强制重建、列表 Diff 与它为什么“换 key 就换生命”.md","lastUpdated":1758475234000}'),n={name:"posts/前端/Vue/Vue 3 中的 key：强制重建、列表 Diff 与它为什么“换 key 就换生命”.md"};function l(h,s,o,k,r,d){return t(),a("div",null,[...s[0]||(s[0]=[e(`<h2 id="摘要" tabindex="-1">摘要 <a class="header-anchor" href="#摘要" aria-label="Permalink to &quot;摘要&quot;">​</a></h2><p><code>key</code> 在 Vue 3 里不仅仅用于 <code>v-for</code>。当我们在<strong>同一个位置</strong>渲染<strong>同一种类型的节点/组件</strong>时，只要 <code>key</code> 改变，Vue 会把它当作<strong>全新的节点</strong>处理：旧的被卸载（unmount），新的被创建并挂载（mount）。</p><h2 id="一、核心用法速记" tabindex="-1">一、核心用法速记 <a class="header-anchor" href="#一、核心用法速记" aria-label="Permalink to &quot;一、核心用法速记&quot;">​</a></h2><ul><li><strong>列表 Diff 标识</strong>：<code>v-for</code> 时用 <code>:key</code> 唯一标识每一项，避免错误复用。</li><li><strong>强制重建组件</strong>：同一位置渲染相同组件，切换 <code>key</code> 会触发卸载+新建，从而清空内部状态与副作用。</li><li><strong>配合 <code>Transition</code>/动画</strong>：不同 <code>key</code> 驱动进入/离场。</li><li><strong>避免状态串味</strong>：表单、第三方控件、复杂内部 state 场景尤佳。</li></ul><p><strong>示例（强制重置 <code>SLTPField</code>）：</strong></p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 复杂逻辑：用 tradeSide 作为 key，切换买/卖将卸载旧实例并创建新实例 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">SLTPField</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\`tp-\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tradeSide</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state.tpValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sltpConfig</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><h2 id="二、为什么-换-key-就换生命-——框架底层怎么做的" tabindex="-1">二、为什么“换 key 就换生命”——框架底层怎么做的？ <a class="header-anchor" href="#二、为什么-换-key-就换生命-——框架底层怎么做的" aria-label="Permalink to &quot;二、为什么“换 key 就换生命”——框架底层怎么做的？&quot;">​</a></h2><h3 id="_2-1-diff-的入口与-同-不同节点-判定" tabindex="-1">2.1 Diff 的入口与“同/不同节点”判定 <a class="header-anchor" href="#_2-1-diff-的入口与-同-不同节点-判定" aria-label="Permalink to &quot;2.1 Diff 的入口与“同/不同节点”判定&quot;">​</a></h3><ul><li><p>Vue 3 渲染更新的核心在 <code>patch(oldVNode, newVNode, container, …)</code>。</p></li><li><p><strong>是否可复用</strong>的第一步检查：<strong>类型 + <code>key</code></strong>。</p><ul><li><strong>类型相同且 <code>key</code> 相同</strong> ⇒ 视为“同一个节点”，执行<strong>就地更新</strong>（props/children/patch）。</li><li><strong>类型不同或 <code>key</code> 不同</strong> ⇒ 视为“不同节点”，<strong>卸载旧的 → 挂载新的</strong>。</li></ul></li><li><p>组件也是节点（<code>type</code> 为组件选项/函数），因此<strong>组件 <code>key</code> 变了 = 不是同一个组件实例</strong>。</p></li></ul><blockquote><p>直观理解：Vue 用 <code>(type, key)</code> 这对“身份证”给每个 VNode 编号。身份证换了，就不是同一个人了；必须办离职（unmount）+新入职（mount）。</p></blockquote><h3 id="_2-2-列表场景的-带-key-diff" tabindex="-1">2.2 列表场景的“带 Key Diff” <a class="header-anchor" href="#_2-2-列表场景的-带-key-diff" aria-label="Permalink to &quot;2.2 列表场景的“带 Key Diff”&quot;">​</a></h3><ul><li><p>子节点为数组时，Vue 3 进入 <strong><code>patchKeyedChildren</code></strong> 分支（带 Key 的比较）。</p></li><li><p>主要步骤（高层次）：</p><ol><li><strong>头尾双指针</strong>：从两端向中间跳过相同 <code>type+key</code> 的项（O(n)）。</li><li><strong>中段映射</strong>：为新列表的剩余部分建立 <code>key → 索引</code> 映射，定位旧项在新列表中的位置。</li><li><strong>构建“新索引数组”</strong>：按旧列表顺序映射到新列表索引。</li><li><strong>最长递增子序列（LIS）</strong>：在“新索引数组”上求 LIS，<strong>LIS 之外的需要移动或新建</strong>，最少 DOM 移动。</li><li><strong>卸载不存在于新列表的旧项</strong>，<strong>挂载新出现的项</strong>。</li></ol></li><li><p><strong>结论</strong>：<code>key</code> 是列表最小变更的锚点。缺失或错误的 <code>key</code> 会导致不必要的卸载/复用，出现“错位更新”“状态串味”。</p></li></ul><h3 id="_2-3-单节点-同位置的-换-key-强制重建" tabindex="-1">2.3 单节点/同位置的“换 Key 强制重建” <a class="header-anchor" href="#_2-3-单节点-同位置的-换-key-强制重建" aria-label="Permalink to &quot;2.3 单节点/同位置的“换 Key 强制重建”&quot;">​</a></h3><ul><li><p>不在列表、而是<strong>同一个占位位置</strong>渲染<strong>相同类型</strong>的组件/元素时：</p><ul><li><code>key</code> 不同 ⇒ <code>patch</code> 直接<strong>判定不同节点</strong> ⇒ 走<strong>完全卸载</strong>（销毁副作用、移除 DOM、触发生命周期/指令解绑）⇒ 再<strong>创建新实例并挂载</strong>（重新跑 <code>setup</code>/<code>onMounted</code> 等）。</li></ul></li><li><p><strong>副作用</strong>：表单状态、内部 <code>ref</code>、watchers、计时器、第三方实例等全部被清空重来——这正是“重置”的本质。</p></li></ul><hr><h2 id="三、这对我们有什么实际影响" tabindex="-1">三、这对我们有什么实际影响？ <a class="header-anchor" href="#三、这对我们有什么实际影响" aria-label="Permalink to &quot;三、这对我们有什么实际影响？&quot;">​</a></h2><h3 id="_3-1-想-重置-子组件-就给它一个会变的-key" tabindex="-1">3.1 想“重置”子组件，就给它一个会变的 <code>key</code> <a class="header-anchor" href="#_3-1-想-重置-子组件-就给它一个会变的-key" aria-label="Permalink to &quot;3.1 想“重置”子组件，就给它一个会变的 \`key\`&quot;">​</a></h3><ul><li>例如方向切换时，<code>SLTPField</code> 的默认区间、步长、校验逻辑可能随 <code>side</code> 不同。</li><li>用 <code>:key=&quot;state.tradeSide&quot;</code> 最简单，<strong>无需在子组件里写一堆重置逻辑</strong>。</li></ul><h3 id="_3-2-避免错误复用-状态污染" tabindex="-1">3.2 避免错误复用 &amp; 状态污染 <a class="header-anchor" href="#_3-2-避免错误复用-状态污染" aria-label="Permalink to &quot;3.2 避免错误复用 &amp; 状态污染&quot;">​</a></h3><ul><li><code>v-for</code> 场景必须用<strong>稳定且唯一</strong>的 <code>key</code>（如业务唯一 ID），不要用索引。</li><li>表单行交换、拖拽排序、切页缓存等，<code>key</code> 错了，会出现“值跟着 DOM 走”的诡异问题。</li></ul><h3 id="_3-3-性能与正确性的权衡" tabindex="-1">3.3 性能与正确性的权衡 <a class="header-anchor" href="#_3-3-性能与正确性的权衡" aria-label="Permalink to &quot;3.3 性能与正确性的权衡&quot;">​</a></h3><ul><li><strong>频繁更换 <code>key</code> = 频繁销毁/重建</strong>，有成本。</li><li>若只是 props 变化且<strong>希望保留内部状态</strong>，就不要改 <code>key</code>，让组件<strong>就地更新</strong>。</li></ul><hr><h2 id="四、典型模式与反模式" tabindex="-1">四、典型模式与反模式 <a class="header-anchor" href="#四、典型模式与反模式" aria-label="Permalink to &quot;四、典型模式与反模式&quot;">​</a></h2><h3 id="✅-推荐" tabindex="-1">✅ 推荐 <a class="header-anchor" href="#✅-推荐" aria-label="Permalink to &quot;✅ 推荐&quot;">​</a></h3><ul><li>列表：<code>v-for=&quot;item in list&quot; :key=&quot;item.id&quot;</code></li><li>强制重建：<code>&lt;Widget :key=&quot;mode&quot; :config=&quot;cfg&quot; /&gt;</code></li><li>动画过渡：<code>&lt;Transition&gt; &lt;Comp :key=&quot;step&quot; /&gt; &lt;/Transition&gt;</code></li></ul><h3 id="❌-避免" tabindex="-1">❌ 避免 <a class="header-anchor" href="#❌-避免" aria-label="Permalink to &quot;❌ 避免&quot;">​</a></h3><ul><li>用数组索引当 <code>key</code>（除非纯静态列表且不会重排）。</li><li>在需要保留内部状态的组件上滥用变更 <code>key</code>。</li></ul><hr><h2 id="五、最小示例" tabindex="-1">五、最小示例 <a class="header-anchor" href="#五、最小示例" aria-label="Permalink to &quot;五、最小示例&quot;">​</a></h2><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;side = side === &#39;buy&#39; ? &#39;sell&#39; : &#39;buy&#39;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      切换方向：{{ side }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    &lt;!-- 复杂逻辑：key 绑定 side，触发强制重建以重置内部状态 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">PriceEditor</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;side&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :side</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;side&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> side</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;buy&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;sell&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;buy&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li><code>PriceEditor</code> 内部可能在 <code>onMounted</code> 里读取 <code>side</code> 计算初始值、建立订阅等。</li><li>当 <code>side</code> 改变时，<code>PriceEditor</code> 被<strong>卸载</strong>并<strong>以新 props 新状态重建</strong>。</li></ul><hr><h2 id="六、和-响应式就地更新-有什么区别" tabindex="-1">六、和“响应式就地更新”有什么区别？ <a class="header-anchor" href="#六、和-响应式就地更新-有什么区别" aria-label="Permalink to &quot;六、和“响应式就地更新”有什么区别？&quot;">​</a></h2><ul><li><strong>就地更新（同 key）</strong>：组件实例 <strong>不变</strong>，只触发 <code>props</code>、<code>render</code>、<code>watch</code> 等更新，<strong>内部状态保留</strong>。</li><li><strong>重建（换 key）</strong>：旧实例 <strong>销毁</strong>，新实例 <strong>创建</strong>，生命周期完整走一遍，<strong>内部状态重置</strong>。</li></ul><blockquote><p>选择标准：<strong>你是要“换皮”还是要“换命”</strong>？ 换皮 ⇒ 不改 <code>key</code>；换命 ⇒ 改 <code>key</code>。</p></blockquote><hr><h2 id="七、与生态配合的注意点" tabindex="-1">七、与生态配合的注意点 <a class="header-anchor" href="#七、与生态配合的注意点" aria-label="Permalink to &quot;七、与生态配合的注意点&quot;">​</a></h2><ul><li>第三方控件（图表、编辑器、地图）常有复杂内部状态，<strong>改 key</strong> 往往是最稳妥的“清场重来”。</li><li>但在<strong>高频切换</strong>或<strong>大体量控件</strong>场景，优先评估是否可以<strong>参数化就地更新</strong>以节流开销。</li></ul><hr><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><ul><li><code>key</code> 是 Vue 3 Diff 的<strong>身份标签</strong>。</li><li><strong>类型一致 + <code>key</code> 一致</strong> ⇒ 就地更新；<strong>类型或 <code>key</code> 不一致</strong> ⇒ 卸载重建。</li><li>正确使用 <code>key</code> 能避免列表错位、消除状态串味；在需要“重置组件”的场景，<strong>改变 <code>key</code> 是最简单且可靠的办法</strong>。</li></ul><p>如需把上面的强制重建模式落到你的交易面板，只需保证：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">SLTPField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\`tp-\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tradeSide</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">SLTPField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\`sl-\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">state</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tradeSide</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... /&gt;</span></span></code></pre></div><p>即可在切换买/卖时，让两个子组件<strong>以新方向的配置完全初始化</strong>。</p>`,45)])])}const E=i(n,[["render",l]]);export{g as __pageData,E as default};
