import{_ as i,c as a,o as t,ag as n}from"./chunks/framework.oqSrIbQK.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/前端/常用库/tanstack更新.md","filePath":"posts/前端/常用库/tanstack更新.md","lastUpdated":1757689476000}'),e={name:"posts/前端/常用库/tanstack更新.md"};function l(h,s,k,p,r,d){return t(),a("div",null,[...s[0]||(s[0]=[n(`<p>结论先说： 在 <strong>@tanstack/vue-table v8.20+</strong> 中，<code>useVueTable</code> 的 <code>data</code> 是按 <strong>shallowRef（浅层响应）</strong> 来处理的——<strong>只侦听 <code>ref</code> 的 <code>.value</code> 本身是否换了新引用</strong>。因此：</p><ul><li><strong>改数组元素的属性</strong>（例如把某一行的 “报价” 改价）——<strong>需要让 <code>dataRef.value</code> 指向一个</strong>新的数组引用，表格才会进行必要的重算/渲染。</li><li><strong>增删元素</strong>（push/pop/splice）这种<strong>原地修改</strong>不会更换数组引用，表格<strong>不会</strong>感知，需要<strong>重建一个新数组再赋回 <code>dataRef.value</code></strong>。</li><li>官方文档在 “Using Reactive Data” 专章明确说明了这一点，并给了示例：<code>dataRef.value.push(...)</code> 不会更新；<code>dataRef.value = [...dataRef.value, ...]</code> 才会更新。(<a href="https://tanstack.com/table/latest/docs/framework/vue/guide/table-state" title="Table State (Vue) Guide | TanStack Table Vue Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</li></ul><hr><h2 id="为什么必须-换引用" tabindex="-1">为什么必须“换引用”？ <a class="header-anchor" href="#为什么必须-换引用" aria-label="Permalink to &quot;为什么必须“换引用”？&quot;">​</a></h2><ul><li>适配层用 <strong>shallowRef</strong> 做了性能优化：<strong>不追踪深层变动</strong>（数组内部元素或其字段的改动），<strong>只在 <code>.value</code> 指向新引用时</strong>触发表格的行模型/排序/过滤等重算。</li><li>TanStack Table 也明确：<strong>当 <code>data/columns</code> 的引用变了</strong>，或表格内部 state 变了，就会触发更新；而<strong>稳定引用</strong>避免无谓的重建/循环渲染。(<a href="https://tanstack.com/table/latest/docs/faq?utm_source=chatgpt.com" title="FAQ | TanStack Table Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</li></ul><hr><h2 id="实战建议-vue-3" tabindex="-1">实战建议（Vue 3） <a class="header-anchor" href="#实战建议-vue-3" aria-label="Permalink to &quot;实战建议（Vue 3）&quot;">​</a></h2><h3 id="_1-更新单行-报价-字段-不可变更新" tabindex="-1">1）更新单行“报价”字段（不可变更新） <a class="header-anchor" href="#_1-更新单行-报价-字段-不可变更新" aria-label="Permalink to &quot;1）更新单行“报价”字段（不可变更新）&quot;">​</a></h3><blockquote><p>逻辑：按 id 找到目标行 → 复制出一个新数组 → 用新对象替换该行 → 把<strong>新数组</strong>赋回 <code>dataRef.value</code></p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在复杂逻辑上一行加注释：不可变更新，生成新数组引用以触发表格重算</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updatePriceById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">price</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> indexById.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataRef.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next[idx] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next[idx], price };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dataRef.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← 必须换引用，shallowRef 才会触发更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-新增-删除一行" tabindex="-1">2）新增 / 删除一行 <a class="header-anchor" href="#_2-新增-删除一行" aria-label="Permalink to &quot;2）新增 / 删除一行&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在复杂逻辑上一行加注释：新增时返回新数组引用（避免 push 原地修改）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addRow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">row</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Row</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dataRef.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dataRef.value, row]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← 换引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在复杂逻辑上一行加注释：删除时用 filter 产生新数组引用（避免 splice 原地修改）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeRowById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dataRef.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataRef.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← 换引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-批量高频更新-如行情报价流" tabindex="-1">3）批量高频更新（如行情报价流） <a class="header-anchor" href="#_3-批量高频更新-如行情报价流" aria-label="Permalink to &quot;3）批量高频更新（如行情报价流）&quot;">​</a></h3><blockquote><p>逻辑：把多次更新合并为<strong>一帧</strong>（或节流窗口）后再一次性换引用，降低开销</p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在复杂逻辑上一行加注释：用 requestAnimationFrame 合批更新，避免每次报价都重建数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pending</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scheduled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> queuePrice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">price</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  pending[id] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> price;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (scheduled) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  scheduled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataRef.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pending)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> indexById.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) next[idx] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next[idx], price: p };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pending[id];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dataRef.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← 一次性换引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scheduled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_4-保持行状态不丢-强烈建议" tabindex="-1">4）保持行状态不丢（强烈建议） <a class="header-anchor" href="#_4-保持行状态不丢-强烈建议" aria-label="Permalink to &quot;4）保持行状态不丢（强烈建议）&quot;">​</a></h3><blockquote><p>逻辑：让表格用<strong>稳定的行 id</strong>，避免你替换数组后选中/展开等状态乱跳</p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在复杂逻辑上一行加注释：用 getRowId 保持行标识稳定（而非默认的行索引）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useVueTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  columns,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data: dataRef,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getRowId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">row</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row.id,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>（<code>getRowId</code> 的用途与示例详见官方 Rows/Row APIs 文档。) (<a href="https://tanstack.com/table/latest/docs/guide/rows?utm_source=chatgpt.com" title="Rows Guide | TanStack Table Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</p><hr><h2 id="常见误区对照" tabindex="-1">常见误区对照 <a class="header-anchor" href="#常见误区对照" aria-label="Permalink to &quot;常见误区对照&quot;">​</a></h2><ul><li><p><strong>误区</strong>：<code>dataRef.value.push(row)</code> / <code>splice</code><strong>现象</strong>：表格不更新或排序/分组不同步。 <strong>正确</strong>：<code>dataRef.value = [...dataRef.value, row]</code> / <code>filter</code> 产生新数组再赋回。(<a href="https://tanstack.com/table/latest/docs/framework/vue/guide/table-state" title="Table State (Vue) Guide | TanStack Table Vue Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</p></li><li><p><strong>误区</strong>：<code>dataRef.value[i].price = x</code> 只改了对象字段 <strong>现象</strong>：某些单元格可能更新，但<strong>排序/汇总/分组</strong>不重算或不一致。 <strong>正确</strong>：替换为新对象，并<strong>整体换引用</strong>：<code>dataRef.value = withUpdatedRow(...)</code>。(<a href="https://tanstack.com/table/latest/docs/framework/vue/guide/table-state" title="Table State (Vue) Guide | TanStack Table Vue Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</p></li><li><p><strong>误区</strong>：把列定义/数据字面量写在 <code>&lt;template&gt;</code> 或渲染过程中 <strong>风险</strong>：频繁生成新引用，引起不必要的重建甚至循环渲染（尤其是 React 端）。 <strong>正确</strong>：列用 <code>shallowRef</code>、数据用 <code>ref</code>，在 <code>&lt;script setup&gt;</code> 顶层准备好稳定引用；React 用 <code>useMemo</code>/<code>useState</code>。(<a href="https://tanstack.com/table/latest/docs/faq?utm_source=chatgpt.com" title="FAQ | TanStack Table Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</p></li></ul><hr><h2 id="回答你的两个关键问题" tabindex="-1">回答你的两个关键问题 <a class="header-anchor" href="#回答你的两个关键问题" aria-label="Permalink to &quot;回答你的两个关键问题&quot;">​</a></h2><p>1）<strong>“难道我必须改变 <code>data.value</code> 才会重新渲染吗？”</strong></p><blockquote><p>在 Vue 适配器中，是的——<strong>要让表格识别到变化，需要让 <code>dataRef.value</code> 指向一个新数组引用</strong>（哪怕你只是改了某个元素的某个字段）。这是由于官方采用 <strong>shallowRef</strong> 只侦听 <code>.value</code> 的引用变化。(<a href="https://tanstack.com/table/latest/docs/framework/vue/guide/table-state" title="Table State (Vue) Guide | TanStack Table Vue Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</p></blockquote><p>2）<strong>“如果数组元素增加、减少或变化，也不需要（= 不必）用 <code>.value</code> 重置数据源吗？”</strong></p><blockquote><p>需要。<strong>增/删/改</strong>都应当以<strong>不可变更新</strong>的方式生成<strong>新数组</strong>并赋给 <code>dataRef.value</code>。原地 <code>push/pop/splice</code> 或只改对象字段不会触发表格的正确更新路径。官方给出的示例也明确了这一点（<code>push</code> 不更新，重新赋值才更新）。(<a href="https://tanstack.com/table/latest/docs/framework/vue/guide/table-state" title="Table State (Vue) Guide | TanStack Table Vue Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</p></blockquote><hr><h2 id="性能与工程化补充" tabindex="-1">性能与工程化补充 <a class="header-anchor" href="#性能与工程化补充" aria-label="Permalink to &quot;性能与工程化补充&quot;">​</a></h2><ul><li><strong>不可变更新的成本</strong>：一次创建新数组是 O(n)，在“几千行”规模通常可接受；TanStack Table 内部对行模型有优化，配合虚拟滚动使用时依然顺滑。若有<strong>高频行情</strong>，建议合批（见上文 rAF 方案）或<strong>按时间窗节流</strong>。</li><li><strong>服务端驱动</strong>：若列表很大且更新频密，可只下发变化集（patch），在客户端**应用 patch 后仍然以“新数组赋回”**的方式触发表格刷新。</li><li><strong>列与数据的“稳定引用”策略</strong>：列用 <code>shallowRef([...])</code>，数据用 <code>ref&lt;Row[]&gt;([])</code>，统一通过“新数组赋回”来驱动更新，避免在模板/计算属性里临时构造数组对象。</li></ul><hr><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><ul><li><strong>Table State (Vue) / Using Reactive Data</strong>：支持 <code>ref/computed</code>，但<strong>示例明确：必须给 <code>dataRef.value</code> 赋新数组</strong>才会更新；<code>push</code> 不会触发。(<a href="https://tanstack.com/table/latest/docs/framework/vue/guide/table-state" title="Table State (Vue) Guide | TanStack Table Vue Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</li><li><strong>FAQ / Data Guide / Table Instance</strong>：强调需要<strong>稳定引用</strong>，错误做法会导致重复重建/循环渲染。(<a href="https://tanstack.com/table/latest/docs/faq?utm_source=chatgpt.com" title="FAQ | TanStack Table Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</li><li><strong>Rows / Row APIs</strong>：使用 <code>getRowId</code> 保持行状态稳定。(<a href="https://tanstack.com/table/latest/docs/guide/rows?utm_source=chatgpt.com" title="Rows Guide | TanStack Table Docs" target="_blank" rel="noreferrer">tanstack.com</a>)</li></ul><p>如果你愿意，把你现在的 <code>useVueTable</code> 初始化和“报价更新”那段代码贴出来；我只给<strong>需要修改的片段</strong>，并在复杂逻辑上一行加注释，帮你改成<strong>不可变更新 + 合批</strong>的版本。</p>`,35)])])}const c=i(e,[["render",l]]);export{g as __pageData,c as default};
