import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.oqSrIbQK.js";const o=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（6）：内联函数与性能优化.md","filePath":"posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（6）：内联函数与性能优化.md","lastUpdated":1758544231000}'),t={name:"posts/kotlin快速入门/第二部分：进阶必修/Kotlin 进阶（6）：内联函数与性能优化.md"};function p(h,s,e,k,E,d){return n(),a("div",null,[...s[0]||(s[0]=[l(`<p>好的 ✅ 我来帮你写 <strong>进阶系列第 6 篇</strong>，主题是 <strong>内联函数与性能优化</strong>，继续保持 Hexo 博客风格，实用精简。</p><hr><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">---</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Kotlin 进阶（6）：内联函数与性能优化</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2025-09-12</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">categories</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Kotlin 进阶学习</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">tags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Kotlin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">内联函数</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">inline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">性能优化</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"># Kotlin 进阶（6）：内联函数与性能优化</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Kotlin 的 </span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**内联函数（inline function）**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 主要用于 </span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**性能优化**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，尤其是高阶函数中，减少不必要的对象创建和函数调用开销。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">---</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## 1. 什么是内联函数？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">一般高阶函数（接受 Lambda 参数的函数）在运行时会生成额外的对象和调用层级。  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">加上 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`inline\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 关键字后，编译器会 </span><span style="--shiki-light:#24292E;--shiki-light-font-weight:bold;--shiki-dark:#E1E4E8;--shiki-dark-font-weight:bold;">**把函数体直接拷贝到调用处**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，减少开销。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`\`\`kotlin</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">inline fun logTime(block: () -&gt; Unit) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    val start = System.currentTimeMillis()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    block()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    val end = System.currentTimeMillis()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    println(&quot;耗时: \${end - start}ms&quot;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fun main() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    logTime {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread.sleep(500)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`\`\`</span></span></code></pre></div><p>👉 输出：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>耗时: 500ms</span></span></code></pre></div><p>这里 <code>block()</code> 会被编译成 <strong>直接调用</strong>，而不是额外的函数对象。</p><hr><h2 id="_2-noinline-关键字" tabindex="-1">2. noinline 关键字 <a class="header-anchor" href="#_2-noinline-关键字" aria-label="Permalink to &quot;2. noinline 关键字&quot;">​</a></h2><p>如果函数有多个 Lambda 参数，但并不是所有都需要内联，可以用 <code>noinline</code> 标记。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    block1: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    noinline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block2: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    block1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    block2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样 <code>block1</code> 会被内联，而 <code>block2</code> 仍然是普通对象。</p><hr><h2 id="_3-crossinline-关键字" tabindex="-1">3. crossinline 关键字 <a class="header-anchor" href="#_3-crossinline-关键字" aria-label="Permalink to &quot;3. crossinline 关键字&quot;">​</a></h2><p>有些 Lambda 要求不能使用 <code>return</code> 直接跳出外层函数，可以用 <code>crossinline</code> 解决。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> runTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">crossinline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unit) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许调用，但禁止直接 return 外层函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h2 id="_4-reified-具体化类型参数" tabindex="-1">4. reified（具体化类型参数） <a class="header-anchor" href="#_4-reified-具体化类型参数" aria-label="Permalink to &quot;4. reified（具体化类型参数）&quot;">​</a></h2><p>通常泛型在运行时会被擦除，用 <code>reified</code> 可以让 <strong>内联函数</strong> 保留类型信息。</p><div class="language-kotlin vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">inline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reified</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.simpleName)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 String</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 Int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这在写工具函数时非常常用，比如 <code>startActivity&lt;T&gt;()</code>。</p><hr><h2 id="_5-使用场景" tabindex="-1">5. 使用场景 <a class="header-anchor" href="#_5-使用场景" aria-label="Permalink to &quot;5. 使用场景&quot;">​</a></h2><ul><li><strong>性能优化</strong>：减少 Lambda 对象创建（常见于集合操作、DSL）</li><li><strong>泛型工具函数</strong>：结合 <code>reified</code>，写更优雅的 API</li><li><strong>Android 开发</strong>：<code>inline fun &lt;reified T : Activity&gt; Context.startActivity()</code></li></ul><hr><h2 id="_6-小结" tabindex="-1">6. 小结 <a class="header-anchor" href="#_6-小结" aria-label="Permalink to &quot;6. 小结&quot;">​</a></h2><ul><li><code>inline</code>：把函数体复制到调用处，减少开销</li><li><code>noinline</code>：某些参数不内联</li><li><code>crossinline</code>：禁止 Lambda 非局部返回</li><li><code>reified</code>：泛型具体化，保留类型信息</li></ul><hr><p>下一篇我们学习 👉 <strong>《Kotlin 进阶（7）：泛型与约束》</strong>，掌握写通用代码的核心技能。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>---</span></span>
<span class="line"><span></span></span>
<span class="line"><span>要不要我接着帮你写 **《Kotlin 进阶（7）：泛型与约束》**？</span></span></code></pre></div>`,29)])])}const g=i(t,[["render",p]]);export{o as __pageData,g as default};
