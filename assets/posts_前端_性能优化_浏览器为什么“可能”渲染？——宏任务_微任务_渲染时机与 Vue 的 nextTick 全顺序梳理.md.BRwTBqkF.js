import{_ as e,c as t,o as n,ag as o}from"./chunks/framework.oqSrIbQK.js";const u=JSON.parse('{"title":"重点-浏览器为什么“可能”渲染？——宏任务/微任务/渲染时机与 Vue 的 nextTick 全顺序梳理","description":"","frontmatter":{"title":"重点-浏览器为什么“可能”渲染？——宏任务/微任务/渲染时机与 Vue 的 nextTick 全顺序梳理","date":"2025-10-11T00:00:00.000Z"},"headers":[],"relativePath":"posts/前端/性能优化/浏览器为什么“可能”渲染？——宏任务/微任务/渲染时机与 Vue 的 nextTick 全顺序梳理.md","filePath":"posts/前端/性能优化/浏览器为什么“可能”渲染？——宏任务/微任务/渲染时机与 Vue 的 nextTick 全顺序梳理.md","lastUpdated":1764331727000}'),a={name:"posts/前端/性能优化/浏览器为什么“可能”渲染？——宏任务/微任务/渲染时机与 Vue 的 nextTick 全顺序梳理.md"};function r(i,s,l,c,g,d){return n(),t("div",null,[...s[0]||(s[0]=[o(`<h2 id="tl-dr-结论先行" tabindex="-1">TL;DR（结论先行） <a class="header-anchor" href="#tl-dr-结论先行" aria-label="Permalink to &quot;TL;DR（结论先行）&quot;">​</a></h2><ul><li><p>一个“浏览器帧”的<strong>典型顺序</strong>（简化）：</p><ol><li><strong>Task（宏任务）</strong></li><li><strong>Microtasks（微任务检查点）</strong>：<code>Promise.then</code>/<code>queueMicrotask</code></li><li><strong><code>requestAnimationFrame</code> 回调</strong></li><li><strong>Microtasks（再次检查点）</strong></li><li><strong>渲染机会（样式计算/布局/绘制/合成）</strong> ← <strong>这里“可能”发生绘制</strong></li><li><strong><code>requestIdleCallback</code></strong>（若本帧有空闲）</li></ol></li><li><p>“<strong>可能</strong>渲染”的原因：浏览器<strong>有权跳过这一帧的绘制</strong>（无可见变更/后台标签页/性能节流/被连续微任务“饿死”等）。</p></li><li><p><strong>Vue 3</strong> 把更新<strong>批量</strong>安排在<strong>微任务</strong>里；<code>nextTick</code> 的回调会在<strong>本轮 DOM patch 完成之后</strong>执行，仍属于微任务阶段。</p></li></ul><hr><h2 id="为什么是-可能发生一次绘制" tabindex="-1">为什么是“可能发生一次绘制”？ <a class="header-anchor" href="#为什么是-可能发生一次绘制" aria-label="Permalink to &quot;为什么是“可能发生一次绘制”？&quot;">​</a></h2><p>浏览器每一帧<strong>只有一个“渲染机会”</strong>，但是否真的去绘制，取决于以下条件：</p><ol><li><strong>没有可见变化</strong>：样式/布局/像素都没变 → 跳过绘制。</li><li><strong>页面不可见/后台标签</strong>：根据 Page Visibility/节流策略，绘制频率被大幅降低甚至暂停。</li><li><strong>节流与合成优化</strong>：有些变更（如仅合成层 transform/opacity）可由合成器线程处理，不一定每帧主线程都要完整“样式 → 布局 → 绘制”。</li><li><strong>主线程被占用</strong>：若你在一帧中不断塞入微任务，可能导致<strong>微任务饥饿</strong>，渲染时机被一再推迟。</li><li><strong>浏览器合帧/省电策略</strong>：屏幕刷新率/系统负载/节能模式下，浏览器可主动减少绘制帧数。</li></ol><blockquote><p>所以规范里描述为“<strong>update the rendering</strong>（更新渲染）”，这一步<strong>提供绘制的机会</strong>，但不保证<strong>一定</strong>输出一帧像素。</p></blockquote><hr><h2 id="事件循环——标准顺序图-可记忆版本" tabindex="-1">事件循环——标准顺序图（可记忆版本） <a class="header-anchor" href="#事件循环——标准顺序图-可记忆版本" aria-label="Permalink to &quot;事件循环——标准顺序图（可记忆版本）&quot;">​</a></h2><p><strong>一帧内的关键阶段：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[1] 宏任务（Task）      例如：setTimeout 回调、事件回调、脚本执行入口</span></span>
<span class="line"><span>[2] 微任务检查点        例如：Promise.then / queueMicrotask</span></span>
<span class="line"><span>[3] requestAnimationFrame 回调（可见文档）</span></span>
<span class="line"><span>[4] 微任务检查点        一些实现会在 rAF 后再跑一次微任务，清理尾巴</span></span>
<span class="line"><span>[5] 更新渲染（样式/布局/绘制/合成）← 可能绘制，也可能跳过</span></span>
<span class="line"><span>[6] requestIdleCallback（若本帧还有空闲时间）</span></span>
<span class="line"><span>→ 下一帧或下一个 Task</span></span></code></pre></div><p><strong>与三个常见 API 的关系：</strong></p><ul><li><code>setTimeout(cb, 0)</code>：排入 <strong>[1] 宏任务</strong>（下一轮 Task）。</li><li><code>Promise.then / queueMicrotask</code>：排入 <strong>[2]/[4] 微任务</strong>（本轮 Task 结束立刻执行，<strong>渲染前</strong>）。</li><li><code>requestAnimationFrame</code>：发生在 <strong>[3]</strong>，<strong>微任务之后、渲染之前</strong>。</li></ul><hr><h2 id="vue-3-的渲染时机与-nexttick-在哪" tabindex="-1">Vue 3 的渲染时机与 nextTick 在哪？ <a class="header-anchor" href="#vue-3-的渲染时机与-nexttick-在哪" aria-label="Permalink to &quot;Vue 3 的渲染时机与 nextTick 在哪？&quot;">​</a></h2><p><strong>Vue 3 的核心点：批处理 + 微任务调度。</strong></p><ul><li>当你修改响应式数据时，Vue <strong>不会立刻渲染</strong>，而是把渲染任务放进一个队列；</li><li>这个队列的<strong>刷新（flushJobs）被安排在微任务</strong>中（通常通过 <code>Promise.resolve()</code>）；</li><li><strong>DOM patch（渲染）发生在这个微任务的 flush 过程中</strong>；</li><li><code>nextTick</code> 会把你的回调<strong>排在渲染 flush 之后</strong>的微任务里，因此<strong>能读到更新后的 DOM</strong>。</li></ul><h3 id="把-vue-放进整体时间线-单帧" tabindex="-1">把 Vue 放进整体时间线（单帧）： <a class="header-anchor" href="#把-vue-放进整体时间线-单帧" aria-label="Permalink to &quot;把 Vue 放进整体时间线（单帧）：&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>同步代码（你的事件处理 / 方法调用）</span></span>
<span class="line"><span>  └─ 触发响应式变更：Vue 把渲染任务加入队列（不立即渲染）</span></span>
<span class="line"><span>Task 结束</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>Microtasks 检查点：</span></span>
<span class="line"><span>  ├─ Vue flushJobs：执行计算/patch → 更新真实 DOM</span></span>
<span class="line"><span>  └─ Vue 的 nextTick 回调（在 flush 之后）→ 你读到“已更新”的 DOM</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>requestAnimationFrame</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>（再次 Microtasks 检查点，视实现而定）</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>渲染机会（可能绘制）</span></span></code></pre></div><blockquote><p>这也解释了：<strong>为什么 <code>await nextTick()</code> 后读取 DOM 是安全的</strong>——因为 Vue 的 patch 已在<strong>同一轮微任务</strong>的<strong>更早阶段</strong>完成。</p></blockquote><hr><h2 id="queuemicrotask-promise-then-settimeout-的位次对比" tabindex="-1"><code>queueMicrotask</code> / <code>Promise.then</code> / <code>setTimeout</code> 的位次对比 <a class="header-anchor" href="#queuemicrotask-promise-then-settimeout-的位次对比" aria-label="Permalink to &quot;\`queueMicrotask\` / \`Promise.then\` / \`setTimeout\` 的位次对比&quot;">​</a></h2><ul><li><p><strong><code>queueMicrotask</code> 与 <code>Promise.then</code></strong>：同属微任务，发生在<strong>Task 结束后、rAF 与渲染之前</strong>。</p><ul><li>差别在于语义与开销：<code>queueMicrotask</code> 更轻，不引入 Promise 链；<code>then</code> 便于链式处理。</li></ul></li><li><p><strong><code>setTimeout</code></strong>：下一轮 <strong>Task</strong>，发生在<strong>渲染机会之后</strong>（通常会比 microtask 晚一拍甚至一整帧）。</p></li></ul><p>这就是在 i18n 初始化里<strong>优先用 <code>queueMicrotask</code><strong>的原因： <strong>不阻塞首屏</strong>，但</strong>尽可能早</strong>（在本轮渲染前）触发语言包懒加载与切换，缩短“临时英文 → 目标语言”的可见窗口。</p><hr><h2 id="常见疑惑与例外" tabindex="-1">常见疑惑与例外 <a class="header-anchor" href="#常见疑惑与例外" aria-label="Permalink to &quot;常见疑惑与例外&quot;">​</a></h2><h3 id="_1-为什么我改了样式却没立刻看到" tabindex="-1">1) 为什么我改了样式却没立刻看到？ <a class="header-anchor" href="#_1-为什么我改了样式却没立刻看到" aria-label="Permalink to &quot;1) 为什么我改了样式却没立刻看到？&quot;">​</a></h3><p>可能落在以下情况：</p><ul><li>改动还在<strong>微任务阶段</strong>，浏览器<strong>尚未进入渲染机会</strong>；</li><li>改动只影响合成层，由合成器线程合成，<strong>不会每次都触发布局/绘制</strong>；</li><li>页面在后台或被节流，这一帧<strong>被跳过</strong>。</li></ul><h3 id="_2-连续大量微任务会怎样" tabindex="-1">2) 连续大量微任务会怎样？ <a class="header-anchor" href="#_2-连续大量微任务会怎样" aria-label="Permalink to &quot;2) 连续大量微任务会怎样？&quot;">​</a></h3><ul><li>可能造成<strong>微任务饥饿</strong>（一直在跑微任务，导致 rAF/渲染迟迟不到）；</li><li>解决：在密集计算中<strong>分片</strong>（<code>setTimeout</code>/<code>scheduler.postTask</code>/<code>requestIdleCallback</code>）或使用 Web Worker。</li></ul><h3 id="_3-nexttick-和-requestanimationframe-谁先" tabindex="-1">3) <code>nextTick</code> 和 <code>requestAnimationFrame</code> 谁先？ <a class="header-anchor" href="#_3-nexttick-和-requestanimationframe-谁先" aria-label="Permalink to &quot;3) \`nextTick\` 和 \`requestAnimationFrame\` 谁先？&quot;">​</a></h3><ul><li><strong>先 <code>nextTick</code>（微任务），后 <code>rAF</code>（渲染前阶段）</strong>。</li><li>想在<strong>真正绘制完成</strong>后读取（例如截图/像素检测），考虑在 <code>rAF</code> 内再排一个 <code>setTimeout(0)</code>（下一轮 Task），或使用 <code>await paint</code> 类的策略（需自定义同步点）。</li></ul><hr><h2 id="开发中怎么用这套顺序做判断" tabindex="-1">开发中怎么用这套顺序做判断？ <a class="header-anchor" href="#开发中怎么用这套顺序做判断" aria-label="Permalink to &quot;开发中怎么用这套顺序做判断？&quot;">​</a></h2><ul><li><strong>读更新后的 DOM</strong>：<code>await nextTick()</code>（Vue）或确保逻辑在<strong>微任务</strong>里执行。</li><li><strong>尽快触发但不阻塞</strong>：用 <code>queueMicrotask</code>。</li><li><strong>让出一帧，避免卡顿</strong>：用 <code>setTimeout(0)</code> 或 <code>requestIdleCallback</code>（有空闲才跑）。</li><li><strong>和绘制对齐</strong>：用 <code>requestAnimationFrame</code>，它在渲染前回调里给你<strong>最后时刻</strong>的控制权。</li></ul><hr><h2 id="口袋卡片-cheat-sheet" tabindex="-1">口袋卡片（Cheat Sheet） <a class="header-anchor" href="#口袋卡片-cheat-sheet" aria-label="Permalink to &quot;口袋卡片（Cheat Sheet）&quot;">​</a></h2><ul><li><strong>帧序</strong>：Task → Microtasks → rAF → Microtasks → <strong>Render(可能)</strong> → Idle → Next Task</li><li><strong>微任务</strong>：Promise.then / queueMicrotask / Vue 的 flush 与 nextTick</li><li><strong>宏任务</strong>：setTimeout / 事件回调 / 网络回调</li><li><strong>“可能”渲染</strong>：无可见变化、后台、节流、合成优化、微任务饥饿，都可能跳过</li><li><strong>Vue</strong>：更新合并 → 微任务阶段 flush → DOM patch 完成 → <code>nextTick</code> 回调 → rAF → 绘制</li></ul><hr><h3 id="一句话总结" tabindex="-1">一句话总结 <a class="header-anchor" href="#一句话总结" aria-label="Permalink to &quot;一句话总结&quot;">​</a></h3><p><strong>把“微任务在前、渲染在后”的大框架记住</strong>：Vue 的 DOM 更新发生在微任务的 flush 中，<code>nextTick</code> 也在微任务中但晚于 patch；rAF 在渲染前；真正绘制<strong>可能</strong>发生，也可能被跳过。掌握这个顺序，你就知道<strong>该把哪段代码放在哪个阶段</strong>，以换来更稳的时序与更快的体验。</p>`,42)])])}const h=e(a,[["render",r]]);export{u as __pageData,h as default};
