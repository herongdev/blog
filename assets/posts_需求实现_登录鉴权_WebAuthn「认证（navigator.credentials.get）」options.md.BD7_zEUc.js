import{_ as t,c as s,o as i,ag as a}from"./chunks/framework.oqSrIbQK.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/需求实现/登录鉴权/WebAuthn「认证（navigator.credentials.get）」options.md","filePath":"posts/需求实现/登录鉴权/WebAuthn「认证（navigator.credentials.get）」options.md","lastUpdated":1758634537000}'),n={name:"posts/需求实现/登录鉴权/WebAuthn「认证（navigator.credentials.get）」options.md"};function r(o,e,l,h,c,d){return i(),s("div",null,[...e[0]||(e[0]=[a(`<h2 id="一、后端返回的-publickeycredentialrequestoptions-认证阶段-options" tabindex="-1">一、后端返回的 <code>PublicKeyCredentialRequestOptions</code>（认证阶段 options） <a class="header-anchor" href="#一、后端返回的-publickeycredentialrequestoptions-认证阶段-options" aria-label="Permalink to &quot;一、后端返回的 \`PublicKeyCredentialRequestOptions\`（认证阶段 options）&quot;">​</a></h2><p>这是浏览器发起 <strong>get/assertion</strong> 的必要参数对象。常见字段如下（都由<strong>后端</strong>生成与返回）：</p><h3 id="_1-challenge-必填" tabindex="-1">1) <code>challenge</code>（必填） <a class="header-anchor" href="#_1-challenge-必填" aria-label="Permalink to &quot;1) \`challenge\`（必填）&quot;">​</a></h3><ul><li><strong>类型</strong>：<code>BufferSource</code>（你通常用 base64url 字符串传，到前端转成 <code>ArrayBuffer</code>）</li><li><strong>作用</strong>：一次性的随机值，防重放。浏览器会把它写进 <code>clientDataJSON</code>，并参与签名校验（后端要比对它是否与发给客户端的一致）。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</li><li><strong>要点</strong>：应足够随机/高熵；后端必须保存并在验证时对上。(<a href="https://github.com/w3c/webauthn/issues/1856?utm_source=chatgpt.com" title="Clarify the need for truly randomly generated challenges ..." target="_blank" rel="noreferrer">GitHub</a>)</li></ul><h3 id="_2-rpid-可选" tabindex="-1">2) <code>rpId</code>（可选） <a class="header-anchor" href="#_2-rpid-可选" aria-label="Permalink to &quot;2) \`rpId\`（可选）&quot;">​</a></h3><ul><li><strong>类型</strong>：字符串（域名）</li><li><strong>作用</strong>：指定<strong>Relying Party ID</strong>。若不填，默认是<strong>调用页面的有效顶级域名(ETLD+1)或其子域</strong>。必须与当前页面域满足“后缀匹配”规则；否则浏览器直接抛 <code>SecurityError</code>。(<a href="https://github.com/w3c/webauthn/wiki/Explainer%3A-Related-origin-requests?utm_source=chatgpt.com" title="Explainer: Related origin requests · w3c/webauthn Wiki" target="_blank" rel="noreferrer">GitHub</a>)</li><li><strong>跨站/多域</strong>：如果你希望 <code>app.example.com</code> 也能使用 <code>example.com</code> 作为 rpId，需要在 <code>https://example.com/.well-known/webauthn</code> 配置 <strong>Related Origin Requests</strong> 白名单；否则也会 <code>SecurityError</code>。注意 Firefox 尚不支持该机制。(<a href="https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com" title="Allow passkey reuse across your sites with Related Origin ..." target="_blank" rel="noreferrer">web.dev</a>)</li></ul><h3 id="_3-allowcredentials-可选" tabindex="-1">3) <code>allowCredentials</code>（可选） <a class="header-anchor" href="#_3-allowcredentials-可选" aria-label="Permalink to &quot;3) \`allowCredentials\`（可选）&quot;">​</a></h3><ul><li><p><strong>类型</strong>：<code>PublicKeyCredentialDescriptor[]</code></p></li><li><p><strong>作用</strong>：限制可用的凭据集合（凭据 ID 列表）。如果你想做<strong>无用户名/可发现凭据（discoverable credentials）<strong>登录，通常</strong>留空</strong>让浏览器从设备中自动发现。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</p></li><li><p><strong>子字段</strong>：</p><ul><li><code>type</code>: 目前恒为 <code>&quot;public-key&quot;</code>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>id</code>: <strong>credentialId</strong>（二进制）；前端需 base64url→ArrayBuffer。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>transports</code>: <strong>提示</strong>浏览器优先尝试的传输介质（不是安全校验的一部分）。值包括：<code>&quot;ble&quot; | &quot;hybrid&quot; | &quot;internal&quot; | &quot;nfc&quot; | &quot;usb&quot;</code>（有的实现还保留 <code>&quot;cable&quot;</code>；<code>&quot;hybrid&quot;</code>为其替代）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul></li></ul><h3 id="_4-userverification-可选" tabindex="-1">4) <code>userVerification</code>（可选） <a class="header-anchor" href="#_4-userverification-可选" aria-label="Permalink to &quot;4) \`userVerification\`（可选）&quot;">​</a></h3><ul><li><p><strong>类型</strong>：<code>&quot;required&quot; | &quot;preferred&quot; | &quot;discouraged&quot;</code></p></li><li><p><strong>作用</strong>：要求是否必须本地生物识别/解锁等<strong>用户验证</strong>：</p><ul><li><code>&quot;required&quot;</code>：必须有人脸/指纹/设备 PIN；后端验证 <code>UV</code> 标志位。</li><li><code>&quot;preferred&quot;</code>：尽量有（最常用默认）。</li><li><code>&quot;discouraged&quot;</code>：不要求。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul></li></ul><h3 id="_5-timeout-可选" tabindex="-1">5) <code>timeout</code>（可选） <a class="header-anchor" href="#_5-timeout-可选" aria-label="Permalink to &quot;5) \`timeout\`（可选）&quot;">​</a></h3><ul><li><strong>类型</strong>：毫秒</li><li><strong>作用</strong>：给浏览器的人机交互超时建议。浏览器<strong>可忽略</strong>或有自己的上限/下限。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><h3 id="_6-extensions-可选" tabindex="-1">6) <code>extensions</code>（可选） <a class="header-anchor" href="#_6-extensions-可选" aria-label="Permalink to &quot;6) \`extensions\`（可选）&quot;">​</a></h3><ul><li><strong>类型</strong>：对象</li><li><strong>作用</strong>：扩展输入（如历史 U2F 兼容的 <code>appid</code>、<code>uvm</code> 等，不同实现支持不同）。后端在验证时也会得到<strong>扩展输出</strong>以决定后续处理。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><blockquote><p>⚠️ <strong><code>mediation</code> 不属于 <code>PublicKeyCredentialRequestOptions</code>！</strong> 它是 <code>navigator.credentials.get({ publicKey, mediation })</code> 的<strong>顶层</strong>参数，用来启用 <strong>Conditional UI</strong>（<code>&#39;conditional&#39;</code>）、<code>&#39;required&#39;</code>、<code>&#39;optional&#39;</code>、<code>&#39;silent&#39;</code> 等。放在 <code>publicKey</code> 里会被忽略。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com" title="CredentialsContainer: get() method - Web APIs - MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></blockquote><p><strong>最简调用形态（仅示意差异处）</strong>：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> publicKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toPublicKeyOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optionsFromServer);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mediation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> optionsFromServer.mediation; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 由你自己透传</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cred</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.credentials.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ publicKey, mediation }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← mediation 在顶层</span></span></code></pre></div><p>（<code>mediation: &#39;conditional&#39;</code> 可启用表单自动填充式的 passkey UI）(<a href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com" title="CredentialsContainer: get() method - Web APIs - MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</p><h2 id="二、你回传给后端的断言-payload-认证结果" tabindex="-1">二、你回传给后端的断言 <code>payload</code>（认证结果） <a class="header-anchor" href="#二、你回传给后端的断言-payload-认证结果" aria-label="Permalink to &quot;二、你回传给后端的断言 \`payload\`（认证结果）&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> payload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id,                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串 ID（可视化用）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  rawId,             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// base64url(二进制 credentialId) —— 服务端验证优先用它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type,              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;public-key&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  options_token,     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 你系统自有：把 options 与本次会话/挑战绑定的防重放令牌</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  response: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    clientDataJSON,      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 包含 challenge/ origin / type 等</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    authenticatorData,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// rpIdHash/flags/signCount/扩展输出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    signature,           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对 (authenticatorData || SHA256(clientDataJSON)) 的签名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    userHandle | null,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可发现凭据时可能包含到用户主键的字节串</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 可选：clientExtensionResults</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>每个字段的用处——</p><h3 id="_1-id-rawid" tabindex="-1">1) <code>id</code> / <code>rawId</code> <a class="header-anchor" href="#_1-id-rawid" aria-label="Permalink to &quot;1) \`id\` / \`rawId\`&quot;">​</a></h3><ul><li><strong><code>id</code></strong>：DOM 字符串形式的凭据标识（实现可把二进制编码成可打印字符串）。</li><li><strong><code>rawId</code></strong>：真正的二进制凭据 ID（你已做 base64url）。<strong>后端应以 <code>rawId</code> 匹配数据库中的 credential 记录</strong>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><h3 id="_2-type" tabindex="-1">2) <code>type</code> <a class="header-anchor" href="#_2-type" aria-label="Permalink to &quot;2) \`type\`&quot;">​</a></h3><ul><li>目前恒为 <code>&quot;public-key&quot;</code>。后端可做兜底校验。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><h3 id="_3-response-clientdatajson" tabindex="-1">3) <code>response.clientDataJSON</code> <a class="header-anchor" href="#_3-response-clientdatajson" aria-label="Permalink to &quot;3) \`response.clientDataJSON\`&quot;">​</a></h3><ul><li><p><strong>浏览器生成的 JSON（再序列化为 ArrayBuffer）</strong>，包含：</p><ul><li><code>type</code>：本次操作类型，认证为 <code>&quot;webauthn.get&quot;</code>；</li><li><code>challenge</code>：后端发的挑战（base64url），<strong>后端必须与会话中保存的挑战比对</strong>；</li><li><code>origin</code>：调用页面的源（协议+域+端口），用来防钓鱼；</li><li>可能还有 <code>crossOrigin</code> 等。</li></ul></li><li><p><strong>服务器验证</strong>会对 <code>clientDataJSON</code> 做 SHA-256，作为签名消息的一部分。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</p></li></ul><h3 id="_4-response-authenticatordata" tabindex="-1">4) <code>response.authenticatorData</code> <a class="header-anchor" href="#_4-response-authenticatordata" aria-label="Permalink to &quot;4) \`response.authenticatorData\`&quot;">​</a></h3><ul><li><p>由<strong>认证器</strong>返回的二进制结构，包含：</p><ul><li><code>rpIdHash</code>：<code>SHA-256(rpId)</code>；</li><li><code>flags</code>：位标志（如 <code>UP</code> 用户在场、<code>UV</code> 用户已验证、<code>BE/BS/AT/ED</code> 等）；</li><li><code>signCount</code>：签名计数（防克隆）；</li><li>以及扩展输出（如果启用）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data?utm_source=chatgpt.com" title="Authenticator data - Web APIs | MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul></li><li><p><strong>服务器需检查</strong>：</p><ul><li><code>rpIdHash</code> 是否与期望 rpId 匹配；</li><li><code>flags</code> 是否满足 <code>userVerification</code> 要求（如要求 <code>UV=1</code>）；</li><li><code>signCount</code> 是否单调递增（&gt; 上次保存的值）。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</li></ul></li></ul><h3 id="_5-response-signature" tabindex="-1">5) <code>response.signature</code> <a class="header-anchor" href="#_5-response-signature" aria-label="Permalink to &quot;5) \`response.signature\`&quot;">​</a></h3><ul><li>认证器使用<strong>该凭据绑定的公钥</strong>对应的<strong>私钥</strong>对如下字节串签名： <code>authenticatorData || SHA-256(clientDataJSON)</code></li><li><strong>服务器</strong>用数据库保存的<strong>公钥</strong>验证签名的真实性。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</li></ul><h3 id="_6-response-userhandle-可能为-null" tabindex="-1">6) <code>response.userHandle</code>（可能为 <code>null</code>） <a class="header-anchor" href="#_6-response-userhandle-可能为-null" aria-label="Permalink to &quot;6) \`response.userHandle\`（可能为 \`null\`）&quot;">​</a></h3><ul><li><strong>discoverable credentials</strong> 场景下，认证器可回传<strong>与凭据绑定的用户标识</strong>（byte[]）。</li><li>后端可据此直接找到用户（无须用户名）。若你只用非可发现凭据或 <code>allowCredentials</code> 白名单，常见为 <code>null</code>。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</li></ul><h3 id="_7-clientextensionresults-可选" tabindex="-1">7) <code>clientExtensionResults</code>（可选） <a class="header-anchor" href="#_7-clientextensionresults-可选" aria-label="Permalink to &quot;7) \`clientExtensionResults\`（可选）&quot;">​</a></h3><ul><li>前端可一并传回，服务端可依据需要处理（例如 <code>uvm</code> 等）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><h3 id="_8-options-token-你系统自定义" tabindex="-1">8) <code>options_token</code>（你系统自定义） <a class="header-anchor" href="#_8-options-token-你系统自定义" aria-label="Permalink to &quot;8) \`options_token\`（你系统自定义）&quot;">​</a></h3><ul><li><strong>标准外</strong>字段，用于<strong>把“本次 options”与“本次 verify”绑定</strong>（有的系统用 session/redis，也有的用外带 token）。目的：<strong>抗重放</strong>与<strong>防参数串改</strong>。无统一规范，思路与保存 <code>challenge</code> 并验证一致。可参考 SimpleWebAuthn 关于“保存 challenge 的会话方案”。(<a href="https://simplewebauthn.dev/docs/packages/server?utm_source=chatgpt.com" title="simplewebauthn/server" target="_blank" rel="noreferrer">SimpleWebAuthn</a>)</li></ul><hr><h2 id="三、服务端典型验证清单-认证" tabindex="-1">三、服务端典型验证清单（认证） <a class="header-anchor" href="#三、服务端典型验证清单-认证" aria-label="Permalink to &quot;三、服务端典型验证清单（认证）&quot;">​</a></h2><p>后端在收到上面的 <code>payload</code> 后，一般需要做（摘要）：</p><ol><li>按 <code>rawId</code> 查找已注册的凭据与其公钥；</li><li>校验 <strong><code>challenge</code></strong>（来自已保存的 options）；</li><li>校验 <strong><code>origin</code></strong> 与 <strong><code>rpIdHash</code></strong>（域/站点匹配）；</li><li>按 <code>userVerification</code> 要求检查 <strong><code>flags</code></strong> 中的 <code>UP/UV</code>；</li><li>用保存的<strong>公钥</strong>验证 <strong><code>signature</code></strong>；</li><li>检查并更新 <strong><code>signCount</code></strong>（克隆检测）；</li><li>处理扩展输出（若配置）。 这些步骤在 W3C 规范“验证认证断言”一节与社区文档中有详细说明。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">W3C</a>)</li></ol><hr><h2 id="四、与你当前代码的两个关键提示" tabindex="-1">四、与你当前代码的两个关键提示 <a class="header-anchor" href="#四、与你当前代码的两个关键提示" aria-label="Permalink to &quot;四、与你当前代码的两个关键提示&quot;">​</a></h2><ol><li><p><strong><code>mediation</code> 放错位置</strong><code>mediation</code> 必须放在 <code>navigator.credentials.get({ publicKey, mediation })</code> 的顶层，而不是 <code>publicKey</code> 里。否则 Conditional UI 不生效。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com" title="CredentialsContainer: get() method - Web APIs - MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></li><li><p><strong><code>rpId</code> 本地兜底</strong> 本地开发建议在前端兜底 <code>rpId=&#39;localhost&#39;</code>（或让后端按环境返回），否则很容易 <code>SecurityError</code>。跨域/多域要配 <strong><code>/.well-known/webauthn</code></strong> 以启用 Related Origin Requests（当前 Firefox 不支持，需考虑降级策略）。(<a href="https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com" title="Allow passkey reuse across your sites with Related Origin ..." target="_blank" rel="noreferrer">web.dev</a>)</p></li></ol><hr><h2 id="五、allowcredentials-使用小抄" tabindex="-1">五、<code>allowCredentials</code> 使用小抄 <a class="header-anchor" href="#五、allowcredentials-使用小抄" aria-label="Permalink to &quot;五、\`allowCredentials\` 使用小抄&quot;">​</a></h2><ul><li><strong>用户名+密码+随后二次验证（绑定到用户）</strong>：通常<strong>传递用户的所有 credentialId</strong> 列表到 <code>allowCredentials</code>，限制可选项。</li><li><strong>无用户名/一键直登（discoverable）</strong>：<strong>留空</strong> <code>allowCredentials</code>，并使用 <code>mediation: &#39;conditional&#39;</code> 以获得自动填充式 UI。(<a href="https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/WebAuthn_Client_Authentication.html?utm_source=chatgpt.com" title="WebAuthn Client Authentication" target="_blank" rel="noreferrer">developers.yubico.com</a>)</li><li><code>transports</code> 仅是<strong>提示</strong>给浏览器，不影响安全验证逻辑。(<a href="https://developers.yubico.com/java-webauthn-server/JavaDoc/webauthn-server-core/2.3.0/com/yubico/webauthn/data/AuthenticatorTransport.html?utm_source=chatgpt.com" title="AuthenticatorTransport (webauthn-server-core 2.3.0 API)" target="_blank" rel="noreferrer">developers.yubico.com</a>)</li></ul><hr><p>如果你愿意，我可以按你的接口结构再给一个**“后端认证校验要点对照表”<strong>（结合 <code>@simplewebauthn/server</code> 的参数名、如何比对 challenge、如何处理 signCount 与 UV 要求等），并补充</strong>错误映射**（<code>NotAllowedError/SecurityError</code> 等）与常见排错 Checklist。</p><p>好嘞——下面给你一份**“后端认证校验要点对照表 + SimpleWebAuthn（v11+）实务清单”<strong>，把</strong>后端返回的 <code>options</code> 各字段作用/取值**，以及<strong>前端回传给后端的断言 payload</strong>如何被验证，逐一对齐。还附上<strong>最小必要的服务端代码片段</strong>（只放关键行、复杂逻辑行上方有中文注释），以及<strong>常见坑与错误映射</strong>。文末都给了权威出处。</p><hr><h2 id="一、认证阶段-publickeycredentialrequestoptions-后端生成-→-前端-navigator-credentials-get-publickey-mediation" tabindex="-1">一、认证阶段 <code>PublicKeyCredentialRequestOptions</code>（后端生成 → 前端 <code>navigator.credentials.get({ publicKey, mediation? })</code>） <a class="header-anchor" href="#一、认证阶段-publickeycredentialrequestoptions-后端生成-→-前端-navigator-credentials-get-publickey-mediation" aria-label="Permalink to &quot;一、认证阶段 \`PublicKeyCredentialRequestOptions\`（后端生成 → 前端 \`navigator.credentials.get({ publicKey, mediation? })\`）&quot;">​</a></h2><table tabindex="0"><thead><tr><th>字段</th><th style="text-align:right;">必须</th><th>类型/典型值</th><th>作用 &amp; 校验点</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><code>challenge</code></td><td style="text-align:right;">✅</td><td>高熵随机字节（前端以 <strong>base64url</strong> 字符串接收 → 转 <code>ArrayBuffer</code>）</td><td><strong>防重放</strong>。浏览器会把它写进 <code>clientDataJSON</code> 并参与签名；后端必须与会话中保存的 challenge 完全一致才通过。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</td><td></td><td></td><td></td><td></td></tr><tr><td><code>rpId</code></td><td style="text-align:right;">⭕</td><td>域名字符串（如 <code>example.com</code> / <code>localhost</code>）</td><td>指定 <strong>RP ID</strong>。应与当前页面域名满足后缀匹配；不匹配浏览器直接抛 <strong><code>SecurityError</code></strong>。多域/跨站共用需配置 <code>/.well-known/webauthn</code> 的 <strong>Related Origin Requests</strong> 白名单。(<a href="https://github.com/w3c/webauthn/issues/1856?utm_source=chatgpt.com" title="Clarify the need for truly randomly generated challenges ..." target="_blank" rel="noreferrer">GitHub</a>)</td><td></td><td></td><td></td><td></td></tr><tr><td><code>allowCredentials</code></td><td style="text-align:right;">⭕</td><td><code>[{ type: &#39;public-key&#39;, id: &lt;Buffer&gt;, transports?: [...] }]</code></td><td>限定可用凭据（<strong>credentialId 白名单</strong>）。做 <strong>无用户名/可发现凭据</strong> 登录时通常留空，让浏览器从设备中自动发现。<code>transports</code> 为提示（\`&quot;internal&quot;</td><td>&quot;usb&quot;</td><td>&quot;nfc&quot;</td><td>&quot;ble&quot;</td><td>&quot;hybrid&quot;\` 等）。(<a href="https://github.com/w3c/webauthn/wiki/Explainer%3A-Related-origin-requests?utm_source=chatgpt.com" title="Explainer: Related origin requests · w3c/webauthn Wiki" target="_blank" rel="noreferrer">udn.realityripple.com</a>)</td></tr><tr><td><code>userVerification</code></td><td style="text-align:right;">⭕</td><td><code>&quot;required&quot; | &quot;preferred&quot; | &quot;discouraged&quot;</code></td><td>是否必须本地生物识别/解锁。若设为 <code>&quot;required&quot;</code>，后端需检查 <code>UV</code> 标志。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</td><td></td><td></td><td></td><td></td></tr><tr><td><code>timeout</code></td><td style="text-align:right;">⭕</td><td>毫秒数</td><td>用户交互超时建议；浏览器可忽略。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</td><td></td><td></td><td></td><td></td></tr><tr><td><code>extensions</code></td><td style="text-align:right;">⭕</td><td>任意对象（各扩展自定义形态）</td><td>WebAuthn 扩展输入；验证时可读取扩展输出决定策略（如 <code>uvm</code> 等）。(<a href="https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com" title="Allow passkey reuse across your sites with Related Origin ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</td><td></td><td></td><td></td><td></td></tr><tr><td><code>mediation</code></td><td style="text-align:right;">❌</td><td><strong>不在 <code>publicKey</code> 里！</strong></td><td><strong>在 <code>navigator.credentials.get</code> 顶层</strong>传入（例如 <code>&#39;conditional&#39;</code> 开启 Conditional UI/表单自动填充式 UI）。放进 <code>publicKey</code> 会被忽略。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>小结：你 <code>toPublicKeyOptions(...)</code> 里把 <code>mediation</code> 放进了 <code>publicKey</code>，应移到 <code>credentials.get</code> 的顶层；<code>rpId</code> 在本地开发建议兜底为 <code>localhost</code>，否则极易 <code>SecurityError</code>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></blockquote><hr><h2 id="二、前端回传给后端的断言-payload-认证结果" tabindex="-1">二、前端回传给后端的断言 <code>payload</code>（认证结果） <a class="header-anchor" href="#二、前端回传给后端的断言-payload-认证结果" aria-label="Permalink to &quot;二、前端回传给后端的断言 \`payload\`（认证结果）&quot;">​</a></h2><p>你当前回传结构（简化）是对的：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  id,                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// UI 标识；通常不用于严谨校验</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  rawId,             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;- base64url(credentialId二进制)，后端用它匹配库中凭据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type,              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;public-key&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  options_token,     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 你的系统自定义防重放/绑会话令牌</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    clientDataJSON,      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 含 challenge / origin / type=&quot;webauthn.get&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    authenticatorData,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 含 rpIdHash / flags(UP/UV/...) / signCount / 扩展输出</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    signature,           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对 (authenticatorData || SHA256(clientDataJSON)) 的签名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    userHandle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可发现凭据时可能存在（用户主键字节串）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  clientExtensionResults</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可选</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong><code>clientDataJSON</code></strong>：后端需校验 <code>challenge</code>、<code>origin</code>、<code>type=&quot;webauthn.get&quot;</code>，再做 <code>SHA-256</code> 参与签名验证。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><strong><code>authenticatorData</code></strong>：后端校验 <code>rpIdHash==SHA256(rpId)</code>、<code>flags</code>（例如是否包含 <code>UV</code>）、并进行 <strong><code>signCount</code> 单调递增</strong>检查。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><strong><code>signature</code></strong>：用数据库保存的<strong>公钥</strong>验签，消息是 <code>authenticatorData || SHA256(clientDataJSON)</code>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com" title="CredentialsContainer: get() method - Web APIs - MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><hr><h2 id="三、simplewebauthn-v11-后端验证清单-认证" tabindex="-1">三、SimpleWebAuthn（v11+）后端验证清单（认证） <a class="header-anchor" href="#三、simplewebauthn-v11-后端验证清单-认证" aria-label="Permalink to &quot;三、SimpleWebAuthn（v11+）后端验证清单（认证）&quot;">​</a></h2><blockquote><p>术语对齐：</p><ul><li>生成 options：<code>generateAuthenticationOptions()</code></li><li>校验断言：<code>verifyAuthenticationResponse()</code>（v11+）</li></ul></blockquote><p><strong>1）生成认证 options（登录 / 二次校验）</strong></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：用用户已绑定的 credentialId 组装 allowCredentials；若做“无用户名直登”，则留空</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> opts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generateAuthenticationOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  rpID: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RP_ID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行：与页面域名/Related Origins 配套</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  allowCredentials: userCreds?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id: base64url.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c.credentialId), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行：DB里通常以base64url存；此处还原为Buffer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;public-key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    transports: c.transports </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可选；仅提示 UA 选择通道</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  userVerification: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preferred&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或 &#39;required&#39;（则后端需检查 UV）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  timeout: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // extensions: {...}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                              // 需要再加</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：把 challenge 与会话绑定（如用 Redis，键=会话ID）；严格用 base64url 存储与比对</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redis.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`webauthn:challenge:\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sid</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, opts.challenge); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5分钟有效</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opts;</span></span></code></pre></div><p>要点：<strong>challenge 必须保存并一次性使用</strong>；即使验证失败也要作废，防止重放。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data?utm_source=chatgpt.com" title="Authenticator data - Web APIs | MDN - Mozilla" target="_blank" rel="noreferrer">简单网页认证</a>)</p><p><strong>2）验证断言</strong>（前端把 <code>PublicKeyCredential</code> 序列化为上面的 payload 发来）</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：取回并删除 challenge，保证一次性使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> expectedChallenge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redis.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`webauthn:challenge:\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sid</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> verification</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> verifyAuthenticationResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  response: payload, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行：就是你发来的 id/rawId/type/response/...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  expectedChallenge, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 严格等比对；base64url 字面一致</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  expectedOrigin: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ORIGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 例：https://app.example.com</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  expectedRPID: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RP_ID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 例：example.com（或 localhost）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  requireUserVerification: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 若你在 options 里要求 UV，此处也应 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">verification.verified) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // … 统一返回登录失败/请重试</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UnauthorizedException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;webauthn verification failed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：依据 authenticationInfo 更新 signCount、定位凭据与用户</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">newCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">credentialID</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">credentialDeviceType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">userVerified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  verification.authenticationInfo;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行：比对/更新 DB 中该 credential 的 counter；若 newCounter &lt;= 已存值，则可能存在克隆风险</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> credentialRepo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(credentialID, { counter: newCounter });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：若 userHandle 存在，可用于无用户名直登从凭据反查用户</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// （simplewebauthn 已做基础校验；你可根据业务增加“账号冻结/设备绑定”等策略）</span></span></code></pre></div><p>接口与字段含义、错误场景见官方文档。(<a href="https://simplewebauthn.dev/docs/packages/server?utm_source=chatgpt.com" title="simplewebauthn/server" target="_blank" rel="noreferrer">简单网页认证</a>)</p><hr><h2 id="四、浏览器端调用要点-只列差异处" tabindex="-1">四、浏览器端调用要点（只列差异处） <a class="header-anchor" href="#四、浏览器端调用要点-只列差异处" aria-label="Permalink to &quot;四、浏览器端调用要点（只列差异处）&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> publicKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toPublicKeyOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(optionsFromServer);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行：Conditional UI 时，请把 mediation 放在顶层（不是 publicKey 内）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mediation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> optionsFromServer.mediation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">??</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 上一行：本地开发/线下环境，rpId 建议兜底为 &#39;localhost&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;localhost&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;127.0.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(location.hostname)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (publicKey </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).rpId </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;localhost&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cred</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.credentials.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ publicKey, mediation });</span></span></code></pre></div><ul><li><code>mediation: &#39;conditional&#39;</code> 可启用表单自动填充式 Passkey 选择 UI。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li>多域共享凭据需配置 <strong><code>/.well-known/webauthn</code></strong> 的 Related Origin Requests；否则会 <strong><code>SecurityError</code></strong>。(<a href="https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/WebAuthn_Client_Authentication.html?utm_source=chatgpt.com" title="WebAuthn Client Authentication" target="_blank" rel="noreferrer">web.dev</a>)</li></ul><hr><h2 id="五、常见坑-错误映射-含排查建议" tabindex="-1">五、常见坑 &amp; 错误映射（含排查建议） <a class="header-anchor" href="#五、常见坑-错误映射-含排查建议" aria-label="Permalink to &quot;五、常见坑 &amp; 错误映射（含排查建议）&quot;">​</a></h2><ul><li><p><strong><code>SecurityError</code></strong>：<code>rpId</code> 与当前页面域不匹配；或跨域未配置 <strong>Related Origin Requests</strong>。</p><ul><li>检查：页面 <code>origin</code>、服务端 <code>rpId</code>、以及是否有 <code>/.well-known/webauthn</code> JSON（Chrome 支持、Firefox 目前不支持）。(<a href="https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/WebAuthn_Client_Authentication.html?utm_source=chatgpt.com" title="WebAuthn Client Authentication" target="_blank" rel="noreferrer">web.dev</a>)</li></ul></li><li><p><strong><code>NotAllowedError</code></strong>：用户取消、未选择、超时或环境不支持。</p><ul><li>建议：UI 上给“重试/改用其它方式”；适当延长 <code>timeout</code>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul></li><li><p><strong>验签失败</strong>：服务端公钥与凭据不匹配，或签名消息拼装错误（必须 <code>authenticatorData || SHA256(clientDataJSON)</code>）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com" title="CredentialsContainer: get() method - Web APIs - MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></li><li><p><strong><code>UV</code> 不满足</strong>：前端 <code>userVerification: &#39;required&#39;</code>，但设备未解锁；后端 <code>requireUserVerification: true</code> 会拒绝。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></li><li><p><strong><code>signCount</code> 未递增</strong>：提示可能的凭据克隆（部分平台计数恒 0，需在策略上兼容）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</p></li><li><p><strong>JOSE/曲线不支持</strong>（如 OKP/Ed25519）导致 <code>verifyAuthenticationResponse</code> 报错：升级依赖或改用受支持算法；参考 SimpleWebAuthn 的已知问题。(<a href="https://simplewebauthn.dev/docs/packages/server?utm_source=chatgpt.com" title="simplewebauthn/server" target="_blank" rel="noreferrer">简单网页认证</a>)</p></li></ul><hr><h2 id="六、字段作用快速对照-你问到的两类" tabindex="-1">六、字段作用快速对照（你问到的两类） <a class="header-anchor" href="#六、字段作用快速对照-你问到的两类" aria-label="Permalink to &quot;六、字段作用快速对照（你问到的两类）&quot;">​</a></h2><p><strong>A. 后端返回给前端的 <code>options</code> 字段（认证阶段）</strong></p><ul><li><code>challenge</code>：一次性随机数，<strong>必须保存并严格匹配</strong>；验证链路里参与签名。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>rpId</code>：RP ID 域；<strong>决定可用凭据的作用域</strong>；与页面域不匹配会被浏览器直接拒绝。(<a href="https://github.com/w3c/webauthn/issues/1856?utm_source=chatgpt.com" title="Clarify the need for truly randomly generated challenges ..." target="_blank" rel="noreferrer">GitHub</a>)</li><li><code>allowCredentials</code>：可用凭据白名单；空则走“设备自动发现”（更适合<strong>无用户名/直登</strong>）。(<a href="https://github.com/w3c/webauthn/wiki/Explainer%3A-Related-origin-requests?utm_source=chatgpt.com" title="Explainer: Related origin requests · w3c/webauthn Wiki" target="_blank" rel="noreferrer">udn.realityripple.com</a>)</li><li><code>userVerification</code>：本地解锁强度要求；后端需一致地要求/校验。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>timeout</code>：交互时间建议。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>extensions</code>：功能扩展输入。(<a href="https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com" title="Allow passkey reuse across your sites with Related Origin ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>mediation</code>：<strong>顶层参数</strong>（非 <code>publicKey</code> 字段）；控制 Conditional UI。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li></ul><p><strong>B. 你回传给后端的断言字段（认证结果）</strong></p><ul><li><code>id</code>/<code>rawId</code>：凭据标识，<strong>以 <code>rawId</code> 匹配库中凭据</strong>。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>type</code>：恒为 <code>&quot;public-key&quot;</code>。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>response.clientDataJSON</code>：含 <code>challenge</code>/<code>origin</code>/<code>type</code> 等，<strong>要校验</strong>；其哈希参与签名。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>response.authenticatorData</code>：含 <code>rpIdHash</code>/<code>flags</code>/<code>signCount</code> 等，<strong>要校验并更新 counter</strong>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>response.signature</code>：对（<code>authenticatorData || SHA256(clientDataJSON)</code>）的签名，<strong>用公钥验签</strong>。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get?utm_source=chatgpt.com" title="CredentialsContainer: get() method - Web APIs - MDN - Mozilla" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>response.userHandle</code>：可发现凭据时可能有；可用于<strong>无用户名直登</strong>回查账号。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>clientExtensionResults</code>：若使用扩展，建议一并传回。(<a href="https://web.dev/articles/webauthn-related-origin-requests?utm_source=chatgpt.com" title="Allow passkey reuse across your sites with Related Origin ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li><code>options_token</code>：<strong>你系统自定义</strong>的会话/挑战绑定令牌，目的与保存/匹配 challenge 一致（防重放）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data?utm_source=chatgpt.com" title="Authenticator data - Web APIs | MDN - Mozilla" target="_blank" rel="noreferrer">简单网页认证</a>)</li></ul><hr><h2 id="七、参考与延伸" tabindex="-1">七、参考与延伸 <a class="header-anchor" href="#七、参考与延伸" aria-label="Permalink to &quot;七、参考与延伸&quot;">​</a></h2><ul><li>MDN：<code>PublicKeyCredentialRequestOptions</code> 字段总览（挑战、UV、allowCredentials 等）。(<a href="https://www.w3.org/TR/webauthn-2/?utm_source=chatgpt.com" title="Web Authentication: An API for accessing Public Key ..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li>MDN：<code>CredentialsContainer.get()</code>（顶层 <code>mediation</code> 选项）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions?utm_source=chatgpt.com" title="PublicKeyCredentialRequestOpti..." target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li>MDN：<code>AuthenticatorAssertionResponse</code>（断言结构、<code>signature</code> 含义）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/AuthenticatorAttestationResponse/getTransports?utm_source=chatgpt.com" title="AuthenticatorAttestationResponse: getTransports() method" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li>W3C WebAuthn Level 3（2025-01-27 版）。(<a href="https://developers.yubico.com/java-webauthn-server/JavaDoc/webauthn-server-core/2.3.0/com/yubico/webauthn/data/AuthenticatorTransport.html?utm_source=chatgpt.com" title="AuthenticatorTransport (webauthn-server-core 2.3.0 API)" target="_blank" rel="noreferrer">W3C</a>)</li><li>Chrome/Web.dev：<strong>Related Origin Requests</strong> 与 <code>/.well-known/webauthn</code>。(<a href="https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/WebAuthn_Client_Authentication.html?utm_source=chatgpt.com" title="WebAuthn Client Authentication" target="_blank" rel="noreferrer">web.dev</a>)</li><li>SimpleWebAuthn：<code>@simplewebauthn/server</code> 与 <code>@simplewebauthn/browser</code> 文档与“Passkeys”最佳实践。(<a href="https://simplewebauthn.dev/docs/packages/server?utm_source=chatgpt.com" title="simplewebauthn/server" target="_blank" rel="noreferrer">简单网页认证</a>)</li></ul><hr><p>如果你接下来想<strong>严格对齐你后端（NestJS + Redis + SimpleWebAuthn v11+）的参数名</strong>，我可以把上面的两段服务端片段，分别扩成<strong>控制器/服务方法</strong>的“最小可运行版本”，并把**<code>expectedChallenge/Origin/RPID</code><strong>、</strong><code>newCounter</code>** 更新、<strong>设备 ID→ 账号绑定</strong>等都按你现有项目约定补齐。需要的话直接说一声。</p>`,86)])])}const k=t(n,[["render",r]]);export{g as __pageData,k as default};
