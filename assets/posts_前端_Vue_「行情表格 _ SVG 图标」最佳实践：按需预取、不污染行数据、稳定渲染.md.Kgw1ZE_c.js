import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.oqSrIbQK.js";const d=JSON.parse('{"title":"「行情表格 + SVG 图标」最佳实践：按需预取、不污染行数据、稳定渲染","description":"","frontmatter":{"title":"「行情表格 + SVG 图标」最佳实践：按需预取、不污染行数据、稳定渲染","date":"2025-09-23T00:00:00.000Z","tags":null},"headers":[],"relativePath":"posts/前端/Vue/「行情表格 + SVG 图标」最佳实践：按需预取、不污染行数据、稳定渲染.md","filePath":"posts/前端/Vue/「行情表格 + SVG 图标」最佳实践：按需预取、不污染行数据、稳定渲染.md","lastUpdated":1758903911000}'),l={name:"posts/前端/Vue/「行情表格 + SVG 图标」最佳实践：按需预取、不污染行数据、稳定渲染.md"};function h(k,s,p,e,r,E){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h2 id="思路总览" tabindex="-1">思路总览 <a class="header-anchor" href="#思路总览" aria-label="Permalink to &quot;思路总览&quot;">​</a></h2><ul><li><strong>不要把 SVG 图标塞进表格数据行里</strong>（每次报价变更你都会替换成新引用，导致整表重渲染）。</li><li><strong>让行数据只承载行情字段</strong>；图标用 <strong>Store 的缓存（<code>svgMap</code>）在渲染时按需读取</strong>。</li><li><strong>在数据源变更时统一预取</strong><code>ensureSvgs</code>，避免在单元格里“边渲染边请求”。</li><li><strong>表格保持稳定 key</strong>（<code>getRowId</code>），列定义用 <code>shallowRef/const</code> 固化，配合虚拟化减少绘制成本。</li></ul><blockquote><p>Vue 3 的 <code>reactive(Map)</code> 对 <strong>按键读取</strong>有依赖跟踪：<code>svgStore.getCached(symbol)</code> 只会在该 <code>symbol</code> 变更时触发相关单元格更新，不会把整张表绑到整张 Map 上——这是我们选择“渲染时读取”的关键。</p></blockquote><hr><h2 id="步骤一-在数据源变化时批量预取图标-避免单元格内发请求" tabindex="-1">步骤一：在数据源变化时<strong>批量预取</strong>图标（避免单元格内发请求） <a class="header-anchor" href="#步骤一-在数据源变化时批量预取图标-避免单元格内发请求" aria-label="Permalink to &quot;步骤一：在数据源变化时**批量预取**图标（避免单元格内发请求）&quot;">​</a></h2><blockquote><p>在你的行情数据获取逻辑处（例如 <code>useOpenPosition</code> 或列表页容器组件）新增这段 watch。</p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：数据源更新时，批量按当前页面出现的 symbols 预取 SVG</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useSvgStore } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/store/svgStore&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> svgStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSvgStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  dataSource,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">rows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rows </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rows.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 复杂逻辑：去重后的 symbol 列表，按需指定 image_type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pageSymbols</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rows.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SYMBOL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.symbol))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Boolean);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    svgStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ensureSvgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pageSymbols, { image_type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;svg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  { immediate: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ul><li>好处：<strong>一次网络请求</strong>覆盖当前页全部符号；</li><li>Store 自带负缓存 / 合并窗口，不会风暴式请求。</li></ul><hr><h2 id="步骤二-列定义里从-store-读取缓存-不修改行数据" tabindex="-1">步骤二：<strong>列定义里</strong>从 Store 读取缓存，不修改行数据 <a class="header-anchor" href="#步骤二-列定义里从-store-读取缓存-不修改行数据" aria-label="Permalink to &quot;步骤二：**列定义里**从 Store 读取缓存，不修改行数据&quot;">​</a></h2><blockquote><p>只改列定义的 <code>cell</code>，让它在渲染时从 Store 拿图标；<strong>不要</strong>把 <code>symbol_svg</code> 写回到行数据。</p></blockquote><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：列定义文件顶部引入 Store（保持单例）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useSvgStore } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@/store/svgStore&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getSymbolListColumns</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 你的参数 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：只创建一次，避免每次 render 都 new 一个 Store</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> svgStore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSvgStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      header: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;trading.search.table.symbol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      accessorKey: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;symbol&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      size: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">140</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      meta: { sticky: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;left&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      cell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        row: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          original: { symbol },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 复杂逻辑：渲染时读取缓存；仅该 symbol 变更时会更新本单元格</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> svgItem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> svgStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getCached</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(symbol);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 你的 ForexPairs 接口：假设接收 images 或 src 列表；未命中时给占位</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bg-ground-box cursor-pointer flex items-center justify-between gap-1&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            &lt;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ForexPairs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              image</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              title</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{symbol}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              images</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{svgItem?.images ?? []} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 未命中时给空数组或占位</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // loading={ !svgItem }</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 若组件支持 loading，可带上</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          &lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... 其它列不变</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ] as ColumnDef&lt;any&gt;[];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><strong>为何不把 <code>symbol_svg</code> 推进行数据？</strong></p><ul><li>你的行情 <code>dataSource</code> 在报价变更时会替换为<strong>新引用</strong>；若你把图标也混进行数据，<strong>每次报价</strong>都让“静态图标字段”跟着重建，放大了渲染成本。</li><li>把图标留在 Store，由单元格按键读取，可做到 <strong>“动态图标独立更新，行情变更不影响已缓存图标”</strong>。</li></ul><hr><h2 id="步骤三-表格稳定性优化-强烈建议" tabindex="-1">步骤三：表格<strong>稳定性优化</strong>（强烈建议） <a class="header-anchor" href="#步骤三-表格稳定性优化-强烈建议" aria-label="Permalink to &quot;步骤三：表格**稳定性优化**（强烈建议）&quot;">​</a></h2><ol><li><p><strong>固定行 key</strong>（避免整行重建）</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useVueTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  data: dataSource.value,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  columns,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getRowId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">row</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SYMBOL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row.symbol, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：行标识稳定</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 其它配置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>列定义常驻</strong></p><ul><li>列数组用 <code>const</code> 或 <code>shallowRef</code> 初始化一次，避免每次渲染都重建列定义。</li></ul></li><li><p><strong>虚拟化容器尺寸稳定</strong></p><ul><li><code>@tanstack/vue-virtual</code> 的 <code>estimateSize</code> / <code>overscan</code> 做好配置，减少滚动时的抖动与频繁挂载。</li></ul></li></ol><hr><h2 id="步骤四-滚动-分页预取-可选增强" tabindex="-1">步骤四：<strong>滚动/分页预取</strong>（可选增强） <a class="header-anchor" href="#步骤四-滚动-分页预取-可选增强" aria-label="Permalink to &quot;步骤四：**滚动/分页预取**（可选增强）&quot;">​</a></h2><p>当你有分页/虚拟滚动时，可以在<strong>可视区变更</strong>时预判接下来可能出现的 symbols，提前 <code>ensureSvgs</code>：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：在可视区变化时，基于 index 预测下一屏的 symbols 并预取</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(virtualizerRange, ({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">startIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">endIndex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextRange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { start: Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, endIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), end: endIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextSymbols</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rows</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextRange.start, nextRange.end)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SYMBOL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ??</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.symbol);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  svgStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ensureSvgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextSymbols)), { image_type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;svg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h2 id="反例对比-为什么-不推荐在每次数据变更时把图标塞回行数据" tabindex="-1">反例对比：为什么“不推荐在每次数据变更时把图标塞回行数据” <a class="header-anchor" href="#反例对比-为什么-不推荐在每次数据变更时把图标塞回行数据" aria-label="Permalink to &quot;反例对比：为什么“不推荐在每次数据变更时把图标塞回行数据”&quot;">​</a></h2><ul><li><strong>多余的内存拷贝</strong>：每个 tick 都在复制一份相同的 SVG 数据。</li><li><strong>渲染级联</strong>：tanstack table 在数据引用变化时需要重建模型，虚拟化也会触发更多计算。</li><li><strong>更新不聚焦</strong>：图标本身频率极低，却被行情高频刷新“绑架”。</li></ul><p><strong>正确姿势</strong>：<strong>数据行只承载“会变的行情字段”</strong>，<strong>资源/元数据</strong>（图标、静态文案）放在 <strong>Store</strong>，按需读取。</p><hr><h2 id="小贴士-结合你当前-store-能力" tabindex="-1">小贴士（结合你当前 Store 能力） <a class="header-anchor" href="#小贴士-结合你当前-store-能力" aria-label="Permalink to &quot;小贴士（结合你当前 Store 能力）&quot;">​</a></h2><ul><li><p>你的 <code>useSvgStore</code> 已有 <strong>合并窗口</strong>、<strong>负缓存</strong>、<strong>inflight 去重</strong>、<strong><code>nextTick</code> 消竞态</strong>：</p><ul><li>这允许你<strong>放心在渲染时读取</strong>并在数据源变化时<strong>统一预取</strong>，不会造成请求放大或时序问题。</li></ul></li><li><p>若列表有<strong>很大规模</strong>的 symbols，预取时可以分批（例如 200/批）并加个微小延迟窗，进一步平滑流量。</p></li></ul><hr><h2 id="最简对接清单" tabindex="-1">最简对接清单 <a class="header-anchor" href="#最简对接清单" aria-label="Permalink to &quot;最简对接清单&quot;">​</a></h2><ol><li>在容器组件 <code>watch(dataSource)</code> → <code>ensureSvgs(当前页 symbols)</code> ✅</li><li>列定义的 <code>cell</code>：<code>svgStore.getCached(symbol)</code> 渲染，未命中给占位 ✅</li><li><code>getRowId</code> 固定行 key；列定义常驻 ✅</li><li>（可选）可视区预测 → 预取下一屏 ✅</li></ol><blockquote><p>这样做，<strong>行情高频刷新</strong>与<strong>图标静态资源</strong>彻底解耦：</p><ul><li>图标只在<strong>首次出现</strong>或<strong>TTL 过期</strong>时触发请求；</li><li>单元格只对<strong>自身 symbol</strong>变化敏感；</li><li>虚拟化 + 稳定 key 让滚动与刷新都很“轻”。</li></ul></blockquote>`,32)])])}const o=i(l,[["render",h]]);export{d as __pageData,o as default};
