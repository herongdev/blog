import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.oqSrIbQK.js";const c=JSON.parse('{"title":"“只绑定了苹果，但在 Windows 的 Chrome 登录怎么办？”——跨设备 Passkey 的正确处理方式（含最小改动代码）","description":"","frontmatter":{"title":"“只绑定了苹果，但在 Windows 的 Chrome 登录怎么办？”——跨设备 Passkey 的正确处理方式（含最小改动代码）","date":"2025-09-17T00:00:00.000Z","tags":null},"headers":[],"relativePath":"posts/需求实现/登录鉴权/跨设备 Passkey 的正确处理方式.md","filePath":"posts/需求实现/登录鉴权/跨设备 Passkey 的正确处理方式.md","lastUpdated":1758470468000}'),t={name:"posts/需求实现/登录鉴权/跨设备 Passkey 的正确处理方式.md"};function l(h,s,p,r,k,o){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h2 id="快速回答" tabindex="-1">快速回答 <a class="header-anchor" href="#快速回答" aria-label="Permalink to &quot;快速回答&quot;">​</a></h2><p>是的，<strong>把当前用户绑定的所有凭据（credentialId 列表，不是“类型”）都给浏览器</strong>是更稳妥的主路线。即使本机没有该 passkey，也可以通过 <strong>跨设备（Hybrid/caBLE）</strong> 用手机（iPhone/Android）扫码登录：浏览器弹出“用附近设备/手机的通行密钥”选项，展示二维码，用户用手机确认后完成签名。苹果官方与 WebAuthn 规范均明确支持这一路径。(<a href="https://developer.apple.com/passkeys/?utm_source=chatgpt.com" title="Passkeys Overview" target="_blank" rel="noreferrer">Apple Developer</a>)</p><blockquote><p>这意味着：<strong>在 Windows 的 Chrome 上，即使用户只在 iPhone（iCloud Keychain）里有 passkey，也能通过</strong>“<strong>用 iPhone 登录</strong>”<strong>扫码完成认证</strong>，前端无需硬拒绝。(<a href="https://support.apple.com/guide/iphone/use-passkeys-to-sign-in-to-websites-and-apps-iphf538ea8d0/ios?utm_source=chatgpt.com" title="Use passkeys to sign in to websites and apps on iPhone" target="_blank" rel="noreferrer">苹果支持</a>)</p></blockquote><hr><h2 id="推荐策略-更合理的业界做法" tabindex="-1">推荐策略（更合理的业界做法） <a class="header-anchor" href="#推荐策略-更合理的业界做法" aria-label="Permalink to &quot;推荐策略（更合理的业界做法）&quot;">​</a></h2><ol><li><p><strong>优先基于真实凭据，而不是猜供应商</strong>：把用户已绑定的所有 <code>credentialId</code> 作为 <code>allowCredentials</code> 发给浏览器；若用 <strong>Conditional UI</strong>（表单自动填充），规范要求把 <code>allowCredentials</code> 设为空数组，让浏览器列出可发现凭据。(<a href="https://web.dev/articles/webauthn-discoverable-credentials?utm_source=chatgpt.com" title="Discoverable credentials deep dive | Articles" target="_blank" rel="noreferrer">web.dev</a>)</p></li><li><p><strong>启用跨设备能力</strong>：为每个 <code>allowCredentials</code> 描述符补上 <code>transports</code>，包含 <code>&#39;hybrid&#39;</code> 等，以便触发“手机扫码登录”的混合传输。规范与 MDN 都有“hybrid/获取可用传输方式”的说明。(<a href="https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com" title="An API for accessing Public Key Credentials - Level 3" target="_blank" rel="noreferrer">W3C</a>)</p></li><li><p><strong>做能力探测与兜底</strong>：</p><ul><li><code>PublicKeyCredential.isConditionalMediationAvailable()</code> → 支持则走 Conditional UI；(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isConditionalMediationAvailable_static?utm_source=chatgpt.com" title="isConditionalMediationAvailable() static method - Web APIs" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li>失败（如设备上没有匹配凭据/用户取消）则<strong>回退到</strong> <code>allowCredentials: []</code> 或提示“换设备/用手机”。</li></ul></li><li><p><strong>“类型 type”建议在</strong>“<strong>验证完成后</strong>”<strong>再落定</strong>：后端从<strong>本次使用的 credentialId</strong> 查到供应商（可用 <strong>AAGUID→ 供应商</strong> 映射），再记录 <code>1=苹果/2=谷歌</code>。这样比前置“猜类型”健壮。(<a href="https://developer.apple.com/documentation/authenticationservices/supporting-passkeys?utm_source=chatgpt.com" title="Supporting passkeys | Apple Developer Documentation" target="_blank" rel="noreferrer">Apple Developer</a>)</p></li></ol><hr><h2 id="仅需修改的代码片段" tabindex="-1">仅需修改的代码片段 <a class="header-anchor" href="#仅需修改的代码片段" aria-label="Permalink to &quot;仅需修改的代码片段&quot;">​</a></h2><blockquote><p>以下是<strong>在你已有实现基础上</strong>的最小改动： 1）更新“选择类型”的函数：<strong>Windows+Chrome 且只绑了苹果</strong>时，不再返回 <code>-1</code>，而是<strong>返回 1</strong>，允许跨设备； 2）补一个<strong>登录兜底</strong>：先用 allowList 试；失败则退回 <strong>空 allowList +（可用时）Conditional UI</strong>； 3）构建 <code>allowCredentials</code> 时带上 <code>transports: [&#39;hybrid&#39;, &#39;internal&#39;, &#39;usb&#39;, &#39;nfc&#39;, &#39;ble&#39;]</code>。</p></blockquote><h3 id="_1-更新你之前的-decidepasskeytype-只改-windows-分支" tabindex="-1">1）更新你之前的 <code>decidePasskeyType</code>（只改 Windows 分支） <a class="header-anchor" href="#_1-更新你之前的-decidepasskeytype-只改-windows-分支" aria-label="Permalink to &quot;1）更新你之前的 \`decidePasskeyType\`（只改 Windows 分支）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：Windows 上若无谷歌但绑定了苹果，允许走“混合传输（iPhone 扫码）”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isWindows) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isChromium </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hasGoogle) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (hasApple) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← 新增：不再直接 -1，支持用 iPhone 跨设备登录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>依据：WebAuthn L3 支持 <strong>hybrid</strong> 传输；苹果官方支持在非 Apple 设备上用 iPhone 扫码使用 passkey。(<a href="https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com" title="An API for accessing Public Key Credentials - Level 3" target="_blank" rel="noreferrer">W3C</a>)</p></blockquote><h3 id="_2-构建-allowcredentials-新增一个小工具" tabindex="-1">2）构建 <code>allowCredentials</code>（新增一个小工具） <a class="header-anchor" href="#_2-构建-allowcredentials-新增一个小工具" aria-label="Permalink to &quot;2）构建 \`allowCredentials\`（新增一个小工具）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：为每个已绑定凭据提供 transports，开启跨设备选项（hybrid）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildAllowCredentials</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">creds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }[]) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> transports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AuthenticatorTransport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;hybrid&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;internal&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;usb&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;nfc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;ble&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> creds.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;public-key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">base64urlToUint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c.id),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    transports, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← 关键</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>规范与 MDN 对 <code>hybrid</code>/传输有说明；大多数现代 passkey 为“可发现凭据”。(<a href="https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com" title="An API for accessing Public Key Credentials - Level 3" target="_blank" rel="noreferrer">W3C</a>)</p></blockquote><h3 id="_3-登录兜底逻辑-先-allowlist-失败再空列表-conditional-ui" tabindex="-1">3）登录兜底逻辑（先 allowList，失败再空列表 + Conditional UI） <a class="header-anchor" href="#_3-登录兜底逻辑-先-allowlist-失败再空列表-conditional-ui" aria-label="Permalink to &quot;3）登录兜底逻辑（先 allowList，失败再空列表 + Conditional UI）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：先尝试“精确匹配已绑定凭据”；失败再回退到“让浏览器列出所有可发现凭据”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loginWithFallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">opts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  challenge</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  userCreds</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }[]; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 你的数据库里拿到的本用户全部 credentialId</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 尝试 1：用 allowCredentials 精确匹配（含 hybrid，支持跨设备）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> startAuthentication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      publicKey: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        challenge: opts.challenge,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        allowCredentials: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">buildAllowCredentials</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opts.userCreds),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timeout: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">45000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        userVerification: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preferred&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 复杂逻辑：没有可用凭据/用户取消等 -&gt; 回退到 Conditional UI 或空 allowList</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> supportConditional</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PublicKeyCredential.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isConditionalMediationAvailable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">?.();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> startAuthentication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      publicKey: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        challenge: opts.challenge,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 关键：空 allowCredentials 让浏览器展示“可发现凭据”（含手机扫码）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        allowCredentials: [],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        userVerification: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preferred&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 条件式 UI 可用则用 &#39;conditional&#39;，否则退到默认</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      mediation: supportConditional </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;conditional&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;optional&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>资料：</p><ul><li><strong>Conditional UI</strong>/表单自动填充与能力探测（<code>isConditionalMediationAvailable</code>）。(<a href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isConditionalMediationAvailable_static?utm_source=chatgpt.com" title="isConditionalMediationAvailable() static method - Web APIs" target="_blank" rel="noreferrer">MDN Web Docs</a>)</li><li>空 <code>allowCredentials</code> → 由浏览器列出<strong>可发现凭据</strong>。(<a href="https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com" title="Passkeys" target="_blank" rel="noreferrer">simplewebauthn.dev</a>)</li></ul></blockquote><blockquote><p>小提示：Chrome 传入多个 <code>allowCredentials</code> 时，UI 可能只挑一个呈现，选择策略并非由你控制，这是正常现象。(<a href="https://stackoverflow.com/questions/76330542/webauthn-allowcredentials-and-credential-selection?utm_source=chatgpt.com" title="Webauthn - allowCredentials and credential selection" target="_blank" rel="noreferrer">Stack Overflow</a>)</p></blockquote><hr><h2 id="服务器端两点备注" tabindex="-1">服务器端两点备注 <a class="header-anchor" href="#服务器端两点备注" aria-label="Permalink to &quot;服务器端两点备注&quot;">​</a></h2><ul><li><strong>生成认证参数</strong>：把数据库中的所有本用户凭据（按你愿意的优先级排序）传给 <code>generateAuthenticationOptions({ allowCredentials })</code>；若走 Conditional UI 的路由，则按规范<strong>清空</strong> <code>allowCredentials</code>。SimpleWebAuthn 文档与规范对这点都有说明。(<a href="https://simplewebauthn.dev/docs/advanced/passkeys?utm_source=chatgpt.com" title="Passkeys" target="_blank" rel="noreferrer">simplewebauthn.dev</a>)</li><li><strong>确定“type”</strong>：验证成功后，后端能拿到本次使用的 <code>credentialID</code>（SimpleWebAuthn 的返回会携带，近期版本将其规范为 base64url 字符串），再根据你存的 <strong>AAGUID→ 供应商</strong> 映射落定 <code>1/2</code>；不建议在认证前硬判供应商。(<a href="https://github.com/MasterKale/SimpleWebAuthn/releases?utm_source=chatgpt.com" title="Releases · MasterKale/SimpleWebAuthn" target="_blank" rel="noreferrer">GitHub</a>)</li></ul><hr><h2 id="为什么这是主流最佳实践" tabindex="-1">为什么这是主流最佳实践 <a class="header-anchor" href="#为什么这是主流最佳实践" aria-label="Permalink to &quot;为什么这是主流最佳实践&quot;">​</a></h2><ul><li><strong>跨设备是官方一等公民</strong>：WebAuthn L3/CTAP 明确“<strong>hybrid</strong>”传输；当本机没有该 passkey 时，可用手机扫码完成登录。(<a href="https://www.w3.org/TR/webauthn-3/?utm_source=chatgpt.com" title="An API for accessing Public Key Credentials - Level 3" target="_blank" rel="noreferrer">W3C</a>)</li><li><strong>Discoverable credentials/Passkeys 普及</strong>：空 <code>allowCredentials</code> 让浏览器列出所有可发现凭据，配合 <strong>Conditional UI</strong> 达到一键直登体验。(<a href="https://web.dev/articles/webauthn-discoverable-credentials?utm_source=chatgpt.com" title="Discoverable credentials deep dive | Articles" target="_blank" rel="noreferrer">web.dev</a>)</li><li><strong>苹果官方明确</strong>：<strong>在非 Apple 设备上也能用 iPhone 的 passkey</strong>（二维码/附近设备）。(<a href="https://developer.apple.com/passkeys/?utm_source=chatgpt.com" title="Passkeys Overview" target="_blank" rel="noreferrer">Apple Developer</a>)</li></ul><hr><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><ul><li>你的理解是对的：<strong>把用户已绑定的所有凭据给浏览器</strong>，浏览器会自动选择本机/外接/手机可用的那一个。</li><li><strong>在 Windows Chrome 但只绑定了苹果时</strong>，不要提前判 <code>-1</code>。按本文最小改动：<strong>类型返回 1</strong>，前端通过 <code>allowCredentials + hybrid</code> 与<strong>兜底的空列表/Conditional UI</strong>，就能让用户<strong>用 iPhone 扫码完成登录</strong>。</li><li>长期看，把“类型”挪到<strong>验证后</strong>基于 <code>credentialID→AAGUID→供应商</code> 来落定，才是更健壮的主路线。</li></ul>`,28)])])}const g=i(t,[["render",l]]);export{c as __pageData,g as default};
