import{_ as s,c as a,o as t,ag as e}from"./chunks/framework.oqSrIbQK.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/swift-advanced-v2/指令/@objc.md","filePath":"posts/swift-advanced-v2/指令/@objc.md","lastUpdated":1758634537000}'),n={name:"posts/swift-advanced-v2/指令/@objc.md"};function l(h,i,p,o,c,k){return t(),a("div",null,[...i[0]||(i[0]=[e('<p><code>@objc</code> 是 Swift 中的一个属性（attribute），用于将 Swift 代码暴露给 Objective-C 运行时。让我详细解释一下：</p><h2 id="objc-的作用" tabindex="-1"><code>@objc</code> 的作用 <a class="header-anchor" href="#objc-的作用" aria-label="Permalink to &quot;`@objc` 的作用&quot;">​</a></h2><ol><li><strong>Objective-C 互操作性</strong>：使 Swift 类、方法、属性能够被 Objective-C 代码调用</li><li><strong>运行时访问</strong>：允许在运行时通过字符串名称访问方法和属性</li><li><strong>动态特性</strong>：支持一些需要 Objective-C 运行时的功能，如 KVO、选择器等</li></ol><h2 id="在你的代码中的使用" tabindex="-1">在你的代码中的使用 <a class="header-anchor" href="#在你的代码中的使用" aria-label="Permalink to &quot;在你的代码中的使用&quot;">​</a></h2><p>从你的 <code>DeviceIdNative.swift</code> 文件中可以看到几种使用场景：</p><h3 id="_1-类级别的-objc" tabindex="-1">1. 类级别的 <code>@objc</code> <a class="header-anchor" href="#_1-类级别的-objc" aria-label="Permalink to &quot;1. 类级别的 `@objc`&quot;">​</a></h3><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@objc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeviceIdNative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span></code></pre></div><ul><li>将整个类暴露给 Objective-C</li><li>继承自 <code>NSObject</code> 是为了获得 Objective-C 的基础功能</li></ul><h3 id="_2-方法级别的-objc" tabindex="-1">2. 方法级别的 <code>@objc</code> <a class="header-anchor" href="#_2-方法级别的-objc" aria-label="Permalink to &quot;2. 方法级别的 `@objc`&quot;">​</a></h3><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@objc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setConsent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    consent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@objc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getIDFAOrNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> requestATT: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>将特定方法暴露给 Objective-C</li><li>这些方法可以被其他语言（如 JavaScript、Java 等）通过桥接调用</li></ul><h2 id="为什么需要-objc" tabindex="-1">为什么需要 <code>@objc</code>？ <a class="header-anchor" href="#为什么需要-objc" aria-label="Permalink to &quot;为什么需要 `@objc`？&quot;">​</a></h2><p>在你的项目中，这是一个 <strong>uni-app 的 UTS 插件</strong>：</p><ol><li><strong>跨平台调用</strong>：UTS (uni-app TypeScript) 需要调用原生 iOS 代码</li><li><strong>桥接机制</strong>：<code>@objc</code> 使得 TypeScript/JavaScript 可以通过 uni-app 的桥接机制调用这些 Swift 方法</li><li><strong>统一接口</strong>：确保 iOS 和 Android 平台提供一致的 API 接口</li></ol><h2 id="语法特点" tabindex="-1">语法特点 <a class="header-anchor" href="#语法特点" aria-label="Permalink to &quot;语法特点&quot;">​</a></h2><ul><li><strong>可选参数</strong>：Swift 的参数标签在 Objective-C 中会变成方法名的一部分</li><li><strong>类型映射</strong>：Swift 类型会自动映射到对应的 Objective-C 类型</li><li><strong>返回值</strong>：可选类型 <code>String?</code> 在 Objective-C 中变成可为 nil 的对象</li></ul><p>总的来说，<code>@objc</code> 是 Swift 与 Objective-C 互操作的关键机制，在你的项目中主要用于让 uni-app 的跨平台框架能够调用原生 iOS 功能。</p>',17)])])}const g=s(n,[["render",l]]);export{d as __pageData,g as default};
