import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.oqSrIbQK.js";const o=JSON.parse('{"title":"Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点","description":"","frontmatter":{"title":"Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点","date":"2025-09-16T00:00:00.000Z"},"headers":[],"relativePath":"posts/swift-advanced-v2/指令/Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点.md","filePath":"posts/swift-advanced-v2/指令/Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点.md","lastUpdated":1758470468000}'),l={name:"posts/swift-advanced-v2/指令/Swift 尾随闭包（Trailing Closure）——一文讲清语法、用法与坑点.md"};function h(p,s,e,k,r,d){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h2 id="什么是尾随闭包" tabindex="-1">什么是尾随闭包？ <a class="header-anchor" href="#什么是尾随闭包" aria-label="Permalink to &quot;什么是尾随闭包？&quot;">​</a></h2><p><strong>尾随闭包</strong>是 Swift 提供的语法糖：当<strong>函数的最后一个参数是闭包</strong>时，可以把这个闭包<strong>写在圆括号 <code>()</code> 外面</strong>，让调用更简洁、更像“DSL”。</p><p>对比（同义写法）：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 普通写法（闭包写在括号里）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arg1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 尾随闭包（把最后一个闭包挪到括号外）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arg1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="语法细节-逐条讲清" tabindex="-1">语法细节（逐条讲清） <a class="header-anchor" href="#语法细节-逐条讲清" aria-label="Permalink to &quot;语法细节（逐条讲清）&quot;">​</a></h2><h3 id="_1-闭包基本形态" tabindex="-1">1) 闭包基本形态 <a class="header-anchor" href="#_1-闭包基本形态" aria-label="Permalink to &quot;1) 闭包基本形态&quot;">​</a></h3><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ (参数列表) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 返回类型 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 闭包体</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>in</code>：分隔<strong>参数/返回类型声明</strong>与<strong>闭包体</strong>。</li><li>未用到的参数可用 <code>_</code> 忽略；也可用<strong>参数速记</strong> <code>$0</code>、<code>$1</code>：</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value) }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等价</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;done&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }</span></span></code></pre></div><h3 id="_2-尾随闭包的触发条件" tabindex="-1">2) 尾随闭包的触发条件 <a class="header-anchor" href="#_2-尾随闭包的触发条件" aria-label="Permalink to &quot;2) 尾随闭包的触发条件&quot;">​</a></h3><ul><li><strong>函数的最后一个参数</strong>必须是闭包；否则不能使用尾随闭包语法（Swift 5.3 起有“多尾随闭包”，见下一条）。</li><li>若函数<strong>只有一个参数且是闭包</strong>，可以<strong>省略空括号</strong>：</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只有闭包一个参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) }   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等价于 doSomething(closure: { ... })</span></span></code></pre></div><h3 id="_3-多尾随闭包-swift-5-3" tabindex="-1">3) 多尾随闭包（Swift 5.3+） <a class="header-anchor" href="#_3-多尾随闭包-swift-5-3" aria-label="Permalink to &quot;3) 多尾随闭包（Swift 5.3+）&quot;">​</a></h3><p>当函数有<strong>多个闭包参数</strong>时，可以把<strong>第一个</strong>闭包写成<strong>无标签</strong>的尾随闭包，<strong>后面的闭包</strong>放在后面、<strong>带标签</strong>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UIView.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">withDuration</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // animations（第一个尾随闭包，无标签）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">completion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { finished </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // completion（第二个尾随闭包，有标签）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>规则小抄：</p><ul><li>第一个尾随闭包<strong>不写标签</strong>。</li><li>后续尾随闭包<strong>必须写出参数标签</strong>（如 <code>completion:</code>、<code>onError:</code>）。</li></ul><h3 id="_4-与-gcd-回调常见组合" tabindex="-1">4) 与 GCD/回调常见组合 <a class="header-anchor" href="#_4-与-gcd-回调常见组合" aria-label="Permalink to &quot;4) 与 GCD/回调常见组合&quot;">​</a></h3><p>你的 ATT 例子里就用了尾随闭包：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DispatchQueue.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ATTrackingManager.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">requestTrackingAuthorization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 尾随闭包</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sem.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>async { ... }</code> 的 <code>{ ... }</code> 是<strong>把任务提交到队列执行</strong>的闭包。</li><li><code>requestTrackingAuthorization { _ in ... }</code> 是<strong>授权结果回调</strong>闭包；参数（授权状态）被 <code>_</code> 忽略。</li></ul><h3 id="_5-捕获列表与内存管理-避免循环引用" tabindex="-1">5) 捕获列表与内存管理（避免循环引用） <a class="header-anchor" href="#_5-捕获列表与内存管理-避免循环引用" aria-label="Permalink to &quot;5) 捕获列表与内存管理（避免循环引用）&quot;">​</a></h3><p>尾随闭包一样可以写<strong>捕获列表</strong>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">someAsyncWork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">weak</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    self</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>闭包默认<strong>强引用</strong>捕获 <code>self</code>，在异步/长期存活的闭包里用 <code>[weak self]</code> 更安全。</li><li>与是否“尾随”无关；是<strong>闭包语法</strong>的一部分。</li></ul><h3 id="_6-escaping-与是否能-逃出当前作用域" tabindex="-1">6) <code>@escaping</code> 与是否能“逃出当前作用域” <a class="header-anchor" href="#_6-escaping-与是否能-逃出当前作用域" aria-label="Permalink to &quot;6) \`@escaping\` 与是否能“逃出当前作用域”&quot;">​</a></h3><ul><li>如果函数<strong>把闭包存起来稍后再调用</strong>（如异步回调），参数要标注 <code>@escaping</code>，这与是否尾随无关：</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> completion: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@escaping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">doAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value) }   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 尾随闭包照常使用</span></span></code></pre></div><hr><h2 id="何时该用-不该用" tabindex="-1">何时该用/不该用？ <a class="header-anchor" href="#何时该用-不该用" aria-label="Permalink to &quot;何时该用/不该用？&quot;">​</a></h2><p><strong>更该用的时候</strong></p><ul><li>闭包体<strong>较长</strong>或<strong>是调用的主体</strong>（例如布局 DSL、动画、网络回调）。</li><li>读起来像自然语言，<strong>减少括号层级</strong>。</li></ul><p><strong>不该用的时候</strong></p><ul><li>函数还有<strong>闭包后面的非闭包参数</strong>（顺序不允许）。</li><li>读者难以分辨哪个是参数、哪个是闭包（<strong>可回退</strong>到普通写法提升可读性）。</li></ul><hr><h2 id="常见坑" tabindex="-1">常见坑 <a class="header-anchor" href="#常见坑" aria-label="Permalink to &quot;常见坑&quot;">​</a></h2><ol><li><p><strong>闭包不是最后一个参数</strong> 不能用尾随闭包（或调整函数签名/调用顺序；或使用多尾随闭包语法）。</p></li><li><p><strong>主线程阻塞</strong> 尾随闭包只是写法变了，<strong>线程/阻塞行为不变</strong>。例如你那段代码里 <code>wait</code> 会阻塞当前线程，因此<strong>不要在主线程</strong>调用包着 <code>wait</code> 的函数。</p></li><li><p><strong>参数标签忘写（多尾随闭包）</strong> 第二个及之后的尾随闭包<strong>必须写标签</strong>，否则不通过。</p></li></ol><hr><h2 id="一段对照练习-从普通到尾随" tabindex="-1">一段对照练习（从普通到尾随） <a class="header-anchor" href="#一段对照练习-从普通到尾随" aria-label="Permalink to &quot;一段对照练习（从普通到尾随）&quot;">​</a></h2><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 普通</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: url, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">success</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">failure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 多尾随闭包（Swift 5.3+）</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: url) { data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">failure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><ul><li><strong>尾随闭包 = “把最后一个闭包参数挪到括号外”</strong> 的写法，核心是<strong>让调用更好读</strong>。</li><li>掌握三件事：<strong>基本闭包语法（参数/返回/in）</strong>、<strong>多尾随闭包规则</strong>、<strong>与并发内存管理的配合（<code>[weak self]</code>、<code>@escaping</code>）</strong>。</li><li>记住：<strong>语法糖不改变语义</strong>；是否阻塞、在哪个线程、何时执行，取决于<strong>函数实现与你怎么调</strong>，不是“尾随”本身。</li></ul>`,43)])])}const E=i(l,[["render",h]]);export{o as __pageData,E as default};
