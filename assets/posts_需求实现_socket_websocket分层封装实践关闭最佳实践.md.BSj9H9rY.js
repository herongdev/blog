import{_ as i,c as e,o,ag as r}from"./chunks/framework.oqSrIbQK.js";const g=JSON.parse('{"title":"分层与命名建议","description":"","frontmatter":{},"headers":[],"relativePath":"posts/需求实现/socket/websocket分层封装实践关闭最佳实践.md","filePath":"posts/需求实现/socket/websocket分层封装实践关闭最佳实践.md","lastUpdated":1764331727000}'),s={name:"posts/需求实现/socket/websocket分层封装实践关闭最佳实践.md"};function t(n,l,c,a,p,u){return o(),e("div",null,[...l[0]||(l[0]=[r('<h1 id="分层与命名建议" tabindex="-1">分层与命名建议 <a class="header-anchor" href="#分层与命名建议" aria-label="Permalink to &quot;分层与命名建议&quot;">​</a></h1><ol><li><p>传输层（Transport / Adapter）</p><ul><li>现在的类：<code>WebSocketClient</code></li><li>职责：原生 WebSocket 封装、事件派发、心跳、重连（指数退避+抖动）、优雅关闭。</li><li>常见模式：<strong>Adapter</strong>（适配原生 API）、<strong>Event Emitter/Observer</strong>（事件发布订阅）。</li></ul></li><li><p>会话/连接层（Connection / Supervisor / Subscription Manager）</p><ul><li>现在的类：<code>WebSocketService</code></li><li>职责：连接生命周期管理（先关后开、代次隔离）、订阅状态机（pending/active）、批量订阅/退订、切换连接时的回灌。</li><li>常见模式：<strong>Supervisor</strong>（监督者，Erlang/Elixir 风格）、<strong>Facade</strong>（对上层提供简化接口）、<strong>Reconciler</strong>（把“期望状态”与“实际状态”对齐）。</li></ul></li><li><p>应用层/状态层（Application Store / Orchestrator）</p><ul><li>现在的模块：Pinia <code>useSocketStore</code></li><li>职责：计算“期望订阅集”（来自多个模块池的并集）、与 Service 做<strong>差量对齐</strong>、业务侧缓存（行情/订单/资金）、登录单飞、命令发送与结果路由。</li><li>常见模式：<strong>MVVM</strong> 里的 <strong>Model/Store</strong>、<strong>Orchestrator</strong>（编排者）、<strong>Controller-Reconciler</strong>（Kubernetes 控制器那套“期望 vs 实际”的宣言式对齐）。</li></ul></li></ol><p>简单一句话：<strong>Adapter（Client） → Supervisor/Facade（Service） → Orchestrator/Store（Pinia）</strong>。</p><h2 id="传输层-transport-adapter" tabindex="-1">传输层（Transport / Adapter） <a class="header-anchor" href="#传输层-transport-adapter" aria-label="Permalink to &quot;传输层（Transport / Adapter）&quot;">​</a></h2><ol><li><p>通过 class 来进行封装；主要管五件事：</p><ul><li>创建实例</li><li>实例操作（连接，关闭）</li><li>操作四种事件处理：（连接成功，收到消息，连接或关闭失败，关闭成功）</li><li>心跳管理</li><li>重连管理</li></ul></li><li><p>构造函数保存的值有，三类：实例，重连相关，心跳</p><ul><li>websocket 实例</li><li>重连相关：close 后是否重连，间隔，最大重连次数，当前已经重连次数</li><li>心跳间隔</li><li>心跳计时器</li></ul></li><li><p>主动 connect 方法</p><ul><li><p>设置 close 后可重连</p></li><li><p>创建实例</p></li><li><p>设置四个事件的监听</p><ul><li>open 回调 <ul><li>重置已重连次数</li><li>向外通知 open 事件</li><li>开始心跳</li></ul></li><li>close 事件回调，默认是回重连的 <ul><li>向外发布 close 事件</li><li>停止心跳（清除计时器）</li><li>重连</li></ul></li><li>message 事件回调：向外发布事件</li><li>error 事件回调：向外发布事件</li></ul></li></ul></li><li><p>close 连接的方法</p><ul><li>控制状态来决定要不要重试</li><li>调用原生 ws.close</li><li><strong>重点</strong> close 包括 ws 原生的 close 调用后，并不是说就一定 close 了，我们还要监听 ws.onclose 事件，事件触发才是真正的 close，所有调用 close，和 promise 的等待 onclose 事件是不一样的；</li></ul></li></ol><h2 id="会话-连接层-connection-supervisor-subscription-manager" tabindex="-1">会话/连接层（Connection / Supervisor / Subscription Manager） <a class="header-anchor" href="#会话-连接层-connection-supervisor-subscription-manager" aria-label="Permalink to &quot;会话/连接层（Connection / Supervisor / Subscription Manager）&quot;">​</a></h2><ol><li><p>通过 class 来进行封装；主要管三件事：</p><ul><li>创建实例</li><li>保存当前已订阅数据和未连接前待订阅数据</li><li>调用传输层实例的方法，同时处理好订阅数据，同时将事件回调转递给传输层</li></ul></li><li><p>构造函数保存的值有，三类：实例，重连相关，心跳</p><ul><li>websocket 实例</li><li>重连相关：close 后是否重连，间隔，最大重连次数，当前已经重连次数</li><li>心跳间隔</li><li>心跳计时器</li></ul></li><li><p>连接方法 connect</p><ul><li><p>状态判断是否返回</p></li><li><p>创建传输层实例</p></li><li><p>设置四个事件的监听</p><ul><li>open 回调 <ul><li>将未订阅的订阅，更新已订阅和未订阅的变量</li></ul></li><li>close 事件回调，默认是回重连的 <ul><li>向外发布 close 事件</li><li>更新订阅状态，把已订阅转成未订阅，<strong>这样下次重连成功后会自动订阅</strong></li></ul></li><li>message 事件回调：向外发布事件</li><li>error 事件回调：向外发布事件</li></ul></li></ul></li><li><p>close 连接的方法</p><ul><li>控制状态来决定要不要重试</li><li>调用原生 ws.close</li><li><strong>重点</strong> close 包括 ws 原生的 close 调用后，并不是说就一定 close 了，我们还要监听 ws.onclose 事件，事件触发才是真正的 close，所有调用 close，和 promise 的等待 onclose 事件是不一样的；</li></ul></li></ol>',7)])])}const _=i(s,[["render",t]]);export{g as __pageData,_ as default};
