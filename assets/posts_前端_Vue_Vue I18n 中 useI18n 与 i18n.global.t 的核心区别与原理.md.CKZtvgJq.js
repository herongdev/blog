import{_ as o,c as a,o as l,ag as i}from"./chunks/framework.oqSrIbQK.js";const h=JSON.parse('{"title":"Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理","description":"","frontmatter":{"title":"Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理","date":"2025-09-15T00:00:00.000Z","tags":["Vue","Vue I18n","前端开发","国际化"]},"headers":[],"relativePath":"posts/前端/Vue/Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理.md","filePath":"posts/前端/Vue/Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理.md","lastUpdated":1758216284000}'),t={name:"posts/前端/Vue/Vue I18n 中 useI18n 与 i18n.global.t 的核心区别与原理.md"};function s(n,e,r,d,c,u){return l(),a("div",null,[...e[0]||(e[0]=[i('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>在 Vue 3 项目中使用 Vue I18n 时，经常会遇到两种调用方式：<code>useI18n()</code> 和 <code>i18n.global.t</code>。<br> 它们在大多数场景下可以互换，但在涉及 <strong>Portal 渲染</strong>（如 <code>Modal.confirm</code>）时，行为却有明显差异。<br> 本文将精炼梳理其核心区别与原理，并给出解决方案。</p><h2 id="usei18n-与-i18n-global-t-的区别" tabindex="-1">useI18n 与 i18n.global.t 的区别 <a class="header-anchor" href="#usei18n-与-i18n-global-t-的区别" aria-label="Permalink to &quot;useI18n 与 i18n.global.t 的区别&quot;">​</a></h2><h3 id="usei18n" tabindex="-1">useI18n() <a class="header-anchor" href="#usei18n" aria-label="Permalink to &quot;useI18n()&quot;">​</a></h3><ul><li>基于 <strong>组合式 API</strong>，通过 <code>provide/inject</code> 获取 i18n 实例。</li><li>默认是 <strong>组件作用域</strong>，依赖于组件树的注入链。</li><li>如果组件渲染在 <strong>脱离应用上下文的 Portal</strong> 中（如 <code>Modal.confirm</code>），注入链会断开，导致报错：<strong>VUE_I18N_SYMBOL</strong> 为 null</li></ul><h3 id="usei18n-usescope-global" tabindex="-1">useI18n({ useScope: &#39;global&#39; }) <a class="header-anchor" href="#usei18n-usescope-global" aria-label="Permalink to &quot;useI18n({ useScope: &#39;global&#39; })&quot;">​</a></h3><ul><li>强制取 <strong>全局 i18n 实例</strong>，等价于 <code>i18n.global</code>。</li><li>不依赖 <code>provide/inject</code>，在 Portal 场景下依然安全可用。</li><li>类型提示完整，开发体验较佳。</li></ul><h3 id="i18n-global-t" tabindex="-1">i18n.global.t <a class="header-anchor" href="#i18n-global-t" aria-label="Permalink to &quot;i18n.global.t&quot;">​</a></h3><ul><li><p>直接调用全局实例上的 <code>t</code> 方法。</p></li><li><p>天然不受 Portal 的注入链影响，不会报错。</p></li><li><p>但在 TypeScript 中，由于 <code>i18n.global</code> 类型是 <code>Composer | VueI18n</code> 的联合类型，<code>.t</code> 方法签名不唯一，可能会报：This expression is not callable</p></li><li><p>需要通过 <strong>类型断言</strong> 或 <strong>any</strong> 绕过。</p></li></ul><h2 id="为什么有的报错-有的不报" tabindex="-1">为什么有的报错，有的不报 <a class="header-anchor" href="#为什么有的报错-有的不报" aria-label="Permalink to &quot;为什么有的报错，有的不报&quot;">​</a></h2><ul><li><p><strong>报错场景</strong>： 使用 <code>useI18n()</code>（默认作用域）时，Portal 中的组件拿不到注入实例 → 报错。</p></li><li><p><strong>不报错场景</strong>：</p></li><li><p>使用 <code>useI18n({ useScope: &#39;global&#39; })</code> → 绕过注入链。</p></li><li><p>或直接调用 <code>i18n.global.t</code> → 使用全局实例。</p></li></ul><h2 id="typescript-报错原因与解决" tabindex="-1">TypeScript 报错原因与解决 <a class="header-anchor" href="#typescript-报错原因与解决" aria-label="Permalink to &quot;TypeScript 报错原因与解决&quot;">​</a></h2><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><ul><li><code>i18n.global</code> 的类型是 <strong>联合类型</strong>（<code>Composer | VueI18n</code>）。</li><li><code>.t</code> 方法在两者中定义不一致，TS 无法推断出唯一签名。</li></ul><h3 id="解决方式" tabindex="-1">解决方式 <a class="header-anchor" href="#解决方式" aria-label="Permalink to &quot;解决方式&quot;">​</a></h3><ol><li><strong>推荐</strong>：使用 <code>useI18n({ useScope: &#39;global&#39; })</code> → <code>t</code> 方法类型清晰。</li><li><strong>备选</strong>：在 <code>i18n.global</code> 上加断言：</li></ol><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i18n.global </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="该如何选择" tabindex="-1">该如何选择 <a class="header-anchor" href="#该如何选择" aria-label="Permalink to &quot;该如何选择&quot;">​</a></h2><ul><li><p><strong>组件内部调用（推荐）</strong>： 使用 <code>useI18n({ useScope: &#39;global&#39; })</code>，类型安全，语义清晰。</p></li><li><p><strong>全局或工具函数调用</strong>： 直接用 <code>i18n.global.t</code>，搭配类型断言解决 TS 报错。</p></li></ul><h2 id="一句话总结" tabindex="-1">一句话总结 <a class="header-anchor" href="#一句话总结" aria-label="Permalink to &quot;一句话总结&quot;">​</a></h2><p>报错的根源在于 <strong>Portal 渲染导致注入链断开</strong>。 解决方法是 <strong>改用全局 i18n</strong>，从机制上绕过 <code>provide/inject</code> 的限制。 因此，最佳实践是：<strong>组件内用 <code>useI18n({ useScope: &#39;global&#39; })</code>，工具层用 <code>i18n.global.t</code></strong>。</p>',21)])])}const g=o(t,[["render",s]]);export{h as __pageData,g as default};
