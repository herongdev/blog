import{_ as e,c as i,o as t,ag as a}from"./chunks/framework.oqSrIbQK.js";const k=JSON.parse('{"title":"Axios 拦截器完全指南：use、eject、clear 的正确用法与执行顺序","description":"","frontmatter":{"title":"Axios 拦截器完全指南：use、eject、clear 的正确用法与执行顺序","date":"2025-09-18T00:00:00.000Z","tags":["axios","拦截器","interceptors","use","eject","clear","TypeScript"],"categories":["Web 前端"]},"headers":[],"relativePath":"posts/前端/常用库/Axios 拦截器完全指南：use、eject、clear 的正确用法与执行顺序.md","filePath":"posts/前端/常用库/Axios 拦截器完全指南：use、eject、clear 的正确用法与执行顺序.md","lastUpdated":1758634537000}'),n={name:"posts/前端/常用库/Axios 拦截器完全指南：use、eject、clear 的正确用法与执行顺序.md"};function r(o,s,l,p,h,c){return t(),i("div",null,[...s[0]||(s[0]=[a(`<p>结论先说：<strong>有的</strong>。 在 Axios 里，<code>interceptors.request</code> 和 <code>interceptors.response</code> 都是一个 <code>AxiosInterceptorManager</code>，它们至少有这三个方法：</p><ul><li><code>use(onFulfilled, onRejected?, options?) → id</code></li><li><code>eject(id) → void</code>（按 id 移除单个拦截器）</li><li><code>clear() → void</code>（<strong>一次性清空</strong>该方向上的所有拦截器）</li></ul><p>官方文档明确了 <code>use/eject</code> 的用法；npm 的 README 还例示了 <code>clear()</code>。另外，请求拦截器支持第三个 <code>options</code> 参数（<code>synchronous</code> / <code>runWhen</code>），<strong>响应拦截器暂不支持</strong>。(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</p><hr><h1 id="一页版教程-含-为什么-和-怎么用" tabindex="-1">一页版教程（含&quot;为什么&quot;和&quot;怎么用&quot;） <a class="header-anchor" href="#一页版教程-含-为什么-和-怎么用" aria-label="Permalink to &quot;一页版教程（含&quot;为什么&quot;和&quot;怎么用&quot;）&quot;">​</a></h1><h2 id="_1-能做什么-api-总览" tabindex="-1">1）能做什么？（API 总览） <a class="header-anchor" href="#_1-能做什么-api-总览" aria-label="Permalink to &quot;1）能做什么？（API 总览）&quot;">​</a></h2><ul><li><strong>添加：</strong><code>const id = axios.interceptors.request.use(fn, errFn, { synchronous, runWhen })</code><code>const id = axios.interceptors.response.use(fn, errFn)</code><code>options</code> 只对<strong>请求</strong>拦截器生效（<code>synchronous</code> 让处理同步；<code>runWhen(cfg)=&gt;boolean</code> 控制是否执行）。(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</li><li><strong>移除单个：</strong><code>axios.interceptors.request.eject(id)</code> / <code>instance.interceptors.response.eject(id)</code>。(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</li><li><strong>清空全部：</strong><code>instance.interceptors.request.clear()</code> / <code>instance.interceptors.response.clear()</code>（npm README 示例中提供）。</li></ul><blockquote><p>提醒：全局 <code>axios</code> 和你通过 <code>axios.create()</code> 得到的 <strong>实例</strong> 各有独立的 <code>interceptors</code>，不要混用。(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</p></blockquote><hr><h2 id="_2-执行顺序-容易踩坑" tabindex="-1">2）执行顺序（容易踩坑） <a class="header-anchor" href="#_2-执行顺序-容易踩坑" aria-label="Permalink to &quot;2）执行顺序（容易踩坑）&quot;">​</a></h2><ul><li><strong>请求拦截器（request）：按注册的逆序（LIFO）</strong> 执行。官方 issue 中有明确讨论与源码链路（<code>unshift</code>）说明。(<a href="https://github.com/axios/axios/issues/841?utm_source=chatgpt.com" title="Order of applying request interceptors is reversed. #841" target="_blank" rel="noreferrer">GitHub</a>)</li><li><strong>响应拦截器（response）：按注册顺序（FIFO）</strong> 执行，官方 README 的 &quot;Multiple Interceptors&quot; 段落写明。</li></ul><hr><h2 id="_3-最常用的三种写法" tabindex="-1">3）最常用的三种写法 <a class="header-anchor" href="#_3-最常用的三种写法" aria-label="Permalink to &quot;3）最常用的三种写法&quot;">​</a></h2><h3 id="a-只加一次拦截器-之后按需移除" tabindex="-1">A. 只加一次拦截器，之后按需移除 <a class="header-anchor" href="#a-只加一次拦截器-之后按需移除" aria-label="Permalink to &quot;A. 只加一次拦截器，之后按需移除&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance.interceptors.response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...统一处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 条件满足时移除</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.interceptors.response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span></code></pre></div><p>（<code>eject(id)</code> 是官方支持的标准方式。）(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</p><h3 id="b-清空所有拦截器-重置到-未添加-状态" tabindex="-1">B. 清空所有拦截器（重置到&quot;未添加&quot;状态） <a class="header-anchor" href="#b-清空所有拦截器-重置到-未添加-状态" aria-label="Permalink to &quot;B. 清空所有拦截器（重置到&quot;未添加&quot;状态）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.interceptors.request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.interceptors.response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>（<code>clear()</code> 用于<strong>一次性</strong>&quot;全移除&quot;。）</p><h3 id="c-仅在特定条件下运行请求拦截器-不阻塞主线程" tabindex="-1">C. 仅在特定条件下运行请求拦截器（不阻塞主线程） <a class="header-anchor" href="#c-仅在特定条件下运行请求拦截器-不阻塞主线程" aria-label="Permalink to &quot;C. 仅在特定条件下运行请求拦截器（不阻塞主线程）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onlyGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cfg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cfg.method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;get&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.interceptors.request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cfg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* ... */</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cfg;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  { synchronous: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, runWhen: onlyGet } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 仅请求拦截器支持</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>（<code>synchronous</code> &amp; <code>runWhen</code> 目前<strong>只支持请求拦截器</strong>。）(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</p><hr><h2 id="_4-最佳实践-易错点" tabindex="-1">4）最佳实践 &amp; 易错点 <a class="header-anchor" href="#_4-最佳实践-易错点" aria-label="Permalink to &quot;4）最佳实践 &amp; 易错点&quot;">​</a></h2><ul><li><strong>拦截器放在模块初始化处</strong>，避免在 React 组件 render/每次调用里重复 <code>use</code> 导致堆积；需要撤销时用 <code>eject(id)</code> 或 <code>clear()</code>。</li><li><strong>顺序相关的逻辑</strong>要考虑&quot;请求逆序 / 响应顺序&quot;的特性；比如你想让某个请求头<strong>最后</strong>合并，应该最后注册或在一个统一的主请求拦截器末尾处理。(<a href="https://github.com/axios/axios/issues/841?utm_source=chatgpt.com" title="Order of applying request interceptors is reversed. #841" target="_blank" rel="noreferrer">GitHub</a>)</li><li><strong>选用实例级拦截器</strong>（<code>axios.create()</code>）隔离不同后端域/不同项目的策略，避免全局互相影响。(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</li><li><strong>性能注意：</strong> 默认请求拦截器当作异步处理，会创建 Promise；确实是同步逻辑时加 <code>synchronous: true</code> 可减少排队延迟。</li></ul><hr><h2 id="_5-官方参考-要点直链" tabindex="-1">5）官方参考（要点直链） <a class="header-anchor" href="#_5-官方参考-要点直链" aria-label="Permalink to &quot;5）官方参考（要点直链）&quot;">​</a></h2><ul><li>Axios 文档：拦截器增删、请求拦截器 <code>options</code> 示例、实例化区别。(<a href="https://axios-http.com/docs/interceptors" title="Interceptors | Axios Docs" target="_blank" rel="noreferrer">Axios</a>)</li><li>npm README：<code>clear()</code> 示例、请求拦截器 <code>options</code> 仅此方向支持、响应多拦截器执行顺序。</li><li>执行顺序的官方 issue 讨论（请求逆序）：(<a href="https://github.com/axios/axios/issues/841?utm_source=chatgpt.com" title="Order of applying request interceptors is reversed. #841" target="_blank" rel="noreferrer">GitHub</a>)</li></ul><hr><p>如果你愿意，我可以把你现有封装里关于&quot;一次性头/作用域头&quot;的实现，改成<strong>只在一个主请求拦截器里收口</strong>，并用返回的 <code>id</code>/<code>clear()</code> 做完整生命周期管理——这样就和上面这些规则完全对齐。</p>`,30)])])}const g=e(n,[["render",r]]);export{k as __pageData,g as default};
