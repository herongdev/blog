import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.oqSrIbQK.js";const E=JSON.parse('{"title":"Vue 3 里设计 composable 的输入与响应式——大厂级最佳实践","description":"深入探讨 Vue 3 Composable 函数的设计规范，涵盖输入参数设计、响应式处理、性能优化等大厂级最佳实践。","frontmatter":{"title":"Vue 3 里设计 composable 的输入与响应式——大厂级最佳实践","date":"2025-10-14T00:00:00.000Z","categories":["前端","Vue"],"tags":["Vue3","Composable","响应式","最佳实践"],"description":"深入探讨 Vue 3 Composable 函数的设计规范，涵盖输入参数设计、响应式处理、性能优化等大厂级最佳实践。"},"headers":[],"relativePath":"posts/前端/Vue/Vue3里设计composable的输入与响应式——大厂级最佳实践.md","filePath":"posts/前端/Vue/Vue3里设计composable的输入与响应式——大厂级最佳实践.md","lastUpdated":1764331727000}'),l={name:"posts/前端/Vue/Vue3里设计composable的输入与响应式——大厂级最佳实践.md"};function h(e,s,p,k,r,o){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h2 id="结论先行-tl-dr" tabindex="-1">结论先行（TL;DR） <a class="header-anchor" href="#结论先行-tl-dr" aria-label="Permalink to &quot;结论先行（TL;DR）&quot;">​</a></h2><ul><li><strong>输入统一：接受 <code>MaybeRefOrGetter&lt;T&gt;</code>（值 / <code>ref</code> / <code>computed</code> / getter 函数均可）</strong>，在内部用 <code>toValue</code>/<code>unref</code> 标准化；这样<strong>既支持响应式参数，也不拒绝原始值</strong>。</li><li><strong>衍生数据一律用 <code>computed</code></strong>；<strong>副作用一律用 <code>watch</code>/<code>watchEffect</code></strong>；只在需要副作用时监听，避免滥用 <code>watch</code>。</li><li><strong>返回值一律是只读 <code>ref</code> 或对象的 <code>readonly</code> 包装</strong>，外部不直接修改内部状态。</li><li><strong>来自 <code>props</code> 的参数，调用方用 <code>toRef(props, &#39;x&#39;)</code> 传入</strong>，而不是原始解构值；可避免&quot;值丢失响应性&quot;。</li><li><strong>可选项（options）类参数</strong>：支持&quot;<strong>静态值 + 响应式覆盖</strong>&quot;双形态，内部通过 <code>toValue</code> 读取，必要时对关键项 <code>watch</code>。</li><li><strong>性能</strong>：默认 <code>shallowRef</code> 保存大对象；<code>watch</code> 谨慎开启深度；对频繁变动源使用节流/防抖；<code>flush: &#39;post&#39;</code> 处理 DOM 相关副作用。</li><li><strong>边界</strong>：组合多个源用 <code>watch([a,b])</code>；异步源配合 <code>watchEffect</code> + 取消；在 <code>onScopeDispose</code> 清理。</li></ul><hr><h2 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-label="Permalink to &quot;设计目标&quot;">​</a></h2><ol><li><strong>调用体验一致</strong>：同一个 composable 既可接收<strong>原始值</strong>（一次性），也能接收<strong>响应式值</strong>（持续更新），调用成本最低。</li><li><strong>内部可维护</strong>：对外暴露最小可变面，逻辑分层清晰（衍生 vs 副作用）。</li><li><strong>性能稳</strong>：避免不必要的深度侦听与重算，易于控制更新频率。</li></ol><hr><h2 id="标准输入类型与约定" tabindex="-1">标准输入类型与约定 <a class="header-anchor" href="#标准输入类型与约定" aria-label="Permalink to &quot;标准输入类型与约定&quot;">​</a></h2><ul><li><strong>统一签名</strong>：<code>input: MaybeRefOrGetter&lt;T&gt;</code><ul><li>调用方可传：<code>42</code>、<code>ref(42)</code>、<code>computed(...)</code>、<code>() =&gt; props.x</code>。</li><li>组合式内部用 <code>toValue(input)</code> 读取当前值，用 <code>watch(input, ...)</code> 订阅变化。</li></ul></li><li><strong>对象/配置</strong>：<code>options?: MaybeRefOrGetter&lt;Partial&lt;Options&gt;&gt;</code>，内部<strong>按需</strong>对关键字段加 <code>watch</code>。</li><li><strong>来自 props</strong>：推荐<strong>调用方</strong>先 <code>toRef(props, &#39;x&#39;)</code> 再传入，避免响应性丢失。</li></ul><hr><h2 id="何时用响应式输入-vs-原始值" tabindex="-1">何时用响应式输入 vs 原始值？ <a class="header-anchor" href="#何时用响应式输入-vs-原始值" aria-label="Permalink to &quot;何时用响应式输入 vs 原始值？&quot;">​</a></h2><ul><li><strong>业务参数（会变）</strong>：传响应式（<code>ref</code>/<code>computed</code>/getter），Composable 自动跟随变化。</li><li><strong>一次性初始化（不变）</strong>：可传原始值（如常量开关/默认阈值）。</li><li><strong>可变但低频</strong>：仍建议响应式；或传 getter（外部自行控制何时变化），内部只 <code>toValue</code> 读取。</li></ul><blockquote><p>大厂常见做法：<strong>对所有可变入参一律允许响应式</strong>，但<strong>不强制</strong>，以降低接入门槛。</p></blockquote><hr><h2 id="衍生与副作用的分工" tabindex="-1">衍生与副作用的分工 <a class="header-anchor" href="#衍生与副作用的分工" aria-label="Permalink to &quot;衍生与副作用的分工&quot;">​</a></h2><ul><li><strong>衍生数据 → <code>computed</code></strong><ul><li>纯函数式、可缓存、易测试。</li></ul></li><li><strong>副作用 → <code>watch</code> / <code>watchEffect</code></strong><ul><li><strong>需要观察具体源时</strong>用 <code>watch(source, cb, options)</code>；</li><li><strong>依赖自动收集</strong>（可能多个源）时用 <code>watchEffect</code>，并正确处理清理函数。</li></ul></li></ul><hr><h2 id="返回值规范" tabindex="-1">返回值规范 <a class="header-anchor" href="#返回值规范" aria-label="Permalink to &quot;返回值规范&quot;">​</a></h2><ul><li><strong>返回 <code>readonly(ref)</code> 或只读对象</strong>：防止外部误改内部状态。</li><li>若需对外暴露&quot;命令式&quot;改变，提供<strong>方法</strong>而非直接暴露可写 <code>ref</code>。</li></ul><hr><h2 id="代码模板-生产级骨架" tabindex="-1">代码模板（生产级骨架） <a class="header-anchor" href="#代码模板-生产级骨架" aria-label="Permalink to &quot;代码模板（生产级骨架）&quot;">​</a></h2><blockquote><p>说明：以下仅给出<strong>关键片段</strong>（符合你的&quot;只给必要代码&quot;的偏好）。复杂逻辑前加中文注释。</p></blockquote><h3 id="类型定义" tabindex="-1">类型定义 <a class="header-anchor" href="#类型定义" aria-label="Permalink to &quot;类型定义&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// types.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaybeRefOrGetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  |</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ComputedRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span></code></pre></div><h3 id="composable-实现" tabindex="-1">Composable 实现 <a class="header-anchor" href="#composable-实现" aria-label="Permalink to &quot;Composable 实现&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// useSmartThing.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ref,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  shallowRef,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  watch,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  watchEffect,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  toValue,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  readonly,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  onScopeDispose,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { MaybeRefOrGetter } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UseSmartThingOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：影响刷新频率与重算窗口</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里的 throttleMs 既可传原始值，也可传 ref/getter</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  throttleMs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  deep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSmartThing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaybeRefOrGetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MaybeRefOrGetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UseSmartThingOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：内部状态大型对象用 shallowRef 降低不必要的深度依赖</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shallowRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;{ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stamp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }&gt;({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    value: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stamp: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> opts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ throttleMs: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options) });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：衍生值只用 computed，避免副作用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pretty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.value.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unknown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：副作用监听输入变化 + 节流控制</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">throttleMs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> opts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (throttleMs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> throttleMs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (timer) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 复杂逻辑：节流窗口内只记录第一次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        state.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: val, stamp: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, throttleMs) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unknown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        state.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: val, stamp: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { immediate: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, deep: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().deep, flush: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;post&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：当 options 自身是响应式时，关键字段变化需要触发重应用（例如 deep/节流策略变化）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 这里按需重建监听/重算策略。简单起见仅触发一次性刷新。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      state.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { value: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input), stamp: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onScopeDispose</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (timer) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    value: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readonly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state), </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对外只读</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pretty, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 衍生值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 提供命令式 API（如需要）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // reset() { ... }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h2 id="原始值如何确保更新-的三种稳妥做法" tabindex="-1">&quot;原始值如何确保更新？&quot;的三种稳妥做法 <a class="header-anchor" href="#原始值如何确保更新-的三种稳妥做法" aria-label="Permalink to &quot;&quot;原始值如何确保更新？&quot;的三种稳妥做法&quot;">​</a></h2><blockquote><p>核心思想：<strong>Composable 不强制输入必须是响应式</strong>，但<strong>内部要能&quot;感知变化来源&quot;</strong>。</p></blockquote><h3 id="_1-由调用方负责响应化-推荐" tabindex="-1">1. 由调用方负责响应化（推荐） <a class="header-anchor" href="#_1-由调用方负责响应化-推荐" aria-label="Permalink to &quot;1. 由调用方负责响应化（推荐）&quot;">​</a></h3><ul><li>来自 <code>props</code>：<code>const xRef = toRef(props, &#39;x&#39;)</code> 后传入。</li><li>外部变量：<code>const xRef = ref(x)</code> 并在外部更新 <code>xRef.value</code>。</li><li><strong>优点</strong>：数据流最清晰，职责边界最明确（大厂偏好）。</li></ul><h3 id="_2-composable-接受-getter-函数" tabindex="-1">2. Composable 接受 getter（函数） <a class="header-anchor" href="#_2-composable-接受-getter-函数" aria-label="Permalink to &quot;2. Composable 接受 getter（函数）&quot;">​</a></h3><ul><li>传 <code>() =&gt; props.x</code> 或 <code>() =&gt; someStore.value</code>，内部 <code>watch(input, ...)</code> 可订阅。</li><li><strong>适合</strong>：不方便造 <code>ref</code> 的场景。</li></ul><h3 id="_3-显式刷新方法-兜底" tabindex="-1">3. 显式刷新方法（兜底） <a class="header-anchor" href="#_3-显式刷新方法-兜底" aria-label="Permalink to &quot;3. 显式刷新方法（兜底）&quot;">​</a></h3><ul><li>返回 <code>refresh()</code>，让调用方在原始值变化时手动触发。</li><li><strong>用于</strong>：变化极少、接入成本敏感的工具类 composable。</li></ul><hr><h2 id="典型调用方写法-防止响应性丢失" tabindex="-1">典型调用方写法（防止响应性丢失） <a class="header-anchor" href="#典型调用方写法-防止响应性丢失" aria-label="Permalink to &quot;典型调用方写法（防止响应性丢失）&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 来自 props 的值，避免直接解构丢失响应性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;count&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pretty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSmartThing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count, { throttleMs: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原始常量，也可以直接传（一次性）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">once</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSmartThing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不便创建 ref 的场景，传 getter</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">viaGetter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSmartThing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> route.query.id);</span></span></code></pre></div><hr><h2 id="监听策略与性能建议" tabindex="-1">监听策略与性能建议 <a class="header-anchor" href="#监听策略与性能建议" aria-label="Permalink to &quot;监听策略与性能建议&quot;">​</a></h2><ul><li><strong>尽量不用 <code>deep: true</code></strong>；需要时对<strong>具体字段</strong>创建 <code>watch(() =&gt; obj.key, ...)</code>。</li><li><strong>大对象用 <code>shallowRef</code></strong>，配合<strong>整体替换</strong>（immutable 写法）触发更新。</li><li><strong>高频源</strong>（输入框、滚动位置）使用<strong>防抖/节流</strong>；<code>flush: &#39;post&#39;</code> 处理布局/DOM 相关副作用。</li><li><strong>拆分副作用</strong>：一个 <code>watch</code> 只做一件事，方便定位与中止。</li><li><strong>组合多源</strong>：<code>watch([a, b], ([na, nb], [oa, ob]) =&gt; { ... })</code>，避免多重监听交叉触发。</li></ul><hr><h2 id="返回-api-的一致性与可测试性" tabindex="-1">返回 API 的一致性与可测试性 <a class="header-anchor" href="#返回-api-的一致性与可测试性" aria-label="Permalink to &quot;返回 API 的一致性与可测试性&quot;">​</a></h2><ul><li><strong>只读输出 + 命令式方法</strong>（而非暴露可写 ref）有利于<strong>单测</strong>与<strong>边界控制</strong>。</li><li><strong>错误边界</strong>：在 composable 内部进行参数校验（类型/范围），尽早失败，日志可控。</li><li><strong>SSR</strong>：涉及 <code>window</code>/DOM 的副作用加环境判断或延迟到 <code>onMounted</code>/<code>flush: &#39;post&#39;</code>。</li></ul><hr><h2 id="常见坑位与规避" tabindex="-1">常见坑位与规避 <a class="header-anchor" href="#常见坑位与规避" aria-label="Permalink to &quot;常见坑位与规避&quot;">​</a></h2><ul><li><strong>直接解构 props 导致&quot;失去响应性&quot;</strong>：总是用 <code>toRef(props, &#39;k&#39;)</code> / <code>toRefs(props)</code>。</li><li><strong>滥用 <code>watchEffect</code></strong>：当依赖集不稳定时会频繁触发；<strong>已知源</strong>优先 <code>watch(source, ...)</code>。</li><li><strong>深度监听大对象</strong>：高成本；改为分字段监听或结构化拷贝 + <code>shallowRef</code>。</li><li><strong>返回可写 ref 被外部改坏状态</strong>：一律 <code>readonly</code> 封装。</li><li><strong>没有清理副作用</strong>：使用 <code>onScopeDispose</code>，或在 <code>watch</code> 回调中返回清理函数。</li></ul><hr><h2 id="小结-大厂风格的-可插可拔-组合式设计" tabindex="-1">小结：大厂风格的&quot;可插可拔&quot;组合式设计 <a class="header-anchor" href="#小结-大厂风格的-可插可拔-组合式设计" aria-label="Permalink to &quot;小结：大厂风格的&quot;可插可拔&quot;组合式设计&quot;">​</a></h2><ol><li><strong>输入宽容</strong>（值/<code>ref</code>/getter 皆可）+ <strong>内部标准化</strong>（<code>toValue</code>）。</li><li><strong>衍生 = <code>computed</code>，副作用 = <code>watch</code></strong>，边界清晰。</li><li><strong>返回只读 + 命令式方法</strong>，利于治理与测试。</li><li><strong>性能可控</strong>：默认浅引用、精确监听、必要时节流防抖。</li><li><strong>调用侧最佳实践</strong>：<code>toRef(props, &#39;x&#39;)</code>、必要时传 getter，实在不便再用 <code>refresh()</code> 兜底。</li></ol><blockquote><p>以上模式在中大型项目验证稳定，既保证了<strong>接入友好</strong>，又维持了<strong>内部约束与性能</strong>。如果你有具体的 composable 正在写，我可以按这个规范帮你把签名与实现&quot;落标&quot;。</p></blockquote>`,50)])])}const g=i(l,[["render",h]]);export{E as __pageData,g as default};
