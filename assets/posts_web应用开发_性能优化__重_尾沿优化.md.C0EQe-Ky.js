import{_ as i,c as a,o as t,ag as n}from"./chunks/framework.oqSrIbQK.js";const c=JSON.parse('{"title":"这段 setTimeout(doFetch, 100) 算防抖吗？跟常见防抖/节流有什么不同","description":"","frontmatter":{"title":"这段 `setTimeout(doFetch, 100)` 算防抖吗？跟常见防抖/节流有什么不同","date":"2025-11-10T00:00:00.000Z","tags":["Vue","Pinia","防抖","节流","并发控制"],"categories":["前端工程实践"]},"headers":[],"relativePath":"posts/web应用开发/性能优化/[重]尾沿优化.md","filePath":"posts/web应用开发/性能优化/[重]尾沿优化.md","lastUpdated":1764331727000}'),l={name:"posts/web应用开发/性能优化/[重]尾沿优化.md"};function e(h,s,p,k,d,r){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h2 id="摘要" tabindex="-1">摘要 <a class="header-anchor" href="#摘要" aria-label="Permalink to &quot;摘要&quot;">​</a></h2><p>你这段代码的 <strong>行为核心是“尾沿防抖（trailing debounce）”</strong>：快速连续切换 Tab 时，会合并为<strong>最后一次</strong>的 <code>doFetch</code> 执行。但它不仅是防抖，还叠加了两点工程化增强：</p><ol><li><strong>并发令牌 <code>token</code></strong>：就算存在竞态（旧定时器没清干净、旧异步刚好触发），也会被 <code>if (token !== lastFetchToken) return</code> <strong>硬性拦截</strong>，防止“过期任务”执行。</li><li><strong>“账户未就绪 → 一次性监听再补拉”</strong>：当 <code>selectedAccount</code> 为空时不立即拉取，而是注册一次性 <code>watch</code>，等账户就绪 <strong>自动补一次</strong> <code>fetchSpecs</code>。这属于<strong>状态就绪门控</strong>，不是防抖/节流的范畴。</li></ol><blockquote><p>简单说：<strong>防抖的外壳 + 并发/状态的内功</strong>。</p></blockquote><hr><h2 id="与-常见防抖-节流-的对照" tabindex="-1">与“常见防抖/节流”的对照 <a class="header-anchor" href="#与-常见防抖-节流-的对照" aria-label="Permalink to &quot;与“常见防抖/节流”的对照&quot;">​</a></h2><table tabindex="0"><thead><tr><th>维度</th><th>你的实现</th><th>典型防抖（debounce）</th><th>典型节流（throttle）</th></tr></thead><tbody><tr><td>触发时机</td><td><strong>尾沿</strong>：最后一次触发后等待 100ms 执行</td><td>可选前沿/尾沿，最常见是尾沿</td><td>固定间隔内<strong>最多一次</strong></td></tr><tr><td>多次快速触发</td><td>只执行最后一次（清理上一个 <code>timeout</code>）</td><td>只执行最后一次（清理上一个 <code>timeout</code>）</td><td>可能执行多次，但频率受限</td></tr><tr><td>并发/竞态保护</td><td><strong>有令牌校验</strong>，避免过期任务乱入</td><td>通常<strong>没有</strong>，需要自加</td><td>通常<strong>没有</strong>，需要自加</td></tr><tr><td>依赖状态未就绪</td><td><strong>挂一次性监听后补拉</strong></td><td>不涉及</td><td>不涉及</td></tr><tr><td>适用场景</td><td>Tab 快速切换、确保<strong>只对最新选择</strong>拉取</td><td>输入框搜索、窗口 resize 等</td><td>滚动监听、窗口 resize 高频但需稳频</td></tr></tbody></table><hr><h2 id="时间线直观示例" tabindex="-1">时间线直观示例 <a class="header-anchor" href="#时间线直观示例" aria-label="Permalink to &quot;时间线直观示例&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>t=0ms: selectTab(A) -&gt; 清前一个定时器 -&gt; 设 timeout(T1, +100)</span></span>
<span class="line"><span>t=30ms: selectTab(B) -&gt; 清 T1 -&gt; 设 timeout(T2, +100)</span></span>
<span class="line"><span>t=60ms: selectTab(C) -&gt; 清 T2 -&gt; 设 timeout(T3, +100)</span></span>
<span class="line"><span>t=160ms: 只会执行 T3（C）的 doFetch</span></span></code></pre></div><blockquote><p>因为每次都会 <code>clearTimeout</code>，<strong>只保留最后一个</strong>。而 <code>token</code> 让就算 T1/T2 因竞态触发也会被 “token 不匹配” 拦下。</p></blockquote><hr><h2 id="为什么还需要-token" tabindex="-1">为什么还需要 <code>token</code>？ <a class="header-anchor" href="#为什么还需要-token" aria-label="Permalink to &quot;为什么还需要 \`token\`？&quot;">​</a></h2><p>单靠 <code>clearTimeout</code> 理论上够用，但在真实环境下可能出现：</p><ul><li>浏览器/运行时调度导致<strong>已过期的定时回调</strong>仍被调用；</li><li>代码后续异步链路中又触发了旧逻辑。</li></ul><p><strong><code>token</code> 是“硬闸门”</strong>：每次选择加一，回调里先比对序号，不匹配就<strong>立即返回</strong>，确保“旧世界的回调进不来新世界”。</p><hr><h2 id="账户就绪一次性监听-是加分项" tabindex="-1">“账户就绪一次性监听”是加分项 <a class="header-anchor" href="#账户就绪一次性监听-是加分项" aria-label="Permalink to &quot;“账户就绪一次性监听”是加分项&quot;">​</a></h2><p>当 <code>selectedAccount</code> 尚未就绪时：</p><ul><li><strong>不白跑</strong>：不做无效拉取；</li><li><strong>不丢失</strong>：用 <code>watch</code> 等就绪后<strong>补一次</strong>；</li><li><strong>不泄漏</strong>：回调里 <code>stop()</code> 并将 <code>waitAccountStop = null</code>，防一次性监听残留。</li></ul><p>这块属于<strong>状态门控/就绪补偿</strong>，和防抖节流是两个维度的工程手段，组合后用户体验更稳。</p><hr><h2 id="常见坑-建议优化" tabindex="-1">常见坑 &amp; 建议优化 <a class="header-anchor" href="#常见坑-建议优化" aria-label="Permalink to &quot;常见坑 &amp; 建议优化&quot;">​</a></h2><ul><li><p>✅（可选）在 <code>doFetch</code> 执行后将 <code>fetchSpecsTimeout = null</code>，便于状态观察与调试。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：回调执行后清理句柄，便于判定当前是否有挂起的定时器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fetchSpecsTimeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doFetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 复杂逻辑：回调已落地，句柄失效，置空</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fetchSpecsTimeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p>✅（可选）在 <code>await symbolInfoStore.fetchSpecs(...)</code> 之后，再次校验“当前选中是否仍为该 tab”，避免慢请求的<strong>结果写回</strong>影响当前 UI（你现在用的是“开始前拦截”，必要时也可“结束后再校验”）。</p></li><li><p>✅（可选）如果后续要<strong>取消在途请求</strong>，可在 <code>fetchSpecs</code> 中支持 <code>AbortController</code> 或内部比对最新 <code>pinned</code> 再落库。</p></li></ul><hr><h2 id="如果用-库版防抖-应如何等价表达" tabindex="-1">如果用“库版防抖”，应如何等价表达？ <a class="header-anchor" href="#如果用-库版防抖-应如何等价表达" aria-label="Permalink to &quot;如果用“库版防抖”，应如何等价表达？&quot;">​</a></h2><p>等价语义是 <strong>尾沿防抖 + 账户就绪补偿 + 并发令牌</strong>。就算用 <code>lodash.debounce</code>，后两者依然要保留：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：创建尾沿防抖的 doFetch（等待 100ms）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> debouncedFetch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tab</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SymbolTabItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 复杂逻辑：并发令牌拦截过期任务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastFetchToken) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">selectedAccount.value) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">waitAccountStop) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 复杂逻辑：账户就绪后补一次拉取，并立刻注销监听</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> selectedAccount.value,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">acc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">acc) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">          try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> symbolInfoStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchSpecs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([tab], acc);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            stop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            waitAccountStop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      waitAccountStop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stop;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> symbolInfoStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchSpecs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([tab], selectedAccount.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 selectTab 内部调用时：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：自增令牌，确保只保留“最后一次选择”的请求有效</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> token</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lastFetchToken;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">debouncedFetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tab, token);</span></span></code></pre></div><blockquote><p>可以看到：<strong>库只替换了“防抖外壳”</strong>，<code>token</code> 和“就绪补偿”仍必须保留。</p></blockquote><hr><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><ul><li>你的实现属于 <strong>尾沿防抖</strong> 的实际效果，<strong>但更强壮</strong>：通过 <code>token</code> 杀死过期回调，通过一次性 <code>watch</code> 在状态就绪后 <strong>可靠补一次</strong>。</li><li>和“我们平常理解的防抖”相比：<strong>多了并发安全与状态门控</strong>，适合交易、行情这类“高速切换、状态依赖强、避免脏写”的场景。</li></ul>`,32)])])}const E=i(l,[["render",e]]);export{c as __pageData,E as default};
