import{_ as o,c as t,o as n,ag as r}from"./chunks/framework.oqSrIbQK.js";const u=JSON.parse('{"title":"一帧里会不会执行多个宏任务、做多次回流计算，但仍不渲染？","description":"","frontmatter":{"title":"一帧里会不会执行多个宏任务、做多次回流计算，但仍不渲染？","date":"2025-10-11T00:00:00.000Z","tags":null},"headers":[],"relativePath":"posts/前端/性能优化/浏览器为什么“可能”渲染？——宏任务/一帧里会不会执行多个宏任务、做多次回流计算，但仍不渲染？.md","filePath":"posts/前端/性能优化/浏览器为什么“可能”渲染？——宏任务/一帧里会不会执行多个宏任务、做多次回流计算，但仍不渲染？.md","lastUpdated":1764331727000}'),a={name:"posts/前端/性能优化/浏览器为什么“可能”渲染？——宏任务/一帧里会不会执行多个宏任务、做多次回流计算，但仍不渲染？.md"};function e(l,s,i,g,c,p){return n(),t("div",null,[...s[0]||(s[0]=[r(`<h2 id="结论先行-tl-dr" tabindex="-1">结论先行（TL;DR） <a class="header-anchor" href="#结论先行-tl-dr" aria-label="Permalink to &quot;结论先行（TL;DR）&quot;">​</a></h2><p><strong>会的。</strong> 浏览器只有在“渲染机会（rendering opportunity）”点才可能提交像素；在此之前：</p><ul><li>可以连续执行<strong>多个宏任务（Tasks）</strong>；</li><li>在这些任务里可以<strong>多次触发布局/回流计算</strong>（包括你代码里强制布局的同步读取）；</li><li><strong>但仍然不发生绘制提交</strong>（像素不更新）。 原因：<strong>JS 执行期间不会绘制</strong>，浏览器有权<strong>跳过</strong>这一帧的绘制（无可见变化/后台/节流/时间片不够/微任务饥饿等）。</li></ul><hr><h2 id="一帧内的-可能-时间线-简化版" tabindex="-1">一帧内的“可能”时间线（简化版） <a class="header-anchor" href="#一帧内的-可能-时间线-简化版" aria-label="Permalink to &quot;一帧内的“可能”时间线（简化版）&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Task A（你的脚本/事件/定时器回调）</span></span>
<span class="line"><span>  ↳ 多次写样式/读布局（可能触发样式/布局计算）</span></span>
<span class="line"><span>Microtasks（Promise/queueMicrotask 等）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Task B（例如另一个 setTimeout/postMessage 回调）</span></span>
<span class="line"><span>  ↳ 再次写样式/读布局（再次触发布局计算）</span></span>
<span class="line"><span>Microtasks（再次）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>requestAnimationFrame（若文档可见）</span></span>
<span class="line"><span>Microtasks（有的实现会在 rAF 后再跑一次）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>渲染机会（样式→布局→绘制→合成）← 这一步**可能**被跳过</span></span>
<span class="line"><span>requestIdleCallback（若本帧还有空闲）</span></span></code></pre></div><blockquote><p>关键点：<strong>渲染机会在一串任务与微任务之后才出现</strong>；浏览器可根据负载与可见性<strong>跳过</strong>绘制。</p></blockquote><hr><h2 id="为什么能出现-多次计算、不渲染" tabindex="-1">为什么能出现“多次计算、不渲染” <a class="header-anchor" href="#为什么能出现-多次计算、不渲染" aria-label="Permalink to &quot;为什么能出现“多次计算、不渲染”&quot;">​</a></h2><ol><li><p><strong>JS 主线程正在跑任务</strong> 浏览器不会中断 JS 去绘制。你在 Task 里频繁 <code>offsetHeight/getComputedStyle</code> 等，会<strong>强制样式/布局计算</strong>，但这些只是<strong>计算步骤</strong>，<strong>不是像素提交</strong>。</p></li><li><p><strong>多个任务连着跑</strong> 比如密集的 <code>setTimeout(0)</code>、<code>postMessage/MessageChannel</code>、事件风暴（滚轮、网络、I/O）。在下一次“渲染机会”到来前，可能已经跑了<strong>多个 Task</strong>。</p></li><li><p><strong>浏览器可以跳过绘制</strong> 无可见变化、标签页后台、节流/省电、超时长任务导致帧预算不足、或连续微任务造成的<strong>微任务饥饿</strong>，都会让这一帧的绘制<strong>被跳过</strong>。</p></li><li><p><strong>合成优化不等于每次绘制</strong> 某些变更（如 <code>transform/opacity</code>）可走合成器线程；主线程这侧即使做了样式/布局计算，也<strong>不一定每帧都提交像素</strong>。</p></li></ol><hr><h2 id="典型场景举例" tabindex="-1">典型场景举例 <a class="header-anchor" href="#典型场景举例" aria-label="Permalink to &quot;典型场景举例&quot;">​</a></h2><ul><li><p><strong>布局抖动（Layout Thrashing）</strong> 在一个或多个 Task 中交替“写样式 → 读布局 → 再写 → 再读”，会触发<strong>多次</strong>样式/布局计算；直到该回合结束且到了渲染机会，才<strong>可能</strong>绘制。</p></li><li><p><strong>密集计时器/消息队列</strong> 多个 <code>setTimeout(0)</code> 或 <code>postMessage</code> 连续执行，挤占了帧预算，<strong>渲染点被推迟</strong>，之前的计算都只是“准备工作”。</p></li><li><p><strong>后台/节流</strong> 标签页隐藏时，浏览器把绘制频率降到极低；任务仍可跑（被节流后频率也会降），但几乎不提交像素。</p></li></ul><hr><h2 id="和-vue-nexttick-的关系" tabindex="-1">和 Vue / <code>nextTick</code> 的关系 <a class="header-anchor" href="#和-vue-nexttick-的关系" aria-label="Permalink to &quot;和 Vue / \`nextTick\` 的关系&quot;">​</a></h2><ul><li>Vue 3 把<strong>渲染队列刷新（patch）安排在微任务</strong>中；<code>nextTick</code> 的回调在<strong>patch 之后</strong>、仍在微任务阶段。</li><li>这意味着<strong>DOM 已更新</strong>，但<strong>像素提交仍要等到后续的渲染机会</strong>；若浏览器跳过这一帧绘制，你仍看不到视觉变化，直到下一次真正绘制发生。</li></ul><hr><h2 id="如何识别你遇到了这种情况" tabindex="-1">如何识别你遇到了这种情况 <a class="header-anchor" href="#如何识别你遇到了这种情况" aria-label="Permalink to &quot;如何识别你遇到了这种情况&quot;">​</a></h2><ul><li><strong><code>requestAnimationFrame</code> 时间戳</strong>：两次 rAF 之间的时间远超目标帧间隔（如 &gt;16ms），说明<strong>帧被跳过/推迟</strong>。</li><li><strong>长任务（Long Task）标记</strong>：Performance 面板看到 &gt;50ms 的长任务，易导致绘制延后。</li><li><strong>布局与样式计算激增</strong>：Performance → Summary/Bottom-Up 里看到 Style/Layout 次数高但 Frames 提交少。</li></ul><hr><h2 id="实战建议-避免-算了很多却没绘制" tabindex="-1">实战建议（避免“算了很多却没绘制”） <a class="header-anchor" href="#实战建议-避免-算了很多却没绘制" aria-label="Permalink to &quot;实战建议（避免“算了很多却没绘制”）&quot;">​</a></h2><ol><li><p><strong>读写分离</strong> 在同一 Task 内，先<strong>批量读取</strong>布局，再<strong>批量写入</strong>样式，避免交替触发强制回流。</p></li><li><p><strong>用 <code>requestAnimationFrame</code> 对齐渲染节奏</strong></p><ul><li>渲染相关写操作（尤其动画步进）放进 rAF；</li><li>读操作可在 rAF 开头统一读取，写操作在 rAF 末尾统一写入。</li></ul></li><li><p><strong>控制任务密度</strong></p><ul><li>不要滥用 <code>setTimeout(0)</code>/<code>postMessage</code> 连环调用；</li><li>长计算用<strong>切片</strong>（<code>setTimeout</code>/<code>scheduler.postTask</code>/<code>requestIdleCallback</code>）或搬到 <strong>Web Worker</strong>。</li></ul></li><li><p><strong>避免微任务饥饿</strong> 连续 <code>queueMicrotask/Promise.then</code> 循环会推迟渲染；必要时插入一个宏任务切片。</p></li><li><p><strong>善用合成层</strong> 能走合成的动画（<code>transform/opacity</code>）更平滑，但也别在主线程塞太多 JS 抢占帧预算。</p></li></ol><hr><h2 id="一句话总结" tabindex="-1">一句话总结 <a class="header-anchor" href="#一句话总结" aria-label="Permalink to &quot;一句话总结&quot;">​</a></h2><p><strong>可以出现</strong>：同一帧里跑了多个宏任务、做了多次样式/布局计算，但<strong>没有渲染</strong>。 <strong>原因</strong>是浏览器只在特定“渲染机会”才可能提交像素，且有权跳过绘制。 <strong>对策</strong>：读写分离、用 rAF 对齐、切片重计算、控制任务与微任务密度。</p><p>简短结论：<strong>不完全是</strong>。 浏览器想要“提交一帧像素”，通常需要<strong>主线程在那一刻是空闲的</strong>（至少要从 JS 执行中<strong>让出控制权</strong>），这样它才能做样式计算、布局、绘制并交给合成器。但也有<strong>少数例外</strong>，即使主线程正忙，画面依然可能变化。</p><hr><h2 id="更精确地说" tabindex="-1">更精确地说 <a class="header-anchor" href="#更精确地说" aria-label="Permalink to &quot;更精确地说&quot;">​</a></h2><h3 id="需要主线程空闲才能发生的" tabindex="-1">需要主线程空闲才能发生的 <a class="header-anchor" href="#需要主线程空闲才能发生的" aria-label="Permalink to &quot;需要主线程空闲才能发生的&quot;">​</a></h3><ul><li><p><strong>样式重算 / 布局 / 绘制 / DOM 变更产生的可见更新</strong> 这些步骤都在<strong>主线程</strong>完成；如果你用长 JS/连续微任务把主线程占住了，<strong>这帧就无法进入渲染阶段</strong>（会延后或掉帧）。</p></li><li><p><strong><code>requestAnimationFrame</code> 回调</strong> rAF 在渲染前触发，也需要主线程有空；主线程被占用时，rAF 会被<strong>推迟</strong>。</p></li><li><p><strong>微任务清空</strong> 渲染前浏览器会跑一轮（或多轮）<strong>microtasks</strong>（如 <code>Promise.then</code>/<code>queueMicrotask</code>）。如果你不停塞微任务，可能出现<strong>微任务饥饿</strong>，导致渲染一直被拖后。</p></li></ul><h3 id="不一定需要主线程空闲也会动的" tabindex="-1">不一定需要主线程空闲也会动的 <a class="header-anchor" href="#不一定需要主线程空闲也会动的" aria-label="Permalink to &quot;不一定需要主线程空闲也会动的&quot;">​</a></h3><ul><li><p><strong>合成器线程驱动的变化</strong>（Compositor-only）</p><ul><li>典型：<strong>只改 <code>transform</code> / <code>opacity</code> 的 CSS 动画/过渡</strong> 这类动画很多情况下由<strong>合成器线程</strong>推进，即使主线程短时忙碌，<strong>视觉仍可能继续</strong>（但主线程太久不让也会卡输入/事件）。</li><li><strong>硬件加速的视频播放、GIF</strong> 在某些实现中也可能继续推进帧。</li><li><strong>异步滚动/惯性滚动</strong> 在现代浏览器常由合成器参与，主线程忙时滚动可能仍继续（交互响应会受影响）。</li></ul></li></ul><blockquote><p>所以更准确的表述是：<strong>大多数 DOM/CSS 带来的可见更新需要主线程阶段性空闲</strong>；但<strong>合成器可独立推进</strong>某些“只合成”的动画与效果。</p></blockquote><hr><h2 id="实用建议" tabindex="-1">实用建议 <a class="header-anchor" href="#实用建议" aria-label="Permalink to &quot;实用建议&quot;">​</a></h2><ul><li><strong>长任务切片</strong>：把重计算拆成小段（<code>setTimeout(0)</code> / <code>scheduler.postTask</code> / <code>requestIdleCallback</code> / Web Worker），给浏览器留出渲染机会。</li><li><strong>避免微任务饥饿</strong>：不要在 <code>then/queueMicrotask</code> 里无限自我追加。</li><li><strong>动画尽量走合成器</strong>：能用 <code>transform/opacity</code> 就别改会触发布局/绘制的属性；必要时配合 <code>will-change</code>。</li><li><strong>读写分离</strong>：同一宏任务中先批量<strong>读布局</strong>，再批量<strong>写样式</strong>，减少强制同步布局。</li></ul><p><strong>一句话</strong>：渲染不要求“完全没有 JS”，但<strong>要求主线程在渲染机会点上能被抢到</strong>。主线程若被 JS 长时间占用，渲染就会被推迟；只有<strong>合成器可独立推进的少数场景</strong>能在此期间继续“看起来在动”。</p>`,37)])])}const h=o(a,[["render",e]]);export{u as __pageData,h as default};
