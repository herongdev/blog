import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.oqSrIbQK.js";const d=JSON.parse('{"title":"Web 与移动应用登录失效后「重新登录」提示的通用方案（含 WS/Token 最佳实践）","description":"","frontmatter":{"title":"Web 与移动应用登录失效后「重新登录」提示的通用方案（含 WS/Token 最佳实践）","date":"2025-09-27T10:00:00.000Z","tags":["登录失效","Token","鉴权与安全"]},"headers":[],"relativePath":"posts/前端/Vue/Web 与移动应用登录失效后重新登录提示的通用方案.md","filePath":"posts/前端/Vue/Web 与移动应用登录失效后重新登录提示的通用方案.md","lastUpdated":1764331727000}'),l={name:"posts/前端/Vue/Web 与移动应用登录失效后重新登录提示的通用方案.md"};function e(h,s,k,r,p,o){return n(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to &quot;概览&quot;">​</a></h1><ul><li><p>目标：当<strong>会话过期</strong>、<strong>多端登录被挤下线</strong>或<strong>长时间未操作</strong>时，<strong>主动提示用户</strong>并<strong>引导重新登录</strong>。</p></li><li><p>核心思路：</p><ol><li><strong>服务端主动通知</strong>（WS/推送）+ <strong>客户端统一处理</strong>。</li><li><strong>客户端被动检测</strong>（拦截 401/403 或本地过期计时）+ <strong>统一登出流程</strong>。</li><li><strong>AccessToken（短）+ RefreshToken（长）</strong> 的续期机制，尽量<strong>无感刷新</strong>；刷新失败再提示登录。</li><li>WebSocket 在<strong>握手即鉴权</strong>，并约定<strong>失效信号与重连策略</strong>。</li></ol></li></ul><hr><h1 id="一、触发与检测机制" tabindex="-1">一、触发与检测机制 <a class="header-anchor" href="#一、触发与检测机制" aria-label="Permalink to &quot;一、触发与检测机制&quot;">​</a></h1><h2 id="_1-服务端主动通知-实时感知" tabindex="-1">1. 服务端主动通知（实时感知） <a class="header-anchor" href="#_1-服务端主动通知-实时感知" aria-label="Permalink to &quot;1. 服务端主动通知（实时感知）&quot;">​</a></h2><ul><li><p>典型场景：<strong>他端登录挤下线</strong>、管理后台<strong>强制失效</strong>、安全风控。</p></li><li><p>通道选择：</p><ul><li><strong>WebSocket</strong>：向客户端推送 <code>logout</code>/<code>session_expired</code> 事件；客户端弹窗 → 清理 → 跳登录。</li><li><strong>移动推送</strong>（APNs/FCM）：App 在前台时提示，后台可静默标记，回到前台统一处理。</li></ul></li><li><p>优点：<strong>即时</strong>、<strong>统一</strong>；缺点：需<strong>协议与客户端处理逻辑</strong>配套。</p></li></ul><h2 id="_2-客户端被动检测-最常见" tabindex="-1">2. 客户端被动检测（最常见） <a class="header-anchor" href="#_2-客户端被动检测-最常见" aria-label="Permalink to &quot;2. 客户端被动检测（最常见）&quot;">​</a></h2><ul><li><strong>HTTP 拦截</strong>：在网络层统一捕获 <strong>401/403</strong>。</li><li><strong>本地计时</strong>：解析 token 的 <code>exp</code>，<strong>到期前刷新</strong>，失败则触发登出。</li><li>优点：实现简单、<strong>集中维护</strong>；缺点：<strong>非实时</strong>（在发起请求时才发现）。</li></ul><hr><h1 id="二、web-应用实现与交互范式-react-vue-spa" tabindex="-1">二、Web 应用实现与交互范式（React/Vue/SPA） <a class="header-anchor" href="#二、web-应用实现与交互范式-react-vue-spa" aria-label="Permalink to &quot;二、Web 应用实现与交互范式（React/Vue/SPA）&quot;">​</a></h1><h2 id="_1-统一拦截器" tabindex="-1">1. 统一拦截器 <a class="header-anchor" href="#_1-统一拦截器" aria-label="Permalink to &quot;1. 统一拦截器&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：统一拦截 401，先清状态再引导登录，避免“幽灵会话”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> axios </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;axios&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">axios.interceptors.response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err?.response?.status;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 401</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 403</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 清本地凭证与用户态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      localStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;authToken&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 可广播给其它标签同步退出（BroadcastChannel 或 storage 事件）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // new BroadcastChannel(&#39;auth&#39;).postMessage({ type: &#39;LOGOUT&#39; });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 友好提示 + 携带回跳</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> redirect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> encodeURIComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        window.location.pathname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.location.search</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      window.location.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`/login?redirect=\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redirect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&amp;reason=expired\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_2-多标签页同步退出" tabindex="-1">2. 多标签页同步退出 <a class="header-anchor" href="#_2-多标签页同步退出" aria-label="Permalink to &quot;2. 多标签页同步退出&quot;">​</a></h2><ul><li>使用 <code>BroadcastChannel(&#39;auth&#39;)</code> 或 <code>window.addEventListener(&#39;storage&#39;)</code> 同步其它标签页的登出动作。</li><li>登出时只做<strong>一次性清理</strong>，其余标签页收到事件后<strong>跳登录</strong>即可。</li></ul><h2 id="_3-交互建议" tabindex="-1">3. 交互建议 <a class="header-anchor" href="#_3-交互建议" aria-label="Permalink to &quot;3. 交互建议&quot;">​</a></h2><ul><li><strong>前台弹窗</strong>（模态框/顶部警示条）：提示“登录已失效，请重新登录”。</li><li><strong>路由守卫</strong>：访问受保护路由时若无有效会话，<strong>直接重定向登录</strong>并带回跳参数。</li><li><strong>可回跳</strong>：登录成功后返回原页面，降低打断感。</li></ul><hr><h1 id="三、移动端实现与交互范式-ios-android-flutter" tabindex="-1">三、移动端实现与交互范式（iOS/Android/Flutter） <a class="header-anchor" href="#三、移动端实现与交互范式-ios-android-flutter" aria-label="Permalink to &quot;三、移动端实现与交互范式（iOS/Android/Flutter）&quot;">​</a></h1><h2 id="_1-网络层统一拦截" tabindex="-1">1. 网络层统一拦截 <a class="header-anchor" href="#_1-网络层统一拦截" aria-label="Permalink to &quot;1. 网络层统一拦截&quot;">​</a></h2><p><strong>Android（OkHttp/Retrofit）示例：</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：网络层统一捕获 401，切至主线程做 UI 提示与登出跳转</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AuthInterceptor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Interceptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Response </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">intercept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Chain </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">chain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IOException {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Response res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">proceed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(chain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 401</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 403</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      App.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">runOnMainThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> App.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onTokenExpired</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>iOS（Alamofire/URLSession）要点：</strong></p><ul><li>在响应回调里判断 401/403 → <code>DispatchQueue.main.async</code> 切主线程弹窗与路由到登录页。</li><li>清理：Keychain/NSUserDefaults 中的 token、内存单例用户对象、与用户相关的后台任务。</li></ul><h2 id="_2-推送配合" tabindex="-1">2. 推送配合 <a class="header-anchor" href="#_2-推送配合" aria-label="Permalink to &quot;2. 推送配合&quot;">​</a></h2><ul><li>前台：展示对话框并跳登录。</li><li>后台：标记“需重登”，用户回前台时统一处理（或使用静默推送直接触发登出流程）。</li></ul><h2 id="_3-导航与状态" tabindex="-1">3. 导航与状态 <a class="header-anchor" href="#_3-导航与状态" aria-label="Permalink to &quot;3. 导航与状态&quot;">​</a></h2><ul><li>清空导航栈/重建根路由，<strong>禁止返回</strong>到受保护页面。</li><li>退出时注销推送别名/话题订阅，避免误投递。</li></ul><hr><h1 id="四、token-最佳实践" tabindex="-1">四、Token 最佳实践 <a class="header-anchor" href="#四、token-最佳实践" aria-label="Permalink to &quot;四、Token 最佳实践&quot;">​</a></h1><h2 id="_1-短-access-长-refresh" tabindex="-1">1. 短 Access + 长 Refresh <a class="header-anchor" href="#_1-短-access-长-refresh" aria-label="Permalink to &quot;1. 短 Access + 长 Refresh&quot;">​</a></h2><ul><li><strong>Access Token</strong>（15–60 分钟）：用于请求；</li><li><strong>Refresh Token</strong>（天/周级）：用于无感续期；</li><li>流程：请求失败（401）→ <strong>先尝试刷新</strong> → 刷新成功重试原请求 → 刷新失败才提示重新登录。</li></ul><h2 id="_2-安全与合规" tabindex="-1">2. 安全与合规 <a class="header-anchor" href="#_2-安全与合规" aria-label="Permalink to &quot;2. 安全与合规&quot;">​</a></h2><ul><li>Web：<strong>Refresh Token 放 HttpOnly Cookie</strong>；Access 可放内存/非持久。</li><li>移动端：Refresh 放 <strong>Keychain/Keystore</strong>；必要时二次加密。</li><li><strong>Refresh Token 轮换</strong>：每次刷新下发新 RT，使旧 RT 失效。</li><li><strong>强退/改密</strong>：后端需可<strong>撤销</strong>既发 token（黑名单/会话存储），并<strong>广播</strong>失效事件。</li></ul><h2 id="_3-客户端实现要点" tabindex="-1">3. 客户端实现要点 <a class="header-anchor" href="#_3-客户端实现要点" aria-label="Permalink to &quot;3. 客户端实现要点&quot;">​</a></h2><ul><li><p>统一的 <strong>token 管理器</strong>：</p><ul><li>维护 <code>access/refresh/exp</code>；</li><li>提供 <code>getValidAccessToken()</code>（自动判断与刷新）；</li><li><strong>并发刷新去抖</strong>：刷新中其余请求<strong>等待同一 Promise</strong>，避免风暴；</li><li>最大会话总时长/刷新次数上限，超限则要求重新登录。</li></ul></li></ul><hr><h1 id="五、websocket-鉴权与失效处理" tabindex="-1">五、WebSocket 鉴权与失效处理 <a class="header-anchor" href="#五、websocket-鉴权与失效处理" aria-label="Permalink to &quot;五、WebSocket 鉴权与失效处理&quot;">​</a></h1><h2 id="_1-握手即鉴权" tabindex="-1">1. 握手即鉴权 <a class="header-anchor" href="#_1-握手即鉴权" aria-label="Permalink to &quot;1. 握手即鉴权&quot;">​</a></h2><ul><li><p><strong>浏览器</strong>：URL 查询参数附带 <code>token</code>（配合 <code>wss://</code>；避免在日志中记录完整 URL）。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：用代次隔离迟到消息，切换/重连时避免“幽灵数据”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">token</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myGen</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gen;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    \`wss://example.com/stream?token=\${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodeURIComponent</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">token</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (myGen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gen) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 正常处理消息 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 根据 code/reason 决定是否提示或重连 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>原生/Node 客户端</strong>：可走 <code>Authorization: Bearer &lt;token&gt;</code> 自定义头。</p></li></ul><h2 id="_2-过期与续期" tabindex="-1">2. 过期与续期 <a class="header-anchor" href="#_2-过期与续期" aria-label="Permalink to &quot;2. 过期与续期&quot;">​</a></h2><ul><li><strong>主动续期</strong>：本地检测将过期 → 刷新成功后 <strong>重建 WS</strong>（带新 token）。</li><li><strong>服务端信号</strong>：约定 <code>auth_error</code> 事件或特定 close code；客户端收到后<strong>弹窗 → 清理 → 跳登录</strong>或执行透明重连。</li><li><strong>多端冲突</strong>：新连接建立 → 服务端关闭旧连接并推送“被挤下线”消息；客户端统一走登出流程。</li></ul><hr><h1 id="六、统一登出流程-web-移动端通用清单" tabindex="-1">六、统一登出流程（Web/移动端通用清单） <a class="header-anchor" href="#六、统一登出流程-web-移动端通用清单" aria-label="Permalink to &quot;六、统一登出流程（Web/移动端通用清单）&quot;">​</a></h1><ol><li><strong>停止一切后续请求</strong>（可取消队列/挂起 UI 操作）。</li><li><strong>清理本地凭证与用户态</strong>：token、用户信息、缓存、订阅、定时器。</li><li><strong>关闭 WS/RTC/推送别名</strong> 等与用户绑定的长连接通道。</li><li><strong>多实例同步</strong>（Web 多标签、移动多进程）。</li><li><strong>跳转登录页</strong>（重建导航栈；可带回跳参数）。</li><li><strong>显式提示原因</strong>：会话超时/他端登录/安全风险等。</li></ol><hr><h1 id="七、常见陷阱与规避" tabindex="-1">七、常见陷阱与规避 <a class="header-anchor" href="#七、常见陷阱与规避" aria-label="Permalink to &quot;七、常见陷阱与规避&quot;">​</a></h1><ul><li><strong>只清 token 不清内存态</strong> → 页面仍显示旧用户信息。</li><li><strong>并发刷新风暴</strong> → 使用<strong>单航道刷新</strong>（队列/锁/共享 Promise）。</li><li><strong>WS 不识别过期</strong> → 缺少 close code/事件约定；补齐协议。</li><li><strong>多标签不同步</strong> → BroadcastChannel/storage 事件必配。</li><li><strong>Refresh 永不过期</strong> → 增加<strong>最长会话窗口</strong>与<strong>轮换</strong>策略。</li></ul><hr><h1 id="八、快速集成清单-落地指南" tabindex="-1">八、快速集成清单（落地指南） <a class="header-anchor" href="#八、快速集成清单-落地指南" aria-label="Permalink to &quot;八、快速集成清单（落地指南）&quot;">​</a></h1><ul><li>[ ] Axios/OkHttp/Alamofire <strong>响应拦截器</strong>接管 401/403。</li><li>[ ] <code>TokenManager</code>：持久化、<code>getValidAccessToken()</code>、并发去抖刷新。</li><li>[ ] <strong>Access+Refresh</strong> 流水线与<strong>轮换</strong>；Web 用 HttpOnly Cookie。</li><li>[ ] WebSocket：<strong>握手鉴权</strong>、<strong>失效信号</strong>、<strong>重连与代次</strong>。</li><li>[ ] 统一 <code>logout()</code>：清理 + 关闭通道 + 同步 + 跳登录。</li><li>[ ] 多端登录策略：后端<strong>单会话/多会话</strong>规则 + 主动通知。</li><li>[ ] UX：显式原因、可回跳、不中断未保存数据（必要时草稿）。</li></ul><hr><h1 id="附-代码片段索引" tabindex="-1">附：代码片段索引 <a class="header-anchor" href="#附-代码片段索引" aria-label="Permalink to &quot;附：代码片段索引&quot;">​</a></h1><ul><li><strong>Web：Axios 401 拦截</strong>（见上文「二-1」）。</li><li><strong>Android：OkHttp 拦截器</strong>（见上文「三-1」）。</li><li><strong>WS：握手鉴权与代次</strong>（见上文「五-1」）。</li></ul><blockquote><p>以上为可直接落地的基线方案；结合你们目前“HTTP 为主 + 服务器亦可下发退出通知”的架构，建议<strong>先完善客户端拦截与统一登出</strong>，再逐步接入<strong>WS 主动通知</strong>与<strong>Refresh 轮换</strong>，最终实现“<strong>无感续期，必要时清晰提示</strong>”的一致体验。</p></blockquote>`,54)])])}const E=i(l,[["render",e]]);export{d as __pageData,E as default};
