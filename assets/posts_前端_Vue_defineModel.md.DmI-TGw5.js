import{_ as s,c as i,o as a,ag as t}from"./chunks/framework.oqSrIbQK.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"posts/前端/Vue/defineModel.md","filePath":"posts/前端/Vue/defineModel.md","lastUpdated":1759031800000}'),n={name:"posts/前端/Vue/defineModel.md"};function l(o,e,r,d,h,p){return a(),i("div",null,[...e[0]||(e[0]=[t(`<p>不是“不能 push”，而是**<code>defineModel</code> 只在你给 <code>model.value</code> 赋新值时才会触发 <code>update:modelValue</code><strong>。 像 <code>push / splice</code> 这种</strong>对同一个数组实例的就地修改**，不会触发 <code>defineModel</code> 的 setter，因此<strong>不会向父组件同步</strong>（除非父子共享同一对象引用，这样虽然会“看起来生效”，但违反单向数据流，且很容易被父层下一次渲染覆盖）。</p><h2 id="结论-基于官方与社区资料" tabindex="-1">结论（基于官方与社区资料） <a class="header-anchor" href="#结论-基于官方与社区资料" aria-label="Permalink to &quot;结论（基于官方与社区资料）&quot;">​</a></h2><ul><li><code>defineModel</code> 本质是<strong>把 <code>modelValue</code> + <code>update:modelValue</code> 封装成一个可写的 ref</strong>；**只有“赋值”**才会触发 emit。(<a href="https://vuejs.org/guide/components/v-model?utm_source=chatgpt.com" title="Component v-model" target="_blank" rel="noreferrer">Vue.js</a>)</li><li>多个社区 / issues 都指出：<strong>对数组/对象的深层修改不会自动 emit</strong>，因此父层拿不到变更；需要<strong>重新赋值</strong>或<strong>手动 emit</strong>。(<a href="https://github.com/vuejs/core/issues/11143?utm_source=chatgpt.com" title="defineModel push array doesnt trigger the value #11143" target="_blank" rel="noreferrer">GitHub</a>)</li><li>这是<strong>设计选择</strong>而非 bug：Vue 仍然倡导<strong>子组件通过事件同步父值</strong>，避免直接深改 props 引用。(<a href="https://v3-migration.vuejs.org/breaking-changes/v-model?utm_source=chatgpt.com" title="v-model breaking" target="_blank" rel="noreferrer">Vue 3 迁移指南</a>)</li></ul><h2 id="推荐做法-两选一" tabindex="-1">推荐做法（两选一） <a class="header-anchor" href="#推荐做法-两选一" aria-label="Permalink to &quot;推荐做法（两选一）&quot;">​</a></h2><h3 id="a-重新赋值-最简、最稳" tabindex="-1">A. 重新赋值（最简、最稳） <a class="header-anchor" href="#a-重新赋值-最简、最稳" aria-label="Permalink to &quot;A. 重新赋值（最简、最稳）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：用新数组触发 defineModel 的 setter，从而 emit 到父层</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model.value, newItem];</span></span></code></pre></div><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：删除/更新同理——返回新数组再赋值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">model.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> model.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">idx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i);</span></span></code></pre></div><h3 id="b-手动-emit-若你没用-definemodel-而是手写-props-emit" tabindex="-1">B. 手动 emit（若你没用 defineModel，而是手写 props/emit） <a class="header-anchor" href="#b-手动-emit-若你没用-definemodel-而是手写-props-emit" aria-label="Permalink to &quot;B. 手动 emit（若你没用 defineModel，而是手写 props/emit）&quot;">​</a></h3><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂逻辑：就地改完后，显式把“新副本”通过事件抛给父层</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> next</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props.modelValue, newItem];</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;update:modelValue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, next);</span></span></code></pre></div><blockquote><p>不建议：<code>model.value.push(x)</code> 之后再 <code>model.value = model.value</code> 这种“自赋值触发”，虽然能 emit，但可读性差、容易踩坑。</p></blockquote><h2 id="什么时候-push-看起来能用" tabindex="-1">什么时候 push“看起来能用”？ <a class="header-anchor" href="#什么时候-push-看起来能用" aria-label="Permalink to &quot;什么时候 push“看起来能用”？&quot;">​</a></h2><p>当父层把同一个数组实例传给子层时，你在子里 <code>push</code> 会直接改到父的那份引用，因此本地能看到变化——但这<strong>绕过了 v-model 的事件同步</strong>，属于<strong>反模式</strong>： 下一次父层产生新引用或重新渲染时，你的改动可能被覆盖掉。(<a href="https://v3-migration.vuejs.org/breaking-changes/v-model?utm_source=chatgpt.com" title="v-model breaking" target="_blank" rel="noreferrer">Vue 3 迁移指南</a>)</p><h2 id="一句话收尾" tabindex="-1">一句话收尾 <a class="header-anchor" href="#一句话收尾" aria-label="Permalink to &quot;一句话收尾&quot;">​</a></h2><p><strong><code>defineModel</code> 没禁止 <code>push</code></strong>；只是<strong>不会为“深层就地改动”自动发 <code>update</code></strong>。想让父子同步，<strong>用“新引用赋值”</strong>（或手动 emit）。这是官方推荐的单向数据流与 v-model 语义。(<a href="https://vuejs.org/guide/components/v-model?utm_source=chatgpt.com" title="Component v-model" target="_blank" rel="noreferrer">Vue.js</a>)</p>`,14)])])}const g=s(n,[["render",l]]);export{c as __pageData,g as default};
