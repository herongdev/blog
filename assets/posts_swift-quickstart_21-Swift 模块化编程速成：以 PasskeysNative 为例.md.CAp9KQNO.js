import{_ as i,c as a,o as t,ag as e}from"./chunks/framework.oqSrIbQK.js";const c=JSON.parse('{"title":"Swift 模块化编程速成：以 PasskeysNative 为例","description":"","frontmatter":{"title":"Swift 模块化编程速成：以 PasskeysNative 为例","date":"2025-09-17T00:00:00.000Z","tags":["ios","swift","模块化"]},"headers":[],"relativePath":"posts/swift-quickstart/21-Swift 模块化编程速成：以 PasskeysNative 为例.md","filePath":"posts/swift-quickstart/21-Swift 模块化编程速成：以 PasskeysNative 为例.md","lastUpdated":1758903911000}'),n={name:"posts/swift-quickstart/21-Swift 模块化编程速成：以 PasskeysNative 为例.md"};function l(o,s,r,h,p,k){return t(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="你将收获" tabindex="-1">你将收获 <a class="header-anchor" href="#你将收获" aria-label="Permalink to &quot;你将收获&quot;">​</a></h1><ul><li>如何为 iOS 代码划清<strong>模块边界</strong>，只暴露稳定的 <strong>Public API</strong>。</li><li>选择 <strong>Swift Package</strong> / <strong>XCFramework</strong> 输出形态，以及最小可行的集成步骤。</li><li>设计<strong>输入输出契约</strong>（JSON 入参与回调），稳定错误模型与平台兼容策略。</li><li>进阶：协议抽象、依赖倒置、可测试性、并发模型、二进制分发与文档化。</li></ul><hr><h1 id="场景设定-把-passkeysnative-做成可复用模块" tabindex="-1">场景设定：把 <code>PasskeysNative</code> 做成可复用模块 <a class="header-anchor" href="#场景设定-把-passkeysnative-做成可复用模块" aria-label="Permalink to &quot;场景设定：把 \`PasskeysNative\` 做成可复用模块&quot;">​</a></h1><p>你的类大致长这样（节选，便于说明；不复述完整代码）：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@objc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PasskeysNative</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NSObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ASAuthorizationControllerDelegate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ASAuthorizationControllerPresentationContextProviding </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... JSON / Base64url 工具方法（internal/private）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... @objc public func register(_ optionsJson: String, _ cb: @escaping (String) -&gt; Void)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... @objc public func authenticate(_ optionsJson: String, _ cb: @escaping (String) -&gt; Void)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... ASAuthorizationControllerDelegate 回调</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>目标：把它抽为 <strong>独立模块</strong>，对外只暴露 <code>register(optionsJson, cb)</code> 与 <code>authenticate(optionsJson, cb)</code>，内部细节（Base64 工具、iOS 16+ 适配、系统回调）全部<strong>隐藏</strong>。</p></blockquote><h1 id="第一部分-·-最常用最重要-先用起来" tabindex="-1">第一部分 · 最常用最重要（先用起来） <a class="header-anchor" href="#第一部分-·-最常用最重要-先用起来" aria-label="Permalink to &quot;第一部分 · 最常用最重要（先用起来）&quot;">​</a></h1><h2 id="_1-划定模块边界与对外-api" tabindex="-1">1. 划定模块边界与对外 API <a class="header-anchor" href="#_1-划定模块边界与对外-api" aria-label="Permalink to &quot;1. 划定模块边界与对外 API&quot;">​</a></h2><p><strong>原则</strong>：</p><ul><li>仅把<strong>稳定能力</strong>标注为 <code>public</code> / <code>@objc</code> 暴露给上层（UTS/JS 桥）。</li><li>细节工具与策略（Base64url、JSON 解析、错误组装）一律 <code>internal</code>/<code>private</code>。</li><li><strong>输入</strong>：<code>optionsJson</code>（WebAuthn 标准字段，经由前端/服务器下发）。</li><li><strong>输出</strong>：统一的回调 JSON：<code>{&quot;ok&quot;: true, &quot;data&quot;: {...}} | {&quot;ok&quot;: false, &quot;errMsg&quot;: &quot;...&quot;}</code>。</li></ul><p><strong>建议 API（示意）</strong>：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@objc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PasskeysAPI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 复杂：跨语言回调形态与线程切换</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ↑ 在复杂逻辑上一行加注释</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> register</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> optionsJson: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cb: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@escaping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> authenticate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> optionsJson: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cb: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@escaping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>说明：把协议放在模块 <code>Public</code> 目录，类 <code>PasskeysNative</code> 作为默认实现，后续可无痛替换（比如接入外部安全 Key 的实现）。</p></blockquote><h2 id="_2-产物类型-swift-package-vs-xcframework-怎么交付" tabindex="-1">2. 产物类型：Swift Package vs XCFramework（怎么交付） <a class="header-anchor" href="#_2-产物类型-swift-package-vs-xcframework-怎么交付" aria-label="Permalink to &quot;2. 产物类型：Swift Package vs XCFramework（怎么交付）&quot;">​</a></h2><p><strong>Swift Package（首选）</strong></p><ul><li>优点：源码分发、版本化清晰、集成简单（Xcode/SwiftPM 原生支持）。</li><li>适合团队内部与持续演进。</li></ul><p><strong>XCFramework（二进制）</strong></p><ul><li>优点：隐藏源码、冷启动更快、适合跨项目/商业分发。</li><li>用法：<code>xcodebuild -create-xcframework -framework ... -output Passkeys.xcframework</code>。</li></ul><blockquote><p>推荐：<strong>先 SwiftPM，后期有保密/性能诉求再补二进制 XCFramework</strong>。</p></blockquote><h2 id="_3-输入输出契约-最易踩坑的地方" tabindex="-1">3. 输入输出契约（最易踩坑的地方） <a class="header-anchor" href="#_3-输入输出契约-最易踩坑的地方" aria-label="Permalink to &quot;3. 输入输出契约（最易踩坑的地方）&quot;">​</a></h2><ul><li><strong>输入</strong>：<code>PublicKeyCredentialCreationOptions</code> / <code>RequestOptions</code> 的<strong>对象本体</strong>（不是 <code>{ publicKey: {} }</code> 外包一层）。</li><li><strong>字段</strong>：<code>rp.id</code>、<code>challenge</code>、<code>user.id</code>/<code>user.name</code>、<code>rpId</code> 等必须存在。</li><li><strong>编码</strong>：二进制字段（<code>challenge</code>、<code>user.id</code>、<code>rawId</code>等）统一 <strong>Base64URL</strong>。</li><li><strong>输出</strong>：遵循 WebAuthn 前端预期形态（<code>id/rawId/type/response/...</code>）。</li><li><strong>错误</strong>：固定 <code>ok/errMsg</code> 键，便于前端/UTS 无分支解析。</li></ul><blockquote><p>小贴士：JSON 序列化失败、必填字段缺失、平台版本不符，<strong>都走同一错误模型</strong>，前端体验最稳定。</p></blockquote><h2 id="_4-平台-版本兼容策略-ios-16" tabindex="-1">4. 平台/版本兼容策略（iOS 16+） <a class="header-anchor" href="#_4-平台-版本兼容策略-ios-16" aria-label="Permalink to &quot;4. 平台/版本兼容策略（iOS 16+）&quot;">​</a></h2><ul><li><code>ASAuthorizationPlatformPublicKeyCredential*</code> 需要 <strong>iOS 16+</strong>。</li><li>在 API 内部用 <code>#available(iOS 16.0, *)</code> <strong>短路返回</strong>统一错误（<code>&quot;iOS 16+ required&quot;</code>）。</li><li>不把平台细节泄露到 API 边界之外（对外只看 <code>ok/errMsg</code>）。</li></ul><h2 id="第二部分-·-深入与难点-架构-工程化" tabindex="-1">第二部分 · 深入与难点（架构/工程化） <a class="header-anchor" href="#第二部分-·-深入与难点-架构-工程化" aria-label="Permalink to &quot;第二部分 · 深入与难点（架构/工程化）&quot;">​</a></h2><h3 id="a-面向协议的抽象与依赖倒置" tabindex="-1">A. 面向协议的抽象与依赖倒置 <a class="header-anchor" href="#a-面向协议的抽象与依赖倒置" aria-label="Permalink to &quot;A. 面向协议的抽象与依赖倒置&quot;">​</a></h3><ul><li><strong>问题</strong>：未来可能接入 FIDO 外置 Key、模拟器桩件或切换到不同系统 API。</li><li><strong>做法</strong>：抽象协议并<strong>依赖接口</strong>而非具体类。</li></ul><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复杂：抽象系统提供者，便于注入 mock 与多实现</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ↑ 在复杂逻辑上一行加注释</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protocol</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CredentialProvider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeRegistrationRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">challenge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Data, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Data) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ASAuthorizationRequest</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> makeAssertionRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">challenge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Data) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ASAuthorizationRequest</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><code>PasskeysNative</code> 通过构造函数接收 <code>CredentialProvider</code>，测试时注入 <strong>FakeProvider</strong>。</p></blockquote><h3 id="b-并发模型-从回调到-async-await-可选" tabindex="-1">B. 并发模型：从回调到 async/await（可选） <a class="header-anchor" href="#b-并发模型-从回调到-async-await-可选" aria-label="Permalink to &quot;B. 并发模型：从回调到 async/await（可选）&quot;">​</a></h3><ul><li><p>门面层保留回调（兼容跨语言），<strong>内部</strong>可封装为 <code>async</code>：</p><ul><li>回调转 <code>CheckedContinuation</code>。</li><li>上层 Swift 调用者可获得 <code>let result = try await client.register(options:)</code> 的良好体验。</li><li>对外仍只暴露回调方法，保持跨语言稳定。</li></ul></li></ul><h3 id="c-错误域与分类" tabindex="-1">C. 错误域与分类 <a class="header-anchor" href="#c-错误域与分类" aria-label="Permalink to &quot;C. 错误域与分类&quot;">​</a></h3><ul><li><p>自定义 <code>PasskeysError: Error</code>，内部归类：</p><ul><li><code>.invalidOptions(field: String)</code>、<code>.platformUnsupported(min: &quot;iOS16&quot;)</code>、<code>.system(Error)</code>、<code>.encoding</code>。</li></ul></li><li><p><strong>统一映射</strong>到 <code>errMsg</code> 字符串，<strong>不上抛内部类型</strong>到跨语言边界。</p></li></ul><h3 id="d-跨语言边界与可见性" tabindex="-1">D. 跨语言边界与可见性 <a class="header-anchor" href="#d-跨语言边界与可见性" aria-label="Permalink to &quot;D. 跨语言边界与可见性&quot;">​</a></h3><ul><li>需要 <code>@objc</code> + <code>NSObject</code> + <code>public</code> 才能被 UTS/JS 调用。</li><li>注意 <code>nullability</code> 与 Swift/ObjC 桥接（<code>String?</code> / <code>Data?</code>）。</li><li><code>JSONSerialization</code> 用 <code>try?</code> + 可控的默认值<strong>收口错误</strong>。</li></ul><h2 id="e-测试策略" tabindex="-1">E. 测试策略 <a class="header-anchor" href="#e-测试策略" aria-label="Permalink to &quot;E. 测试策略&quot;">​</a></h2><ul><li><p><strong>单测</strong>：</p><ul><li>Base64URL 编解码（空输入、无填充、多填充）。</li><li>JSON 契约（必填字段缺失 → 错误）。</li><li>iOS16 可用性分支。</li></ul></li><li><p><strong>组件测试</strong>：</p><ul><li>用 Fake <code>CredentialProvider</code> 模拟成功/失败/取消回调。</li></ul></li><li><p><strong>UI/集成</strong>：</p><ul><li>最小 Demo App 调通真实设备的注册/登录流程。</li></ul></li></ul><h2 id="f-工程化-版本与分发" tabindex="-1">F. 工程化：版本与分发 <a class="header-anchor" href="#f-工程化-版本与分发" aria-label="Permalink to &quot;F. 工程化：版本与分发&quot;">​</a></h2><ul><li><p><strong>语义化版本</strong>：<code>MAJOR.MINOR.PATCH</code>。</p><ul><li>修改 JSON 字段 →<strong>MAJOR</strong>。</li><li>新增字段（向后兼容）→<strong>MINOR</strong>。</li><li>修复/优化 →<strong>PATCH</strong>。</li></ul></li><li><p><strong>二进制分发</strong>（可选）：出 <code>*.xcframework</code> + 校验脚本（<code>codesign --verify</code>）。</p></li></ul><h2 id="g-文档化与可发现性" tabindex="-1">G. 文档化与可发现性 <a class="header-anchor" href="#g-文档化与可发现性" aria-label="Permalink to &quot;G. 文档化与可发现性&quot;">​</a></h2><ul><li>用 <strong>DocC</strong> 为 <code>PasskeysAPI</code> 生成文档；</li><li>在包内提供 <code>Examples/</code>，含最小调用样例与 JSON 模版。</li></ul><hr><h1 id="目录结构建议-可直接照搬" tabindex="-1">目录结构建议（可直接照搬） <a class="header-anchor" href="#目录结构建议-可直接照搬" aria-label="Permalink to &quot;目录结构建议（可直接照搬）&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>PasskeysKit/</span></span>
<span class="line"><span>├─ Package.swift</span></span>
<span class="line"><span>├─ Sources/</span></span>
<span class="line"><span>│  └─ PasskeysKit/</span></span>
<span class="line"><span>│     ├─ Public/</span></span>
<span class="line"><span>│     │  ├─ PasskeysAPI.swift</span></span>
<span class="line"><span>│     │  └─ PasskeysErrors.swift</span></span>
<span class="line"><span>│     └─ Internal/</span></span>
<span class="line"><span>│        ├─ PasskeysNative.swift</span></span>
<span class="line"><span>│        ├─ CredentialProvider.swift</span></span>
<span class="line"><span>│        ├─ Base64URL.swift</span></span>
<span class="line"><span>│        └─ JSONCoder.swift</span></span>
<span class="line"><span>└─ Tests/</span></span>
<span class="line"><span>   └─ PasskeysKitTests/</span></span>
<span class="line"><span>      ├─ Base64URLTests.swift</span></span>
<span class="line"><span>      ├─ OptionsParsingTests.swift</span></span>
<span class="line"><span>      └─ PlatformAvailabilityTests.swift</span></span></code></pre></div><hr><h1 id="模块化落地清单-checklist" tabindex="-1">模块化落地清单（Checklist） <a class="header-anchor" href="#模块化落地清单-checklist" aria-label="Permalink to &quot;模块化落地清单（Checklist）&quot;">​</a></h1><ul><li>[ ] Public API <strong>最小化</strong>，仅暴露 <code>register/authenticate</code>。</li><li>[ ] 输入/输出 JSON 契约文档齐全，错误模型统一。</li><li>[ ] <code>#available(iOS 16, *)</code> 在内部<strong>短路</strong>，不外泄平台细节。</li><li>[ ] SwiftPM 集成通过；必要时补 XCFramework。</li><li>[ ] 协议抽象 + 依赖注入，测试可控。</li><li>[ ] 版本语义化与变更日志。</li><li>[ ] DocC 文档与 <code>Examples/</code> 示例齐备。</li></ul><hr><h1 id="常见坑位与规避" tabindex="-1">常见坑位与规避 <a class="header-anchor" href="#常见坑位与规避" aria-label="Permalink to &quot;常见坑位与规避&quot;">​</a></h1><ul><li><strong>Base64URL</strong> 填充处理：注意 <code>=</code> 去/补；空字符串与非法字符要兜底为空 <code>Data()</code>。</li><li><strong>回调置空</strong>：一次请求结束后 <code>callback = nil</code>，避免多次触发或悬挂引用。</li><li><strong>线程语义</strong>：系统回调不保证在主线程；UI 更新前<strong>切主线程</strong>。</li><li><strong><code>presentationAnchor</code></strong>：确保返回 <strong>keyWindow</strong>；多场景时注意窗口切换。</li><li><strong>版本分支</strong>：把 <code>iOS 16+</code> 检查放在<strong>最前</strong>，尽早失败、错误可预期。</li><li><strong>跨语言兼容</strong>：<code>@objc public</code> 与 <code>NSObject</code> 继承别漏；字符串编码用 UTF-8。</li></ul><hr><h1 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h1><p>把功能做成<strong>小而稳的模块</strong>，先对外统一契约，再在内部迭代实现，是 Swift/iOS 项目长期可维护的关键。你现在的 <code>PasskeysNative</code> 已经很接近理想门面：<strong>只需把工具与系统细节收入 Internal，把 API 抽到 Public 协议里</strong>，就能在不破坏上层调用的前提下，持续演进到更专业的工程形态。</p>`,54)])])}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
